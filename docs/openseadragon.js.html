<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">

    <link rel="shortcut icon" type="image/png" href="/images/logo16.png">
    <title>OpenSeadragon Source: openseadragon.js</title>

    <link type="text/css" rel="stylesheet" href="styles/highlight.js/default.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-openseadragon.css">

    <!--[if lt IE 9]>
      <script src="scripts/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div id="main-container">
<div id="main">

    <h1 class="page-title">Source: openseadragon.js</h1>

    



    
    <section>
        <article>
            <pre class="source-code"><code><span id="line1" class="line"></span>//! openseadragon 6.0.0
<span id="line2" class="line"></span>//! Built on 2026-02-18
<span id="line3" class="line"></span>//! Git commit: v6.0.0-0-2bbaff29
<span id="line4" class="line"></span>//! http://openseadragon.github.io
<span id="line5" class="line"></span>//! License: http://openseadragon.github.io/license/
<span id="line6" class="line"></span>
<span id="line7" class="line"></span>/*
<span id="line8" class="line"></span> * OpenSeadragon
<span id="line9" class="line"></span> *
<span id="line10" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line11" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line12" class="line"></span> *
<span id="line13" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line14" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line15" class="line"></span> * met:
<span id="line16" class="line"></span> *
<span id="line17" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line18" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line19" class="line"></span> *
<span id="line20" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line21" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line22" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line23" class="line"></span> *
<span id="line24" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line25" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line26" class="line"></span> *   this software without specific prior written permission.
<span id="line27" class="line"></span> *
<span id="line28" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line29" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line30" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line31" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line32" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line33" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line34" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line35" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line36" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line37" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line38" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line39" class="line"></span> */
<span id="line40" class="line"></span>
<span id="line41" class="line"></span>/*
<span id="line42" class="line"></span> * Portions of this source file taken from jQuery:
<span id="line43" class="line"></span> *
<span id="line44" class="line"></span> * Copyright 2011 John Resig
<span id="line45" class="line"></span> *
<span id="line46" class="line"></span> * Permission is hereby granted, free of charge, to any person obtaining
<span id="line47" class="line"></span> * a copy of this software and associated documentation files (the
<span id="line48" class="line"></span> * "Software"), to deal in the Software without restriction, including
<span id="line49" class="line"></span> * without limitation the rights to use, copy, modify, merge, publish,
<span id="line50" class="line"></span> * distribute, sublicense, and/or sell copies of the Software, and to
<span id="line51" class="line"></span> * permit persons to whom the Software is furnished to do so, subject to
<span id="line52" class="line"></span> * the following conditions:
<span id="line53" class="line"></span> *
<span id="line54" class="line"></span> * The above copyright notice and this permission notice shall be
<span id="line55" class="line"></span> * included in all copies or substantial portions of the Software.
<span id="line56" class="line"></span> *
<span id="line57" class="line"></span> * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
<span id="line58" class="line"></span> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
<span id="line59" class="line"></span> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
<span id="line60" class="line"></span> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
<span id="line61" class="line"></span> * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
<span id="line62" class="line"></span> * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
<span id="line63" class="line"></span> * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
<span id="line64" class="line"></span> */
<span id="line65" class="line"></span>
<span id="line66" class="line"></span>/*
<span id="line67" class="line"></span> * Portions of this source file taken from mattsnider.com:
<span id="line68" class="line"></span> *
<span id="line69" class="line"></span> * Copyright (c) 2006-2013 Matt Snider
<span id="line70" class="line"></span> *
<span id="line71" class="line"></span> * Permission is hereby granted, free of charge, to any person obtaining a
<span id="line72" class="line"></span> * copy of this software and associated documentation files (the "Software"),
<span id="line73" class="line"></span> * to deal in the Software without restriction, including without limitation
<span id="line74" class="line"></span> * the rights to use, copy, modify, merge, publish, distribute, sublicense,
<span id="line75" class="line"></span> * and/or sell copies of the Software, and to permit persons to whom the
<span id="line76" class="line"></span> * Software is furnished to do so, subject to the following conditions:
<span id="line77" class="line"></span> *
<span id="line78" class="line"></span> * The above copyright notice and this permission notice shall be included
<span id="line79" class="line"></span> * in all copies or substantial portions of the Software.
<span id="line80" class="line"></span> *
<span id="line81" class="line"></span> * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
<span id="line82" class="line"></span> * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
<span id="line83" class="line"></span> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
<span id="line84" class="line"></span> * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
<span id="line85" class="line"></span> * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
<span id="line86" class="line"></span> * OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
<span id="line87" class="line"></span> * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
<span id="line88" class="line"></span> */
<span id="line89" class="line"></span>
<span id="line90" class="line"></span>
<span id="line91" class="line"></span>/**
<span id="line92" class="line"></span> * @namespace OpenSeadragon
<span id="line93" class="line"></span> * @version openseadragon 6.0.0
<span id="line94" class="line"></span> * @classdesc The root namespace for OpenSeadragon.  All utility methods
<span id="line95" class="line"></span> * and classes are defined on or below this namespace.
<span id="line96" class="line"></span> *
<span id="line97" class="line"></span> */
<span id="line98" class="line"></span>
<span id="line99" class="line"></span>
<span id="line100" class="line"></span>// Typedefs
<span id="line101" class="line"></span>
<span id="line102" class="line"></span> /**
<span id="line103" class="line"></span>  * All required and optional settings for instantiating a new instance of an OpenSeadragon image viewer.
<span id="line104" class="line"></span>  *
<span id="line105" class="line"></span>  * @typedef {Object} Options
<span id="line106" class="line"></span>  * @memberof OpenSeadragon
<span id="line107" class="line"></span>  *
<span id="line108" class="line"></span>  * @property {String} id
<span id="line109" class="line"></span>  *     Id of the element to append the viewer's container element to. If not provided, the 'element' property must be provided.
<span id="line110" class="line"></span>  *     If both the element and id properties are specified, the viewer is appended to the element provided in the element property.
<span id="line111" class="line"></span>  *
<span id="line112" class="line"></span>  * @property {Element} element
<span id="line113" class="line"></span>  *     The element to append the viewer's container element to. If not provided, the 'id' property must be provided.
<span id="line114" class="line"></span>  *     If both the element and id properties are specified, the viewer is appended to the element provided in the element property.
<span id="line115" class="line"></span>  *
<span id="line116" class="line"></span>  * @property {Array|String|Function|Object} [tileSources=null]
<span id="line117" class="line"></span>  *     Tile source(s) to open initially. This is a complex parameter; see
<span id="line118" class="line"></span>  *     {@link OpenSeadragon.Viewer#open} for details.
<span id="line119" class="line"></span>  *
<span id="line120" class="line"></span>  * @property {Number} [tabIndex=0]
<span id="line121" class="line"></span>  *     Tabbing order index to assign to the viewer element. Positive values are selected in increasing order. When tabIndex is 0
<span id="line122" class="line"></span>  *     source order is used. A negative value omits the viewer from the tabbing order.
<span id="line123" class="line"></span>  *
<span id="line124" class="line"></span>  * @property {Array} overlays Array of objects defining permanent overlays of
<span id="line125" class="line"></span>  *     the viewer. The overlays added via this option and later removed with
<span id="line126" class="line"></span>  *     {@link OpenSeadragon.Viewer#removeOverlay} will be added back when a new
<span id="line127" class="line"></span>  *     image is opened.
<span id="line128" class="line"></span>  *     To add overlays which can be definitively removed, one must use
<span id="line129" class="line"></span>  *     {@link OpenSeadragon.Viewer#addOverlay}
<span id="line130" class="line"></span>  *     If displaying a sequence of images, the overlays can be associated
<span id="line131" class="line"></span>  *     with a specific page by passing the overlays array to the page's
<span id="line132" class="line"></span>  *     tile source configuration.
<span id="line133" class="line"></span>  *     Expected properties:
<span id="line134" class="line"></span>  *     * x, y, (or px, py for pixel coordinates) to define the location.
<span id="line135" class="line"></span>  *     * width, height in point if using x,y or in pixels if using px,py. If width
<span id="line136" class="line"></span>  *       and height are specified, the overlay size is adjusted when zooming,
<span id="line137" class="line"></span>  *       otherwise the size stays the size of the content (or the size defined by CSS).
<span id="line138" class="line"></span>  *     * className to associate a class to the overlay
<span id="line139" class="line"></span>  *     * id to set the overlay element. If an element with this id already exists,
<span id="line140" class="line"></span>  *       it is reused, otherwise it is created. If not specified, a new element is
<span id="line141" class="line"></span>  *       created.
<span id="line142" class="line"></span>  *     * placement a string to define the relative position to the viewport.
<span id="line143" class="line"></span>  *       Only used if no width and height are specified. Default: 'TOP_LEFT'.
<span id="line144" class="line"></span>  *       See {@link OpenSeadragon.Placement} for possible values.
<span id="line145" class="line"></span>  *
<span id="line146" class="line"></span>  * @property {String} [xmlPath=null]
<span id="line147" class="line"></span>  *     &lt;strong&gt;DEPRECATED&lt;/strong&gt;. A relative path to load a DZI file from the server.
<span id="line148" class="line"></span>  *     Prefer the newer Options.tileSources.
<span id="line149" class="line"></span>  *
<span id="line150" class="line"></span>  * @property {String} [prefixUrl='/images/']
<span id="line151" class="line"></span>  *     Prepends the prefixUrl to navImages paths, which is very useful
<span id="line152" class="line"></span>  *     since the default paths are rarely useful for production
<span id="line153" class="line"></span>  *     environments.
<span id="line154" class="line"></span>  *
<span id="line155" class="line"></span>  * @property {OpenSeadragon.NavImages} [navImages]
<span id="line156" class="line"></span>  *     An object with a property for each button or other built-in navigation
<span id="line157" class="line"></span>  *     control, eg the current 'zoomIn', 'zoomOut', 'home', and 'fullpage'.
<span id="line158" class="line"></span>  *     Each of those in turn provides an image path for each state of the button
<span id="line159" class="line"></span>  *     or navigation control, eg 'REST', 'GROUP', 'HOVER', 'PRESS'. Finally the
<span id="line160" class="line"></span>  *     image paths, by default assume there is a folder on the servers root path
<span id="line161" class="line"></span>  *     called '/images', eg '/images/zoomin_rest.png'.  If you need to adjust
<span id="line162" class="line"></span>  *     these paths, prefer setting the option.prefixUrl rather than overriding
<span id="line163" class="line"></span>  *     every image path directly through this setting.
<span id="line164" class="line"></span>  *
<span id="line165" class="line"></span>  * @property {Boolean} [debugMode=false]
<span id="line166" class="line"></span>  *     TODO: provide an in-screen panel providing event detail feedback.
<span id="line167" class="line"></span>  *
<span id="line168" class="line"></span>  * @property {String} [debugGridColor=['#437AB2', '#1B9E77', '#D95F02', '#7570B3', '#E7298A', '#66A61E', '#E6AB02', '#A6761D', '#666666']]
<span id="line169" class="line"></span>  *     The colors of grids in debug mode. Each tiled image's grid uses a consecutive color.
<span id="line170" class="line"></span>  *     If there are more tiled images than provided colors, the color vector is recycled.
<span id="line171" class="line"></span>  *
<span id="line172" class="line"></span>  * @property {Boolean} [silenceMultiImageWarnings=false]
<span id="line173" class="line"></span>  *     Silences warnings when calling viewport coordinate functions with multi-image.
<span id="line174" class="line"></span>  *     Useful when you're overlaying multiple images on top of one another.
<span id="line175" class="line"></span>  *
<span id="line176" class="line"></span>  * @property {Number} [blendTime=0]
<span id="line177" class="line"></span>  *     Specifies the duration of animation as higher or lower level tiles are
<span id="line178" class="line"></span>  *     replacing the existing tile.
<span id="line179" class="line"></span>  *
<span id="line180" class="line"></span>  * @property {Boolean} [alwaysBlend=false]
<span id="line181" class="line"></span>  *     Forces the tile to always blend.  By default the tiles skip blending
<span id="line182" class="line"></span>  *     when the blendTime is surpassed and the current animation frame would
<span id="line183" class="line"></span>  *     not complete the blend.
<span id="line184" class="line"></span>  *
<span id="line185" class="line"></span>  * @property {Boolean} [autoHideControls=true]
<span id="line186" class="line"></span>  *     If the user stops interacting with the viewport, fade the navigation
<span id="line187" class="line"></span>  *     controls.  Useful for presentation since the controls are by default
<span id="line188" class="line"></span>  *     floated on top of the image the user is viewing.
<span id="line189" class="line"></span>  *
<span id="line190" class="line"></span>  * @property {Boolean} [immediateRender=false]
<span id="line191" class="line"></span>  *     Render the best closest level first, ignoring the lowering levels which
<span id="line192" class="line"></span>  *     provide the effect of very blurry to sharp. It is recommended to change
<span id="line193" class="line"></span>  *     setting to true for mobile devices.
<span id="line194" class="line"></span>  *
<span id="line195" class="line"></span>  * @property {Number} [defaultZoomLevel=0]
<span id="line196" class="line"></span>  *     Zoom level to use when image is first opened or the home button is clicked.
<span id="line197" class="line"></span>  *     If 0, adjusts to fit viewer.
<span id="line198" class="line"></span>  *
<span id="line199" class="line"></span>  * @property {String|DrawerImplementation|Array} [drawer = ['auto', 'webgl', 'canvas', 'html']]
<span id="line200" class="line"></span>  *     Which drawer to use. Valid strings are 'auto', 'webgl', 'canvas', and 'html'.
<span id="line201" class="line"></span>  *     The string 'auto' is converted to one or more drawer type strings depending
<span id="line202" class="line"></span>  *     on the platform. On iOS-like devices it becomes 'canvas' due to performance
<span id="line203" class="line"></span>  *     limitations with the webgl drawer. On all other platforms it becomes ['webgl', 'canvas']
<span id="line204" class="line"></span>  *     meaning that webgl is tried first, and canvas is available as a fallback if webgl is not supported.
<span id="line205" class="line"></span>  *
<span id="line206" class="line"></span>  *     The 'webgl' drawer automatically uses WebGL2 when available, falling back to WebGL1.
<span id="line207" class="line"></span>  *
<span id="line208" class="line"></span>  *     External drawer plugins can register additional drawer types as strings.
<span id="line209" class="line"></span>  *     Valid drawer implementations are constructors of classes that extend OpenSeadragon.DrawerBase.
<span id="line210" class="line"></span>  *     An array of strings and/or constructors can be used to indicate the priority
<span id="line211" class="line"></span>  *     of different implementations, which will be tried in order based on browser support.
<span id="line212" class="line"></span>  *     The 'webgl' drawer can automatically fall back to canvas as needed, for example to draw
<span id="line213" class="line"></span>  *     images that do not have CORS headers set which makes them tainted and unavailable to webgl.
<span id="line214" class="line"></span>  *     This behavior depends on 'canvas' being included in the list of drawer candidates. If
<span id="line215" class="line"></span>  *     webgl is needed and canvas fallback is not desired, use 'webgl' without including 'canvas' in the list.
<span id="line216" class="line"></span>  *
<span id="line217" class="line"></span>  * @property {Object} drawerOptions
<span id="line218" class="line"></span>  *     Options to pass to the selected drawer implementation. For details
<span id="line219" class="line"></span>  *     please see {@link OpenSeadragon.DrawerOptions}.
<span id="line220" class="line"></span>  *
<span id="line221" class="line"></span>  * @property {Number} [opacity=1]
<span id="line222" class="line"></span>  *     Default proportional opacity of the tiled images (1=opaque, 0=hidden)
<span id="line223" class="line"></span>  *     Hidden images do not draw and only load when preloading is allowed.
<span id="line224" class="line"></span>  *
<span id="line225" class="line"></span>  * @property {Boolean} [preload=false]
<span id="line226" class="line"></span>  *     Default switch for loading hidden images (true loads, false blocks)
<span id="line227" class="line"></span>  *
<span id="line228" class="line"></span>  * @property {String} [compositeOperation=null]
<span id="line229" class="line"></span>  *     Valid values are 'source-over', 'source-atop', 'source-in', 'source-out',
<span id="line230" class="line"></span>  *     'destination-over', 'destination-atop', 'destination-in', 'destination-out',
<span id="line231" class="line"></span>  *     'lighter', 'difference', 'copy', 'xor', etc.
<span id="line232" class="line"></span>  *     For complete list of modes, please @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation/ globalCompositeOperation}
<span id="line233" class="line"></span>  *
<span id="line234" class="line"></span>  * @property {Boolean} [imageSmoothingEnabled=true]
<span id="line235" class="line"></span>  *     Image smoothing for rendering. Supported by the canvas and webgl drawers,
<span id="line236" class="line"></span>  *     and may also be supported by external drawer plugins. Note: Ignored by some
<span id="line237" class="line"></span>  *     (especially older) browsers which do not support this canvas property.
<span id="line238" class="line"></span>  *     This property can be changed in {@link Viewer.DrawerBase.setImageSmoothingEnabled}.
<span id="line239" class="line"></span>  *
<span id="line240" class="line"></span>  * @property {String|CanvasGradient|CanvasPattern|Function} [placeholderFillStyle=null]
<span id="line241" class="line"></span>  *     Draws a colored rectangle behind the tile if it is not loaded yet.
<span id="line242" class="line"></span>  *     You can pass a CSS color value like "#FF8800".
<span id="line243" class="line"></span>  *     When passing a function the tiledImage and canvas context are available as argument which is useful when you draw a gradient or pattern.
<span id="line244" class="line"></span>  *
<span id="line245" class="line"></span>  * @property {Object} [subPixelRoundingForTransparency=null]
<span id="line246" class="line"></span>  *     Determines when subpixel rounding should be applied for tiles when rendering images that support transparency.
<span id="line247" class="line"></span>  *     This property is a subpixel rounding enum values dictionary [{@link BROWSERS}] --&gt; {@link SUBPIXEL_ROUNDING_OCCURRENCES}.
<span id="line248" class="line"></span>  *     The key is a {@link BROWSERS} value, and the value is one of {@link SUBPIXEL_ROUNDING_OCCURRENCES},
<span id="line249" class="line"></span>  *     indicating, for a given browser, when to apply subpixel rounding.
<span id="line250" class="line"></span>  *     Key '*' is the fallback value for any browser not specified in the dictionary.
<span id="line251" class="line"></span>  *     This property has a simple mode, and one can set it directly to
<span id="line252" class="line"></span>  *     {@link SUBPIXEL_ROUNDING_OCCURRENCES.NEVER}, {@link SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST} or {@link SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS}
<span id="line253" class="line"></span>  *     in order to apply this rule for all browser. The values {@link SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS} would be equivalent to { '*', SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS }.
<span id="line254" class="line"></span>  *     The default is {@link SUBPIXEL_ROUNDING_OCCURRENCES.NEVER} for all browsers, for backward compatibility reason.
<span id="line255" class="line"></span>  *
<span id="line256" class="line"></span>  * @property {Number} [degrees=0]
<span id="line257" class="line"></span>  *     Initial rotation.
<span id="line258" class="line"></span>  *
<span id="line259" class="line"></span>  * @property {Boolean} [flipped=false]
<span id="line260" class="line"></span>  *     Initial flip state.
<span id="line261" class="line"></span>  *
<span id="line262" class="line"></span>  * @property {Boolean} [overlayPreserveContentDirection=true]
<span id="line263" class="line"></span>  *     When the viewport is flipped (by pressing 'f'), the overlay is flipped using ScaleX.
<span id="line264" class="line"></span>  *     Normally, this setting (default true) keeps the overlay's content readable by flipping it back.
<span id="line265" class="line"></span>  *     To make the content flip with the overlay, set overlayPreserveContentDirection to false.
<span id="line266" class="line"></span>  *
<span id="line267" class="line"></span>  * @property {Number} [minZoomLevel=null]
<span id="line268" class="line"></span>  *
<span id="line269" class="line"></span>  * @property {Number} [maxZoomLevel=null]
<span id="line270" class="line"></span>  *
<span id="line271" class="line"></span>  * @property {Boolean} [homeFillsViewer=false]
<span id="line272" class="line"></span>  *     Make the 'home' button fill the viewer and clip the image, instead
<span id="line273" class="line"></span>  *     of fitting the image to the viewer and letterboxing.
<span id="line274" class="line"></span>  *
<span id="line275" class="line"></span>  * @property {Boolean} [panHorizontal=true]
<span id="line276" class="line"></span>  *     Allow horizontal pan.
<span id="line277" class="line"></span>  *
<span id="line278" class="line"></span>  * @property {Boolean} [panVertical=true]
<span id="line279" class="line"></span>  *     Allow vertical pan.
<span id="line280" class="line"></span>  *
<span id="line281" class="line"></span>  * @property {Boolean} [constrainDuringPan=false]
<span id="line282" class="line"></span>  *
<span id="line283" class="line"></span>  * @property {Boolean} [wrapHorizontal=false]
<span id="line284" class="line"></span>  *     Set to true to force the image to wrap horizontally within the viewport.
<span id="line285" class="line"></span>  *     Useful for maps or images representing the surface of a sphere or cylinder.
<span id="line286" class="line"></span>  *
<span id="line287" class="line"></span>  * @property {Boolean} [wrapVertical=false]
<span id="line288" class="line"></span>  *     Set to true to force the image to wrap vertically within the viewport.
<span id="line289" class="line"></span>  *     Useful for maps or images representing the surface of a sphere or cylinder.
<span id="line290" class="line"></span>  *
<span id="line291" class="line"></span>  * @property {Number} [minZoomImageRatio=0.9]
<span id="line292" class="line"></span>  *     The minimum percentage ( expressed as a number between 0 and 1 ) of
<span id="line293" class="line"></span>  *     the viewport height or width at which the zoom out will be constrained.
<span id="line294" class="line"></span>  *     Setting it to 0, for example will allow you to zoom out infinity.
<span id="line295" class="line"></span>  *
<span id="line296" class="line"></span>  * @property {Number} [maxZoomPixelRatio=1.1]
<span id="line297" class="line"></span>  *     The maximum ratio to allow a zoom-in to affect the highest level pixel
<span id="line298" class="line"></span>  *     ratio. This can be set to Infinity to allow 'infinite' zooming into the
<span id="line299" class="line"></span>  *     image though it is less effective visually if the HTML5 Canvas is not
<span id="line300" class="line"></span>  *     available on the viewing device.
<span id="line301" class="line"></span>  *
<span id="line302" class="line"></span>  * @property {Number} [smoothTileEdgesMinZoom=1.1]
<span id="line303" class="line"></span>  *     A zoom percentage ( where 1 is 100% ) of the highest resolution level.
<span id="line304" class="line"></span>  *     When zoomed in beyond this value alternative compositing will be used to
<span id="line305" class="line"></span>  *     smooth out the edges between tiles. This will have a performance impact.
<span id="line306" class="line"></span>  *     Can be set to Infinity to turn it off.
<span id="line307" class="line"></span>  *     Note: This setting is ignored on iOS devices due to a known bug (See {@link https://github.com/openseadragon/openseadragon/issues/952})
<span id="line308" class="line"></span>  *
<span id="line309" class="line"></span>  * @property {Boolean} [iOSDevice=?]
<span id="line310" class="line"></span>  *     True if running on an iOS device, false otherwise.
<span id="line311" class="line"></span>  *     Used to disable certain features that behave differently on iOS devices.
<span id="line312" class="line"></span>  *
<span id="line313" class="line"></span>  * @property {Boolean} [autoResize=true]
<span id="line314" class="line"></span>  *     Set to false to prevent polling for viewer size changes. Useful for providing custom resize behavior.
<span id="line315" class="line"></span>  *
<span id="line316" class="line"></span>  * @property {Boolean} [preserveImageSizeOnResize=false]
<span id="line317" class="line"></span>  *     Set to true to have the image size preserved when the viewer is resized. This requires autoResize=true (default).
<span id="line318" class="line"></span>  *
<span id="line319" class="line"></span>  * @property {Number} [minScrollDeltaTime=50]
<span id="line320" class="line"></span>  *     Number of milliseconds between canvas-scroll events. This value helps normalize the rate of canvas-scroll
<span id="line321" class="line"></span>  *     events between different devices, causing the faster devices to slow down enough to make the zoom control
<span id="line322" class="line"></span>  *     more manageable.
<span id="line323" class="line"></span>  *
<span id="line324" class="line"></span>  * @property {Number} [rotationIncrement=90]
<span id="line325" class="line"></span>  *     The number of degrees to rotate right or left when the rotate buttons or keyboard shortcuts are activated.
<span id="line326" class="line"></span>  *
<span id="line327" class="line"></span>  * @property {Number} [maxTilesPerFrame=1]
<span id="line328" class="line"></span>  *     The number of tiles loaded per frame. As the frame rate of the client's machine is usually high (e.g., 50 fps),
<span id="line329" class="line"></span>  *     one tile per frame should be a good choice. However, for large screens or lower frame rates, the number of
<span id="line330" class="line"></span>  *     loaded tiles per frame can be adjusted here. Reasonable values might be 2 or 3 tiles per frame.
<span id="line331" class="line"></span>  *     (Note that the actual frame rate is given by the client's browser and machine).
<span id="line332" class="line"></span>  *
<span id="line333" class="line"></span>  * @property {Number} [pixelsPerWheelLine=40]
<span id="line334" class="line"></span>  *     For pixel-resolution scrolling devices, the number of pixels equal to one scroll line.
<span id="line335" class="line"></span>  *
<span id="line336" class="line"></span>  * @property {Number} [pixelsPerArrowPress=40]
<span id="line337" class="line"></span>  *     The number of pixels viewport moves when an arrow key is pressed.
<span id="line338" class="line"></span>  *
<span id="line339" class="line"></span>  * @property {Number} [visibilityRatio=0.5]
<span id="line340" class="line"></span>  *     The percentage ( as a number from 0 to 1 ) of the source image which
<span id="line341" class="line"></span>  *     must be kept within the viewport.  If the image is dragged beyond that
<span id="line342" class="line"></span>  *     limit, it will 'bounce' back until the minimum visibility ratio is
<span id="line343" class="line"></span>  *     achieved.  Setting this to 0 and wrapHorizontal ( or wrapVertical ) to
<span id="line344" class="line"></span>  *     true will provide the effect of an infinitely scrolling viewport.
<span id="line345" class="line"></span>  *
<span id="line346" class="line"></span>  * @property {Object} [viewportMargins={}]
<span id="line347" class="line"></span>  *     Pushes the "home" region in from the sides by the specified amounts.
<span id="line348" class="line"></span>  *     Possible subproperties (Numbers, in screen coordinates): left, top, right, bottom.
<span id="line349" class="line"></span>  *
<span id="line350" class="line"></span>  * @property {Number} [imageLoaderLimit=0]
<span id="line351" class="line"></span>  *     The maximum number of image requests to make concurrently. By default
<span id="line352" class="line"></span>  *     it is set to 0 allowing the browser to make the maximum number of
<span id="line353" class="line"></span>  *     image requests in parallel as allowed by the browsers policy.
<span id="line354" class="line"></span>  *
<span id="line355" class="line"></span>  * @property {Number} [clickTimeThreshold=300]
<span id="line356" class="line"></span>  *      The number of milliseconds within which a pointer down-up event combination
<span id="line357" class="line"></span>  *      will be treated as a click gesture.
<span id="line358" class="line"></span>  *
<span id="line359" class="line"></span>  * @property {Number} [clickDistThreshold=5]
<span id="line360" class="line"></span>  *      The maximum distance allowed between a pointer down event and a pointer up event
<span id="line361" class="line"></span>  *      to be treated as a click gesture.
<span id="line362" class="line"></span>  *
<span id="line363" class="line"></span>  * @property {Number} [dblClickTimeThreshold=300]
<span id="line364" class="line"></span>  *      The number of milliseconds within which two pointer down-up event combinations
<span id="line365" class="line"></span>  *      will be treated as a double-click gesture.
<span id="line366" class="line"></span>  *
<span id="line367" class="line"></span>  * @property {Number} [dblClickDistThreshold=20]
<span id="line368" class="line"></span>  *      The maximum distance allowed between two pointer click events
<span id="line369" class="line"></span>  *      to be treated as a double-click gesture.
<span id="line370" class="line"></span>  *
<span id="line371" class="line"></span>  * @property {Number} [springStiffness=6.5]
<span id="line372" class="line"></span>  *
<span id="line373" class="line"></span>  * @property {Number} [animationTime=1.2]
<span id="line374" class="line"></span>  *     Specifies the animation duration per each {@link OpenSeadragon.Spring}
<span id="line375" class="line"></span>  *     which occur when the image is dragged, zoomed or rotated.
<span id="line376" class="line"></span>  *
<span id="line377" class="line"></span>  * @property {Boolean} [loadDestinationTilesOnAnimation=true]
<span id="line378" class="line"></span>  *    If true, tiles are loaded only at the destination of an animation.
<span id="line379" class="line"></span>  *    If false, tiles are loaded along the animation path during the animation.
<span id="line380" class="line"></span>  * @property {OpenSeadragon.GestureSettings} [gestureSettingsMouse]
<span id="line381" class="line"></span>  *     Settings for gestures generated by a mouse pointer device. (See {@link OpenSeadragon.GestureSettings})
<span id="line382" class="line"></span>  * @property {Boolean} [gestureSettingsMouse.dragToPan=true] - Pan on drag gesture
<span id="line383" class="line"></span>  * @property {Boolean} [gestureSettingsMouse.scrollToZoom=true] - Zoom on scroll gesture
<span id="line384" class="line"></span>  * @property {Boolean} [gestureSettingsMouse.clickToZoom=true] - Zoom on click gesture
<span id="line385" class="line"></span>  * @property {Boolean} [gestureSettingsMouse.dblClickToZoom=false] - Zoom on double-click gesture. Note: If set to true
<span id="line386" class="line"></span>  *     then clickToZoom should be set to false to prevent multiple zooms.
<span id="line387" class="line"></span>  * @property {Boolean} [gestureSettingsMouse.dblClickDragToZoom=false] - Zoom on dragging through
<span id="line388" class="line"></span>  * double-click gesture ( single click and next click to drag).  Note: If set to true
<span id="line389" class="line"></span>  *     then clickToZoom should be set to false to prevent multiple zooms.
<span id="line390" class="line"></span>  * @property {Boolean} [gestureSettingsMouse.pinchToZoom=false] - Zoom on pinch gesture
<span id="line391" class="line"></span>  * @property {Boolean} [gestureSettingsMouse.zoomToRefPoint=true] - If zoomToRefPoint is true, the zoom is centered at the pointer position. Otherwise,
<span id="line392" class="line"></span>  *     the zoom is centered at the canvas center.
<span id="line393" class="line"></span>  * @property {Boolean} [gestureSettingsMouse.flickEnabled=false] - Enable flick gesture
<span id="line394" class="line"></span>  * @property {Number} [gestureSettingsMouse.flickMinSpeed=120] - If flickEnabled is true, the minimum speed to initiate a flick gesture (pixels-per-second)
<span id="line395" class="line"></span>  * @property {Number} [gestureSettingsMouse.flickMomentum=0.25] - If flickEnabled is true, the momentum factor for the flick gesture
<span id="line396" class="line"></span>  * @property {Boolean} [gestureSettingsMouse.pinchRotate=false] - If pinchRotate is true, the user will have the ability to rotate the image using their fingers.
<span id="line397" class="line"></span>  *
<span id="line398" class="line"></span>  * @property {OpenSeadragon.GestureSettings} [gestureSettingsTouch]
<span id="line399" class="line"></span>  *     Settings for gestures generated by a touch pointer device. (See {@link OpenSeadragon.GestureSettings})
<span id="line400" class="line"></span>  * @property {Boolean} [gestureSettingsTouch.dragToPan=true] - Pan on drag gesture
<span id="line401" class="line"></span>  * @property {Boolean} [gestureSettingsTouch.scrollToZoom=false] - Zoom on scroll gesture
<span id="line402" class="line"></span>  * @property {Boolean} [gestureSettingsTouch.clickToZoom=false] - Zoom on click gesture
<span id="line403" class="line"></span>  * @property {Boolean} [gestureSettingsTouch.dblClickToZoom=true] - Zoom on double-click gesture. Note: If set to true
<span id="line404" class="line"></span>  *     then clickToZoom should be set to false to prevent multiple zooms.
<span id="line405" class="line"></span>    * @property {Boolean} [gestureSettingsTouch.dblClickDragToZoom=true] - Zoom on dragging through
<span id="line406" class="line"></span>  * double-click gesture ( single click and next click to drag).  Note: If set to true
<span id="line407" class="line"></span>  *     then clickToZoom should be set to false to prevent multiple zooms.
<span id="line408" class="line"></span>
<span id="line409" class="line"></span>  * @property {Boolean} [gestureSettingsTouch.pinchToZoom=true] - Zoom on pinch gesture
<span id="line410" class="line"></span>  * @property {Boolean} [gestureSettingsTouch.zoomToRefPoint=true] - If zoomToRefPoint is true, the zoom is centered at the pointer position. Otherwise,
<span id="line411" class="line"></span>  *     the zoom is centered at the canvas center.
<span id="line412" class="line"></span>  * @property {Boolean} [gestureSettingsTouch.flickEnabled=true] - Enable flick gesture
<span id="line413" class="line"></span>  * @property {Number} [gestureSettingsTouch.flickMinSpeed=120] - If flickEnabled is true, the minimum speed to initiate a flick gesture (pixels-per-second)
<span id="line414" class="line"></span>  * @property {Number} [gestureSettingsTouch.flickMomentum=0.25] - If flickEnabled is true, the momentum factor for the flick gesture
<span id="line415" class="line"></span>  * @property {Boolean} [gestureSettingsTouch.pinchRotate=false] - If pinchRotate is true, the user will have the ability to rotate the image using their fingers.
<span id="line416" class="line"></span>  *
<span id="line417" class="line"></span>  * @property {OpenSeadragon.GestureSettings} [gestureSettingsPen]
<span id="line418" class="line"></span>  *     Settings for gestures generated by a pen pointer device. (See {@link OpenSeadragon.GestureSettings})
<span id="line419" class="line"></span>  * @property {Boolean} [gestureSettingsPen.dragToPan=true] - Pan on drag gesture
<span id="line420" class="line"></span>  * @property {Boolean} [gestureSettingsPen.scrollToZoom=false] - Zoom on scroll gesture
<span id="line421" class="line"></span>  * @property {Boolean} [gestureSettingsPen.clickToZoom=true] - Zoom on click gesture
<span id="line422" class="line"></span>  * @property {Boolean} [gestureSettingsPen.dblClickToZoom=false] - Zoom on double-click gesture. Note: If set to true
<span id="line423" class="line"></span>  *     then clickToZoom should be set to false to prevent multiple zooms.
<span id="line424" class="line"></span>  * @property {Boolean} [gestureSettingsPen.pinchToZoom=false] - Zoom on pinch gesture
<span id="line425" class="line"></span>  * @property {Boolean} [gestureSettingsPen.zoomToRefPoint=true] - If zoomToRefPoint is true, the zoom is centered at the pointer position. Otherwise,
<span id="line426" class="line"></span>  *     the zoom is centered at the canvas center.
<span id="line427" class="line"></span>  * @property {Boolean} [gestureSettingsPen.flickEnabled=false] - Enable flick gesture
<span id="line428" class="line"></span>  * @property {Number} [gestureSettingsPen.flickMinSpeed=120] - If flickEnabled is true, the minimum speed to initiate a flick gesture (pixels-per-second)
<span id="line429" class="line"></span>  * @property {Number} [gestureSettingsPen.flickMomentum=0.25] - If flickEnabled is true, the momentum factor for the flick gesture
<span id="line430" class="line"></span>  * @property {Boolean} [gestureSettingsPen.pinchRotate=false] - If pinchRotate is true, the user will have the ability to rotate the image using their fingers.
<span id="line431" class="line"></span>  *
<span id="line432" class="line"></span>  * @property {OpenSeadragon.GestureSettings} [gestureSettingsUnknown]
<span id="line433" class="line"></span>  *     Settings for gestures generated by unknown pointer devices. (See {@link OpenSeadragon.GestureSettings})
<span id="line434" class="line"></span>  * @property {Boolean} [gestureSettingsUnknown.dragToPan=true] - Pan on drag gesture
<span id="line435" class="line"></span>  * @property {Boolean} [gestureSettingsUnknown.scrollToZoom=true] - Zoom on scroll gesture
<span id="line436" class="line"></span>  * @property {Boolean} [gestureSettingsUnknown.clickToZoom=false] - Zoom on click gesture
<span id="line437" class="line"></span>  * @property {Boolean} [gestureSettingsUnknown.dblClickToZoom=true] - Zoom on double-click gesture. Note: If set to true
<span id="line438" class="line"></span>  *     then clickToZoom should be set to false to prevent multiple zooms.
<span id="line439" class="line"></span>  * @property {Boolean} [gestureSettingsUnknown.dblClickDragToZoom=false] - Zoom on dragging through
<span id="line440" class="line"></span>  * double-click gesture ( single click and next click to drag).  Note: If set to true
<span id="line441" class="line"></span>  *     then clickToZoom should be set to false to prevent multiple zooms.
<span id="line442" class="line"></span>  * @property {Boolean} [gestureSettingsUnknown.pinchToZoom=true] - Zoom on pinch gesture
<span id="line443" class="line"></span>  * @property {Boolean} [gestureSettingsUnknown.zoomToRefPoint=true] - If zoomToRefPoint is true, the zoom is centered at the pointer position. Otherwise,
<span id="line444" class="line"></span>  *     the zoom is centered at the canvas center.
<span id="line445" class="line"></span>  * @property {Boolean} [gestureSettingsUnknown.flickEnabled=true] - Enable flick gesture
<span id="line446" class="line"></span>  * @property {Number} [gestureSettingsUnknown.flickMinSpeed=120] - If flickEnabled is true, the minimum speed to initiate a flick gesture (pixels-per-second)
<span id="line447" class="line"></span>  * @property {Number} [gestureSettingsUnknown.flickMomentum=0.25] - If flickEnabled is true, the momentum factor for the flick gesture
<span id="line448" class="line"></span>  * @property {Boolean} [gestureSettingsUnknown.pinchRotate=false] - If pinchRotate is true, the user will have the ability to rotate the image using their fingers.
<span id="line449" class="line"></span>  *
<span id="line450" class="line"></span>  * @property {Number} [zoomPerClick=2.0]
<span id="line451" class="line"></span>  *     The "zoom distance" per mouse click or touch tap. &lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt; Setting this to 1.0 effectively disables the click-to-zoom feature (also see gestureSettings[Mouse|Touch|Pen].clickToZoom/dblClickToZoom).&lt;/em&gt;
<span id="line452" class="line"></span>  *
<span id="line453" class="line"></span>  * @property {Number} [zoomPerScroll=1.2]
<span id="line454" class="line"></span>  *     The "zoom distance" per mouse scroll or touch pinch. &lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt; Setting this to 1.0 effectively disables the mouse-wheel zoom feature (also see gestureSettings[Mouse|Touch|Pen].scrollToZoom}).&lt;/em&gt;
<span id="line455" class="line"></span>  *
<span id="line456" class="line"></span>  * @property {Number} [zoomPerDblClickDrag=1.2]
<span id="line457" class="line"></span>  *     The "zoom distance" per double-click mouse drag. &lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt; Setting this to 1.0 effectively disables the double-click-drag-to-Zoom feature (also see gestureSettings[Mouse|Touch|Pen].dblClickDragToZoom).&lt;/em&gt;
<span id="line458" class="line"></span>  *
<span id="line459" class="line"></span>  * @property {Number} [zoomPerSecond=1.0]
<span id="line460" class="line"></span>  *     Sets the zoom amount per second when zoomIn/zoomOut buttons are pressed and held.
<span id="line461" class="line"></span>  *     The value is a factor of the current zoom, so 1.0 (the default) disables zooming when the zoomIn/zoomOut buttons
<span id="line462" class="line"></span>  *     are held. Higher values will increase the rate of zoom when the zoomIn/zoomOut buttons are held. Note that values
<span id="line463" class="line"></span>  *     &lt; 1.0 will reverse the operation of the zoomIn/zoomOut buttons (zoomIn button will decrease the zoom, zoomOut will
<span id="line464" class="line"></span>  *     increase the zoom).
<span id="line465" class="line"></span>  *
<span id="line466" class="line"></span>  * @property {Boolean} [showNavigator=false]
<span id="line467" class="line"></span>  *     Set to true to make the navigator minimap appear.
<span id="line468" class="line"></span>  *
<span id="line469" class="line"></span>  * @property {Element} [navigatorElement=null]
<span id="line470" class="line"></span>  *     The element to hold the navigator minimap.
<span id="line471" class="line"></span>  *     If an element is specified, the Id option (see navigatorId) is ignored.
<span id="line472" class="line"></span>  *     If no element nor ID is specified, a div element will be generated accordingly.
<span id="line473" class="line"></span>  *
<span id="line474" class="line"></span>  * @property {String} [navigatorId=navigator-GENERATED DATE]
<span id="line475" class="line"></span>  *     The ID of a div to hold the navigator minimap.
<span id="line476" class="line"></span>  *     If an ID is specified, the navigatorPosition, navigatorSizeRatio, navigatorMaintainSizeRatio, navigator[Top|Left|Height|Width] and navigatorAutoFade options will be ignored.
<span id="line477" class="line"></span>  *     If an ID is not specified, a div element will be generated and placed on top of the main image.
<span id="line478" class="line"></span>  *
<span id="line479" class="line"></span>  * @property {String} [navigatorPosition='TOP_RIGHT']
<span id="line480" class="line"></span>  *     Valid values are 'TOP_LEFT', 'TOP_RIGHT', 'BOTTOM_LEFT', 'BOTTOM_RIGHT', or 'ABSOLUTE'.&lt;br&gt;
<span id="line481" class="line"></span>  *     If 'ABSOLUTE' is specified, then navigator[Top|Left|Height|Width] determines the size and position of the navigator minimap in the viewer, and navigatorSizeRatio and navigatorMaintainSizeRatio are ignored.&lt;br&gt;
<span id="line482" class="line"></span>  *     For 'TOP_LEFT', 'TOP_RIGHT', 'BOTTOM_LEFT', and 'BOTTOM_RIGHT', the navigatorSizeRatio or navigator[Height|Width] values determine the size of the navigator minimap.
<span id="line483" class="line"></span>  *
<span id="line484" class="line"></span>  * @property {Number} [navigatorSizeRatio=0.2]
<span id="line485" class="line"></span>  *     Ratio of navigator size to viewer size. Ignored if navigator[Height|Width] are specified.
<span id="line486" class="line"></span>  *
<span id="line487" class="line"></span>  * @property {Boolean} [navigatorMaintainSizeRatio=false]
<span id="line488" class="line"></span>  *     If true, the navigator minimap is resized (using navigatorSizeRatio) when the viewer size changes.
<span id="line489" class="line"></span>  *
<span id="line490" class="line"></span>  * @property {Number|String} [navigatorTop=null]
<span id="line491" class="line"></span>  *     Specifies the location of the navigator minimap (see navigatorPosition).
<span id="line492" class="line"></span>  *
<span id="line493" class="line"></span>  * @property {Number|String} [navigatorLeft=null]
<span id="line494" class="line"></span>  *     Specifies the location of the navigator minimap (see navigatorPosition).
<span id="line495" class="line"></span>  *
<span id="line496" class="line"></span>  * @property {Number|String} [navigatorHeight=null]
<span id="line497" class="line"></span>  *     Specifies the size of the navigator minimap (see navigatorPosition).
<span id="line498" class="line"></span>  *     If specified, navigatorSizeRatio and navigatorMaintainSizeRatio are ignored.
<span id="line499" class="line"></span>  *
<span id="line500" class="line"></span>  * @property {Number|String} [navigatorWidth=null]
<span id="line501" class="line"></span>  *     Specifies the size of the navigator minimap (see navigatorPosition).
<span id="line502" class="line"></span>  *     If specified, navigatorSizeRatio and navigatorMaintainSizeRatio are ignored.
<span id="line503" class="line"></span>  *
<span id="line504" class="line"></span>  * @property {Boolean} [navigatorAutoFade=true]
<span id="line505" class="line"></span>  *     If the user stops interacting with the viewport, fade the navigator minimap.
<span id="line506" class="line"></span>  *     Setting to false will make the navigator minimap always visible.
<span id="line507" class="line"></span>  *
<span id="line508" class="line"></span>  * @property {Boolean} [navigatorRotate=true]
<span id="line509" class="line"></span>  *     If true, the navigator will be rotated together with the viewer.
<span id="line510" class="line"></span>  *
<span id="line511" class="line"></span>  * @property {String} [navigatorBackground='#000']
<span id="line512" class="line"></span>  *     Specifies the background color of the navigator minimap
<span id="line513" class="line"></span>  *
<span id="line514" class="line"></span>  * @property {Number} [navigatorOpacity=0.8]
<span id="line515" class="line"></span>  *     Specifies the opacity of the navigator minimap.
<span id="line516" class="line"></span>  *
<span id="line517" class="line"></span>  * @property {String} [navigatorBorderColor='#555']
<span id="line518" class="line"></span>  *     Specifies the border color of the navigator minimap
<span id="line519" class="line"></span>  *
<span id="line520" class="line"></span>  * @property {String} [navigatorDisplayRegionColor='#900']
<span id="line521" class="line"></span>  *     Specifies the border color of the display region rectangle of the navigator minimap
<span id="line522" class="line"></span>  *
<span id="line523" class="line"></span>  * @property {Number} [controlsFadeDelay=2000]
<span id="line524" class="line"></span>  *     The number of milliseconds to wait once the user has stopped interacting
<span id="line525" class="line"></span>  *     with the interface before beginning to fade the controls. Assumes
<span id="line526" class="line"></span>  *     showNavigationControl and autoHideControls are both true.
<span id="line527" class="line"></span>  *
<span id="line528" class="line"></span>  * @property {Number} [controlsFadeLength=1500]
<span id="line529" class="line"></span>  *     The number of milliseconds to animate the controls fading out.
<span id="line530" class="line"></span>  *
<span id="line531" class="line"></span>  * @property {Number} [maxImageCacheCount=200]
<span id="line532" class="line"></span>  *     The max number of images we should keep in memory (per drawer).
<span id="line533" class="line"></span>  *
<span id="line534" class="line"></span>  * @property {Number} [timeout=30000]
<span id="line535" class="line"></span>  *     The max number of milliseconds that an image job may take to complete.
<span id="line536" class="line"></span>  *
<span id="line537" class="line"></span>  * @property {Number} [tileRetryMax=0]
<span id="line538" class="line"></span>  *     The max number of retries when a tile download fails. By default it's 0, so retries are disabled.
<span id="line539" class="line"></span>  *
<span id="line540" class="line"></span>  * @property {Number} [tileRetryDelay=2500]
<span id="line541" class="line"></span>  *     Milliseconds to wait after each tile retry if tileRetryMax is set.
<span id="line542" class="line"></span>  *
<span id="line543" class="line"></span>  * @property {Boolean} [useCanvas=true]
<span id="line544" class="line"></span>  *     Deprecated. Use the `drawer` option to specify preferred renderer.
<span id="line545" class="line"></span>  *
<span id="line546" class="line"></span>  * @property {Number} [minPixelRatio=0.5]
<span id="line547" class="line"></span>  *     The higher the minPixelRatio, the lower the quality of the image that
<span id="line548" class="line"></span>  *     is considered sufficient to stop rendering a given zoom level.  For
<span id="line549" class="line"></span>  *     example, if you are targeting mobile devices with less bandwidth you may
<span id="line550" class="line"></span>  *     try setting this to 1.5 or higher.
<span id="line551" class="line"></span>  *
<span id="line552" class="line"></span>  * @property {Boolean} [mouseNavEnabled=true]
<span id="line553" class="line"></span>  *     Is the user able to interact with the image via mouse or touch. Default
<span id="line554" class="line"></span>  *     interactions include draging the image in a plane, and zooming in toward
<span id="line555" class="line"></span>  *     and away from the image.
<span id="line556" class="line"></span>  *
<span id="line557" class="line"></span>  * @property {boolean} [keyboardNavEnabled=true]
<span id="line558" class="line"></span>  *     Is the user able to interact with the image via keyboard.
<span id="line559" class="line"></span>  *
<span id="line560" class="line"></span>  * @property {Boolean} [showNavigationControl=true]
<span id="line561" class="line"></span>  *     Set to false to prevent the appearance of the default navigation controls.&lt;br&gt;
<span id="line562" class="line"></span>  *     Note that if set to false, the customs buttons set by the options
<span id="line563" class="line"></span>  *     zoomInButton, zoomOutButton etc, are rendered inactive.
<span id="line564" class="line"></span>  *
<span id="line565" class="line"></span>  * @property {OpenSeadragon.ControlAnchor} [navigationControlAnchor=TOP_LEFT]
<span id="line566" class="line"></span>  *     Placement of the default navigation controls.
<span id="line567" class="line"></span>  *     To set the placement of the sequence controls, see the
<span id="line568" class="line"></span>  *     sequenceControlAnchor option.
<span id="line569" class="line"></span>  *
<span id="line570" class="line"></span>  * @property {Boolean} [showZoomControl=true]
<span id="line571" class="line"></span>  *     If true then + and - buttons to zoom in and out are displayed.&lt;br&gt;
<span id="line572" class="line"></span>  *     Note: {@link OpenSeadragon.Options.showNavigationControl} is overriding
<span id="line573" class="line"></span>  *     this setting when set to false.
<span id="line574" class="line"></span>  *
<span id="line575" class="line"></span>  * @property {Boolean} [showHomeControl=true]
<span id="line576" class="line"></span>  *     If true then the 'Go home' button is displayed to go back to the original
<span id="line577" class="line"></span>  *     zoom and pan.&lt;br&gt;
<span id="line578" class="line"></span>  *     Note: {@link OpenSeadragon.Options.showNavigationControl} is overriding
<span id="line579" class="line"></span>  *     this setting when set to false.
<span id="line580" class="line"></span>  *
<span id="line581" class="line"></span>  * @property {Boolean} [showFullPageControl=true]
<span id="line582" class="line"></span>  *     If true then the 'Toggle full page' button is displayed to switch
<span id="line583" class="line"></span>  *     between full page and normal mode.&lt;br&gt;
<span id="line584" class="line"></span>  *     Note: {@link OpenSeadragon.Options.showNavigationControl} is overriding
<span id="line585" class="line"></span>  *     this setting when set to false.
<span id="line586" class="line"></span>  *
<span id="line587" class="line"></span>  * @property {Boolean} [showRotationControl=false]
<span id="line588" class="line"></span>  *     If true then the rotate left/right controls will be displayed as part of the
<span id="line589" class="line"></span>  *     standard controls. This is also subject to the browser support for rotate
<span id="line590" class="line"></span>  *     (e.g. viewer.drawer.canRotate()).&lt;br&gt;
<span id="line591" class="line"></span>  *     Note: {@link OpenSeadragon.Options.showNavigationControl} is overriding
<span id="line592" class="line"></span>  *     this setting when set to false.
<span id="line593" class="line"></span>  *
<span id="line594" class="line"></span>  * @property {Boolean} [showFlipControl=false]
<span id="line595" class="line"></span>  *     If true then the flip controls will be displayed as part of the
<span id="line596" class="line"></span>  *     standard controls.
<span id="line597" class="line"></span>  *
<span id="line598" class="line"></span>  * @property {Boolean} [showSequenceControl=true]
<span id="line599" class="line"></span>  *     If sequenceMode is true, then provide buttons for navigating forward and
<span id="line600" class="line"></span>  *     backward through the images.
<span id="line601" class="line"></span>  *
<span id="line602" class="line"></span>  * @property {OpenSeadragon.ControlAnchor} [sequenceControlAnchor=TOP_LEFT]
<span id="line603" class="line"></span>  *     Placement of the default sequence controls.
<span id="line604" class="line"></span>  *
<span id="line605" class="line"></span>  * @property {Boolean} [navPrevNextWrap=false]
<span id="line606" class="line"></span>  *     If true then the 'previous' button will wrap to the last image when
<span id="line607" class="line"></span>  *     viewing the first image and the 'next' button will wrap to the first
<span id="line608" class="line"></span>  *     image when viewing the last image.
<span id="line609" class="line"></span>  *
<span id="line610" class="line"></span>  *@property {String|Element} zoomInButton
<span id="line611" class="line"></span>  *     Set the id or element of the custom 'Zoom in' button to use.
<span id="line612" class="line"></span>  *     This is useful to have a custom button anywhere in the web page.&lt;br&gt;
<span id="line613" class="line"></span>  *     To only change the button images, consider using
<span id="line614" class="line"></span>  *     {@link OpenSeadragon.Options.navImages}
<span id="line615" class="line"></span>  *
<span id="line616" class="line"></span>  * @property {String|Element} zoomOutButton
<span id="line617" class="line"></span>  *     Set the id or element of the custom 'Zoom out' button to use.
<span id="line618" class="line"></span>  *     This is useful to have a custom button anywhere in the web page.&lt;br&gt;
<span id="line619" class="line"></span>  *     To only change the button images, consider using
<span id="line620" class="line"></span>  *     {@link OpenSeadragon.Options.navImages}
<span id="line621" class="line"></span>  *
<span id="line622" class="line"></span>  * @property {String|Element} homeButton
<span id="line623" class="line"></span>  *     Set the id or element of the custom 'Go home' button to use.
<span id="line624" class="line"></span>  *     This is useful to have a custom button anywhere in the web page.&lt;br&gt;
<span id="line625" class="line"></span>  *     To only change the button images, consider using
<span id="line626" class="line"></span>  *     {@link OpenSeadragon.Options.navImages}
<span id="line627" class="line"></span>  *
<span id="line628" class="line"></span>  * @property {String|Element} fullPageButton
<span id="line629" class="line"></span>  *     Set the id or element of the custom 'Toggle full page' button to use.
<span id="line630" class="line"></span>  *     This is useful to have a custom button anywhere in the web page.&lt;br&gt;
<span id="line631" class="line"></span>  *     To only change the button images, consider using
<span id="line632" class="line"></span>  *     {@link OpenSeadragon.Options.navImages}
<span id="line633" class="line"></span>  *
<span id="line634" class="line"></span>  * @property {String|Element} rotateLeftButton
<span id="line635" class="line"></span>  *     Set the id or element of the custom 'Rotate left' button to use.
<span id="line636" class="line"></span>  *     This is useful to have a custom button anywhere in the web page.&lt;br&gt;
<span id="line637" class="line"></span>  *     To only change the button images, consider using
<span id="line638" class="line"></span>  *     {@link OpenSeadragon.Options.navImages}
<span id="line639" class="line"></span>  *
<span id="line640" class="line"></span>  * @property {String|Element} rotateRightButton
<span id="line641" class="line"></span>  *     Set the id or element of the custom 'Rotate right' button to use.
<span id="line642" class="line"></span>  *     This is useful to have a custom button anywhere in the web page.&lt;br&gt;
<span id="line643" class="line"></span>  *     To only change the button images, consider using
<span id="line644" class="line"></span>  *     {@link OpenSeadragon.Options.navImages}
<span id="line645" class="line"></span>  *
<span id="line646" class="line"></span>  * @property {String|Element} previousButton
<span id="line647" class="line"></span>  *     Set the id or element of the custom 'Previous page' button to use.
<span id="line648" class="line"></span>  *     This is useful to have a custom button anywhere in the web page.&lt;br&gt;
<span id="line649" class="line"></span>  *     To only change the button images, consider using
<span id="line650" class="line"></span>  *     {@link OpenSeadragon.Options.navImages}
<span id="line651" class="line"></span>  *
<span id="line652" class="line"></span>  * @property {String|Element} nextButton
<span id="line653" class="line"></span>  *     Set the id or element of the custom 'Next page' button to use.
<span id="line654" class="line"></span>  *     This is useful to have a custom button anywhere in the web page.&lt;br&gt;
<span id="line655" class="line"></span>  *     To only change the button images, consider using
<span id="line656" class="line"></span>  *     {@link OpenSeadragon.Options.navImages}
<span id="line657" class="line"></span>  *
<span id="line658" class="line"></span>  * @property {Boolean} [sequenceMode=false]
<span id="line659" class="line"></span>  *     Set to true to have the viewer treat your tilesources as a sequence of images to
<span id="line660" class="line"></span>  *     be opened one at a time rather than all at once.
<span id="line661" class="line"></span>  *
<span id="line662" class="line"></span>  * @property {Number} [initialPage=0]
<span id="line663" class="line"></span>  *     If sequenceMode is true, display this page initially.
<span id="line664" class="line"></span>  *
<span id="line665" class="line"></span>  * @property {Boolean} [preserveViewport=false]
<span id="line666" class="line"></span>  *     If sequenceMode is true, then normally navigating through each image resets the
<span id="line667" class="line"></span>  *     viewport to 'home' position.  If preserveViewport is set to true, then the viewport
<span id="line668" class="line"></span>  *     position is preserved when navigating between images in the sequence.
<span id="line669" class="line"></span>  *
<span id="line670" class="line"></span>  * @property {Boolean} [preserveOverlays=false]
<span id="line671" class="line"></span>  *     If sequenceMode is true, then normally navigating through each image
<span id="line672" class="line"></span>  *     resets the overlays.
<span id="line673" class="line"></span>  *     If preserveOverlays is set to true, then the overlays added with {@link OpenSeadragon.Viewer#addOverlay}
<span id="line674" class="line"></span>  *     are preserved when navigating between images in the sequence.
<span id="line675" class="line"></span>  *     Note: setting preserveOverlays overrides any overlays specified in the global
<span id="line676" class="line"></span>  *     "overlays" option for the Viewer. It's also not compatible with specifying
<span id="line677" class="line"></span>  *     per-tileSource overlays via the options, as those overlays will persist
<span id="line678" class="line"></span>  *     even after the tileSource is closed.
<span id="line679" class="line"></span>  *
<span id="line680" class="line"></span>  * @property {Boolean} [showReferenceStrip=false]
<span id="line681" class="line"></span>  *     If sequenceMode is true, then display a scrolling strip of image thumbnails for
<span id="line682" class="line"></span>  *     navigating through the images.
<span id="line683" class="line"></span>  *
<span id="line684" class="line"></span>  * @property {String} [referenceStripScroll='horizontal']
<span id="line685" class="line"></span>  *
<span id="line686" class="line"></span>  * @property {Element} [referenceStripElement=null]
<span id="line687" class="line"></span>  *
<span id="line688" class="line"></span>  * @property {Number} [referenceStripHeight=null]
<span id="line689" class="line"></span>  *
<span id="line690" class="line"></span>  * @property {Number} [referenceStripWidth=null]
<span id="line691" class="line"></span>  *
<span id="line692" class="line"></span>  * @property {String} [referenceStripPosition='BOTTOM_LEFT']
<span id="line693" class="line"></span>  *
<span id="line694" class="line"></span>  * @property {Number} [referenceStripSizeRatio=0.2]
<span id="line695" class="line"></span>  *
<span id="line696" class="line"></span>  * @property {Boolean} [collectionMode=false]
<span id="line697" class="line"></span>  *     Set to true to have the viewer arrange your TiledImages in a grid or line.
<span id="line698" class="line"></span>  *
<span id="line699" class="line"></span>  * @property {Number} [collectionRows=3]
<span id="line700" class="line"></span>  *     If collectionMode is true, specifies how many rows the grid should have. Use 1 to make a line.
<span id="line701" class="line"></span>  *     If collectionLayout is 'vertical', specifies how many columns instead.
<span id="line702" class="line"></span>  *
<span id="line703" class="line"></span>  * @property {Number} [collectionColumns=0]
<span id="line704" class="line"></span>  *     If collectionMode is true, specifies how many columns the grid should have. Use 1 to make a line.
<span id="line705" class="line"></span>  *     If collectionLayout is 'vertical', specifies how many rows instead. Ignored if collectionRows is not set to a falsy value.
<span id="line706" class="line"></span>  *
<span id="line707" class="line"></span>  * @property {String} [collectionLayout='horizontal']
<span id="line708" class="line"></span>  *     If collectionMode is true, specifies whether to arrange vertically or horizontally.
<span id="line709" class="line"></span>  *
<span id="line710" class="line"></span>  * @property {Number} [collectionTileSize=800]
<span id="line711" class="line"></span>  *     If collectionMode is true, specifies the size, in viewport coordinates, for each TiledImage to fit into.
<span id="line712" class="line"></span>  *     The TiledImage will be centered within a square of the specified size.
<span id="line713" class="line"></span>  *
<span id="line714" class="line"></span>  * @property {Number} [collectionTileMargin=80]
<span id="line715" class="line"></span>  *     If collectionMode is true, specifies the margin, in viewport coordinates, between each TiledImage.
<span id="line716" class="line"></span>  *
<span id="line717" class="line"></span>  * @property {String|Boolean} [crossOriginPolicy=false]
<span id="line718" class="line"></span>  *     Valid values are 'Anonymous', 'use-credentials', and false. If false, canvas requests will
<span id="line719" class="line"></span>  *     not use CORS, and the canvas will be tainted.
<span id="line720" class="line"></span>  *
<span id="line721" class="line"></span>  * @property {Boolean} [ajaxWithCredentials=false]
<span id="line722" class="line"></span>  *     Whether to set the withCredentials XHR flag for AJAX requests.
<span id="line723" class="line"></span>  *     Note that this can be overridden at the {@link OpenSeadragon.TileSource} level.
<span id="line724" class="line"></span>  *
<span id="line725" class="line"></span>  * @property {Boolean} [loadTilesWithAjax=false]
<span id="line726" class="line"></span>  *     Whether to load tile data using AJAX requests.
<span id="line727" class="line"></span>  *     Note that this can be overridden at the {@link OpenSeadragon.TileSource} level.
<span id="line728" class="line"></span>  *
<span id="line729" class="line"></span>  * @property {Object} [ajaxHeaders={}]
<span id="line730" class="line"></span>  *     A set of headers to include when making AJAX requests for tile sources or tiles.
<span id="line731" class="line"></span>  *
<span id="line732" class="line"></span>  * @property {Boolean} [splitHashDataForPost=false]
<span id="line733" class="line"></span>  *     Allows to treat _first_ hash ('#') symbol as a separator for POST data:
<span id="line734" class="line"></span>  *     URL to be opened by a {@link OpenSeadragon.TileSource} can thus look like: http://some.url#postdata=here.
<span id="line735" class="line"></span>  *     The whole URL is used to fetch image info metadata and it is then split to 'http://some.url' and
<span id="line736" class="line"></span>  *     'postdata=here'; post data is given to the {@link OpenSeadragon.TileSource} of the choice and can be further
<span id="line737" class="line"></span>  *     used within tile requests (see TileSource methods).
<span id="line738" class="line"></span>  *     NOTE: {@link OpenSeadragon.TileSource.prototype.configure} return value should contain the post data
<span id="line739" class="line"></span>  *     if you want to use it later - so that it is given to your constructor later.
<span id="line740" class="line"></span>  *     NOTE: usually, post data is expected to be ampersand-separated (just like GET parameters), and is NOT USED
<span id="line741" class="line"></span>  *     to fetch tile image data unless explicitly programmed, or if loadTilesWithAjax=false 4
<span id="line742" class="line"></span>  *     (but it is still used for the initial image info request).
<span id="line743" class="line"></span>  *     NOTE: passing POST data from URL by this feature only supports string values, however,
<span id="line744" class="line"></span>  *     TileSource can send any data using POST as long as the header is correct
<span id="line745" class="line"></span>  *     (@see OpenSeadragon.TileSource.prototype.getTilePostData)
<span id="line746" class="line"></span>  *
<span id="line747" class="line"></span>  * @property {Boolean} [callTileLoadedWithCachedData=false]
<span id="line748" class="line"></span>  *     tile-loaded event is called only for tiles that downloaded new data or
<span id="line749" class="line"></span>  *     their data is stored in the original form in a suplementary cache object.
<span id="line750" class="line"></span>  *     Caches that render directly from re-used cache does not trigger this event again,
<span id="line751" class="line"></span>  *     as possible modifications would be applied twice.
<span id="line752" class="line"></span>  */
<span id="line753" class="line"></span>
<span id="line754" class="line"></span> /**
<span id="line755" class="line"></span>  * Settings for gestures generated by a pointer device.
<span id="line756" class="line"></span>  *
<span id="line757" class="line"></span>  * @typedef {Object} GestureSettings
<span id="line758" class="line"></span>  * @memberof OpenSeadragon
<span id="line759" class="line"></span>  *
<span id="line760" class="line"></span>  * @property {Boolean} dragToPan
<span id="line761" class="line"></span>  *     Set to false to disable panning on drag gestures.
<span id="line762" class="line"></span>  *
<span id="line763" class="line"></span>  * @property {Boolean} scrollToZoom
<span id="line764" class="line"></span>  *     Set to false to disable zooming on scroll gestures.
<span id="line765" class="line"></span>  *
<span id="line766" class="line"></span>  * @property {Boolean} clickToZoom
<span id="line767" class="line"></span>  *     Set to false to disable zooming on click gestures.
<span id="line768" class="line"></span>  *
<span id="line769" class="line"></span>  * @property {Boolean} dblClickToZoom
<span id="line770" class="line"></span>  *     Set to false to disable zooming on double-click gestures. Note: If set to true
<span id="line771" class="line"></span>  *     then clickToZoom should be set to false to prevent multiple zooms.
<span id="line772" class="line"></span>  *
<span id="line773" class="line"></span>  * @property {Boolean} pinchToZoom
<span id="line774" class="line"></span>  *     Set to false to disable zooming on pinch gestures.
<span id="line775" class="line"></span>  *
<span id="line776" class="line"></span>  * @property {Boolean} flickEnabled
<span id="line777" class="line"></span>  *     Set to false to disable the kinetic panning effect (flick) at the end of a drag gesture.
<span id="line778" class="line"></span>  *
<span id="line779" class="line"></span>  * @property {Number} flickMinSpeed
<span id="line780" class="line"></span>  *     If flickEnabled is true, the minimum speed (in pixels-per-second) required to cause the kinetic panning effect (flick) at the end of a drag gesture.
<span id="line781" class="line"></span>  *
<span id="line782" class="line"></span>  * @property {Number} flickMomentum
<span id="line783" class="line"></span>  *     If flickEnabled is true, a constant multiplied by the velocity to determine the distance of the kinetic panning effect (flick) at the end of a drag gesture.
<span id="line784" class="line"></span>  *     A larger value will make the flick feel "lighter", while a smaller value will make the flick feel "heavier".
<span id="line785" class="line"></span>  *     Note: springStiffness and animationTime also affect the "spring" used to stop the flick animation.
<span id="line786" class="line"></span>  *
<span id="line787" class="line"></span>  */
<span id="line788" class="line"></span>
<span id="line789" class="line"></span>/**
<span id="line790" class="line"></span> * @typedef {OpenSeadragon.BaseDrawerOptions} OpenSeadragon.WebGLDrawerOptions
<span id="line791" class="line"></span> * @memberof OpenSeadragon
<span id="line792" class="line"></span> * @property {Boolean} [unpackWithPremultipliedAlpha=false]
<span id="line793" class="line"></span> *  Whether to enable gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL when uploading textures.
<span id="line794" class="line"></span> */
<span id="line795" class="line"></span>
<span id="line796" class="line"></span>/**
<span id="line797" class="line"></span> * @typedef {Object.&lt;string, OpenSeadragon.BaseDrawerOptions&gt;} DrawerOptions
<span id="line798" class="line"></span> * Can support any drawer key as long as a drawer is registered with the drawer id = map key.
<span id="line799" class="line"></span> * Therefore, one can register a new drawer that extends a drawer base and submit a custom key in the options.
<span id="line800" class="line"></span> * @memberof OpenSeadragon
<span id="line801" class="line"></span> * @property {OpenSeadragon.WebGLDrawerOptions} webgl - options if the WebGLDrawer is used.
<span id="line802" class="line"></span> * @property {OpenSeadragon.BaseDrawerOptions} canvas - options if the CanvasDrawer is used.
<span id="line803" class="line"></span> * @property {OpenSeadragon.BaseDrawerOptions} html - options if the HTMLDrawer is used.
<span id="line804" class="line"></span> * @property {OpenSeadragon.BaseDrawerOptions} custom - options if a custom drawer is used.
<span id="line805" class="line"></span> */
<span id="line806" class="line"></span>
<span id="line807" class="line"></span>
<span id="line808" class="line"></span>/**
<span id="line809" class="line"></span>  * The names for the image resources used for the image navigation buttons.
<span id="line810" class="line"></span>  *
<span id="line811" class="line"></span>  * @typedef {Object} NavImages
<span id="line812" class="line"></span>  * @memberof OpenSeadragon
<span id="line813" class="line"></span>  *
<span id="line814" class="line"></span>  * @property {Object} zoomIn - Images for the zoom-in button.
<span id="line815" class="line"></span>  * @property {String} zoomIn.REST
<span id="line816" class="line"></span>  * @property {String} zoomIn.GROUP
<span id="line817" class="line"></span>  * @property {String} zoomIn.HOVER
<span id="line818" class="line"></span>  * @property {String} zoomIn.DOWN
<span id="line819" class="line"></span>  *
<span id="line820" class="line"></span>  * @property {Object} zoomOut - Images for the zoom-out button.
<span id="line821" class="line"></span>  * @property {String} zoomOut.REST
<span id="line822" class="line"></span>  * @property {String} zoomOut.GROUP
<span id="line823" class="line"></span>  * @property {String} zoomOut.HOVER
<span id="line824" class="line"></span>  * @property {String} zoomOut.DOWN
<span id="line825" class="line"></span>  *
<span id="line826" class="line"></span>  * @property {Object} home - Images for the home button.
<span id="line827" class="line"></span>  * @property {String} home.REST
<span id="line828" class="line"></span>  * @property {String} home.GROUP
<span id="line829" class="line"></span>  * @property {String} home.HOVER
<span id="line830" class="line"></span>  * @property {String} home.DOWN
<span id="line831" class="line"></span>  *
<span id="line832" class="line"></span>  * @property {Object} fullpage - Images for the full-page button.
<span id="line833" class="line"></span>  * @property {String} fullpage.REST
<span id="line834" class="line"></span>  * @property {String} fullpage.GROUP
<span id="line835" class="line"></span>  * @property {String} fullpage.HOVER
<span id="line836" class="line"></span>  * @property {String} fullpage.DOWN
<span id="line837" class="line"></span>  *
<span id="line838" class="line"></span>  * @property {Object} rotateleft - Images for the rotate left button.
<span id="line839" class="line"></span>  * @property {String} rotateleft.REST
<span id="line840" class="line"></span>  * @property {String} rotateleft.GROUP
<span id="line841" class="line"></span>  * @property {String} rotateleft.HOVER
<span id="line842" class="line"></span>  * @property {String} rotateleft.DOWN
<span id="line843" class="line"></span>  *
<span id="line844" class="line"></span>  * @property {Object} rotateright - Images for the rotate right button.
<span id="line845" class="line"></span>  * @property {String} rotateright.REST
<span id="line846" class="line"></span>  * @property {String} rotateright.GROUP
<span id="line847" class="line"></span>  * @property {String} rotateright.HOVER
<span id="line848" class="line"></span>  * @property {String} rotateright.DOWN
<span id="line849" class="line"></span>  *
<span id="line850" class="line"></span>  * @property {Object} flip - Images for the flip button.
<span id="line851" class="line"></span>  * @property {String} flip.REST
<span id="line852" class="line"></span>  * @property {String} flip.GROUP
<span id="line853" class="line"></span>  * @property {String} flip.HOVER
<span id="line854" class="line"></span>  * @property {String} flip.DOWN
<span id="line855" class="line"></span>  *
<span id="line856" class="line"></span>  * @property {Object} previous - Images for the previous button.
<span id="line857" class="line"></span>  * @property {String} previous.REST
<span id="line858" class="line"></span>  * @property {String} previous.GROUP
<span id="line859" class="line"></span>  * @property {String} previous.HOVER
<span id="line860" class="line"></span>  * @property {String} previous.DOWN
<span id="line861" class="line"></span>  *
<span id="line862" class="line"></span>  * @property {Object} next - Images for the next button.
<span id="line863" class="line"></span>  * @property {String} next.REST
<span id="line864" class="line"></span>  * @property {String} next.GROUP
<span id="line865" class="line"></span>  * @property {String} next.HOVER
<span id="line866" class="line"></span>  * @property {String} next.DOWN
<span id="line867" class="line"></span>  *
<span id="line868" class="line"></span>  */
<span id="line869" class="line"></span>
<span id="line870" class="line"></span>/* eslint-disable no-redeclare */
<span id="line871" class="line"></span>function OpenSeadragon( options ){
<span id="line872" class="line"></span>    return new OpenSeadragon.Viewer( options );
<span id="line873" class="line"></span>}
<span id="line874" class="line"></span>
<span id="line875" class="line"></span>(function( $ ){
<span id="line876" class="line"></span>
<span id="line877" class="line"></span>
<span id="line878" class="line"></span>    /**
<span id="line879" class="line"></span>     * The OpenSeadragon version.
<span id="line880" class="line"></span>     *
<span id="line881" class="line"></span>     * @member {Object} OpenSeadragon.version
<span id="line882" class="line"></span>     * @property {String} versionStr - The version number as a string ('major.minor.revision').
<span id="line883" class="line"></span>     * @property {Number} major - The major version number.
<span id="line884" class="line"></span>     * @property {Number} minor - The minor version number.
<span id="line885" class="line"></span>     * @property {Number} revision - The revision number.
<span id="line886" class="line"></span>     * @since 1.0.0
<span id="line887" class="line"></span>     */
<span id="line888" class="line"></span>    $.version = {
<span id="line889" class="line"></span>        versionStr: '6.0.0',
<span id="line890" class="line"></span>        major: parseInt('6', 10),
<span id="line891" class="line"></span>        minor: parseInt('0', 10),
<span id="line892" class="line"></span>        revision: parseInt('0', 10)
<span id="line893" class="line"></span>    };
<span id="line894" class="line"></span>
<span id="line895" class="line"></span>
<span id="line896" class="line"></span>    /**
<span id="line897" class="line"></span>     * Taken from jquery 1.6.1
<span id="line898" class="line"></span>     * [[Class]] -&gt; type pairs
<span id="line899" class="line"></span>     * @private
<span id="line900" class="line"></span>     */
<span id="line901" class="line"></span>    const class2type = {
<span id="line902" class="line"></span>            '[object Boolean]':                  'boolean',
<span id="line903" class="line"></span>            '[object Number]':                   'number',
<span id="line904" class="line"></span>            '[object String]':                   'string',
<span id="line905" class="line"></span>            '[object Function]':                 'function',
<span id="line906" class="line"></span>            '[object AsyncFunction]':            'function',
<span id="line907" class="line"></span>            '[object Promise]':                  'promise',
<span id="line908" class="line"></span>            '[object Array]':                    'array',
<span id="line909" class="line"></span>            '[object Date]':                     'date',
<span id="line910" class="line"></span>            '[object RegExp]':                   'regexp',
<span id="line911" class="line"></span>            '[object Object]':                   'object',
<span id="line912" class="line"></span>            '[object HTMLUnknownElement]':       'dom-node',
<span id="line913" class="line"></span>            '[object HTMLImageElement]':         'image',
<span id="line914" class="line"></span>            '[object HTMLCanvasElement]':        'canvas',
<span id="line915" class="line"></span>            '[object CanvasRenderingContext2D]': 'context2d'
<span id="line916" class="line"></span>        };
<span id="line917" class="line"></span>        // Save a reference to some core methods
<span id="line918" class="line"></span>    const toString    = Object.prototype.toString;
<span id="line919" class="line"></span>    const hasOwn      = Object.prototype.hasOwnProperty;
<span id="line920" class="line"></span>
<span id="line921" class="line"></span>    /**
<span id="line922" class="line"></span>     * Taken from jQuery 1.6.1
<span id="line923" class="line"></span>     * @function isFunction
<span id="line924" class="line"></span>     * @memberof OpenSeadragon
<span id="line925" class="line"></span>     * @see {@link http://www.jquery.com/ jQuery}
<span id="line926" class="line"></span>     */
<span id="line927" class="line"></span>    $.isFunction = function( obj ) {
<span id="line928" class="line"></span>        return $.type(obj) === "function";
<span id="line929" class="line"></span>    };
<span id="line930" class="line"></span>
<span id="line931" class="line"></span>    /**
<span id="line932" class="line"></span>     * Taken from jQuery 1.6.1
<span id="line933" class="line"></span>     * @function isArray
<span id="line934" class="line"></span>     * @memberof OpenSeadragon
<span id="line935" class="line"></span>     * @see {@link http://www.jquery.com/ jQuery}
<span id="line936" class="line"></span>     */
<span id="line937" class="line"></span>    $.isArray = Array.isArray || function( obj ) {
<span id="line938" class="line"></span>        return $.type(obj) === "array";
<span id="line939" class="line"></span>    };
<span id="line940" class="line"></span>
<span id="line941" class="line"></span>
<span id="line942" class="line"></span>    /**
<span id="line943" class="line"></span>     * A crude way of determining if an object is a window.
<span id="line944" class="line"></span>     * Taken from jQuery 1.6.1
<span id="line945" class="line"></span>     * @function isWindow
<span id="line946" class="line"></span>     * @memberof OpenSeadragon
<span id="line947" class="line"></span>     * @see {@link http://www.jquery.com/ jQuery}
<span id="line948" class="line"></span>     */
<span id="line949" class="line"></span>    $.isWindow = function( obj ) {
<span id="line950" class="line"></span>        return obj &amp;&amp; typeof obj === "object" &amp;&amp; "setInterval" in obj;
<span id="line951" class="line"></span>    };
<span id="line952" class="line"></span>
<span id="line953" class="line"></span>
<span id="line954" class="line"></span>    /**
<span id="line955" class="line"></span>     * Taken from jQuery 1.6.1
<span id="line956" class="line"></span>     * @function type
<span id="line957" class="line"></span>     * @memberof OpenSeadragon
<span id="line958" class="line"></span>     * @see {@link http://www.jquery.com/ jQuery}
<span id="line959" class="line"></span>     */
<span id="line960" class="line"></span>    $.type = function( obj ) {
<span id="line961" class="line"></span>        return ( obj === null ) || ( obj === undefined ) ?
<span id="line962" class="line"></span>            String( obj ) :
<span id="line963" class="line"></span>            class2type[ toString.call(obj) ] || "object";
<span id="line964" class="line"></span>    };
<span id="line965" class="line"></span>
<span id="line966" class="line"></span>
<span id="line967" class="line"></span>    /**
<span id="line968" class="line"></span>     * Taken from jQuery 1.6.1
<span id="line969" class="line"></span>     * @function isPlainObject
<span id="line970" class="line"></span>     * @memberof OpenSeadragon
<span id="line971" class="line"></span>     * @see {@link http://www.jquery.com/ jQuery}
<span id="line972" class="line"></span>     */
<span id="line973" class="line"></span>    $.isPlainObject = function( obj ) {
<span id="line974" class="line"></span>        // Must be an Object.
<span id="line975" class="line"></span>        // Because of IE, we also have to check the presence of the constructor property.
<span id="line976" class="line"></span>        // Make sure that DOM nodes and window objects don't pass through, as well
<span id="line977" class="line"></span>        if ( !obj || OpenSeadragon.type(obj) !== "object" || obj.nodeType || $.isWindow( obj ) ) {
<span id="line978" class="line"></span>            return false;
<span id="line979" class="line"></span>        }
<span id="line980" class="line"></span>
<span id="line981" class="line"></span>        // Not own constructor property must be Object
<span id="line982" class="line"></span>        if ( obj.constructor &amp;&amp;
<span id="line983" class="line"></span>            !hasOwn.call(obj, "constructor") &amp;&amp;
<span id="line984" class="line"></span>            !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
<span id="line985" class="line"></span>            return false;
<span id="line986" class="line"></span>        }
<span id="line987" class="line"></span>
<span id="line988" class="line"></span>        // Own properties are enumerated firstly, so to speed up,
<span id="line989" class="line"></span>        // if last one is own, then all properties are own.
<span id="line990" class="line"></span>
<span id="line991" class="line"></span>        let lastKey;
<span id="line992" class="line"></span>        for (const key in obj ) {
<span id="line993" class="line"></span>            lastKey = key;
<span id="line994" class="line"></span>        }
<span id="line995" class="line"></span>
<span id="line996" class="line"></span>        return lastKey === undefined || hasOwn.call( obj, lastKey );
<span id="line997" class="line"></span>    };
<span id="line998" class="line"></span>
<span id="line999" class="line"></span>
<span id="line1000" class="line"></span>    /**
<span id="line1001" class="line"></span>     * Taken from jQuery 1.6.1
<span id="line1002" class="line"></span>     * @function isEmptyObject
<span id="line1003" class="line"></span>     * @memberof OpenSeadragon
<span id="line1004" class="line"></span>     * @see {@link http://www.jquery.com/ jQuery}
<span id="line1005" class="line"></span>     */
<span id="line1006" class="line"></span>    $.isEmptyObject = function( obj ) {
<span id="line1007" class="line"></span>        for ( const name in obj ) {
<span id="line1008" class="line"></span>            return false;
<span id="line1009" class="line"></span>        }
<span id="line1010" class="line"></span>        return true;
<span id="line1011" class="line"></span>    };
<span id="line1012" class="line"></span>
<span id="line1013" class="line"></span>    /**
<span id="line1014" class="line"></span>     * Shim around Object.freeze. Does nothing if Object.freeze is not supported.
<span id="line1015" class="line"></span>     * @param {Object} obj The object to freeze.
<span id="line1016" class="line"></span>     * @returns {Object} obj The frozen object.
<span id="line1017" class="line"></span>     */
<span id="line1018" class="line"></span>    $.freezeObject = function(obj) {
<span id="line1019" class="line"></span>        if (Object.freeze) {
<span id="line1020" class="line"></span>            $.freezeObject = Object.freeze;
<span id="line1021" class="line"></span>        } else {
<span id="line1022" class="line"></span>            $.freezeObject = function(obj) {
<span id="line1023" class="line"></span>                return obj;
<span id="line1024" class="line"></span>            };
<span id="line1025" class="line"></span>        }
<span id="line1026" class="line"></span>        return $.freezeObject(obj);
<span id="line1027" class="line"></span>    };
<span id="line1028" class="line"></span>
<span id="line1029" class="line"></span>    /**
<span id="line1030" class="line"></span>     * True if the browser supports the HTML5 canvas element
<span id="line1031" class="line"></span>     * @member {Boolean} supportsCanvas
<span id="line1032" class="line"></span>     * @memberof OpenSeadragon
<span id="line1033" class="line"></span>     */
<span id="line1034" class="line"></span>    $.supportsCanvas = (function () {
<span id="line1035" class="line"></span>        const canvasElement = document.createElement( 'canvas' );
<span id="line1036" class="line"></span>        return !!( $.isFunction( canvasElement.getContext ) &amp;&amp;
<span id="line1037" class="line"></span>                    canvasElement.getContext( '2d' ) );
<span id="line1038" class="line"></span>    }());
<span id="line1039" class="line"></span>
<span id="line1040" class="line"></span>    /**
<span id="line1041" class="line"></span>     * Test whether the submitted canvas is tainted or not.
<span id="line1042" class="line"></span>     * @argument {Canvas} canvas The canvas to test.
<span id="line1043" class="line"></span>     * @returns {Boolean} True if the canvas is tainted.
<span id="line1044" class="line"></span>     */
<span id="line1045" class="line"></span>    $.isCanvasTainted = function(canvas) {
<span id="line1046" class="line"></span>        let isTainted = false;
<span id="line1047" class="line"></span>        try {
<span id="line1048" class="line"></span>            // We test if the canvas is tainted by retrieving data from it.
<span id="line1049" class="line"></span>            // An exception will be raised if the canvas is tainted.
<span id="line1050" class="line"></span>            canvas.getContext('2d').getImageData(0, 0, 1, 1);
<span id="line1051" class="line"></span>        } catch (e) {
<span id="line1052" class="line"></span>            isTainted = true;
<span id="line1053" class="line"></span>        }
<span id="line1054" class="line"></span>        return isTainted;
<span id="line1055" class="line"></span>    };
<span id="line1056" class="line"></span>
<span id="line1057" class="line"></span>    /**
<span id="line1058" class="line"></span>     * True if the browser supports the EventTarget.addEventListener() method
<span id="line1059" class="line"></span>     * @member {Boolean} supportsAddEventListener
<span id="line1060" class="line"></span>     * @memberof OpenSeadragon
<span id="line1061" class="line"></span>     */
<span id="line1062" class="line"></span>    $.supportsAddEventListener = (function () {
<span id="line1063" class="line"></span>        return !!(document.documentElement.addEventListener &amp;&amp; document.addEventListener);
<span id="line1064" class="line"></span>    }());
<span id="line1065" class="line"></span>
<span id="line1066" class="line"></span>    /**
<span id="line1067" class="line"></span>     * True if the browser supports the EventTarget.removeEventListener() method
<span id="line1068" class="line"></span>     * @member {Boolean} supportsRemoveEventListener
<span id="line1069" class="line"></span>     * @memberof OpenSeadragon
<span id="line1070" class="line"></span>     */
<span id="line1071" class="line"></span>    $.supportsRemoveEventListener = (function () {
<span id="line1072" class="line"></span>        return !!(document.documentElement.removeEventListener &amp;&amp; document.removeEventListener);
<span id="line1073" class="line"></span>    }());
<span id="line1074" class="line"></span>
<span id="line1075" class="line"></span>    /**
<span id="line1076" class="line"></span>     * True if the browser supports the newer EventTarget.addEventListener options argument
<span id="line1077" class="line"></span>     * @member {Boolean} supportsEventListenerOptions
<span id="line1078" class="line"></span>     * @memberof OpenSeadragon
<span id="line1079" class="line"></span>     */
<span id="line1080" class="line"></span>    $.supportsEventListenerOptions = (function () {
<span id="line1081" class="line"></span>        let supported = 0;
<span id="line1082" class="line"></span>
<span id="line1083" class="line"></span>        if ( $.supportsAddEventListener ) {
<span id="line1084" class="line"></span>            try {
<span id="line1085" class="line"></span>                const options = {
<span id="line1086" class="line"></span>                    get capture() {
<span id="line1087" class="line"></span>                        supported++;
<span id="line1088" class="line"></span>                        return false;
<span id="line1089" class="line"></span>                    },
<span id="line1090" class="line"></span>                    get once() {
<span id="line1091" class="line"></span>                        supported++;
<span id="line1092" class="line"></span>                        return false;
<span id="line1093" class="line"></span>                    },
<span id="line1094" class="line"></span>                    get passive() {
<span id="line1095" class="line"></span>                        supported++;
<span id="line1096" class="line"></span>                        return false;
<span id="line1097" class="line"></span>                    }
<span id="line1098" class="line"></span>                };
<span id="line1099" class="line"></span>                window.addEventListener("test", null, options);
<span id="line1100" class="line"></span>                window.removeEventListener("test", null, options);
<span id="line1101" class="line"></span>            } catch ( e ) {
<span id="line1102" class="line"></span>                supported = 0;
<span id="line1103" class="line"></span>            }
<span id="line1104" class="line"></span>        }
<span id="line1105" class="line"></span>
<span id="line1106" class="line"></span>        return supported &gt;= 3;
<span id="line1107" class="line"></span>    }());
<span id="line1108" class="line"></span>
<span id="line1109" class="line"></span>    /**
<span id="line1110" class="line"></span>     * If true, OpenSeadragon uses async execution, else it uses synchronous execution.
<span id="line1111" class="line"></span>     * Note that disabling async means no plugins that use Promises / async will work with OSD.
<span id="line1112" class="line"></span>     * @member {boolean}
<span id="line1113" class="line"></span>     * @memberof OpenSeadragon
<span id="line1114" class="line"></span>     */
<span id="line1115" class="line"></span>    $.supportsAsync = true;
<span id="line1116" class="line"></span>
<span id="line1117" class="line"></span>    /**
<span id="line1118" class="line"></span>     * A ratio comparing the device screen's pixel density to the canvas's backing store pixel density,
<span id="line1119" class="line"></span>     * clamped to a minimum of 1. Defaults to 1 if canvas isn't supported by the browser.
<span id="line1120" class="line"></span>     * @function getCurrentPixelDensityRatio
<span id="line1121" class="line"></span>     * @memberof OpenSeadragon
<span id="line1122" class="line"></span>     * @returns {Number}
<span id="line1123" class="line"></span>     */
<span id="line1124" class="line"></span>    $.getCurrentPixelDensityRatio = function() {
<span id="line1125" class="line"></span>        if ( $.supportsCanvas ) {
<span id="line1126" class="line"></span>            const context = document.createElement('canvas').getContext('2d');
<span id="line1127" class="line"></span>            const devicePixelRatio = window.devicePixelRatio || 1;
<span id="line1128" class="line"></span>            const backingStoreRatio = context.webkitBackingStorePixelRatio ||
<span id="line1129" class="line"></span>                                    context.mozBackingStorePixelRatio ||
<span id="line1130" class="line"></span>                                    context.msBackingStorePixelRatio ||
<span id="line1131" class="line"></span>                                    context.oBackingStorePixelRatio ||
<span id="line1132" class="line"></span>                                    context.backingStorePixelRatio || 1;
<span id="line1133" class="line"></span>            return Math.max(devicePixelRatio, 1) / backingStoreRatio;
<span id="line1134" class="line"></span>        } else {
<span id="line1135" class="line"></span>            return 1;
<span id="line1136" class="line"></span>        }
<span id="line1137" class="line"></span>    };
<span id="line1138" class="line"></span>
<span id="line1139" class="line"></span>    /**
<span id="line1140" class="line"></span>     * A ratio comparing the device screen's pixel density to the canvas's backing store pixel density,
<span id="line1141" class="line"></span>     * clamped to a minimum of 1. Defaults to 1 if canvas isn't supported by the browser.
<span id="line1142" class="line"></span>     * @member {Number} pixelDensityRatio
<span id="line1143" class="line"></span>     * @memberof OpenSeadragon
<span id="line1144" class="line"></span>     */
<span id="line1145" class="line"></span>    $.pixelDensityRatio = $.getCurrentPixelDensityRatio();
<span id="line1146" class="line"></span>
<span id="line1147" class="line"></span>}( OpenSeadragon ));
<span id="line1148" class="line"></span>
<span id="line1149" class="line"></span>/**
<span id="line1150" class="line"></span> *  This closure defines all static methods available to the OpenSeadragon
<span id="line1151" class="line"></span> *  namespace.  Many, if not most, are taken directly from jQuery for use
<span id="line1152" class="line"></span> *  to simplify and reduce common programming patterns.  More static methods
<span id="line1153" class="line"></span> *  from jQuery may eventually make their way into this though we are
<span id="line1154" class="line"></span> *  attempting to avoid an explicit dependency on jQuery only because
<span id="line1155" class="line"></span> *  OpenSeadragon is a broadly useful code base and would be made less broad
<span id="line1156" class="line"></span> *  by requiring jQuery fully.
<span id="line1157" class="line"></span> *
<span id="line1158" class="line"></span> *  Some static methods have also been refactored from the original OpenSeadragon
<span id="line1159" class="line"></span> *  project.
<span id="line1160" class="line"></span> */
<span id="line1161" class="line"></span>(function( $ ){
<span id="line1162" class="line"></span>
<span id="line1163" class="line"></span>    /**
<span id="line1164" class="line"></span>     * Taken from jQuery 1.6.1
<span id="line1165" class="line"></span>     * @function extend
<span id="line1166" class="line"></span>     * @memberof OpenSeadragon
<span id="line1167" class="line"></span>     * @see {@link http://www.jquery.com/ jQuery}
<span id="line1168" class="line"></span>     */
<span id="line1169" class="line"></span>    $.extend = function() {
<span id="line1170" class="line"></span>        let options;
<span id="line1171" class="line"></span>        let name;
<span id="line1172" class="line"></span>        let src;
<span id="line1173" class="line"></span>        let copy;
<span id="line1174" class="line"></span>        let copyIsArray;
<span id="line1175" class="line"></span>        let clone;
<span id="line1176" class="line"></span>        let target = arguments[ 0 ] || {};
<span id="line1177" class="line"></span>        const length = arguments.length;
<span id="line1178" class="line"></span>        let deep = false;
<span id="line1179" class="line"></span>        let i = 1;
<span id="line1180" class="line"></span>
<span id="line1181" class="line"></span>        // Handle a deep copy situation
<span id="line1182" class="line"></span>        if ( typeof target === "boolean" ) {
<span id="line1183" class="line"></span>            deep    = target;
<span id="line1184" class="line"></span>            target  = arguments[ 1 ] || {};
<span id="line1185" class="line"></span>            // skip the boolean and the target
<span id="line1186" class="line"></span>            i = 2;
<span id="line1187" class="line"></span>        }
<span id="line1188" class="line"></span>
<span id="line1189" class="line"></span>        // Handle case when target is a string or something (possible in deep copy)
<span id="line1190" class="line"></span>        if ( typeof target !== "object" &amp;&amp; !OpenSeadragon.isFunction( target ) ) {
<span id="line1191" class="line"></span>            target = {};
<span id="line1192" class="line"></span>        }
<span id="line1193" class="line"></span>
<span id="line1194" class="line"></span>        // extend jQuery itself if only one argument is passed
<span id="line1195" class="line"></span>        if ( length === i ) {
<span id="line1196" class="line"></span>            target = this;
<span id="line1197" class="line"></span>            --i;
<span id="line1198" class="line"></span>        }
<span id="line1199" class="line"></span>
<span id="line1200" class="line"></span>        for ( ; i &lt; length; i++ ) {
<span id="line1201" class="line"></span>            // Only deal with non-null/undefined values
<span id="line1202" class="line"></span>            options = arguments[ i ];
<span id="line1203" class="line"></span>            if ( options !== null || options !== undefined ) {
<span id="line1204" class="line"></span>                // Extend the base object
<span id="line1205" class="line"></span>                for ( name in options ) {
<span id="line1206" class="line"></span>                    const descriptor = Object.getOwnPropertyDescriptor(options, name);
<span id="line1207" class="line"></span>
<span id="line1208" class="line"></span>                    if (descriptor !== undefined) {
<span id="line1209" class="line"></span>                        if (descriptor.get || descriptor.set) {
<span id="line1210" class="line"></span>                            Object.defineProperty(target, name, descriptor);
<span id="line1211" class="line"></span>                            continue;
<span id="line1212" class="line"></span>                        }
<span id="line1213" class="line"></span>
<span id="line1214" class="line"></span>                        copy = descriptor.value;
<span id="line1215" class="line"></span>                    } else {
<span id="line1216" class="line"></span>                        $.console.warn('Could not copy inherited property "' + name + '".');
<span id="line1217" class="line"></span>                        continue;
<span id="line1218" class="line"></span>                    }
<span id="line1219" class="line"></span>
<span id="line1220" class="line"></span>                    // Prevent never-ending loop
<span id="line1221" class="line"></span>                    if ( target === copy ) {
<span id="line1222" class="line"></span>                        continue;
<span id="line1223" class="line"></span>                    }
<span id="line1224" class="line"></span>
<span id="line1225" class="line"></span>                    // Recurse if we're merging plain objects or arrays
<span id="line1226" class="line"></span>                    if ( deep &amp;&amp; copy &amp;&amp; ( OpenSeadragon.isPlainObject( copy ) || ( copyIsArray = OpenSeadragon.isArray( copy ) ) ) ) {
<span id="line1227" class="line"></span>                        src = target[ name ];
<span id="line1228" class="line"></span>
<span id="line1229" class="line"></span>                        if ( copyIsArray ) {
<span id="line1230" class="line"></span>                            copyIsArray = false;
<span id="line1231" class="line"></span>                            clone = src &amp;&amp; OpenSeadragon.isArray( src ) ? src : [];
<span id="line1232" class="line"></span>
<span id="line1233" class="line"></span>                        } else {
<span id="line1234" class="line"></span>                            clone = src &amp;&amp; OpenSeadragon.isPlainObject( src ) ? src : {};
<span id="line1235" class="line"></span>                        }
<span id="line1236" class="line"></span>
<span id="line1237" class="line"></span>                        // Never move original objects, clone them
<span id="line1238" class="line"></span>                        target[ name ] = OpenSeadragon.extend( deep, clone, copy );
<span id="line1239" class="line"></span>
<span id="line1240" class="line"></span>                    // Don't bring in undefined values
<span id="line1241" class="line"></span>                    } else if ( copy !== undefined ) {
<span id="line1242" class="line"></span>                        target[ name ] = copy;
<span id="line1243" class="line"></span>                    }
<span id="line1244" class="line"></span>                }
<span id="line1245" class="line"></span>            }
<span id="line1246" class="line"></span>        }
<span id="line1247" class="line"></span>
<span id="line1248" class="line"></span>        // Return the modified object
<span id="line1249" class="line"></span>        return target;
<span id="line1250" class="line"></span>    };
<span id="line1251" class="line"></span>
<span id="line1252" class="line"></span>    const isIOSDevice = function () {
<span id="line1253" class="line"></span>        if (typeof navigator !== 'object') {
<span id="line1254" class="line"></span>            return false;
<span id="line1255" class="line"></span>        }
<span id="line1256" class="line"></span>        const userAgent = navigator.userAgent;
<span id="line1257" class="line"></span>        if (typeof userAgent !== 'string') {
<span id="line1258" class="line"></span>            return false;
<span id="line1259" class="line"></span>        }
<span id="line1260" class="line"></span>        return userAgent.indexOf('iPhone') !== -1 ||
<span id="line1261" class="line"></span>               userAgent.indexOf('iPad') !== -1 ||
<span id="line1262" class="line"></span>               userAgent.indexOf('iPod') !== -1;
<span id="line1263" class="line"></span>    };
<span id="line1264" class="line"></span>
<span id="line1265" class="line"></span>    $.extend( $, /** @lends OpenSeadragon */{
<span id="line1266" class="line"></span>        /**
<span id="line1267" class="line"></span>         * The default values for the optional settings documented at {@link OpenSeadragon.Options}.
<span id="line1268" class="line"></span>         * @static
<span id="line1269" class="line"></span>         * @type {Object}
<span id="line1270" class="line"></span>         */
<span id="line1271" class="line"></span>        DEFAULT_SETTINGS: {
<span id="line1272" class="line"></span>            //DATA SOURCE DETAILS
<span id="line1273" class="line"></span>            xmlPath:                null,
<span id="line1274" class="line"></span>            tileSources:            null,
<span id="line1275" class="line"></span>            tileHost:               null,
<span id="line1276" class="line"></span>            initialPage:            0,
<span id="line1277" class="line"></span>            crossOriginPolicy:      false,
<span id="line1278" class="line"></span>            ajaxWithCredentials:    false,
<span id="line1279" class="line"></span>            loadTilesWithAjax:      false,
<span id="line1280" class="line"></span>            ajaxHeaders:            {},
<span id="line1281" class="line"></span>            splitHashDataForPost:   false,
<span id="line1282" class="line"></span>            callTileLoadedWithCachedData: false,
<span id="line1283" class="line"></span>
<span id="line1284" class="line"></span>            //PAN AND ZOOM SETTINGS AND CONSTRAINTS
<span id="line1285" class="line"></span>            panHorizontal:          true,
<span id="line1286" class="line"></span>            panVertical:            true,
<span id="line1287" class="line"></span>            constrainDuringPan:     false,
<span id="line1288" class="line"></span>            wrapHorizontal:         false,
<span id="line1289" class="line"></span>            wrapVertical:           false,
<span id="line1290" class="line"></span>            visibilityRatio:        0.5, //-&gt; how much of the viewer can be negative space
<span id="line1291" class="line"></span>            minPixelRatio:          0.5, //-&gt;closer to 0 draws tiles meant for a higher zoom at this zoom
<span id="line1292" class="line"></span>            defaultZoomLevel:       0,
<span id="line1293" class="line"></span>            minZoomLevel:           null,
<span id="line1294" class="line"></span>            maxZoomLevel:           null,
<span id="line1295" class="line"></span>            homeFillsViewer:        false,
<span id="line1296" class="line"></span>
<span id="line1297" class="line"></span>            //UI RESPONSIVENESS AND FEEL
<span id="line1298" class="line"></span>            clickTimeThreshold:     300,
<span id="line1299" class="line"></span>            clickDistThreshold:     5,
<span id="line1300" class="line"></span>            dblClickTimeThreshold:  300,
<span id="line1301" class="line"></span>            dblClickDistThreshold:  20,
<span id="line1302" class="line"></span>            springStiffness:        6.5,
<span id="line1303" class="line"></span>            animationTime:          1.2,
<span id="line1304" class="line"></span>            loadDestinationTilesOnAnimation: true,
<span id="line1305" class="line"></span>            gestureSettingsMouse:   {
<span id="line1306" class="line"></span>                dragToPan: true,
<span id="line1307" class="line"></span>                scrollToZoom: true,
<span id="line1308" class="line"></span>                clickToZoom: true,
<span id="line1309" class="line"></span>                dblClickToZoom: false,
<span id="line1310" class="line"></span>                dblClickDragToZoom: false,
<span id="line1311" class="line"></span>                pinchToZoom: false,
<span id="line1312" class="line"></span>                zoomToRefPoint: true,
<span id="line1313" class="line"></span>                flickEnabled: false,
<span id="line1314" class="line"></span>                flickMinSpeed: 120,
<span id="line1315" class="line"></span>                flickMomentum: 0.25,
<span id="line1316" class="line"></span>                pinchRotate: false
<span id="line1317" class="line"></span>            },
<span id="line1318" class="line"></span>            gestureSettingsTouch:   {
<span id="line1319" class="line"></span>                dragToPan: true,
<span id="line1320" class="line"></span>                scrollToZoom: false,
<span id="line1321" class="line"></span>                clickToZoom: false,
<span id="line1322" class="line"></span>                dblClickToZoom: true,
<span id="line1323" class="line"></span>                dblClickDragToZoom: true,
<span id="line1324" class="line"></span>                pinchToZoom: true,
<span id="line1325" class="line"></span>                zoomToRefPoint: true,
<span id="line1326" class="line"></span>                flickEnabled: true,
<span id="line1327" class="line"></span>                flickMinSpeed: 120,
<span id="line1328" class="line"></span>                flickMomentum: 0.25,
<span id="line1329" class="line"></span>                pinchRotate: false
<span id="line1330" class="line"></span>            },
<span id="line1331" class="line"></span>            gestureSettingsPen:     {
<span id="line1332" class="line"></span>                dragToPan: true,
<span id="line1333" class="line"></span>                scrollToZoom: false,
<span id="line1334" class="line"></span>                clickToZoom: true,
<span id="line1335" class="line"></span>                dblClickToZoom: false,
<span id="line1336" class="line"></span>                dblClickDragToZoom: false,
<span id="line1337" class="line"></span>                pinchToZoom: false,
<span id="line1338" class="line"></span>                zoomToRefPoint: true,
<span id="line1339" class="line"></span>                flickEnabled: false,
<span id="line1340" class="line"></span>                flickMinSpeed: 120,
<span id="line1341" class="line"></span>                flickMomentum: 0.25,
<span id="line1342" class="line"></span>                pinchRotate: false
<span id="line1343" class="line"></span>            },
<span id="line1344" class="line"></span>            gestureSettingsUnknown: {
<span id="line1345" class="line"></span>                dragToPan: true,
<span id="line1346" class="line"></span>                scrollToZoom: false,
<span id="line1347" class="line"></span>                clickToZoom: false,
<span id="line1348" class="line"></span>                dblClickToZoom: true,
<span id="line1349" class="line"></span>                dblClickDragToZoom: false,
<span id="line1350" class="line"></span>                pinchToZoom: true,
<span id="line1351" class="line"></span>                zoomToRefPoint: true,
<span id="line1352" class="line"></span>                flickEnabled: true,
<span id="line1353" class="line"></span>                flickMinSpeed: 120,
<span id="line1354" class="line"></span>                flickMomentum: 0.25,
<span id="line1355" class="line"></span>                pinchRotate: false
<span id="line1356" class="line"></span>            },
<span id="line1357" class="line"></span>            zoomPerClick:           2,
<span id="line1358" class="line"></span>            zoomPerScroll:          1.2,
<span id="line1359" class="line"></span>            zoomPerDblClickDrag:    1.2,
<span id="line1360" class="line"></span>            zoomPerSecond:          1.0,
<span id="line1361" class="line"></span>            blendTime:              0,
<span id="line1362" class="line"></span>            alwaysBlend:            false,
<span id="line1363" class="line"></span>            autoHideControls:       true,
<span id="line1364" class="line"></span>            immediateRender:        false,
<span id="line1365" class="line"></span>            minZoomImageRatio:      0.9, //-&gt; closer to 0 allows zoom out to infinity
<span id="line1366" class="line"></span>            maxZoomPixelRatio:      1.1, //-&gt; higher allows 'over zoom' into pixels
<span id="line1367" class="line"></span>            smoothTileEdgesMinZoom: 1.1, //-&gt; higher than maxZoomPixelRatio disables it
<span id="line1368" class="line"></span>            iOSDevice:              isIOSDevice(),
<span id="line1369" class="line"></span>            pixelsPerWheelLine:     40,
<span id="line1370" class="line"></span>            pixelsPerArrowPress:    40,
<span id="line1371" class="line"></span>            autoResize:             true,
<span id="line1372" class="line"></span>            preserveImageSizeOnResize: false, // requires autoResize=true
<span id="line1373" class="line"></span>            minScrollDeltaTime:     50,
<span id="line1374" class="line"></span>            rotationIncrement:      90,
<span id="line1375" class="line"></span>            maxTilesPerFrame:       1,
<span id="line1376" class="line"></span>
<span id="line1377" class="line"></span>            //DEFAULT CONTROL SETTINGS
<span id="line1378" class="line"></span>            showSequenceControl:     true,  //SEQUENCE
<span id="line1379" class="line"></span>            sequenceControlAnchor:   null,  //SEQUENCE
<span id="line1380" class="line"></span>            preserveViewport:        false, //SEQUENCE
<span id="line1381" class="line"></span>            preserveOverlays:        false, //SEQUENCE
<span id="line1382" class="line"></span>            navPrevNextWrap:         false, //SEQUENCE
<span id="line1383" class="line"></span>            showNavigationControl:   true,  //ZOOM/HOME/FULL/ROTATION
<span id="line1384" class="line"></span>            navigationControlAnchor: null,  //ZOOM/HOME/FULL/ROTATION
<span id="line1385" class="line"></span>            showZoomControl:         true,  //ZOOM
<span id="line1386" class="line"></span>            showHomeControl:         true,  //HOME
<span id="line1387" class="line"></span>            showFullPageControl:     true,  //FULL
<span id="line1388" class="line"></span>            showRotationControl:     false, //ROTATION
<span id="line1389" class="line"></span>            showFlipControl:         false,  //FLIP
<span id="line1390" class="line"></span>            controlsFadeDelay:       2000,  //ZOOM/HOME/FULL/SEQUENCE
<span id="line1391" class="line"></span>            controlsFadeLength:      1500,  //ZOOM/HOME/FULL/SEQUENCE
<span id="line1392" class="line"></span>            mouseNavEnabled:         true,  //GENERAL MOUSE INTERACTIVITY
<span id="line1393" class="line"></span>            keyboardNavEnabled:      true,  //GENERAL KEYBOARD INTERACTIVITY
<span id="line1394" class="line"></span>
<span id="line1395" class="line"></span>            //VIEWPORT NAVIGATOR SETTINGS
<span id="line1396" class="line"></span>            showNavigator:              false,
<span id="line1397" class="line"></span>            navigatorElement:           null,
<span id="line1398" class="line"></span>            navigatorId:                null,
<span id="line1399" class="line"></span>            navigatorPosition:          null,
<span id="line1400" class="line"></span>            navigatorSizeRatio:         0.2,
<span id="line1401" class="line"></span>            navigatorMaintainSizeRatio: false,
<span id="line1402" class="line"></span>            navigatorTop:               null,
<span id="line1403" class="line"></span>            navigatorLeft:              null,
<span id="line1404" class="line"></span>            navigatorHeight:            null,
<span id="line1405" class="line"></span>            navigatorWidth:             null,
<span id="line1406" class="line"></span>            navigatorAutoFade:          true,
<span id="line1407" class="line"></span>            navigatorRotate:            true,
<span id="line1408" class="line"></span>            navigatorBackground:        '#000',
<span id="line1409" class="line"></span>            navigatorOpacity:           0.8,
<span id="line1410" class="line"></span>            navigatorBorderColor:       '#555',
<span id="line1411" class="line"></span>            navigatorDisplayRegionColor: '#900',
<span id="line1412" class="line"></span>
<span id="line1413" class="line"></span>            // INITIAL ROTATION
<span id="line1414" class="line"></span>            degrees:                    0,
<span id="line1415" class="line"></span>
<span id="line1416" class="line"></span>            // INITIAL FLIP STATE
<span id="line1417" class="line"></span>            flipped:                          false,
<span id="line1418" class="line"></span>            overlayPreserveContentDirection:  true,
<span id="line1419" class="line"></span>
<span id="line1420" class="line"></span>            // APPEARANCE
<span id="line1421" class="line"></span>            opacity:                           1, // to be passed into each TiledImage
<span id="line1422" class="line"></span>            compositeOperation:                null, // to be passed into each TiledImage
<span id="line1423" class="line"></span>
<span id="line1424" class="line"></span>            // DRAWER SETTINGS
<span id="line1425" class="line"></span>            drawer:                            ['auto', 'webgl', 'canvas', 'html'], // prefer using auto, then webgl (with WebGL2 if available), then canvas (i.e. context2d), then fallback to html
<span id="line1426" class="line"></span>            // DRAWER CONFIGURATIONS
<span id="line1427" class="line"></span>            drawerOptions: {
<span id="line1428" class="line"></span>                // [drawer-id]: {options} map
<span id="line1429" class="line"></span>            },
<span id="line1430" class="line"></span>
<span id="line1431" class="line"></span>            // TILED IMAGE SETTINGS
<span id="line1432" class="line"></span>            preload:                           false, // to be passed into each TiledImage
<span id="line1433" class="line"></span>            imageSmoothingEnabled:             true,  // to be passed into each TiledImage
<span id="line1434" class="line"></span>            placeholderFillStyle:              null,  // to be passed into each TiledImage
<span id="line1435" class="line"></span>            subPixelRoundingForTransparency:   null,  // to be passed into each TiledImage
<span id="line1436" class="line"></span>
<span id="line1437" class="line"></span>            //REFERENCE STRIP SETTINGS
<span id="line1438" class="line"></span>            showReferenceStrip:          false,
<span id="line1439" class="line"></span>            referenceStripScroll:       'horizontal',
<span id="line1440" class="line"></span>            referenceStripElement:       null,
<span id="line1441" class="line"></span>            referenceStripHeight:        null,
<span id="line1442" class="line"></span>            referenceStripWidth:         null,
<span id="line1443" class="line"></span>            referenceStripPosition:      'BOTTOM_LEFT',
<span id="line1444" class="line"></span>            referenceStripSizeRatio:     0.2,
<span id="line1445" class="line"></span>
<span id="line1446" class="line"></span>            //COLLECTION VISUALIZATION SETTINGS
<span id="line1447" class="line"></span>            collectionRows:         3, //or columns depending on layout
<span id="line1448" class="line"></span>            collectionColumns:      0, //columns in horizontal layout, rows in vertical layout
<span id="line1449" class="line"></span>            collectionLayout:       'horizontal', //vertical
<span id="line1450" class="line"></span>            collectionMode:         false,
<span id="line1451" class="line"></span>            collectionTileSize:     800,
<span id="line1452" class="line"></span>            collectionTileMargin:   80,
<span id="line1453" class="line"></span>
<span id="line1454" class="line"></span>            //PERFORMANCE SETTINGS
<span id="line1455" class="line"></span>            imageLoaderLimit:       0,
<span id="line1456" class="line"></span>            maxImageCacheCount:     200,
<span id="line1457" class="line"></span>            timeout:                30000,
<span id="line1458" class="line"></span>            tileRetryMax:           0,
<span id="line1459" class="line"></span>            tileRetryDelay:         2500,
<span id="line1460" class="line"></span>
<span id="line1461" class="line"></span>            //INTERFACE RESOURCE SETTINGS
<span id="line1462" class="line"></span>            prefixUrl:              "/images/",
<span id="line1463" class="line"></span>            navImages: {
<span id="line1464" class="line"></span>                zoomIn: {
<span id="line1465" class="line"></span>                    REST:   'zoomin_rest.png',
<span id="line1466" class="line"></span>                    GROUP:  'zoomin_grouphover.png',
<span id="line1467" class="line"></span>                    HOVER:  'zoomin_hover.png',
<span id="line1468" class="line"></span>                    DOWN:   'zoomin_pressed.png'
<span id="line1469" class="line"></span>                },
<span id="line1470" class="line"></span>                zoomOut: {
<span id="line1471" class="line"></span>                    REST:   'zoomout_rest.png',
<span id="line1472" class="line"></span>                    GROUP:  'zoomout_grouphover.png',
<span id="line1473" class="line"></span>                    HOVER:  'zoomout_hover.png',
<span id="line1474" class="line"></span>                    DOWN:   'zoomout_pressed.png'
<span id="line1475" class="line"></span>                },
<span id="line1476" class="line"></span>                home: {
<span id="line1477" class="line"></span>                    REST:   'home_rest.png',
<span id="line1478" class="line"></span>                    GROUP:  'home_grouphover.png',
<span id="line1479" class="line"></span>                    HOVER:  'home_hover.png',
<span id="line1480" class="line"></span>                    DOWN:   'home_pressed.png'
<span id="line1481" class="line"></span>                },
<span id="line1482" class="line"></span>                fullpage: {
<span id="line1483" class="line"></span>                    REST:   'fullpage_rest.png',
<span id="line1484" class="line"></span>                    GROUP:  'fullpage_grouphover.png',
<span id="line1485" class="line"></span>                    HOVER:  'fullpage_hover.png',
<span id="line1486" class="line"></span>                    DOWN:   'fullpage_pressed.png'
<span id="line1487" class="line"></span>                },
<span id="line1488" class="line"></span>                rotateleft: {
<span id="line1489" class="line"></span>                    REST:   'rotateleft_rest.png',
<span id="line1490" class="line"></span>                    GROUP:  'rotateleft_grouphover.png',
<span id="line1491" class="line"></span>                    HOVER:  'rotateleft_hover.png',
<span id="line1492" class="line"></span>                    DOWN:   'rotateleft_pressed.png'
<span id="line1493" class="line"></span>                },
<span id="line1494" class="line"></span>                rotateright: {
<span id="line1495" class="line"></span>                    REST:   'rotateright_rest.png',
<span id="line1496" class="line"></span>                    GROUP:  'rotateright_grouphover.png',
<span id="line1497" class="line"></span>                    HOVER:  'rotateright_hover.png',
<span id="line1498" class="line"></span>                    DOWN:   'rotateright_pressed.png'
<span id="line1499" class="line"></span>                },
<span id="line1500" class="line"></span>                flip: { // Flip icon designed by Yaroslav Samoylov from the Noun Project and modified by Nelson Campos ncampos@criteriamarathon.com, https://thenounproject.com/term/flip/136289/
<span id="line1501" class="line"></span>                    REST:   'flip_rest.png',
<span id="line1502" class="line"></span>                    GROUP:  'flip_grouphover.png',
<span id="line1503" class="line"></span>                    HOVER:  'flip_hover.png',
<span id="line1504" class="line"></span>                    DOWN:   'flip_pressed.png'
<span id="line1505" class="line"></span>                },
<span id="line1506" class="line"></span>                previous: {
<span id="line1507" class="line"></span>                    REST:   'previous_rest.png',
<span id="line1508" class="line"></span>                    GROUP:  'previous_grouphover.png',
<span id="line1509" class="line"></span>                    HOVER:  'previous_hover.png',
<span id="line1510" class="line"></span>                    DOWN:   'previous_pressed.png'
<span id="line1511" class="line"></span>                },
<span id="line1512" class="line"></span>                next: {
<span id="line1513" class="line"></span>                    REST:   'next_rest.png',
<span id="line1514" class="line"></span>                    GROUP:  'next_grouphover.png',
<span id="line1515" class="line"></span>                    HOVER:  'next_hover.png',
<span id="line1516" class="line"></span>                    DOWN:   'next_pressed.png'
<span id="line1517" class="line"></span>                }
<span id="line1518" class="line"></span>            },
<span id="line1519" class="line"></span>
<span id="line1520" class="line"></span>            //DEVELOPER SETTINGS
<span id="line1521" class="line"></span>            debugMode:              false,
<span id="line1522" class="line"></span>            debugGridColor:         ['#437AB2', '#1B9E77', '#D95F02', '#7570B3', '#E7298A', '#66A61E', '#E6AB02', '#A6761D', '#666666'],
<span id="line1523" class="line"></span>            silenceMultiImageWarnings: false
<span id="line1524" class="line"></span>
<span id="line1525" class="line"></span>        },
<span id="line1526" class="line"></span>
<span id="line1527" class="line"></span>        /**
<span id="line1528" class="line"></span>         * Returns a function which invokes the method as if it were a method belonging to the object.
<span id="line1529" class="line"></span>         * @function
<span id="line1530" class="line"></span>         * @param {Object} object
<span id="line1531" class="line"></span>         * @param {Function} method
<span id="line1532" class="line"></span>         * @returns {Function}
<span id="line1533" class="line"></span>         */
<span id="line1534" class="line"></span>        delegate: function( object, method ) {
<span id="line1535" class="line"></span>            return function(){
<span id="line1536" class="line"></span>                let args = arguments;
<span id="line1537" class="line"></span>                if ( args === undefined ){
<span id="line1538" class="line"></span>                    args = [];
<span id="line1539" class="line"></span>                }
<span id="line1540" class="line"></span>                return method.apply( object, args );
<span id="line1541" class="line"></span>            };
<span id="line1542" class="line"></span>        },
<span id="line1543" class="line"></span>
<span id="line1544" class="line"></span>
<span id="line1545" class="line"></span>        /**
<span id="line1546" class="line"></span>         * An enumeration of Browser vendors.
<span id="line1547" class="line"></span>         * @static
<span id="line1548" class="line"></span>         * @type {Object}
<span id="line1549" class="line"></span>         * @property {Number} UNKNOWN
<span id="line1550" class="line"></span>         * @property {Number} IE
<span id="line1551" class="line"></span>         * @property {Number} FIREFOX
<span id="line1552" class="line"></span>         * @property {Number} SAFARI
<span id="line1553" class="line"></span>         * @property {Number} CHROME
<span id="line1554" class="line"></span>         * @property {Number} OPERA
<span id="line1555" class="line"></span>         * @property {Number} EDGE
<span id="line1556" class="line"></span>         * @property {Number} CHROMEEDGE
<span id="line1557" class="line"></span>         */
<span id="line1558" class="line"></span>        BROWSERS: {
<span id="line1559" class="line"></span>            UNKNOWN:    0,
<span id="line1560" class="line"></span>            IE:         1,
<span id="line1561" class="line"></span>            FIREFOX:    2,
<span id="line1562" class="line"></span>            SAFARI:     3,
<span id="line1563" class="line"></span>            CHROME:     4,
<span id="line1564" class="line"></span>            OPERA:      5,
<span id="line1565" class="line"></span>            EDGE:       6,
<span id="line1566" class="line"></span>            CHROMEEDGE: 7
<span id="line1567" class="line"></span>        },
<span id="line1568" class="line"></span>
<span id="line1569" class="line"></span>        /**
<span id="line1570" class="line"></span>         * An enumeration of when subpixel rounding should occur.
<span id="line1571" class="line"></span>         * @static
<span id="line1572" class="line"></span>         * @type {Object}
<span id="line1573" class="line"></span>         * @property {Number} NEVER Never apply subpixel rounding for transparency.
<span id="line1574" class="line"></span>         * @property {Number} ONLY_AT_REST Do not apply subpixel rounding for transparency during animation (panning, zoom, rotation) and apply it once animation is over.
<span id="line1575" class="line"></span>         * @property {Number} ALWAYS Apply subpixel rounding for transparency during animation and when animation is over.
<span id="line1576" class="line"></span>         */
<span id="line1577" class="line"></span>        SUBPIXEL_ROUNDING_OCCURRENCES: {
<span id="line1578" class="line"></span>            NEVER:        0,
<span id="line1579" class="line"></span>            ONLY_AT_REST: 1,
<span id="line1580" class="line"></span>            ALWAYS:       2
<span id="line1581" class="line"></span>        },
<span id="line1582" class="line"></span>
<span id="line1583" class="line"></span>        /**
<span id="line1584" class="line"></span>         * Keep track of which {@link Viewer}s have been created.
<span id="line1585" class="line"></span>         * - Key: {@link Element} to which a Viewer is attached.
<span id="line1586" class="line"></span>         * - Value: {@link Viewer} of the element defined by the key.
<span id="line1587" class="line"></span>         * @private
<span id="line1588" class="line"></span>         * @static
<span id="line1589" class="line"></span>         * @type {Object}
<span id="line1590" class="line"></span>         */
<span id="line1591" class="line"></span>        _viewers: new Map(),
<span id="line1592" class="line"></span>
<span id="line1593" class="line"></span>       /**
<span id="line1594" class="line"></span>         * Returns the {@link Viewer} attached to a given DOM element. If there is
<span id="line1595" class="line"></span>         * no viewer attached to the provided element, undefined is returned.
<span id="line1596" class="line"></span>         * @function
<span id="line1597" class="line"></span>         * @param {String|Element} element Accepts an id or element.
<span id="line1598" class="line"></span>         * @returns {Viewer} The viewer attached to the given element, or undefined.
<span id="line1599" class="line"></span>         */
<span id="line1600" class="line"></span>        getViewer: function(element) {
<span id="line1601" class="line"></span>            return $._viewers.get(this.getElement(element));
<span id="line1602" class="line"></span>        },
<span id="line1603" class="line"></span>
<span id="line1604" class="line"></span>        /**
<span id="line1605" class="line"></span>         * Returns a DOM Element for the given id or element.
<span id="line1606" class="line"></span>         * @function
<span id="line1607" class="line"></span>         * @param {String|Element} element Accepts an id or element.
<span id="line1608" class="line"></span>         * @returns {Element} The element with the given id, null, or the element itself.
<span id="line1609" class="line"></span>         */
<span id="line1610" class="line"></span>        getElement: function( element ) {
<span id="line1611" class="line"></span>            if ( typeof ( element ) === "string" ) {
<span id="line1612" class="line"></span>                element = document.getElementById( element );
<span id="line1613" class="line"></span>            }
<span id="line1614" class="line"></span>            return element;
<span id="line1615" class="line"></span>        },
<span id="line1616" class="line"></span>
<span id="line1617" class="line"></span>
<span id="line1618" class="line"></span>        /**
<span id="line1619" class="line"></span>         * Determines the position of the upper-left corner of the element.
<span id="line1620" class="line"></span>         * @function
<span id="line1621" class="line"></span>         * @param {Element|String} element - the element we want the position for.
<span id="line1622" class="line"></span>         * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element.
<span id="line1623" class="line"></span>         */
<span id="line1624" class="line"></span>        getElementPosition: function( element ) {
<span id="line1625" class="line"></span>            let result = new $.Point();
<span id="line1626" class="line"></span>            let isFixed;
<span id="line1627" class="line"></span>            let offsetParent;
<span id="line1628" class="line"></span>
<span id="line1629" class="line"></span>            element      = $.getElement( element );
<span id="line1630" class="line"></span>            isFixed      = $.getElementStyle( element ).position === "fixed";
<span id="line1631" class="line"></span>            offsetParent = getOffsetParent( element, isFixed );
<span id="line1632" class="line"></span>
<span id="line1633" class="line"></span>            while ( offsetParent ) {
<span id="line1634" class="line"></span>
<span id="line1635" class="line"></span>                result.x += element.offsetLeft;
<span id="line1636" class="line"></span>                result.y += element.offsetTop;
<span id="line1637" class="line"></span>
<span id="line1638" class="line"></span>                if ( isFixed ) {
<span id="line1639" class="line"></span>                    result = result.plus( $.getPageScroll() );
<span id="line1640" class="line"></span>                }
<span id="line1641" class="line"></span>
<span id="line1642" class="line"></span>                element = offsetParent;
<span id="line1643" class="line"></span>                isFixed = $.getElementStyle( element ).position === "fixed";
<span id="line1644" class="line"></span>                offsetParent = getOffsetParent( element, isFixed );
<span id="line1645" class="line"></span>            }
<span id="line1646" class="line"></span>
<span id="line1647" class="line"></span>            return result;
<span id="line1648" class="line"></span>        },
<span id="line1649" class="line"></span>
<span id="line1650" class="line"></span>
<span id="line1651" class="line"></span>        /**
<span id="line1652" class="line"></span>         * Determines the position of the upper-left corner of the element adjusted for current page and/or element scroll.
<span id="line1653" class="line"></span>         * @function
<span id="line1654" class="line"></span>         * @param {Element|String} element - the element we want the position for.
<span id="line1655" class="line"></span>         * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element adjusted for current page and/or element scroll.
<span id="line1656" class="line"></span>         */
<span id="line1657" class="line"></span>        getElementOffset: function( element ) {
<span id="line1658" class="line"></span>            element = $.getElement( element );
<span id="line1659" class="line"></span>
<span id="line1660" class="line"></span>            const doc = element &amp;&amp; element.ownerDocument;
<span id="line1661" class="line"></span>            let boundingRect = { top: 0, left: 0 };
<span id="line1662" class="line"></span>
<span id="line1663" class="line"></span>            if ( !doc ) {
<span id="line1664" class="line"></span>                return new $.Point();
<span id="line1665" class="line"></span>            }
<span id="line1666" class="line"></span>
<span id="line1667" class="line"></span>            const docElement = doc.documentElement;
<span id="line1668" class="line"></span>
<span id="line1669" class="line"></span>            if ( typeof element.getBoundingClientRect !== typeof undefined ) {
<span id="line1670" class="line"></span>                boundingRect = element.getBoundingClientRect();
<span id="line1671" class="line"></span>            }
<span id="line1672" class="line"></span>
<span id="line1673" class="line"></span>            const win = ( doc === doc.window ) ?
<span id="line1674" class="line"></span>                doc :
<span id="line1675" class="line"></span>                ( doc.nodeType === 9 ) ?
<span id="line1676" class="line"></span>                    doc.defaultView || doc.parentWindow :
<span id="line1677" class="line"></span>                    false;
<span id="line1678" class="line"></span>
<span id="line1679" class="line"></span>            return new $.Point(
<span id="line1680" class="line"></span>                boundingRect.left + ( win.pageXOffset || docElement.scrollLeft ) - ( docElement.clientLeft || 0 ),
<span id="line1681" class="line"></span>                boundingRect.top + ( win.pageYOffset || docElement.scrollTop ) - ( docElement.clientTop || 0 )
<span id="line1682" class="line"></span>            );
<span id="line1683" class="line"></span>        },
<span id="line1684" class="line"></span>
<span id="line1685" class="line"></span>
<span id="line1686" class="line"></span>        /**
<span id="line1687" class="line"></span>         * Determines the height and width of the given element.
<span id="line1688" class="line"></span>         * @function
<span id="line1689" class="line"></span>         * @param {Element|String} element
<span id="line1690" class="line"></span>         * @returns {OpenSeadragon.Point}
<span id="line1691" class="line"></span>         */
<span id="line1692" class="line"></span>        getElementSize: function( element ) {
<span id="line1693" class="line"></span>            element = $.getElement( element );
<span id="line1694" class="line"></span>
<span id="line1695" class="line"></span>            return new $.Point(
<span id="line1696" class="line"></span>                element.clientWidth,
<span id="line1697" class="line"></span>                element.clientHeight
<span id="line1698" class="line"></span>            );
<span id="line1699" class="line"></span>        },
<span id="line1700" class="line"></span>
<span id="line1701" class="line"></span>
<span id="line1702" class="line"></span>        /**
<span id="line1703" class="line"></span>         * Returns the CSSStyle object for the given element.
<span id="line1704" class="line"></span>         * @function
<span id="line1705" class="line"></span>         * @param {Element|String} element
<span id="line1706" class="line"></span>         * @returns {CSSStyle}
<span id="line1707" class="line"></span>         */
<span id="line1708" class="line"></span>        getElementStyle:
<span id="line1709" class="line"></span>            document.documentElement.currentStyle ?
<span id="line1710" class="line"></span>            function( element ) {
<span id="line1711" class="line"></span>                element = $.getElement( element );
<span id="line1712" class="line"></span>                return element.currentStyle;
<span id="line1713" class="line"></span>            } :
<span id="line1714" class="line"></span>            function( element ) {
<span id="line1715" class="line"></span>                element = $.getElement( element );
<span id="line1716" class="line"></span>                return window.getComputedStyle( element, "" );
<span id="line1717" class="line"></span>            },
<span id="line1718" class="line"></span>
<span id="line1719" class="line"></span>        /**
<span id="line1720" class="line"></span>         * Returns the property with the correct vendor prefix appended.
<span id="line1721" class="line"></span>         * @param {String} property the property name
<span id="line1722" class="line"></span>         * @returns {String} the property with the correct prefix or null if not
<span id="line1723" class="line"></span>         * supported.
<span id="line1724" class="line"></span>         */
<span id="line1725" class="line"></span>        getCssPropertyWithVendorPrefix: function(property) {
<span id="line1726" class="line"></span>            const memo = {};
<span id="line1727" class="line"></span>
<span id="line1728" class="line"></span>            $.getCssPropertyWithVendorPrefix = function(property) {
<span id="line1729" class="line"></span>                if (memo[property] !== undefined) {
<span id="line1730" class="line"></span>                    return memo[property];
<span id="line1731" class="line"></span>                }
<span id="line1732" class="line"></span>                const style = document.createElement('div').style;
<span id="line1733" class="line"></span>                let result = null;
<span id="line1734" class="line"></span>                if (style[property] !== undefined) {
<span id="line1735" class="line"></span>                    result = property;
<span id="line1736" class="line"></span>                } else {
<span id="line1737" class="line"></span>                    const prefixes = ['Webkit', 'Moz', 'MS', 'O',
<span id="line1738" class="line"></span>                        'webkit', 'moz', 'ms', 'o'];
<span id="line1739" class="line"></span>                    const suffix = $.capitalizeFirstLetter(property);
<span id="line1740" class="line"></span>                    for (let i = 0; i &lt; prefixes.length; i++) {
<span id="line1741" class="line"></span>                        const prop = prefixes[i] + suffix;
<span id="line1742" class="line"></span>                        if (style[prop] !== undefined) {
<span id="line1743" class="line"></span>                            result = prop;
<span id="line1744" class="line"></span>                            break;
<span id="line1745" class="line"></span>                        }
<span id="line1746" class="line"></span>                    }
<span id="line1747" class="line"></span>                }
<span id="line1748" class="line"></span>                memo[property] = result;
<span id="line1749" class="line"></span>                return result;
<span id="line1750" class="line"></span>            };
<span id="line1751" class="line"></span>            return $.getCssPropertyWithVendorPrefix(property);
<span id="line1752" class="line"></span>        },
<span id="line1753" class="line"></span>
<span id="line1754" class="line"></span>        /**
<span id="line1755" class="line"></span>         * Capitalizes the first letter of a string
<span id="line1756" class="line"></span>         * @param {String} string
<span id="line1757" class="line"></span>         * @returns {String} The string with the first letter capitalized
<span id="line1758" class="line"></span>         */
<span id="line1759" class="line"></span>        capitalizeFirstLetter: function(string) {
<span id="line1760" class="line"></span>            return string.charAt(0).toUpperCase() + string.slice(1);
<span id="line1761" class="line"></span>        },
<span id="line1762" class="line"></span>
<span id="line1763" class="line"></span>        /**
<span id="line1764" class="line"></span>         * Compute the modulo of a number but makes sure to always return
<span id="line1765" class="line"></span>         * a positive value (also known as Euclidean modulo).
<span id="line1766" class="line"></span>         * @param {Number} number the number to compute the modulo of
<span id="line1767" class="line"></span>         * @param {Number} modulo the modulo
<span id="line1768" class="line"></span>         * @returns {Number} the result of the modulo of number
<span id="line1769" class="line"></span>         */
<span id="line1770" class="line"></span>        positiveModulo: function(number, modulo) {
<span id="line1771" class="line"></span>            let result = number % modulo;
<span id="line1772" class="line"></span>            if (result &lt; 0) {
<span id="line1773" class="line"></span>                result += modulo;
<span id="line1774" class="line"></span>            }
<span id="line1775" class="line"></span>            return result;
<span id="line1776" class="line"></span>        },
<span id="line1777" class="line"></span>
<span id="line1778" class="line"></span>
<span id="line1779" class="line"></span>        /**
<span id="line1780" class="line"></span>         * Determines if a point is within the bounding rectangle of the given element (hit-test).
<span id="line1781" class="line"></span>         * @function
<span id="line1782" class="line"></span>         * @param {Element|String} element
<span id="line1783" class="line"></span>         * @param {OpenSeadragon.Point} point
<span id="line1784" class="line"></span>         * @returns {Boolean}
<span id="line1785" class="line"></span>         */
<span id="line1786" class="line"></span>        pointInElement: function( element, point ) {
<span id="line1787" class="line"></span>            element = $.getElement( element );
<span id="line1788" class="line"></span>            const offset = $.getElementOffset( element );
<span id="line1789" class="line"></span>            const size = $.getElementSize( element );
<span id="line1790" class="line"></span>            return point.x &gt;= offset.x &amp;&amp; point.x &lt; offset.x + size.x &amp;&amp; point.y &lt; offset.y + size.y &amp;&amp; point.y &gt;= offset.y;
<span id="line1791" class="line"></span>        },
<span id="line1792" class="line"></span>
<span id="line1793" class="line"></span>
<span id="line1794" class="line"></span>        /**
<span id="line1795" class="line"></span>         * Gets the position of the mouse on the screen for a given event.
<span id="line1796" class="line"></span>         * @function
<span id="line1797" class="line"></span>         * @param {Event} [event]
<span id="line1798" class="line"></span>         * @returns {OpenSeadragon.Point}
<span id="line1799" class="line"></span>         */
<span id="line1800" class="line"></span>        getMousePosition: function( event ) {
<span id="line1801" class="line"></span>
<span id="line1802" class="line"></span>            if ( typeof ( event.pageX ) === "number" ) {
<span id="line1803" class="line"></span>                $.getMousePosition = function( event ){
<span id="line1804" class="line"></span>                    const result = new $.Point();
<span id="line1805" class="line"></span>
<span id="line1806" class="line"></span>                    result.x = event.pageX;
<span id="line1807" class="line"></span>                    result.y = event.pageY;
<span id="line1808" class="line"></span>
<span id="line1809" class="line"></span>                    return result;
<span id="line1810" class="line"></span>                };
<span id="line1811" class="line"></span>            } else if ( typeof ( event.clientX ) === "number" ) {
<span id="line1812" class="line"></span>                $.getMousePosition = function( event ){
<span id="line1813" class="line"></span>                    const result = new $.Point();
<span id="line1814" class="line"></span>
<span id="line1815" class="line"></span>                    result.x =
<span id="line1816" class="line"></span>                        event.clientX +
<span id="line1817" class="line"></span>                        document.body.scrollLeft +
<span id="line1818" class="line"></span>                        document.documentElement.scrollLeft;
<span id="line1819" class="line"></span>                    result.y =
<span id="line1820" class="line"></span>                        event.clientY +
<span id="line1821" class="line"></span>                        document.body.scrollTop +
<span id="line1822" class="line"></span>                        document.documentElement.scrollTop;
<span id="line1823" class="line"></span>
<span id="line1824" class="line"></span>                    return result;
<span id="line1825" class="line"></span>                };
<span id="line1826" class="line"></span>            } else {
<span id="line1827" class="line"></span>                throw new Error(
<span id="line1828" class="line"></span>                    "Unknown event mouse position, no known technique."
<span id="line1829" class="line"></span>                );
<span id="line1830" class="line"></span>            }
<span id="line1831" class="line"></span>
<span id="line1832" class="line"></span>            return $.getMousePosition( event );
<span id="line1833" class="line"></span>        },
<span id="line1834" class="line"></span>
<span id="line1835" class="line"></span>
<span id="line1836" class="line"></span>        /**
<span id="line1837" class="line"></span>         * Determines the page's current scroll position.
<span id="line1838" class="line"></span>         * @function
<span id="line1839" class="line"></span>         * @returns {OpenSeadragon.Point}
<span id="line1840" class="line"></span>         */
<span id="line1841" class="line"></span>        getPageScroll: function() {
<span id="line1842" class="line"></span>            const docElement = document.documentElement || {};
<span id="line1843" class="line"></span>            const body = document.body || {};
<span id="line1844" class="line"></span>
<span id="line1845" class="line"></span>            if ( typeof ( window.pageXOffset ) === "number" ) {
<span id="line1846" class="line"></span>                $.getPageScroll = function(){
<span id="line1847" class="line"></span>                    return new $.Point(
<span id="line1848" class="line"></span>                        window.pageXOffset,
<span id="line1849" class="line"></span>                        window.pageYOffset
<span id="line1850" class="line"></span>                    );
<span id="line1851" class="line"></span>                };
<span id="line1852" class="line"></span>            } else if ( body.scrollLeft || body.scrollTop ) {
<span id="line1853" class="line"></span>                $.getPageScroll = function(){
<span id="line1854" class="line"></span>                    return new $.Point(
<span id="line1855" class="line"></span>                        document.body.scrollLeft,
<span id="line1856" class="line"></span>                        document.body.scrollTop
<span id="line1857" class="line"></span>                    );
<span id="line1858" class="line"></span>                };
<span id="line1859" class="line"></span>            } else if ( docElement.scrollLeft || docElement.scrollTop ) {
<span id="line1860" class="line"></span>                $.getPageScroll = function(){
<span id="line1861" class="line"></span>                    return new $.Point(
<span id="line1862" class="line"></span>                        document.documentElement.scrollLeft,
<span id="line1863" class="line"></span>                        document.documentElement.scrollTop
<span id="line1864" class="line"></span>                    );
<span id="line1865" class="line"></span>                };
<span id="line1866" class="line"></span>            } else {
<span id="line1867" class="line"></span>                // We can't reassign the function yet, as there was no scroll.
<span id="line1868" class="line"></span>                return new $.Point(0, 0);
<span id="line1869" class="line"></span>            }
<span id="line1870" class="line"></span>
<span id="line1871" class="line"></span>            return $.getPageScroll();
<span id="line1872" class="line"></span>        },
<span id="line1873" class="line"></span>
<span id="line1874" class="line"></span>        /**
<span id="line1875" class="line"></span>         * Set the page scroll position.
<span id="line1876" class="line"></span>         * @function
<span id="line1877" class="line"></span>         * @returns {OpenSeadragon.Point}
<span id="line1878" class="line"></span>         */
<span id="line1879" class="line"></span>        setPageScroll: function( scroll ) {
<span id="line1880" class="line"></span>            if ( typeof ( window.scrollTo ) !== "undefined" ) {
<span id="line1881" class="line"></span>                $.setPageScroll = function( scroll ) {
<span id="line1882" class="line"></span>                    window.scrollTo( scroll.x, scroll.y );
<span id="line1883" class="line"></span>                };
<span id="line1884" class="line"></span>            } else {
<span id="line1885" class="line"></span>                const originalScroll = $.getPageScroll();
<span id="line1886" class="line"></span>                if ( originalScroll.x === scroll.x &amp;&amp;
<span id="line1887" class="line"></span>                    originalScroll.y === scroll.y ) {
<span id="line1888" class="line"></span>                    // We are already correctly positioned and there
<span id="line1889" class="line"></span>                    // is no way to detect the correct method.
<span id="line1890" class="line"></span>                    return;
<span id="line1891" class="line"></span>                }
<span id="line1892" class="line"></span>
<span id="line1893" class="line"></span>                document.body.scrollLeft = scroll.x;
<span id="line1894" class="line"></span>                document.body.scrollTop = scroll.y;
<span id="line1895" class="line"></span>                let currentScroll = $.getPageScroll();
<span id="line1896" class="line"></span>                if ( currentScroll.x !== originalScroll.x &amp;&amp;
<span id="line1897" class="line"></span>                    currentScroll.y !== originalScroll.y ) {
<span id="line1898" class="line"></span>                    $.setPageScroll = function( scroll ) {
<span id="line1899" class="line"></span>                        document.body.scrollLeft = scroll.x;
<span id="line1900" class="line"></span>                        document.body.scrollTop = scroll.y;
<span id="line1901" class="line"></span>                    };
<span id="line1902" class="line"></span>                    return;
<span id="line1903" class="line"></span>                }
<span id="line1904" class="line"></span>
<span id="line1905" class="line"></span>                document.documentElement.scrollLeft = scroll.x;
<span id="line1906" class="line"></span>                document.documentElement.scrollTop = scroll.y;
<span id="line1907" class="line"></span>                currentScroll = $.getPageScroll();
<span id="line1908" class="line"></span>                if ( currentScroll.x !== originalScroll.x &amp;&amp;
<span id="line1909" class="line"></span>                    currentScroll.y !== originalScroll.y ) {
<span id="line1910" class="line"></span>                    $.setPageScroll = function( scroll ) {
<span id="line1911" class="line"></span>                        document.documentElement.scrollLeft = scroll.x;
<span id="line1912" class="line"></span>                        document.documentElement.scrollTop = scroll.y;
<span id="line1913" class="line"></span>                    };
<span id="line1914" class="line"></span>                    return;
<span id="line1915" class="line"></span>                }
<span id="line1916" class="line"></span>
<span id="line1917" class="line"></span>                // We can't find anything working, so we do nothing.
<span id="line1918" class="line"></span>                $.setPageScroll = function( scroll ) {
<span id="line1919" class="line"></span>                };
<span id="line1920" class="line"></span>            }
<span id="line1921" class="line"></span>
<span id="line1922" class="line"></span>            $.setPageScroll( scroll );
<span id="line1923" class="line"></span>        },
<span id="line1924" class="line"></span>
<span id="line1925" class="line"></span>        /**
<span id="line1926" class="line"></span>         * Determines the size of the browsers window.
<span id="line1927" class="line"></span>         * @function
<span id="line1928" class="line"></span>         * @returns {OpenSeadragon.Point}
<span id="line1929" class="line"></span>         */
<span id="line1930" class="line"></span>        getWindowSize: function() {
<span id="line1931" class="line"></span>            const docElement = document.documentElement || {};
<span id="line1932" class="line"></span>            const body = document.body || {};
<span id="line1933" class="line"></span>
<span id="line1934" class="line"></span>            if ( typeof ( window.innerWidth ) === 'number' ) {
<span id="line1935" class="line"></span>                $.getWindowSize = function(){
<span id="line1936" class="line"></span>                    return new $.Point(
<span id="line1937" class="line"></span>                        window.innerWidth,
<span id="line1938" class="line"></span>                        window.innerHeight
<span id="line1939" class="line"></span>                    );
<span id="line1940" class="line"></span>                };
<span id="line1941" class="line"></span>            } else if ( docElement.clientWidth || docElement.clientHeight ) {
<span id="line1942" class="line"></span>                $.getWindowSize = function(){
<span id="line1943" class="line"></span>                    return new $.Point(
<span id="line1944" class="line"></span>                        document.documentElement.clientWidth,
<span id="line1945" class="line"></span>                        document.documentElement.clientHeight
<span id="line1946" class="line"></span>                    );
<span id="line1947" class="line"></span>                };
<span id="line1948" class="line"></span>            } else if ( body.clientWidth || body.clientHeight ) {
<span id="line1949" class="line"></span>                $.getWindowSize = function(){
<span id="line1950" class="line"></span>                    return new $.Point(
<span id="line1951" class="line"></span>                        document.body.clientWidth,
<span id="line1952" class="line"></span>                        document.body.clientHeight
<span id="line1953" class="line"></span>                    );
<span id="line1954" class="line"></span>                };
<span id="line1955" class="line"></span>            } else {
<span id="line1956" class="line"></span>                throw new Error("Unknown window size, no known technique.");
<span id="line1957" class="line"></span>            }
<span id="line1958" class="line"></span>
<span id="line1959" class="line"></span>            return $.getWindowSize();
<span id="line1960" class="line"></span>        },
<span id="line1961" class="line"></span>
<span id="line1962" class="line"></span>
<span id="line1963" class="line"></span>        /**
<span id="line1964" class="line"></span>         * Wraps the given element in a nest of divs so that the element can
<span id="line1965" class="line"></span>         * be easily centered using CSS tables
<span id="line1966" class="line"></span>         * @function
<span id="line1967" class="line"></span>         * @param {Element|String} element
<span id="line1968" class="line"></span>         * @returns {Element} outermost wrapper element
<span id="line1969" class="line"></span>         */
<span id="line1970" class="line"></span>        makeCenteredNode: function( element ) {
<span id="line1971" class="line"></span>            // Convert a possible ID to an actual HTMLElement
<span id="line1972" class="line"></span>            element = $.getElement( element );
<span id="line1973" class="line"></span>
<span id="line1974" class="line"></span>            /*
<span id="line1975" class="line"></span>                CSS tables require you to have a display:table/row/cell hierarchy so we need to create
<span id="line1976" class="line"></span>                three nested wrapper divs:
<span id="line1977" class="line"></span>             */
<span id="line1978" class="line"></span>
<span id="line1979" class="line"></span>            const wrappers = [
<span id="line1980" class="line"></span>                $.makeNeutralElement( 'div' ),
<span id="line1981" class="line"></span>                $.makeNeutralElement( 'div' ),
<span id="line1982" class="line"></span>                $.makeNeutralElement( 'div' )
<span id="line1983" class="line"></span>            ];
<span id="line1984" class="line"></span>
<span id="line1985" class="line"></span>            // It feels like we should be able to pass style dicts to makeNeutralElement:
<span id="line1986" class="line"></span>            $.extend(wrappers[0].style, {
<span id="line1987" class="line"></span>                display: "table",
<span id="line1988" class="line"></span>                height: "100%",
<span id="line1989" class="line"></span>                width: "100%"
<span id="line1990" class="line"></span>            });
<span id="line1991" class="line"></span>
<span id="line1992" class="line"></span>            $.extend(wrappers[1].style, {
<span id="line1993" class="line"></span>                display: "table-row"
<span id="line1994" class="line"></span>            });
<span id="line1995" class="line"></span>
<span id="line1996" class="line"></span>            $.extend(wrappers[2].style, {
<span id="line1997" class="line"></span>                display: "table-cell",
<span id="line1998" class="line"></span>                verticalAlign: "middle",
<span id="line1999" class="line"></span>                textAlign: "center"
<span id="line2000" class="line"></span>            });
<span id="line2001" class="line"></span>
<span id="line2002" class="line"></span>            wrappers[0].appendChild(wrappers[1]);
<span id="line2003" class="line"></span>            wrappers[1].appendChild(wrappers[2]);
<span id="line2004" class="line"></span>            wrappers[2].appendChild(element);
<span id="line2005" class="line"></span>
<span id="line2006" class="line"></span>            return wrappers[0];
<span id="line2007" class="line"></span>        },
<span id="line2008" class="line"></span>
<span id="line2009" class="line"></span>        /**
<span id="line2010" class="line"></span>         * Log trace information from the system. Useful for logging and debugging
<span id="line2011" class="line"></span>         * async events. Calls to this function SHOULD NOT BE present in the release.
<span id="line2012" class="line"></span>         * (or at least used only in debug mode).
<span id="line2013" class="line"></span>         * @param {OpenSeadragon.Tile|OpenSeadragon.CacheRecord|string} tile message to log or tile to inspect
<span id="line2014" class="line"></span>         * @param {boolean} stacktrace if true log the stacktrace
<span id="line2015" class="line"></span>         */
<span id="line2016" class="line"></span>        trace: function(tile, stacktrace = false) {
<span id="line2017" class="line"></span>            this.__traceLogs = [];
<span id="line2018" class="line"></span>            setInterval(() =&gt; {
<span id="line2019" class="line"></span>                if (!this.__traceLogs.length) {
<span id="line2020" class="line"></span>                    return;
<span id="line2021" class="line"></span>                }
<span id="line2022" class="line"></span>                console.log(this.__traceLogs.join('\n'));
<span id="line2023" class="line"></span>                this.__traceLogs = [];
<span id="line2024" class="line"></span>            }, 2000);
<span id="line2025" class="line"></span>            this.trace = function (tile, stacktrace = false) {
<span id="line2026" class="line"></span>                if (typeof tile === 'string') {
<span id="line2027" class="line"></span>                    this.__traceLogs.push(tile);
<span id="line2028" class="line"></span>                    if (stacktrace) {
<span id="line2029" class="line"></span>                        this.__traceLogs.push(...new Error().stack.split('\n').slice(1));
<span id="line2030" class="line"></span>                    }
<span id="line2031" class="line"></span>                    return;
<span id="line2032" class="line"></span>                }
<span id="line2033" class="line"></span>                if (tile instanceof OpenSeadragon.Tile) {
<span id="line2034" class="line"></span>                    tile = tile.getCache(tile.originalCacheKey);
<span id="line2035" class="line"></span>                }
<span id="line2036" class="line"></span>                const cacheTile = tile._tiles[0];
<span id="line2037" class="line"></span>                this.__traceLogs.push(`Cache ${cacheTile.toString()} loaded ${cacheTile.loaded} loading ${cacheTile.loading} cacheCount ${Object.keys(cacheTile._caches).length} - CACHE ${tile.__invStamp}`);
<span id="line2038" class="line"></span>                if (stacktrace) {
<span id="line2039" class="line"></span>                    this.__traceLogs.push(...new Error().stack.split('\n').slice(1));
<span id="line2040" class="line"></span>                }
<span id="line2041" class="line"></span>            };
<span id="line2042" class="line"></span>            this.trace(tile, stacktrace);
<span id="line2043" class="line"></span>        },
<span id="line2044" class="line"></span>
<span id="line2045" class="line"></span>
<span id="line2046" class="line"></span>        /**
<span id="line2047" class="line"></span>         * Creates an easily positionable element of the given type that therefor
<span id="line2048" class="line"></span>         * serves as an excellent container element.
<span id="line2049" class="line"></span>         * @function
<span id="line2050" class="line"></span>         * @param {String} tagName
<span id="line2051" class="line"></span>         * @returns {Element}
<span id="line2052" class="line"></span>         */
<span id="line2053" class="line"></span>        makeNeutralElement: function( tagName ) {
<span id="line2054" class="line"></span>            const element = document.createElement( tagName );
<span id="line2055" class="line"></span>            const style   = element.style;
<span id="line2056" class="line"></span>
<span id="line2057" class="line"></span>            style.background = "transparent none";
<span id="line2058" class="line"></span>            style.border     = "none";
<span id="line2059" class="line"></span>            style.margin     = "0px";
<span id="line2060" class="line"></span>            style.padding    = "0px";
<span id="line2061" class="line"></span>            style.position   = "static";
<span id="line2062" class="line"></span>
<span id="line2063" class="line"></span>            return element;
<span id="line2064" class="line"></span>        },
<span id="line2065" class="line"></span>
<span id="line2066" class="line"></span>
<span id="line2067" class="line"></span>        /**
<span id="line2068" class="line"></span>         * Returns the current milliseconds, using Date.now() if available
<span id="line2069" class="line"></span>         * @function
<span id="line2070" class="line"></span>         */
<span id="line2071" class="line"></span>        now: function( ) {
<span id="line2072" class="line"></span>            if (Date.now) {
<span id="line2073" class="line"></span>                $.now = Date.now;
<span id="line2074" class="line"></span>            } else {
<span id="line2075" class="line"></span>                $.now = function() {
<span id="line2076" class="line"></span>                    return new Date().getTime();
<span id="line2077" class="line"></span>                };
<span id="line2078" class="line"></span>            }
<span id="line2079" class="line"></span>
<span id="line2080" class="line"></span>            return $.now();
<span id="line2081" class="line"></span>        },
<span id="line2082" class="line"></span>
<span id="line2083" class="line"></span>
<span id="line2084" class="line"></span>        /**
<span id="line2085" class="line"></span>         * Ensures an image is loaded correctly to support alpha transparency.
<span id="line2086" class="line"></span>         * @function
<span id="line2087" class="line"></span>         * @param {String} src
<span id="line2088" class="line"></span>         * @returns {Element}
<span id="line2089" class="line"></span>         */
<span id="line2090" class="line"></span>        makeTransparentImage: function( src ) {
<span id="line2091" class="line"></span>            const img = $.makeNeutralElement( "img" );
<span id="line2092" class="line"></span>
<span id="line2093" class="line"></span>            img.src = src;
<span id="line2094" class="line"></span>
<span id="line2095" class="line"></span>            return img;
<span id="line2096" class="line"></span>        },
<span id="line2097" class="line"></span>
<span id="line2098" class="line"></span>
<span id="line2099" class="line"></span>        /**
<span id="line2100" class="line"></span>         * Sets the opacity of the specified element.
<span id="line2101" class="line"></span>         * @function
<span id="line2102" class="line"></span>         * @param {Element|String} element
<span id="line2103" class="line"></span>         * @param {Number} opacity
<span id="line2104" class="line"></span>         * @param {Boolean} [usesAlpha]
<span id="line2105" class="line"></span>         */
<span id="line2106" class="line"></span>        setElementOpacity: function( element, opacity, usesAlpha ) {
<span id="line2107" class="line"></span>
<span id="line2108" class="line"></span>            let ieOpacity;
<span id="line2109" class="line"></span>            let ieFilter;
<span id="line2110" class="line"></span>
<span id="line2111" class="line"></span>            element = $.getElement( element );
<span id="line2112" class="line"></span>
<span id="line2113" class="line"></span>            if ( usesAlpha &amp;&amp; !$.Browser.alpha ) {
<span id="line2114" class="line"></span>                opacity = Math.round( opacity );
<span id="line2115" class="line"></span>            }
<span id="line2116" class="line"></span>
<span id="line2117" class="line"></span>            if ( $.Browser.opacity ) {
<span id="line2118" class="line"></span>                element.style.opacity = opacity &lt; 1 ? opacity : "";
<span id="line2119" class="line"></span>            } else {
<span id="line2120" class="line"></span>                if ( opacity &lt; 1 ) {
<span id="line2121" class="line"></span>                    ieOpacity = Math.round( 100 * opacity );
<span id="line2122" class="line"></span>                    ieFilter  = "alpha(opacity=" + ieOpacity + ")";
<span id="line2123" class="line"></span>                    element.style.filter = ieFilter;
<span id="line2124" class="line"></span>                } else {
<span id="line2125" class="line"></span>                    element.style.filter = "";
<span id="line2126" class="line"></span>                }
<span id="line2127" class="line"></span>            }
<span id="line2128" class="line"></span>        },
<span id="line2129" class="line"></span>
<span id="line2130" class="line"></span>
<span id="line2131" class="line"></span>        /**
<span id="line2132" class="line"></span>         * Sets the specified element's touch-action style attribute to 'none'.
<span id="line2133" class="line"></span>         * @function
<span id="line2134" class="line"></span>         * @param {Element|String} element
<span id="line2135" class="line"></span>         */
<span id="line2136" class="line"></span>        setElementTouchActionNone: function( element ) {
<span id="line2137" class="line"></span>            element = $.getElement( element );
<span id="line2138" class="line"></span>            if ( typeof element.style.touchAction !== 'undefined' ) {
<span id="line2139" class="line"></span>                element.style.touchAction = 'none';
<span id="line2140" class="line"></span>            } else if ( typeof element.style.msTouchAction !== 'undefined' ) {
<span id="line2141" class="line"></span>                element.style.msTouchAction = 'none';
<span id="line2142" class="line"></span>            }
<span id="line2143" class="line"></span>        },
<span id="line2144" class="line"></span>
<span id="line2145" class="line"></span>
<span id="line2146" class="line"></span>        /**
<span id="line2147" class="line"></span>         * Sets the specified element's pointer-events style attribute to the passed value.
<span id="line2148" class="line"></span>         * @function
<span id="line2149" class="line"></span>         * @param {Element|String} element
<span id="line2150" class="line"></span>         * @param {String} value
<span id="line2151" class="line"></span>         */
<span id="line2152" class="line"></span>        setElementPointerEvents: function( element, value ) {
<span id="line2153" class="line"></span>            element = $.getElement( element );
<span id="line2154" class="line"></span>            if (typeof element.style !== 'undefined' &amp;&amp; typeof element.style.pointerEvents !== 'undefined' ) {
<span id="line2155" class="line"></span>                element.style.pointerEvents = value;
<span id="line2156" class="line"></span>            }
<span id="line2157" class="line"></span>        },
<span id="line2158" class="line"></span>
<span id="line2159" class="line"></span>
<span id="line2160" class="line"></span>        /**
<span id="line2161" class="line"></span>         * Sets the specified element's pointer-events style attribute to 'none'.
<span id="line2162" class="line"></span>         * @function
<span id="line2163" class="line"></span>         * @param {Element|String} element
<span id="line2164" class="line"></span>         */
<span id="line2165" class="line"></span>        setElementPointerEventsNone: function( element ) {
<span id="line2166" class="line"></span>            $.setElementPointerEvents( element, 'none' );
<span id="line2167" class="line"></span>        },
<span id="line2168" class="line"></span>
<span id="line2169" class="line"></span>
<span id="line2170" class="line"></span>        /**
<span id="line2171" class="line"></span>         * Add the specified CSS class to the element if not present.
<span id="line2172" class="line"></span>         * @function
<span id="line2173" class="line"></span>         * @param {Element|String} element
<span id="line2174" class="line"></span>         * @param {String} className
<span id="line2175" class="line"></span>         */
<span id="line2176" class="line"></span>        addClass: function( element, className ) {
<span id="line2177" class="line"></span>            element = $.getElement( element );
<span id="line2178" class="line"></span>
<span id="line2179" class="line"></span>            if (!element.className) {
<span id="line2180" class="line"></span>                element.className = className;
<span id="line2181" class="line"></span>            } else if ( ( ' ' + element.className + ' ' ).
<span id="line2182" class="line"></span>                indexOf( ' ' + className + ' ' ) === -1 ) {
<span id="line2183" class="line"></span>                element.className += ' ' + className;
<span id="line2184" class="line"></span>            }
<span id="line2185" class="line"></span>        },
<span id="line2186" class="line"></span>
<span id="line2187" class="line"></span>        /**
<span id="line2188" class="line"></span>         * Find the first index at which an element is found in an array or -1
<span id="line2189" class="line"></span>         * if not present.
<span id="line2190" class="line"></span>         *
<span id="line2191" class="line"></span>         * Code taken and adapted from
<span id="line2192" class="line"></span>         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Compatibility
<span id="line2193" class="line"></span>         *
<span id="line2194" class="line"></span>         * @function
<span id="line2195" class="line"></span>         * @param {Array} array The array from which to find the element
<span id="line2196" class="line"></span>         * @param {Object} searchElement The element to find
<span id="line2197" class="line"></span>         * @param {Number} [fromIndex=0] Index to start research.
<span id="line2198" class="line"></span>         * @returns {Number} The index of the element in the array.
<span id="line2199" class="line"></span>         */
<span id="line2200" class="line"></span>        indexOf: function( array, searchElement, fromIndex ) {
<span id="line2201" class="line"></span>            if ( Array.prototype.indexOf ) {
<span id="line2202" class="line"></span>                this.indexOf = function( array, searchElement, fromIndex ) {
<span id="line2203" class="line"></span>                    return array.indexOf( searchElement, fromIndex );
<span id="line2204" class="line"></span>                };
<span id="line2205" class="line"></span>            } else {
<span id="line2206" class="line"></span>                this.indexOf = function( array, searchElement, fromIndex ) {
<span id="line2207" class="line"></span>                    let pivot = ( fromIndex ) ? fromIndex : 0;
<span id="line2208" class="line"></span>                    if ( !array ) {
<span id="line2209" class="line"></span>                        throw new TypeError( );
<span id="line2210" class="line"></span>                    }
<span id="line2211" class="line"></span>
<span id="line2212" class="line"></span>                    const length = array.length;
<span id="line2213" class="line"></span>                    if ( length === 0 || pivot &gt;= length ) {
<span id="line2214" class="line"></span>                        return -1;
<span id="line2215" class="line"></span>                    }
<span id="line2216" class="line"></span>
<span id="line2217" class="line"></span>                    if ( pivot &lt; 0 ) {
<span id="line2218" class="line"></span>                        pivot = length - Math.abs( pivot );
<span id="line2219" class="line"></span>                    }
<span id="line2220" class="line"></span>
<span id="line2221" class="line"></span>                    for ( let i = pivot; i &lt; length; i++ ) {
<span id="line2222" class="line"></span>                        if ( array[i] === searchElement ) {
<span id="line2223" class="line"></span>                            return i;
<span id="line2224" class="line"></span>                        }
<span id="line2225" class="line"></span>                    }
<span id="line2226" class="line"></span>                    return -1;
<span id="line2227" class="line"></span>                };
<span id="line2228" class="line"></span>            }
<span id="line2229" class="line"></span>            return this.indexOf( array, searchElement, fromIndex );
<span id="line2230" class="line"></span>        },
<span id="line2231" class="line"></span>
<span id="line2232" class="line"></span>        /**
<span id="line2233" class="line"></span>         * Remove the specified CSS class from the element.
<span id="line2234" class="line"></span>         * @function
<span id="line2235" class="line"></span>         * @param {Element|String} element
<span id="line2236" class="line"></span>         * @param {String} className
<span id="line2237" class="line"></span>         */
<span id="line2238" class="line"></span>        removeClass: function( element, className ) {
<span id="line2239" class="line"></span>            const newClasses = [];
<span id="line2240" class="line"></span>
<span id="line2241" class="line"></span>            element = $.getElement( element );
<span id="line2242" class="line"></span>            const oldClasses = element.className.split( /\s+/ );
<span id="line2243" class="line"></span>            for ( let i = 0; i &lt; oldClasses.length; i++ ) {
<span id="line2244" class="line"></span>                if ( oldClasses[ i ] &amp;&amp; oldClasses[ i ] !== className ) {
<span id="line2245" class="line"></span>                    newClasses.push( oldClasses[ i ] );
<span id="line2246" class="line"></span>                }
<span id="line2247" class="line"></span>            }
<span id="line2248" class="line"></span>            element.className = newClasses.join(' ');
<span id="line2249" class="line"></span>        },
<span id="line2250" class="line"></span>
<span id="line2251" class="line"></span>        /**
<span id="line2252" class="line"></span>         * Convert passed addEventListener() options to boolean or options object,
<span id="line2253" class="line"></span>         * depending on browser support.
<span id="line2254" class="line"></span>         * @function
<span id="line2255" class="line"></span>         * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
<span id="line2256" class="line"></span>         * @param {Boolean} [options.capture]
<span id="line2257" class="line"></span>         * @param {Boolean} [options.passive]
<span id="line2258" class="line"></span>         * @param {Boolean} [options.once]
<span id="line2259" class="line"></span>         * @returns {String} The protocol (http:, https:, file:, ftp: ...)
<span id="line2260" class="line"></span>         */
<span id="line2261" class="line"></span>        normalizeEventListenerOptions: function (options) {
<span id="line2262" class="line"></span>            let opts;
<span id="line2263" class="line"></span>            if ( typeof options !== 'undefined' ) {
<span id="line2264" class="line"></span>                if ( typeof options === 'boolean' ) {
<span id="line2265" class="line"></span>                    // Legacy Boolean useCapture
<span id="line2266" class="line"></span>                    opts = $.supportsEventListenerOptions ? { capture: options } : options;
<span id="line2267" class="line"></span>                } else {
<span id="line2268" class="line"></span>                    // Options object
<span id="line2269" class="line"></span>                    opts = $.supportsEventListenerOptions ? options :
<span id="line2270" class="line"></span>                        ( ( typeof options.capture !== 'undefined' ) ? options.capture : false );
<span id="line2271" class="line"></span>                }
<span id="line2272" class="line"></span>            } else {
<span id="line2273" class="line"></span>                // No options specified - Legacy optional useCapture argument
<span id="line2274" class="line"></span>                //   (for IE, first supported on version 9, so we'll pass a Boolean)
<span id="line2275" class="line"></span>                opts = $.supportsEventListenerOptions ? { capture: false } : false;
<span id="line2276" class="line"></span>            }
<span id="line2277" class="line"></span>            return opts;
<span id="line2278" class="line"></span>        },
<span id="line2279" class="line"></span>
<span id="line2280" class="line"></span>        /**
<span id="line2281" class="line"></span>         * Adds an event listener for the given element, eventName and handler.
<span id="line2282" class="line"></span>         * @function
<span id="line2283" class="line"></span>         * @param {Element|String} element
<span id="line2284" class="line"></span>         * @param {String} eventName
<span id="line2285" class="line"></span>         * @param {Function} handler
<span id="line2286" class="line"></span>         * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
<span id="line2287" class="line"></span>         * @param {Boolean} [options.capture]
<span id="line2288" class="line"></span>         * @param {Boolean} [options.passive]
<span id="line2289" class="line"></span>         * @param {Boolean} [options.once]
<span id="line2290" class="line"></span>         */
<span id="line2291" class="line"></span>        addEvent: (function () {
<span id="line2292" class="line"></span>            if ( $.supportsAddEventListener ) {
<span id="line2293" class="line"></span>                return function ( element, eventName, handler, options ) {
<span id="line2294" class="line"></span>                    options = $.normalizeEventListenerOptions(options);
<span id="line2295" class="line"></span>                    element = $.getElement( element );
<span id="line2296" class="line"></span>                    element.addEventListener( eventName, handler, options );
<span id="line2297" class="line"></span>                };
<span id="line2298" class="line"></span>            } else if ( document.documentElement.attachEvent &amp;&amp; document.attachEvent ) {
<span id="line2299" class="line"></span>                return function ( element, eventName, handler ) {
<span id="line2300" class="line"></span>                    element = $.getElement( element );
<span id="line2301" class="line"></span>                    element.attachEvent( 'on' + eventName, handler );
<span id="line2302" class="line"></span>                };
<span id="line2303" class="line"></span>            } else {
<span id="line2304" class="line"></span>                throw new Error( "No known event model." );
<span id="line2305" class="line"></span>            }
<span id="line2306" class="line"></span>        }()),
<span id="line2307" class="line"></span>
<span id="line2308" class="line"></span>
<span id="line2309" class="line"></span>        /**
<span id="line2310" class="line"></span>         * Remove a given event listener for the given element, event type and
<span id="line2311" class="line"></span>         * handler.
<span id="line2312" class="line"></span>         * @function
<span id="line2313" class="line"></span>         * @param {Element|String} element
<span id="line2314" class="line"></span>         * @param {String} eventName
<span id="line2315" class="line"></span>         * @param {Function} handler
<span id="line2316" class="line"></span>         * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
<span id="line2317" class="line"></span>         * @param {Boolean} [options.capture]
<span id="line2318" class="line"></span>         */
<span id="line2319" class="line"></span>        removeEvent: (function () {
<span id="line2320" class="line"></span>            if ( $.supportsRemoveEventListener ) {
<span id="line2321" class="line"></span>                return function ( element, eventName, handler, options ) {
<span id="line2322" class="line"></span>                    options = $.normalizeEventListenerOptions(options);
<span id="line2323" class="line"></span>                    element = $.getElement( element );
<span id="line2324" class="line"></span>                    element.removeEventListener( eventName, handler, options );
<span id="line2325" class="line"></span>                };
<span id="line2326" class="line"></span>            } else if ( document.documentElement.detachEvent &amp;&amp; document.detachEvent ) {
<span id="line2327" class="line"></span>                return function( element, eventName, handler ) {
<span id="line2328" class="line"></span>                    element = $.getElement( element );
<span id="line2329" class="line"></span>                    element.detachEvent( 'on' + eventName, handler );
<span id="line2330" class="line"></span>                };
<span id="line2331" class="line"></span>            } else {
<span id="line2332" class="line"></span>                throw new Error( "No known event model." );
<span id="line2333" class="line"></span>            }
<span id="line2334" class="line"></span>        }()),
<span id="line2335" class="line"></span>
<span id="line2336" class="line"></span>
<span id="line2337" class="line"></span>        /**
<span id="line2338" class="line"></span>         * Cancels the default browser behavior had the event propagated all
<span id="line2339" class="line"></span>         * the way up the DOM to the window object.
<span id="line2340" class="line"></span>         * @function
<span id="line2341" class="line"></span>         * @param {Event} [event]
<span id="line2342" class="line"></span>         */
<span id="line2343" class="line"></span>        cancelEvent: function( event ) {
<span id="line2344" class="line"></span>            event.preventDefault();
<span id="line2345" class="line"></span>        },
<span id="line2346" class="line"></span>
<span id="line2347" class="line"></span>
<span id="line2348" class="line"></span>        /**
<span id="line2349" class="line"></span>         * Returns true if {@link OpenSeadragon.cancelEvent|cancelEvent} has been called on
<span id="line2350" class="line"></span>         * the event, otherwise returns false.
<span id="line2351" class="line"></span>         * @function
<span id="line2352" class="line"></span>         * @param {Event} [event]
<span id="line2353" class="line"></span>         */
<span id="line2354" class="line"></span>        eventIsCanceled: function( event ) {
<span id="line2355" class="line"></span>            return event.defaultPrevented;
<span id="line2356" class="line"></span>        },
<span id="line2357" class="line"></span>
<span id="line2358" class="line"></span>
<span id="line2359" class="line"></span>        /**
<span id="line2360" class="line"></span>         * Stops the propagation of the event through the DOM in the capturing and bubbling phases.
<span id="line2361" class="line"></span>         * @function
<span id="line2362" class="line"></span>         * @param {Event} [event]
<span id="line2363" class="line"></span>         */
<span id="line2364" class="line"></span>        stopEvent: function( event ) {
<span id="line2365" class="line"></span>            event.stopPropagation();
<span id="line2366" class="line"></span>        },
<span id="line2367" class="line"></span>
<span id="line2368" class="line"></span>
<span id="line2369" class="line"></span>        /**
<span id="line2370" class="line"></span>         * Retrieves the value of a url parameter from the window.location string.
<span id="line2371" class="line"></span>         * @function
<span id="line2372" class="line"></span>         * @param {String} key
<span id="line2373" class="line"></span>         * @returns {String} The value of the url parameter or null if no param matches.
<span id="line2374" class="line"></span>         */
<span id="line2375" class="line"></span>        getUrlParameter: function( key ) {
<span id="line2376" class="line"></span>            // eslint-disable-next-line no-use-before-define
<span id="line2377" class="line"></span>            const value = URLPARAMS[ key ];
<span id="line2378" class="line"></span>            return value ? value : null;
<span id="line2379" class="line"></span>        },
<span id="line2380" class="line"></span>
<span id="line2381" class="line"></span>        /**
<span id="line2382" class="line"></span>         * Retrieves the protocol used by the url. The url can either be absolute
<span id="line2383" class="line"></span>         * or relative.
<span id="line2384" class="line"></span>         * @function
<span id="line2385" class="line"></span>         * @private
<span id="line2386" class="line"></span>         * @param {String} url The url to retrieve the protocol from.
<span id="line2387" class="line"></span>         * @returns {String} The protocol (http:, https:, file:, ftp: ...)
<span id="line2388" class="line"></span>         */
<span id="line2389" class="line"></span>        getUrlProtocol: function( url ) {
<span id="line2390" class="line"></span>            const match = url.match(/^([a-z]+:)\/\//i);
<span id="line2391" class="line"></span>            if ( match === null ) {
<span id="line2392" class="line"></span>                // Relative URL, retrive the protocol from window.location
<span id="line2393" class="line"></span>                return window.location.protocol;
<span id="line2394" class="line"></span>            }
<span id="line2395" class="line"></span>            return match[1].toLowerCase();
<span id="line2396" class="line"></span>        },
<span id="line2397" class="line"></span>
<span id="line2398" class="line"></span>        /**
<span id="line2399" class="line"></span>         * Create an XHR object
<span id="line2400" class="line"></span>         * @private
<span id="line2401" class="line"></span>         * @param {type} [local] Deprecated. Ignored (IE/ActiveXObject file protocol no longer supported).
<span id="line2402" class="line"></span>         * @returns {XMLHttpRequest}
<span id="line2403" class="line"></span>         */
<span id="line2404" class="line"></span>        createAjaxRequest: function() {
<span id="line2405" class="line"></span>            if ( window.XMLHttpRequest ) {
<span id="line2406" class="line"></span>                $.createAjaxRequest = function() {
<span id="line2407" class="line"></span>                    return new XMLHttpRequest();
<span id="line2408" class="line"></span>                };
<span id="line2409" class="line"></span>                return new XMLHttpRequest();
<span id="line2410" class="line"></span>            } else {
<span id="line2411" class="line"></span>                throw new Error( "Browser doesn't support XMLHttpRequest." );
<span id="line2412" class="line"></span>            }
<span id="line2413" class="line"></span>        },
<span id="line2414" class="line"></span>
<span id="line2415" class="line"></span>        /**
<span id="line2416" class="line"></span>         * Makes an AJAX request.
<span id="line2417" class="line"></span>         * @param {String} url - the url to request
<span id="line2418" class="line"></span>         * @param {Function} onSuccess
<span id="line2419" class="line"></span>         * @param {Function} onError
<span id="line2420" class="line"></span>         * @throws {Error}
<span id="line2421" class="line"></span>         * @returns {XMLHttpRequest}
<span id="line2422" class="line"></span>         * @deprecated deprecated way of calling this function
<span id="line2423" class="line"></span>         *//**
<span id="line2424" class="line"></span>         * Makes an AJAX request.
<span id="line2425" class="line"></span>         * @param {Object} options
<span id="line2426" class="line"></span>         * @param {String} options.url - the url to request
<span id="line2427" class="line"></span>         * @param {Function} options.success - a function to call on a successful response
<span id="line2428" class="line"></span>         * @param {Function} options.error - a function to call on when an error occurs
<span id="line2429" class="line"></span>         * @param {Object} options.headers - headers to add to the AJAX request
<span id="line2430" class="line"></span>         * @param {String} options.responseType - the response type of the AJAX request
<span id="line2431" class="line"></span>         * @param {String} options.postData - HTTP POST data (usually but not necessarily in k=v&amp;k2=v2... form,
<span id="line2432" class="line"></span>         *      see TileSource::getTilePostData), GET method used if null
<span id="line2433" class="line"></span>         * @param {Boolean} [options.withCredentials=false] - whether to set the XHR's withCredentials
<span id="line2434" class="line"></span>         * @throws {Error}
<span id="line2435" class="line"></span>         * @returns {XMLHttpRequest}
<span id="line2436" class="line"></span>         */
<span id="line2437" class="line"></span>        makeAjaxRequest: function( url, onSuccess, onError ) {
<span id="line2438" class="line"></span>            let withCredentials;
<span id="line2439" class="line"></span>            let headers;
<span id="line2440" class="line"></span>            let responseType;
<span id="line2441" class="line"></span>            let postData;
<span id="line2442" class="line"></span>
<span id="line2443" class="line"></span>            // Note that our preferred API is that you pass in a single object; the named
<span id="line2444" class="line"></span>            // arguments are for legacy support.
<span id="line2445" class="line"></span>            if( $.isPlainObject( url ) ){
<span id="line2446" class="line"></span>                onSuccess = url.success;
<span id="line2447" class="line"></span>                onError = url.error;
<span id="line2448" class="line"></span>                withCredentials = url.withCredentials;
<span id="line2449" class="line"></span>                headers = url.headers;
<span id="line2450" class="line"></span>                responseType = url.responseType || null;
<span id="line2451" class="line"></span>                postData = url.postData || null;
<span id="line2452" class="line"></span>                url = url.url;
<span id="line2453" class="line"></span>            } else {
<span id="line2454" class="line"></span>                $.console.warn("OpenSeadragon.makeAjaxRequest() deprecated usage!");
<span id="line2455" class="line"></span>            }
<span id="line2456" class="line"></span>
<span id="line2457" class="line"></span>            const protocol = $.getUrlProtocol( url );
<span id="line2458" class="line"></span>            const request = $.createAjaxRequest();
<span id="line2459" class="line"></span>
<span id="line2460" class="line"></span>            if ( !$.isFunction( onSuccess ) ) {
<span id="line2461" class="line"></span>                throw new Error( "makeAjaxRequest requires a success callback" );
<span id="line2462" class="line"></span>            }
<span id="line2463" class="line"></span>
<span id="line2464" class="line"></span>            request.onreadystatechange = function() {
<span id="line2465" class="line"></span>                // 4 = DONE (https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#Properties)
<span id="line2466" class="line"></span>                if ( request.readyState === 4 ) {
<span id="line2467" class="line"></span>                    request.onreadystatechange = function(){};
<span id="line2468" class="line"></span>
<span id="line2469" class="line"></span>                    // With protocols other than http/https, a successful request status is in
<span id="line2470" class="line"></span>                    // the 200's on Firefox and 0 on other browsers
<span id="line2471" class="line"></span>                    if ( (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) ||
<span id="line2472" class="line"></span>                        ( request.status === 0 &amp;&amp;
<span id="line2473" class="line"></span>                          protocol !== "http:" &amp;&amp;
<span id="line2474" class="line"></span>                          protocol !== "https:" )) {
<span id="line2475" class="line"></span>                        onSuccess( request );
<span id="line2476" class="line"></span>                    } else {
<span id="line2477" class="line"></span>                        if ( $.isFunction( onError ) ) {
<span id="line2478" class="line"></span>                            onError( request );
<span id="line2479" class="line"></span>                        } else {
<span id="line2480" class="line"></span>                            $.console.error( "AJAX request returned %d: %s", request.status, url );
<span id="line2481" class="line"></span>                        }
<span id="line2482" class="line"></span>                    }
<span id="line2483" class="line"></span>                }
<span id="line2484" class="line"></span>            };
<span id="line2485" class="line"></span>
<span id="line2486" class="line"></span>            const method = postData ? "POST" : "GET";
<span id="line2487" class="line"></span>            try {
<span id="line2488" class="line"></span>                request.open( method, url, true );
<span id="line2489" class="line"></span>
<span id="line2490" class="line"></span>                if (responseType) {
<span id="line2491" class="line"></span>                    request.responseType = responseType;
<span id="line2492" class="line"></span>                }
<span id="line2493" class="line"></span>
<span id="line2494" class="line"></span>                if (headers) {
<span id="line2495" class="line"></span>                    for (const headerName in headers) {
<span id="line2496" class="line"></span>                        if (Object.prototype.hasOwnProperty.call(headers, headerName) &amp;&amp; headers[headerName]) {
<span id="line2497" class="line"></span>                            request.setRequestHeader(headerName, headers[headerName]);
<span id="line2498" class="line"></span>                        }
<span id="line2499" class="line"></span>                    }
<span id="line2500" class="line"></span>                }
<span id="line2501" class="line"></span>
<span id="line2502" class="line"></span>                if (withCredentials) {
<span id="line2503" class="line"></span>                    request.withCredentials = true;
<span id="line2504" class="line"></span>                }
<span id="line2505" class="line"></span>
<span id="line2506" class="line"></span>                request.send(postData);
<span id="line2507" class="line"></span>            } catch (e) {
<span id="line2508" class="line"></span>                $.console.error( "%s while making AJAX request: %s", e.name, e.message );
<span id="line2509" class="line"></span>
<span id="line2510" class="line"></span>                request.onreadystatechange = function(){};
<span id="line2511" class="line"></span>
<span id="line2512" class="line"></span>                if ( $.isFunction( onError ) ) {
<span id="line2513" class="line"></span>                    onError( request, e );
<span id="line2514" class="line"></span>                }
<span id="line2515" class="line"></span>            }
<span id="line2516" class="line"></span>
<span id="line2517" class="line"></span>            return request;
<span id="line2518" class="line"></span>        },
<span id="line2519" class="line"></span>
<span id="line2520" class="line"></span>        /**
<span id="line2521" class="line"></span>         * Taken from jQuery 1.6.1
<span id="line2522" class="line"></span>         * @function
<span id="line2523" class="line"></span>         * @param {Object} options
<span id="line2524" class="line"></span>         * @param {String} options.url
<span id="line2525" class="line"></span>         * @param {Function} options.callback
<span id="line2526" class="line"></span>         * @param {String} [options.param='callback'] The name of the url parameter
<span id="line2527" class="line"></span>         *      to request the jsonp provider with.
<span id="line2528" class="line"></span>         * @param {String} [options.callbackName=] The name of the callback to
<span id="line2529" class="line"></span>         *      request the jsonp provider with.
<span id="line2530" class="line"></span>         */
<span id="line2531" class="line"></span>        jsonp: function( options ){
<span id="line2532" class="line"></span>            let script;
<span id="line2533" class="line"></span>            let url     = options.url;
<span id="line2534" class="line"></span>            const head    = document.head ||
<span id="line2535" class="line"></span>                    document.getElementsByTagName( "head" )[ 0 ] ||
<span id="line2536" class="line"></span>                    document.documentElement;
<span id="line2537" class="line"></span>            const jsonpCallback = options.callbackName || 'openseadragon' + $.now();
<span id="line2538" class="line"></span>            const previous      = window[ jsonpCallback ];
<span id="line2539" class="line"></span>            const replace       = "$1" + jsonpCallback + "$2";
<span id="line2540" class="line"></span>            const callbackParam = options.param || 'callback';
<span id="line2541" class="line"></span>            const callback      = options.callback;
<span id="line2542" class="line"></span>
<span id="line2543" class="line"></span>            url = url.replace( /(=)\?(&amp;|$)|\?\?/i, replace );
<span id="line2544" class="line"></span>            // Add callback manually
<span id="line2545" class="line"></span>            url += (/\?/.test( url ) ? "&amp;" : "?") + callbackParam + "=" + jsonpCallback;
<span id="line2546" class="line"></span>
<span id="line2547" class="line"></span>            // Install callback
<span id="line2548" class="line"></span>            window[ jsonpCallback ] = function( response ) {
<span id="line2549" class="line"></span>                if ( !previous ){
<span id="line2550" class="line"></span>                    try{
<span id="line2551" class="line"></span>                        delete window[ jsonpCallback ];
<span id="line2552" class="line"></span>                    }catch(e){
<span id="line2553" class="line"></span>                        //swallow
<span id="line2554" class="line"></span>                    }
<span id="line2555" class="line"></span>                } else {
<span id="line2556" class="line"></span>                    window[ jsonpCallback ] = previous;
<span id="line2557" class="line"></span>                }
<span id="line2558" class="line"></span>                if( callback &amp;&amp; $.isFunction( callback ) ){
<span id="line2559" class="line"></span>                    callback( response );
<span id="line2560" class="line"></span>                }
<span id="line2561" class="line"></span>            };
<span id="line2562" class="line"></span>
<span id="line2563" class="line"></span>            script = document.createElement( "script" );
<span id="line2564" class="line"></span>
<span id="line2565" class="line"></span>            //TODO: having an issue with async info requests
<span id="line2566" class="line"></span>            if( undefined !== options.async || false !== options.async ){
<span id="line2567" class="line"></span>                script.async = "async";
<span id="line2568" class="line"></span>            }
<span id="line2569" class="line"></span>
<span id="line2570" class="line"></span>            if ( options.scriptCharset ) {
<span id="line2571" class="line"></span>                script.charset = options.scriptCharset;
<span id="line2572" class="line"></span>            }
<span id="line2573" class="line"></span>
<span id="line2574" class="line"></span>            script.src = url;
<span id="line2575" class="line"></span>
<span id="line2576" class="line"></span>            // Attach handlers for all browsers
<span id="line2577" class="line"></span>            script.onload = script.onreadystatechange = function( _, isAbort ) {
<span id="line2578" class="line"></span>
<span id="line2579" class="line"></span>                if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {
<span id="line2580" class="line"></span>
<span id="line2581" class="line"></span>                    // Handle memory leak in IE
<span id="line2582" class="line"></span>                    script.onload = script.onreadystatechange = null;
<span id="line2583" class="line"></span>
<span id="line2584" class="line"></span>                    // Remove the script
<span id="line2585" class="line"></span>                    if ( head &amp;&amp; script.parentNode ) {
<span id="line2586" class="line"></span>                        head.removeChild( script );
<span id="line2587" class="line"></span>                    }
<span id="line2588" class="line"></span>
<span id="line2589" class="line"></span>                    // Dereference the script
<span id="line2590" class="line"></span>                    script = undefined;
<span id="line2591" class="line"></span>                }
<span id="line2592" class="line"></span>            };
<span id="line2593" class="line"></span>            // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
<span id="line2594" class="line"></span>            // This arises when a base node is used (#2709 and #4378).
<span id="line2595" class="line"></span>            head.insertBefore( script, head.firstChild );
<span id="line2596" class="line"></span>
<span id="line2597" class="line"></span>        },
<span id="line2598" class="line"></span>
<span id="line2599" class="line"></span>
<span id="line2600" class="line"></span>        /**
<span id="line2601" class="line"></span>         * Fully deprecated. Will throw an error.
<span id="line2602" class="line"></span>         * @function
<span id="line2603" class="line"></span>         * @deprecated use {@link OpenSeadragon.Viewer#open}
<span id="line2604" class="line"></span>         */
<span id="line2605" class="line"></span>        createFromDZI: function() {
<span id="line2606" class="line"></span>            throw "OpenSeadragon.createFromDZI is deprecated, use Viewer.open.";
<span id="line2607" class="line"></span>        },
<span id="line2608" class="line"></span>
<span id="line2609" class="line"></span>        /**
<span id="line2610" class="line"></span>         * Parses an XML string into a DOM Document.
<span id="line2611" class="line"></span>         * @function
<span id="line2612" class="line"></span>         * @param {String} string
<span id="line2613" class="line"></span>         * @returns {Document}
<span id="line2614" class="line"></span>         */
<span id="line2615" class="line"></span>        parseXml: function( string ) {
<span id="line2616" class="line"></span>            if ( window.DOMParser ) {
<span id="line2617" class="line"></span>
<span id="line2618" class="line"></span>                $.parseXml = function( string ) {
<span id="line2619" class="line"></span>                    let xmlDoc = null;
<span id="line2620" class="line"></span>
<span id="line2621" class="line"></span>                    const parser = new DOMParser();
<span id="line2622" class="line"></span>                    xmlDoc = parser.parseFromString( string, "text/xml" );
<span id="line2623" class="line"></span>                    return xmlDoc;
<span id="line2624" class="line"></span>                };
<span id="line2625" class="line"></span>
<span id="line2626" class="line"></span>            } else {
<span id="line2627" class="line"></span>                throw new Error( "Browser doesn't support XML DOM." );
<span id="line2628" class="line"></span>            }
<span id="line2629" class="line"></span>
<span id="line2630" class="line"></span>            return $.parseXml( string );
<span id="line2631" class="line"></span>        },
<span id="line2632" class="line"></span>
<span id="line2633" class="line"></span>        /**
<span id="line2634" class="line"></span>         * Parses a JSON string into a Javascript object.
<span id="line2635" class="line"></span>         * @function
<span id="line2636" class="line"></span>         * @param {String} string
<span id="line2637" class="line"></span>         * @returns {Object}
<span id="line2638" class="line"></span>         */
<span id="line2639" class="line"></span>        parseJSON: function(string) {
<span id="line2640" class="line"></span>            $.parseJSON = window.JSON.parse;
<span id="line2641" class="line"></span>            return $.parseJSON(string);
<span id="line2642" class="line"></span>        },
<span id="line2643" class="line"></span>
<span id="line2644" class="line"></span>        /**
<span id="line2645" class="line"></span>         * Reports whether the image format is supported for tiling in this
<span id="line2646" class="line"></span>         * version.
<span id="line2647" class="line"></span>         * @function
<span id="line2648" class="line"></span>         * @param {String} [extension]
<span id="line2649" class="line"></span>         * @returns {Boolean}
<span id="line2650" class="line"></span>         */
<span id="line2651" class="line"></span>        imageFormatSupported: function( extension ) {
<span id="line2652" class="line"></span>            extension = extension ? extension : "";
<span id="line2653" class="line"></span>            // eslint-disable-next-line no-use-before-define
<span id="line2654" class="line"></span>            return !!FILEFORMATS[ extension.toLowerCase() ];
<span id="line2655" class="line"></span>        },
<span id="line2656" class="line"></span>
<span id="line2657" class="line"></span>        /**
<span id="line2658" class="line"></span>         * Updates supported image formats with user-specified values.
<span id="line2659" class="line"></span>         * Preexisting formats that are not being updated are left unchanged.
<span id="line2660" class="line"></span>         * By default, the defined formats are
<span id="line2661" class="line"></span>         * &lt;pre&gt;&lt;code&gt;{
<span id="line2662" class="line"></span>         *      avif: true,
<span id="line2663" class="line"></span>         *      bmp:  false,
<span id="line2664" class="line"></span>         *      jpeg: true,
<span id="line2665" class="line"></span>         *      jpg:  true,
<span id="line2666" class="line"></span>         *      png:  true,
<span id="line2667" class="line"></span>         *      tif:  false,
<span id="line2668" class="line"></span>         *      wdp:  false,
<span id="line2669" class="line"></span>         *      webp: true
<span id="line2670" class="line"></span>         * }
<span id="line2671" class="line"></span>         * &lt;/code&gt;&lt;/pre&gt;
<span id="line2672" class="line"></span>         * @function
<span id="line2673" class="line"></span>         * @example
<span id="line2674" class="line"></span>         * // sets bmp as supported and png as unsupported
<span id="line2675" class="line"></span>         * setImageFormatsSupported({bmp: true, png: false});
<span id="line2676" class="line"></span>         * @param {Object} formats An object containing format extensions as
<span id="line2677" class="line"></span>         * keys and booleans as values.
<span id="line2678" class="line"></span>         */
<span id="line2679" class="line"></span>        setImageFormatsSupported: function(formats) {
<span id="line2680" class="line"></span>            //TODO: how to deal with this within the data pipeline?
<span id="line2681" class="line"></span>            // $.console.warn("setImageFormatsSupported method is deprecated. You should check that" +
<span id="line2682" class="line"></span>            //     " the system supports your TileSources by implementing corresponding data type converters.");
<span id="line2683" class="line"></span>
<span id="line2684" class="line"></span>            // eslint-disable-next-line no-use-before-define
<span id="line2685" class="line"></span>            $.extend(FILEFORMATS, formats);
<span id="line2686" class="line"></span>        },
<span id="line2687" class="line"></span>    });
<span id="line2688" class="line"></span>
<span id="line2689" class="line"></span>
<span id="line2690" class="line"></span>    //TODO: $.console is often used inside a try/catch block which generally
<span id="line2691" class="line"></span>    //      prevents allowings errors to occur with detection until a debugger
<span id="line2692" class="line"></span>    //      is attached.  Although I've been guilty of the same anti-pattern
<span id="line2693" class="line"></span>    //      I eventually was convinced that errors should naturally propagate in
<span id="line2694" class="line"></span>    //      all but the most special cases.
<span id="line2695" class="line"></span>    /**
<span id="line2696" class="line"></span>     * A convenient alias for console when available, and a simple null
<span id="line2697" class="line"></span>     * function when console is unavailable.
<span id="line2698" class="line"></span>     * @static
<span id="line2699" class="line"></span>     * @private
<span id="line2700" class="line"></span>     */
<span id="line2701" class="line"></span>    const nullfunction = function( msg ){
<span id="line2702" class="line"></span>        //document.location.hash = msg;
<span id="line2703" class="line"></span>    };
<span id="line2704" class="line"></span>
<span id="line2705" class="line"></span>    $.console = window.console || {
<span id="line2706" class="line"></span>        log:    nullfunction,
<span id="line2707" class="line"></span>        debug:  nullfunction,
<span id="line2708" class="line"></span>        info:   nullfunction,
<span id="line2709" class="line"></span>        warn:   nullfunction,
<span id="line2710" class="line"></span>        error:  nullfunction,
<span id="line2711" class="line"></span>        assert: nullfunction
<span id="line2712" class="line"></span>    };
<span id="line2713" class="line"></span>
<span id="line2714" class="line"></span>
<span id="line2715" class="line"></span>    /**
<span id="line2716" class="line"></span>     * The current browser vendor, version, and related information regarding detected features.
<span id="line2717" class="line"></span>     * @member {Object} Browser
<span id="line2718" class="line"></span>     * @memberof OpenSeadragon
<span id="line2719" class="line"></span>     * @static
<span id="line2720" class="line"></span>     * @type {Object}
<span id="line2721" class="line"></span>     * @property {OpenSeadragon.BROWSERS} vendor - One of the {@link OpenSeadragon.BROWSERS} enumeration values.
<span id="line2722" class="line"></span>     * @property {Number} version
<span id="line2723" class="line"></span>     * @property {Boolean} alpha - Does the browser support image alpha transparency.
<span id="line2724" class="line"></span>     */
<span id="line2725" class="line"></span>    $.Browser = {
<span id="line2726" class="line"></span>        vendor:     $.BROWSERS.UNKNOWN,
<span id="line2727" class="line"></span>        version:    0,
<span id="line2728" class="line"></span>        alpha:      true
<span id="line2729" class="line"></span>    };
<span id="line2730" class="line"></span>
<span id="line2731" class="line"></span>
<span id="line2732" class="line"></span>    const FILEFORMATS = {
<span id="line2733" class="line"></span>            avif: true,
<span id="line2734" class="line"></span>            bmp:  false,
<span id="line2735" class="line"></span>            jpeg: true,
<span id="line2736" class="line"></span>            jpg:  true,
<span id="line2737" class="line"></span>            png:  true,
<span id="line2738" class="line"></span>            tif:  false,
<span id="line2739" class="line"></span>            wdp:  false,
<span id="line2740" class="line"></span>            webp: true
<span id="line2741" class="line"></span>        };
<span id="line2742" class="line"></span>    const URLPARAMS = {};
<span id="line2743" class="line"></span>
<span id="line2744" class="line"></span>    (function() {
<span id="line2745" class="line"></span>        //A small auto-executing routine to determine the browser vendor,
<span id="line2746" class="line"></span>        //version and supporting feature sets.
<span id="line2747" class="line"></span>        const ver = navigator.appVersion;
<span id="line2748" class="line"></span>        const ua  = navigator.userAgent;
<span id="line2749" class="line"></span>        let regex;
<span id="line2750" class="line"></span>
<span id="line2751" class="line"></span>        //console.error( 'appName: ' + navigator.appName );
<span id="line2752" class="line"></span>        //console.error( 'appVersion: ' + navigator.appVersion );
<span id="line2753" class="line"></span>        //console.error( 'userAgent: ' + navigator.userAgent );
<span id="line2754" class="line"></span>
<span id="line2755" class="line"></span>        //TODO navigator.appName is deprecated. Should be 'Netscape' for all browsers
<span id="line2756" class="line"></span>        //  but could be dropped at any time
<span id="line2757" class="line"></span>        //  See https://developer.mozilla.org/en-US/docs/Web/API/Navigator/appName
<span id="line2758" class="line"></span>        //      https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
<span id="line2759" class="line"></span>        switch( navigator.appName ){
<span id="line2760" class="line"></span>            case "Microsoft Internet Explorer":
<span id="line2761" class="line"></span>                if( !!window.attachEvent &amp;&amp;
<span id="line2762" class="line"></span>                    !!window.ActiveXObject ) {
<span id="line2763" class="line"></span>
<span id="line2764" class="line"></span>                    $.Browser.vendor = $.BROWSERS.IE;
<span id="line2765" class="line"></span>                    $.Browser.version = parseFloat(
<span id="line2766" class="line"></span>                        ua.substring(
<span id="line2767" class="line"></span>                            ua.indexOf( "MSIE" ) + 5,
<span id="line2768" class="line"></span>                            ua.indexOf( ";", ua.indexOf( "MSIE" ) ) )
<span id="line2769" class="line"></span>                        );
<span id="line2770" class="line"></span>                }
<span id="line2771" class="line"></span>                break;
<span id="line2772" class="line"></span>            case "Netscape":
<span id="line2773" class="line"></span>                if (window.addEventListener) {
<span id="line2774" class="line"></span>                    if ( ua.indexOf( "Edge" ) &gt;= 0 ) {
<span id="line2775" class="line"></span>                        $.Browser.vendor = $.BROWSERS.EDGE;
<span id="line2776" class="line"></span>                        $.Browser.version = parseFloat(
<span id="line2777" class="line"></span>                            ua.substring( ua.indexOf( "Edge" ) + 5 )
<span id="line2778" class="line"></span>                        );
<span id="line2779" class="line"></span>                    } else if ( ua.indexOf( "Edg" ) &gt;= 0 ) {
<span id="line2780" class="line"></span>                        $.Browser.vendor = $.BROWSERS.CHROMEEDGE;
<span id="line2781" class="line"></span>                        $.Browser.version = parseFloat(
<span id="line2782" class="line"></span>                            ua.substring( ua.indexOf( "Edg" ) + 4 )
<span id="line2783" class="line"></span>                        );
<span id="line2784" class="line"></span>                    } else if ( ua.indexOf( "Firefox" ) &gt;= 0 ) {
<span id="line2785" class="line"></span>                        $.Browser.vendor = $.BROWSERS.FIREFOX;
<span id="line2786" class="line"></span>                        $.Browser.version = parseFloat(
<span id="line2787" class="line"></span>                            ua.substring( ua.indexOf( "Firefox" ) + 8 )
<span id="line2788" class="line"></span>                        );
<span id="line2789" class="line"></span>                    } else if ( ua.indexOf( "Safari" ) &gt;= 0 ) {
<span id="line2790" class="line"></span>                        $.Browser.vendor = ua.indexOf( "Chrome" ) &gt;= 0 ?
<span id="line2791" class="line"></span>                            $.BROWSERS.CHROME :
<span id="line2792" class="line"></span>                            $.BROWSERS.SAFARI;
<span id="line2793" class="line"></span>                        $.Browser.version = parseFloat(
<span id="line2794" class="line"></span>                            ua.substring(
<span id="line2795" class="line"></span>                                ua.substring( 0, ua.indexOf( "Safari" ) ).lastIndexOf( "/" ) + 1,
<span id="line2796" class="line"></span>                                ua.indexOf( "Safari" )
<span id="line2797" class="line"></span>                            )
<span id="line2798" class="line"></span>                        );
<span id="line2799" class="line"></span>                    } else {
<span id="line2800" class="line"></span>                        regex = new RegExp( "Trident/.*rv:([0-9]{1,}[.0-9]{0,})");
<span id="line2801" class="line"></span>                        if ( regex.exec( ua ) !== null ) {
<span id="line2802" class="line"></span>                            $.Browser.vendor = $.BROWSERS.IE;
<span id="line2803" class="line"></span>                            $.Browser.version = parseFloat( RegExp.$1 );
<span id="line2804" class="line"></span>                        }
<span id="line2805" class="line"></span>                    }
<span id="line2806" class="line"></span>                }
<span id="line2807" class="line"></span>                break;
<span id="line2808" class="line"></span>            case "Opera":
<span id="line2809" class="line"></span>                $.Browser.vendor = $.BROWSERS.OPERA;
<span id="line2810" class="line"></span>                $.Browser.version = parseFloat( ver );
<span id="line2811" class="line"></span>                break;
<span id="line2812" class="line"></span>        }
<span id="line2813" class="line"></span>
<span id="line2814" class="line"></span>            // ignore '?' portion of query string
<span id="line2815" class="line"></span>        const query = window.location.search.substring( 1 );
<span id="line2816" class="line"></span>        const parts = query.split('&amp;');
<span id="line2817" class="line"></span>
<span id="line2818" class="line"></span>        for ( let i = 0; i &lt; parts.length; i++ ) {
<span id="line2819" class="line"></span>            const part = parts[ i ];
<span id="line2820" class="line"></span>            const sep  = part.indexOf( '=' );
<span id="line2821" class="line"></span>
<span id="line2822" class="line"></span>            if ( sep &gt; 0 ) {
<span id="line2823" class="line"></span>                const key = part.substring( 0, sep );
<span id="line2824" class="line"></span>                const value = part.substring( sep + 1 );
<span id="line2825" class="line"></span>                try {
<span id="line2826" class="line"></span>                    URLPARAMS[ key ] = decodeURIComponent( value );
<span id="line2827" class="line"></span>                } catch (e) {
<span id="line2828" class="line"></span>                    $.console.error( "Ignoring malformed URL parameter: %s=%s", key, value );
<span id="line2829" class="line"></span>                }
<span id="line2830" class="line"></span>            }
<span id="line2831" class="line"></span>        }
<span id="line2832" class="line"></span>
<span id="line2833" class="line"></span>        //determine if this browser supports image alpha transparency
<span id="line2834" class="line"></span>        $.Browser.alpha = !(
<span id="line2835" class="line"></span>            $.Browser.vendor === $.BROWSERS.CHROME &amp;&amp; $.Browser.version &lt; 2
<span id="line2836" class="line"></span>        );
<span id="line2837" class="line"></span>
<span id="line2838" class="line"></span>        //determine if this browser supports element.style.opacity
<span id="line2839" class="line"></span>        $.Browser.opacity = true;
<span id="line2840" class="line"></span>
<span id="line2841" class="line"></span>        if ( $.Browser.vendor === $.BROWSERS.IE ) {
<span id="line2842" class="line"></span>            $.console.error('Internet Explorer is not supported by OpenSeadragon');
<span id="line2843" class="line"></span>        }
<span id="line2844" class="line"></span>    })();
<span id="line2845" class="line"></span>
<span id="line2846" class="line"></span>
<span id="line2847" class="line"></span>    // Adding support for HTML5's requestAnimationFrame as suggested by acdha.
<span id="line2848" class="line"></span>    // Implementation taken from matt synder's post here:
<span id="line2849" class="line"></span>    // http://mattsnider.com/cross-browser-and-legacy-supported-requestframeanimation/
<span id="line2850" class="line"></span>    (function( w ) {
<span id="line2851" class="line"></span>
<span id="line2852" class="line"></span>        // most browsers have an implementation
<span id="line2853" class="line"></span>        const requestAnimationFrame = w.requestAnimationFrame ||
<span id="line2854" class="line"></span>            w.mozRequestAnimationFrame ||
<span id="line2855" class="line"></span>            w.webkitRequestAnimationFrame ||
<span id="line2856" class="line"></span>            w.msRequestAnimationFrame;
<span id="line2857" class="line"></span>
<span id="line2858" class="line"></span>        const cancelAnimationFrame = w.cancelAnimationFrame ||
<span id="line2859" class="line"></span>            w.mozCancelAnimationFrame ||
<span id="line2860" class="line"></span>            w.webkitCancelAnimationFrame ||
<span id="line2861" class="line"></span>            w.msCancelAnimationFrame;
<span id="line2862" class="line"></span>
<span id="line2863" class="line"></span>        // polyfill, when necessary
<span id="line2864" class="line"></span>        if ( requestAnimationFrame &amp;&amp; cancelAnimationFrame ) {
<span id="line2865" class="line"></span>            // We can't assign these window methods directly to $ because they
<span id="line2866" class="line"></span>            // expect their "this" to be "window", so we call them in wrappers.
<span id="line2867" class="line"></span>            $.requestAnimationFrame = function(){
<span id="line2868" class="line"></span>                return requestAnimationFrame.apply( w, arguments );
<span id="line2869" class="line"></span>            };
<span id="line2870" class="line"></span>            $.cancelAnimationFrame = function(){
<span id="line2871" class="line"></span>                return cancelAnimationFrame.apply( w, arguments );
<span id="line2872" class="line"></span>            };
<span id="line2873" class="line"></span>        } else {
<span id="line2874" class="line"></span>            let aAnimQueue = [];
<span id="line2875" class="line"></span>            let processing = [];
<span id="line2876" class="line"></span>            let iIntervalId;
<span id="line2877" class="line"></span>            let iRequestId = 0;
<span id="line2878" class="line"></span>
<span id="line2879" class="line"></span>            // create a mock requestAnimationFrame function
<span id="line2880" class="line"></span>            $.requestAnimationFrame = function( callback ) {
<span id="line2881" class="line"></span>                aAnimQueue.push( [ ++iRequestId, callback ] );
<span id="line2882" class="line"></span>
<span id="line2883" class="line"></span>                if ( !iIntervalId ) {
<span id="line2884" class="line"></span>                     iIntervalId = setInterval( function() {
<span id="line2885" class="line"></span>                        if ( aAnimQueue.length ) {
<span id="line2886" class="line"></span>                            const time = $.now();
<span id="line2887" class="line"></span>                            // Process all of the currently outstanding frame
<span id="line2888" class="line"></span>                            // requests, but none that get added during the
<span id="line2889" class="line"></span>                            // processing.
<span id="line2890" class="line"></span>                            // Swap the arrays so we don't have to create a new
<span id="line2891" class="line"></span>                            // array every frame.
<span id="line2892" class="line"></span>                            const temp = processing;
<span id="line2893" class="line"></span>                            processing = aAnimQueue;
<span id="line2894" class="line"></span>                            aAnimQueue = temp;
<span id="line2895" class="line"></span>                            while ( processing.length ) {
<span id="line2896" class="line"></span>                                processing.shift()[ 1 ]( time );
<span id="line2897" class="line"></span>                            }
<span id="line2898" class="line"></span>                        } else {
<span id="line2899" class="line"></span>                            // don't continue the interval, if unnecessary
<span id="line2900" class="line"></span>                            clearInterval( iIntervalId );
<span id="line2901" class="line"></span>                            iIntervalId = undefined;
<span id="line2902" class="line"></span>                        }
<span id="line2903" class="line"></span>                    }, 1000 / 50);  // estimating support for 50 frames per second
<span id="line2904" class="line"></span>                }
<span id="line2905" class="line"></span>
<span id="line2906" class="line"></span>                return iRequestId;
<span id="line2907" class="line"></span>            };
<span id="line2908" class="line"></span>
<span id="line2909" class="line"></span>            // create a mock cancelAnimationFrame function
<span id="line2910" class="line"></span>            $.cancelAnimationFrame = function( requestId ) {
<span id="line2911" class="line"></span>                // find the request ID and remove it
<span id="line2912" class="line"></span>                let i, j;
<span id="line2913" class="line"></span>                for ( i = 0, j = aAnimQueue.length; i &lt; j; i += 1 ) {
<span id="line2914" class="line"></span>                    if ( aAnimQueue[ i ][ 0 ] === requestId ) {
<span id="line2915" class="line"></span>                        aAnimQueue.splice( i, 1 );
<span id="line2916" class="line"></span>                        return;
<span id="line2917" class="line"></span>                    }
<span id="line2918" class="line"></span>                }
<span id="line2919" class="line"></span>
<span id="line2920" class="line"></span>                // If it's not in the queue, it may be in the set we're currently
<span id="line2921" class="line"></span>                // processing (if cancelAnimationFrame is called from within a
<span id="line2922" class="line"></span>                // requestAnimationFrame callback).
<span id="line2923" class="line"></span>                for ( i = 0, j = processing.length; i &lt; j; i += 1 ) {
<span id="line2924" class="line"></span>                    if ( processing[ i ][ 0 ] === requestId ) {
<span id="line2925" class="line"></span>                        processing.splice( i, 1 );
<span id="line2926" class="line"></span>                        return;
<span id="line2927" class="line"></span>                    }
<span id="line2928" class="line"></span>                }
<span id="line2929" class="line"></span>            };
<span id="line2930" class="line"></span>        }
<span id="line2931" class="line"></span>    })( window );
<span id="line2932" class="line"></span>
<span id="line2933" class="line"></span>    /**
<span id="line2934" class="line"></span>     * @private
<span id="line2935" class="line"></span>     * @inner
<span id="line2936" class="line"></span>     * @function
<span id="line2937" class="line"></span>     * @param {Element} element
<span id="line2938" class="line"></span>     * @param {Boolean} [isFixed]
<span id="line2939" class="line"></span>     * @returns {Element}
<span id="line2940" class="line"></span>     */
<span id="line2941" class="line"></span>    function getOffsetParent( element, isFixed ) {
<span id="line2942" class="line"></span>        if ( isFixed &amp;&amp; element !== document.body ) {
<span id="line2943" class="line"></span>            return document.body;
<span id="line2944" class="line"></span>        } else {
<span id="line2945" class="line"></span>            return element.offsetParent;
<span id="line2946" class="line"></span>        }
<span id="line2947" class="line"></span>    }
<span id="line2948" class="line"></span>
<span id="line2949" class="line"></span>    /**
<span id="line2950" class="line"></span>     * @template T
<span id="line2951" class="line"></span>     * @typedef {function(): OpenSeadragon.Promise&lt;T&gt;} AsyncNullaryFunction
<span id="line2952" class="line"></span>     * Represents an asynchronous function that takes no arguments and returns a promise of type T.
<span id="line2953" class="line"></span>     */
<span id="line2954" class="line"></span>
<span id="line2955" class="line"></span>    /**
<span id="line2956" class="line"></span>     * @template T, A
<span id="line2957" class="line"></span>     * @typedef {function(A): OpenSeadragon.Promise&lt;T&gt;} AsyncUnaryFunction
<span id="line2958" class="line"></span>     * Represents an asynchronous function that:
<span id="line2959" class="line"></span>     * @param {A} arg - The single argument of type A.
<span id="line2960" class="line"></span>     * @returns {OpenSeadragon.Promise&lt;T&gt;} A promise that resolves to a value of type T.
<span id="line2961" class="line"></span>     */
<span id="line2962" class="line"></span>
<span id="line2963" class="line"></span>    /**
<span id="line2964" class="line"></span>     * @template T, A, B
<span id="line2965" class="line"></span>     * @typedef {function(A, B): OpenSeadragon.Promise&lt;T&gt;} AsyncBinaryFunction
<span id="line2966" class="line"></span>     * Represents an asynchronous function that:
<span id="line2967" class="line"></span>     * @param {A} arg1 - The first argument of type A.
<span id="line2968" class="line"></span>     * @param {B} arg2 - The second argument of type B.
<span id="line2969" class="line"></span>     * @returns {OpenSeadragon.Promise&lt;T&gt;} A promise that resolves to a value of type T.
<span id="line2970" class="line"></span>     */
<span id="line2971" class="line"></span>
<span id="line2972" class="line"></span>    /**
<span id="line2973" class="line"></span>     * Promise proxy in OpenSeadragon, enables $.supportsAsync feature.
<span id="line2974" class="line"></span>     * This proxy is also necessary because OperaMini does not implement Promises (checks fail).
<span id="line2975" class="line"></span>     * @type {PromiseConstructor}
<span id="line2976" class="line"></span>     */
<span id="line2977" class="line"></span>    $.Promise = window["Promise"] &amp;&amp; $.supportsAsync ? window["Promise"] : class {
<span id="line2978" class="line"></span>        constructor(handler) {
<span id="line2979" class="line"></span>            this._error = false;
<span id="line2980" class="line"></span>            this.__value = undefined;
<span id="line2981" class="line"></span>
<span id="line2982" class="line"></span>            try {
<span id="line2983" class="line"></span>                // Make sure to unwrap all nested promises!
<span id="line2984" class="line"></span>                handler(
<span id="line2985" class="line"></span>                    (value) =&gt; {
<span id="line2986" class="line"></span>                        while (value instanceof $.Promise) {
<span id="line2987" class="line"></span>                            value = value._value;
<span id="line2988" class="line"></span>                        }
<span id="line2989" class="line"></span>                        this._value = value;
<span id="line2990" class="line"></span>                    },
<span id="line2991" class="line"></span>                    (error) =&gt; {
<span id="line2992" class="line"></span>                        while (error instanceof $.Promise) {
<span id="line2993" class="line"></span>                            error = error._value;
<span id="line2994" class="line"></span>                        }
<span id="line2995" class="line"></span>                        this._value = error;
<span id="line2996" class="line"></span>                        this._error = true;
<span id="line2997" class="line"></span>                    }
<span id="line2998" class="line"></span>                );
<span id="line2999" class="line"></span>            } catch (e) {
<span id="line3000" class="line"></span>                this._value = e;
<span id="line3001" class="line"></span>                this._error = true;
<span id="line3002" class="line"></span>            }
<span id="line3003" class="line"></span>        }
<span id="line3004" class="line"></span>
<span id="line3005" class="line"></span>        then(handler) {
<span id="line3006" class="line"></span>            if (!this._error) {
<span id="line3007" class="line"></span>                try {
<span id="line3008" class="line"></span>                    this._value = handler(this._value);
<span id="line3009" class="line"></span>                } catch (e) {
<span id="line3010" class="line"></span>                    this._value = e;
<span id="line3011" class="line"></span>                    this._error = true;
<span id="line3012" class="line"></span>                }
<span id="line3013" class="line"></span>            }
<span id="line3014" class="line"></span>            return this;
<span id="line3015" class="line"></span>        }
<span id="line3016" class="line"></span>
<span id="line3017" class="line"></span>        catch(handler) {
<span id="line3018" class="line"></span>            if (this._error) {
<span id="line3019" class="line"></span>                try {
<span id="line3020" class="line"></span>                    this._value = handler(this._value);
<span id="line3021" class="line"></span>                    this._error = false;
<span id="line3022" class="line"></span>                } catch (e) {
<span id="line3023" class="line"></span>                    this._value = e;
<span id="line3024" class="line"></span>                    this._error = true;
<span id="line3025" class="line"></span>                }
<span id="line3026" class="line"></span>            }
<span id="line3027" class="line"></span>            return this;
<span id="line3028" class="line"></span>        }
<span id="line3029" class="line"></span>
<span id="line3030" class="line"></span>        get _value() {
<span id="line3031" class="line"></span>            return this.__value;
<span id="line3032" class="line"></span>        }
<span id="line3033" class="line"></span>        set _value(val) {
<span id="line3034" class="line"></span>            if (val &amp;&amp; val.constructor === this.constructor) {
<span id="line3035" class="line"></span>                val = val._value; //unwrap
<span id="line3036" class="line"></span>            }
<span id="line3037" class="line"></span>            this.__value = val;
<span id="line3038" class="line"></span>        }
<span id="line3039" class="line"></span>
<span id="line3040" class="line"></span>        static resolve(value) {
<span id="line3041" class="line"></span>            return new this((resolve) =&gt; resolve(value));
<span id="line3042" class="line"></span>        }
<span id="line3043" class="line"></span>
<span id="line3044" class="line"></span>        static reject(error) {
<span id="line3045" class="line"></span>            return new this((_, reject) =&gt; reject(error));
<span id="line3046" class="line"></span>        }
<span id="line3047" class="line"></span>
<span id="line3048" class="line"></span>        static all(functions) {
<span id="line3049" class="line"></span>            return new this((resolve) =&gt; {
<span id="line3050" class="line"></span>                // no async support, just execute them
<span id="line3051" class="line"></span>                return resolve(functions.map(fn =&gt; fn()));
<span id="line3052" class="line"></span>            });
<span id="line3053" class="line"></span>        }
<span id="line3054" class="line"></span>
<span id="line3055" class="line"></span>        static race(functions) {
<span id="line3056" class="line"></span>            if (functions.length &lt; 1) {
<span id="line3057" class="line"></span>                return this.resolve();
<span id="line3058" class="line"></span>            }
<span id="line3059" class="line"></span>            // no async support, just execute the first
<span id="line3060" class="line"></span>            return new this((resolve) =&gt; {
<span id="line3061" class="line"></span>                return resolve(functions[0]());
<span id="line3062" class="line"></span>            });
<span id="line3063" class="line"></span>        }
<span id="line3064" class="line"></span>    };
<span id="line3065" class="line"></span>}(OpenSeadragon));
<span id="line3066" class="line"></span>
<span id="line3067" class="line"></span>
<span id="line3068" class="line"></span>// Universal Module Definition, supports CommonJS, AMD and simple script tag
<span id="line3069" class="line"></span>(function (root, $) {
<span id="line3070" class="line"></span>    if (typeof define === 'function' &amp;&amp; define.amd) {
<span id="line3071" class="line"></span>        // expose as amd module
<span id="line3072" class="line"></span>        define([], function () {
<span id="line3073" class="line"></span>            return $;
<span id="line3074" class="line"></span>        });
<span id="line3075" class="line"></span>    } else if (typeof module === 'object' &amp;&amp; module.exports) {
<span id="line3076" class="line"></span>        // expose as commonjs module
<span id="line3077" class="line"></span>        module.exports = $;
<span id="line3078" class="line"></span>    } else {
<span id="line3079" class="line"></span>        if (!root) {
<span id="line3080" class="line"></span>            root = typeof window === 'object' &amp;&amp; window;
<span id="line3081" class="line"></span>            if (!root) {
<span id="line3082" class="line"></span>                $.console.error("OpenSeadragon must run in browser environment!");
<span id="line3083" class="line"></span>            }
<span id="line3084" class="line"></span>        }
<span id="line3085" class="line"></span>        // expose as window.OpenSeadragon
<span id="line3086" class="line"></span>        root.OpenSeadragon = $;
<span id="line3087" class="line"></span>    }
<span id="line3088" class="line"></span>}(this, OpenSeadragon));
<span id="line3089" class="line"></span>
<span id="line3090" class="line"></span>/* eslint-disable one-var-declaration-per-line */
<span id="line3091" class="line"></span>
<span id="line3092" class="line"></span>/*
<span id="line3093" class="line"></span> * OpenSeadragon - Mat3
<span id="line3094" class="line"></span> *
<span id="line3095" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line3096" class="line"></span> *
<span id="line3097" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line3098" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line3099" class="line"></span> * met:
<span id="line3100" class="line"></span> *
<span id="line3101" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line3102" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line3103" class="line"></span> *
<span id="line3104" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line3105" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line3106" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line3107" class="line"></span> *
<span id="line3108" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line3109" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line3110" class="line"></span> *   this software without specific prior written permission.
<span id="line3111" class="line"></span> *
<span id="line3112" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line3113" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line3114" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line3115" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line3116" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line3117" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line3118" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line3119" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line3120" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line3121" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line3122" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line3123" class="line"></span> *
<span id="line3124" class="line"></span> */
<span id="line3125" class="line"></span>
<span id="line3126" class="line"></span>
<span id="line3127" class="line"></span>/*
<span id="line3128" class="line"></span> * Portions of this source file are taken from WegGL Fundamentals:
<span id="line3129" class="line"></span> *
<span id="line3130" class="line"></span> * Copyright 2012, Gregg Tavares.
<span id="line3131" class="line"></span> * All rights reserved.
<span id="line3132" class="line"></span> *
<span id="line3133" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line3134" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line3135" class="line"></span> * met:
<span id="line3136" class="line"></span> *
<span id="line3137" class="line"></span> *     * Redistributions of source code must retain the above copyright
<span id="line3138" class="line"></span> * notice, this list of conditions and the following disclaimer.
<span id="line3139" class="line"></span> *     * Redistributions in binary form must reproduce the above
<span id="line3140" class="line"></span> * copyright notice, this list of conditions and the following disclaimer
<span id="line3141" class="line"></span> * in the documentation and/or other materials provided with the
<span id="line3142" class="line"></span> * distribution.
<span id="line3143" class="line"></span> *     * Neither the name of Gregg Tavares. nor the names of his
<span id="line3144" class="line"></span> * contributors may be used to endorse or promote products derived from
<span id="line3145" class="line"></span> * this software without specific prior written permission.
<span id="line3146" class="line"></span> *
<span id="line3147" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line3148" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line3149" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line3150" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
<span id="line3151" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line3152" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
<span id="line3153" class="line"></span> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
<span id="line3154" class="line"></span> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
<span id="line3155" class="line"></span> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
<span id="line3156" class="line"></span> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
<span id="line3157" class="line"></span> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line3158" class="line"></span> *
<span id="line3159" class="line"></span> */
<span id="line3160" class="line"></span>
<span id="line3161" class="line"></span>
<span id="line3162" class="line"></span>
<span id="line3163" class="line"></span>
<span id="line3164" class="line"></span>(function( $ ){
<span id="line3165" class="line"></span>
<span id="line3166" class="line"></span>// Modified from https://webglfundamentals.org/webgl/lessons/webgl-2d-matrices.html
<span id="line3167" class="line"></span>
<span id="line3168" class="line"></span>/**
<span id="line3169" class="line"></span> *
<span id="line3170" class="line"></span> *
<span id="line3171" class="line"></span> * @class Mat3
<span id="line3172" class="line"></span> * @classdesc A left-to-right matrix representation, useful for affine transforms for
<span id="line3173" class="line"></span> * positioning tiles for drawing
<span id="line3174" class="line"></span> *
<span id="line3175" class="line"></span> * @memberof OpenSeadragon
<span id="line3176" class="line"></span> *
<span id="line3177" class="line"></span> * @param {Array} [values] - Initial values for the matrix
<span id="line3178" class="line"></span> *
<span id="line3179" class="line"></span> **/
<span id="line3180" class="line"></span>class Mat3{
<span id="line3181" class="line"></span>    constructor(values){
<span id="line3182" class="line"></span>        if(!values) {
<span id="line3183" class="line"></span>            values = [
<span id="line3184" class="line"></span>                0, 0, 0,
<span id="line3185" class="line"></span>                0, 0, 0,
<span id="line3186" class="line"></span>                0, 0, 0
<span id="line3187" class="line"></span>            ];
<span id="line3188" class="line"></span>        }
<span id="line3189" class="line"></span>        this.values = values;
<span id="line3190" class="line"></span>    }
<span id="line3191" class="line"></span>
<span id="line3192" class="line"></span>    /**
<span id="line3193" class="line"></span>     * @function makeIdentity
<span id="line3194" class="line"></span>     * @memberof OpenSeadragon.Mat3
<span id="line3195" class="line"></span>     * @static
<span id="line3196" class="line"></span>     * @returns {OpenSeadragon.Mat3} an identity matrix
<span id="line3197" class="line"></span>     */
<span id="line3198" class="line"></span>    static makeIdentity(){
<span id="line3199" class="line"></span>        return new Mat3([
<span id="line3200" class="line"></span>            1, 0, 0,
<span id="line3201" class="line"></span>            0, 1, 0,
<span id="line3202" class="line"></span>            0, 0, 1
<span id="line3203" class="line"></span>        ]);
<span id="line3204" class="line"></span>    }
<span id="line3205" class="line"></span>
<span id="line3206" class="line"></span>    /**
<span id="line3207" class="line"></span>     * @function makeTranslation
<span id="line3208" class="line"></span>     * @memberof OpenSeadragon.Mat3
<span id="line3209" class="line"></span>     * @static
<span id="line3210" class="line"></span>     * @param {Number} tx The x value of the translation
<span id="line3211" class="line"></span>     * @param {Number} ty The y value of the translation
<span id="line3212" class="line"></span>     * @returns {OpenSeadragon.Mat3} A translation matrix
<span id="line3213" class="line"></span>     */
<span id="line3214" class="line"></span>    static makeTranslation(tx, ty) {
<span id="line3215" class="line"></span>        return new Mat3([
<span id="line3216" class="line"></span>            1, 0, 0,
<span id="line3217" class="line"></span>            0, 1, 0,
<span id="line3218" class="line"></span>            tx, ty, 1,
<span id="line3219" class="line"></span>        ]);
<span id="line3220" class="line"></span>    }
<span id="line3221" class="line"></span>
<span id="line3222" class="line"></span>    /**
<span id="line3223" class="line"></span>     * @function makeRotation
<span id="line3224" class="line"></span>     * @memberof OpenSeadragon.Mat3
<span id="line3225" class="line"></span>     * @static
<span id="line3226" class="line"></span>     * @param {Number} angleInRadians The desired rotation angle, in radians
<span id="line3227" class="line"></span>     * @returns {OpenSeadragon.Mat3} A rotation matrix
<span id="line3228" class="line"></span>     */
<span id="line3229" class="line"></span>    static makeRotation(angleInRadians) {
<span id="line3230" class="line"></span>        const c = Math.cos(angleInRadians);
<span id="line3231" class="line"></span>        const s = Math.sin(angleInRadians);
<span id="line3232" class="line"></span>        return new Mat3([
<span id="line3233" class="line"></span>            c, -s, 0,
<span id="line3234" class="line"></span>            s, c, 0,
<span id="line3235" class="line"></span>            0, 0, 1,
<span id="line3236" class="line"></span>        ]);
<span id="line3237" class="line"></span>    }
<span id="line3238" class="line"></span>
<span id="line3239" class="line"></span>    /**
<span id="line3240" class="line"></span>     * @function makeScaling
<span id="line3241" class="line"></span>     * @memberof OpenSeadragon.Mat3
<span id="line3242" class="line"></span>     * @static
<span id="line3243" class="line"></span>     * @param {Number} sx The x value of the scaling
<span id="line3244" class="line"></span>     * @param {Number} sy The y value of the scaling
<span id="line3245" class="line"></span>     * @returns {OpenSeadragon.Mat3} A scaling matrix
<span id="line3246" class="line"></span>     */
<span id="line3247" class="line"></span>    static makeScaling(sx, sy) {
<span id="line3248" class="line"></span>        return new Mat3([
<span id="line3249" class="line"></span>            sx, 0, 0,
<span id="line3250" class="line"></span>            0, sy, 0,
<span id="line3251" class="line"></span>            0, 0, 1,
<span id="line3252" class="line"></span>        ]);
<span id="line3253" class="line"></span>    }
<span id="line3254" class="line"></span>
<span id="line3255" class="line"></span>    /**
<span id="line3256" class="line"></span>     * @alias multiply
<span id="line3257" class="line"></span>     * @memberof! OpenSeadragon.Mat3
<span id="line3258" class="line"></span>     * @param {OpenSeadragon.Mat3} other the matrix to multiply with
<span id="line3259" class="line"></span>     * @returns {OpenSeadragon.Mat3} The result of matrix multiplication
<span id="line3260" class="line"></span>     */
<span id="line3261" class="line"></span>    multiply(other) {
<span id="line3262" class="line"></span>        let a = this.values;
<span id="line3263" class="line"></span>        let b = other.values;
<span id="line3264" class="line"></span>
<span id="line3265" class="line"></span>        const a00 = a[0 * 3 + 0], a01 = a[0 * 3 + 1], a02 = a[0 * 3 + 2];
<span id="line3266" class="line"></span>        const a10 = a[1 * 3 + 0], a11 = a[1 * 3 + 1], a12 = a[1 * 3 + 2];
<span id="line3267" class="line"></span>        const a20 = a[2 * 3 + 0], a21 = a[2 * 3 + 1], a22 = a[2 * 3 + 2];
<span id="line3268" class="line"></span>        const b00 = b[0 * 3 + 0], b01 = b[0 * 3 + 1], b02 = b[0 * 3 + 2];
<span id="line3269" class="line"></span>        const b10 = b[1 * 3 + 0], b11 = b[1 * 3 + 1], b12 = b[1 * 3 + 2];
<span id="line3270" class="line"></span>        const b20 = b[2 * 3 + 0], b21 = b[2 * 3 + 1], b22 = b[2 * 3 + 2];
<span id="line3271" class="line"></span>
<span id="line3272" class="line"></span>        return new Mat3([
<span id="line3273" class="line"></span>            b00 * a00 + b01 * a10 + b02 * a20,
<span id="line3274" class="line"></span>            b00 * a01 + b01 * a11 + b02 * a21,
<span id="line3275" class="line"></span>            b00 * a02 + b01 * a12 + b02 * a22,
<span id="line3276" class="line"></span>            b10 * a00 + b11 * a10 + b12 * a20,
<span id="line3277" class="line"></span>            b10 * a01 + b11 * a11 + b12 * a21,
<span id="line3278" class="line"></span>            b10 * a02 + b11 * a12 + b12 * a22,
<span id="line3279" class="line"></span>            b20 * a00 + b21 * a10 + b22 * a20,
<span id="line3280" class="line"></span>            b20 * a01 + b21 * a11 + b22 * a21,
<span id="line3281" class="line"></span>            b20 * a02 + b21 * a12 + b22 * a22,
<span id="line3282" class="line"></span>        ]);
<span id="line3283" class="line"></span>    }
<span id="line3284" class="line"></span>
<span id="line3285" class="line"></span>    /**
<span id="line3286" class="line"></span>     * Sets the values of the matrix.
<span id="line3287" class="line"></span>     * @param a00 top left
<span id="line3288" class="line"></span>     * @param a01 top middle
<span id="line3289" class="line"></span>     * @param a02 top right
<span id="line3290" class="line"></span>     * @param a10 middle left
<span id="line3291" class="line"></span>     * @param a11 middle middle
<span id="line3292" class="line"></span>     * @param a12 middle right
<span id="line3293" class="line"></span>     * @param a20 bottom left
<span id="line3294" class="line"></span>     * @param a21 bottom middle
<span id="line3295" class="line"></span>     * @param a22 bottom right
<span id="line3296" class="line"></span>     */
<span id="line3297" class="line"></span>    setValues(a00, a01, a02,
<span id="line3298" class="line"></span>              a10, a11, a12,
<span id="line3299" class="line"></span>              a20, a21, a22) {
<span id="line3300" class="line"></span>        this.values[0] = a00;
<span id="line3301" class="line"></span>        this.values[1] = a01;
<span id="line3302" class="line"></span>        this.values[2] = a02;
<span id="line3303" class="line"></span>        this.values[3] = a10;
<span id="line3304" class="line"></span>        this.values[4] = a11;
<span id="line3305" class="line"></span>        this.values[5] = a12;
<span id="line3306" class="line"></span>        this.values[6] = a20;
<span id="line3307" class="line"></span>        this.values[7] = a21;
<span id="line3308" class="line"></span>        this.values[8] = a22;
<span id="line3309" class="line"></span>    }
<span id="line3310" class="line"></span>
<span id="line3311" class="line"></span>    /**
<span id="line3312" class="line"></span>     * Scaling &amp; translation only changes certain values, no need to compute full matrix multiplication.
<span id="line3313" class="line"></span>     * @memberof OpenSeadragon.Mat3
<span id="line3314" class="line"></span>     * @returns {OpenSeadragon.Mat3} The result of matrix multiplication
<span id="line3315" class="line"></span>     */
<span id="line3316" class="line"></span>    scaleAndTranslate(sx, sy, tx, ty) {
<span id="line3317" class="line"></span>        const a = this.values;
<span id="line3318" class="line"></span>        const a00 = a[0];
<span id="line3319" class="line"></span>        const a01 = a[1];
<span id="line3320" class="line"></span>        const a02 = a[2];
<span id="line3321" class="line"></span>        const a10 = a[3];
<span id="line3322" class="line"></span>        const a11 = a[4];
<span id="line3323" class="line"></span>        const a12 = a[5];
<span id="line3324" class="line"></span>        return new Mat3([
<span id="line3325" class="line"></span>            sx * a00,
<span id="line3326" class="line"></span>            sx * a01,
<span id="line3327" class="line"></span>            sx * a02,
<span id="line3328" class="line"></span>            sy * a10,
<span id="line3329" class="line"></span>            sy * a11,
<span id="line3330" class="line"></span>            sy * a12,
<span id="line3331" class="line"></span>            tx * a00 + ty * a10,
<span id="line3332" class="line"></span>            tx * a01 + ty * a11,
<span id="line3333" class="line"></span>            tx * a02 + ty * a12,
<span id="line3334" class="line"></span>        ]);
<span id="line3335" class="line"></span>    }
<span id="line3336" class="line"></span>
<span id="line3337" class="line"></span>    /**
<span id="line3338" class="line"></span>     * Scaling &amp; translation only changes certain values, no need to compute full matrix multiplication.
<span id="line3339" class="line"></span>     * Optimization: in case the original matrix can be thrown away, optimize instead by computing in-place.
<span id="line3340" class="line"></span>     * @memberof OpenSeadragon.Mat3
<span id="line3341" class="line"></span>     */
<span id="line3342" class="line"></span>    scaleAndTranslateSelf(sx, sy, tx, ty) {
<span id="line3343" class="line"></span>        const a = this.values;
<span id="line3344" class="line"></span>
<span id="line3345" class="line"></span>        const m00 = a[0], m01 = a[1], m02 = a[2];
<span id="line3346" class="line"></span>        const m10 = a[3], m11 = a[4], m12 = a[5];
<span id="line3347" class="line"></span>
<span id="line3348" class="line"></span>        a[0] = sx * m00;
<span id="line3349" class="line"></span>        a[1] = sx * m01;
<span id="line3350" class="line"></span>        a[2] = sx * m02;
<span id="line3351" class="line"></span>
<span id="line3352" class="line"></span>        a[3] = sy * m10;
<span id="line3353" class="line"></span>        a[4] = sy * m11;
<span id="line3354" class="line"></span>        a[5] = sy * m12;
<span id="line3355" class="line"></span>
<span id="line3356" class="line"></span>        a[6] = tx * m00 + ty * m10 + a[6];
<span id="line3357" class="line"></span>        a[7] = tx * m01 + ty * m11 + a[7];
<span id="line3358" class="line"></span>        a[8] = tx * m02 + ty * m12 + a[8];
<span id="line3359" class="line"></span>    }
<span id="line3360" class="line"></span>
<span id="line3361" class="line"></span>    /**
<span id="line3362" class="line"></span>     * Move and translate another matrix by self. 'this' matrix must be scale &amp; translate matrix.
<span id="line3363" class="line"></span>     * Optimization: in case the original matrix can be thrown away, optimize instead by computing in-place.
<span id="line3364" class="line"></span>     * Used for optimization: we have
<span id="line3365" class="line"></span>     * A) THIS matrix, carrying scale and translation,
<span id="line3366" class="line"></span>     * B) OTHER general matrix to scale and translate.
<span id="line3367" class="line"></span>     * Since THIS matrix is unique per tile, we can optimize the operation by:
<span id="line3368" class="line"></span>     *  - move &amp; scale OTHER by THIS, and
<span id="line3369" class="line"></span>     *  - store the result to THIS, since we don't need to keep the scaling and translation, but
<span id="line3370" class="line"></span>     *    we need to keep the original OTHER matrix (for each tile within tiled image).
<span id="line3371" class="line"></span>     * @param {OpenSeadragon.Mat3} other the matrix to scale and translate by this matrix and accept values from
<span id="line3372" class="line"></span>     * @memberof OpenSeadragon.Mat3
<span id="line3373" class="line"></span>     */
<span id="line3374" class="line"></span>    scaleAndTranslateOtherSetSelf(other) {
<span id="line3375" class="line"></span>        const a = other.values;
<span id="line3376" class="line"></span>        const out = this.values;
<span id="line3377" class="line"></span>
<span id="line3378" class="line"></span>        // Read scale and translation values from 'this'
<span id="line3379" class="line"></span>        const sx = out[0]; // scale X (this[0])
<span id="line3380" class="line"></span>        const sy = out[4]; // scale Y (this[4])
<span id="line3381" class="line"></span>        const tx = out[6]; // translate X
<span id="line3382" class="line"></span>        const ty = out[7]; // translate Y
<span id="line3383" class="line"></span>
<span id="line3384" class="line"></span>        // Compute result = this * other, store into this.values (in-place)
<span id="line3385" class="line"></span>        out[0] = sx * a[0];
<span id="line3386" class="line"></span>        out[1] = sx * a[1];
<span id="line3387" class="line"></span>        out[2] = sx * a[2];
<span id="line3388" class="line"></span>
<span id="line3389" class="line"></span>        out[3] = sy * a[3];
<span id="line3390" class="line"></span>        out[4] = sy * a[4];
<span id="line3391" class="line"></span>        out[5] = sy * a[5];
<span id="line3392" class="line"></span>
<span id="line3393" class="line"></span>        out[6] = tx * a[0] + ty * a[3] + a[6];
<span id="line3394" class="line"></span>        out[7] = tx * a[1] + ty * a[4] + a[7];
<span id="line3395" class="line"></span>        out[8] = tx * a[2] + ty * a[5] + a[8];
<span id="line3396" class="line"></span>    }
<span id="line3397" class="line"></span>}
<span id="line3398" class="line"></span>
<span id="line3399" class="line"></span>
<span id="line3400" class="line"></span>$.Mat3 = Mat3;
<span id="line3401" class="line"></span>
<span id="line3402" class="line"></span>}( OpenSeadragon ));
<span id="line3403" class="line"></span>
<span id="line3404" class="line"></span>/*
<span id="line3405" class="line"></span> * OpenSeadragon - full-screen support functions
<span id="line3406" class="line"></span> *
<span id="line3407" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line3408" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line3409" class="line"></span> *
<span id="line3410" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line3411" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line3412" class="line"></span> * met:
<span id="line3413" class="line"></span> *
<span id="line3414" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line3415" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line3416" class="line"></span> *
<span id="line3417" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line3418" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line3419" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line3420" class="line"></span> *
<span id="line3421" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line3422" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line3423" class="line"></span> *   this software without specific prior written permission.
<span id="line3424" class="line"></span> *
<span id="line3425" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line3426" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line3427" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line3428" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line3429" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line3430" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line3431" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line3432" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line3433" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line3434" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line3435" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line3436" class="line"></span> */
<span id="line3437" class="line"></span>
<span id="line3438" class="line"></span>(function( $ ) {
<span id="line3439" class="line"></span>    /**
<span id="line3440" class="line"></span>     * Determine native full screen support we can get from the browser.
<span id="line3441" class="line"></span>     * @member fullScreenApi
<span id="line3442" class="line"></span>     * @memberof OpenSeadragon
<span id="line3443" class="line"></span>     * @type {object}
<span id="line3444" class="line"></span>     * @property {Boolean} supportsFullScreen Return true if full screen API is supported.
<span id="line3445" class="line"></span>     * @property {Function} isFullScreen Return true if currently in full screen mode.
<span id="line3446" class="line"></span>     * @property {Function} getFullScreenElement Return the element currently in full screen mode.
<span id="line3447" class="line"></span>     * @property {Function} requestFullScreen Make a request to go in full screen mode.
<span id="line3448" class="line"></span>     * @property {Function} exitFullScreen Make a request to exit full screen mode.
<span id="line3449" class="line"></span>     * @property {Function} cancelFullScreen Deprecated, use exitFullScreen instead.
<span id="line3450" class="line"></span>     * @property {String} fullScreenEventName Event fired when the full screen mode change.
<span id="line3451" class="line"></span>     * @property {String} fullScreenErrorEventName Event fired when a request to go
<span id="line3452" class="line"></span>     * in full screen mode failed.
<span id="line3453" class="line"></span>     */
<span id="line3454" class="line"></span>    const fullScreenApi = {
<span id="line3455" class="line"></span>        supportsFullScreen: false,
<span id="line3456" class="line"></span>        isFullScreen: function() { return false; },
<span id="line3457" class="line"></span>        getFullScreenElement: function() { return null; },
<span id="line3458" class="line"></span>        requestFullScreen: function() {},
<span id="line3459" class="line"></span>        exitFullScreen: function() {},
<span id="line3460" class="line"></span>        cancelFullScreen: function() {},
<span id="line3461" class="line"></span>        fullScreenEventName: '',
<span id="line3462" class="line"></span>        fullScreenErrorEventName: ''
<span id="line3463" class="line"></span>    };
<span id="line3464" class="line"></span>
<span id="line3465" class="line"></span>    // check for native support
<span id="line3466" class="line"></span>    if ( document.exitFullscreen ) {
<span id="line3467" class="line"></span>        // W3C standard
<span id="line3468" class="line"></span>        fullScreenApi.supportsFullScreen = true;
<span id="line3469" class="line"></span>        fullScreenApi.getFullScreenElement = function() {
<span id="line3470" class="line"></span>            return document.fullscreenElement;
<span id="line3471" class="line"></span>        };
<span id="line3472" class="line"></span>        fullScreenApi.requestFullScreen = function( element ) {
<span id="line3473" class="line"></span>            return element.requestFullscreen().catch(function (msg) {
<span id="line3474" class="line"></span>                $.console.error('Fullscreen request failed: ', msg);
<span id="line3475" class="line"></span>            });
<span id="line3476" class="line"></span>        };
<span id="line3477" class="line"></span>        fullScreenApi.exitFullScreen = function() {
<span id="line3478" class="line"></span>            document.exitFullscreen().catch(function (msg) {
<span id="line3479" class="line"></span>                $.console.error('Error while exiting fullscreen: ', msg);
<span id="line3480" class="line"></span>            });
<span id="line3481" class="line"></span>        };
<span id="line3482" class="line"></span>        fullScreenApi.fullScreenEventName = "fullscreenchange";
<span id="line3483" class="line"></span>        fullScreenApi.fullScreenErrorEventName = "fullscreenerror";
<span id="line3484" class="line"></span>    } else if ( document.msExitFullscreen ) {
<span id="line3485" class="line"></span>        // IE 11
<span id="line3486" class="line"></span>        fullScreenApi.supportsFullScreen = true;
<span id="line3487" class="line"></span>        fullScreenApi.getFullScreenElement = function() {
<span id="line3488" class="line"></span>            return document.msFullscreenElement;
<span id="line3489" class="line"></span>        };
<span id="line3490" class="line"></span>        fullScreenApi.requestFullScreen = function( element ) {
<span id="line3491" class="line"></span>            return element.msRequestFullscreen();
<span id="line3492" class="line"></span>        };
<span id="line3493" class="line"></span>        fullScreenApi.exitFullScreen = function() {
<span id="line3494" class="line"></span>            document.msExitFullscreen();
<span id="line3495" class="line"></span>        };
<span id="line3496" class="line"></span>        fullScreenApi.fullScreenEventName = "MSFullscreenChange";
<span id="line3497" class="line"></span>        fullScreenApi.fullScreenErrorEventName = "MSFullscreenError";
<span id="line3498" class="line"></span>    } else if ( document.webkitExitFullscreen ) {
<span id="line3499" class="line"></span>        // Recent webkit
<span id="line3500" class="line"></span>        fullScreenApi.supportsFullScreen = true;
<span id="line3501" class="line"></span>        fullScreenApi.getFullScreenElement = function() {
<span id="line3502" class="line"></span>            return document.webkitFullscreenElement;
<span id="line3503" class="line"></span>        };
<span id="line3504" class="line"></span>        fullScreenApi.requestFullScreen = function( element ) {
<span id="line3505" class="line"></span>            return element.webkitRequestFullscreen();
<span id="line3506" class="line"></span>        };
<span id="line3507" class="line"></span>        fullScreenApi.exitFullScreen = function() {
<span id="line3508" class="line"></span>            document.webkitExitFullscreen();
<span id="line3509" class="line"></span>        };
<span id="line3510" class="line"></span>        fullScreenApi.fullScreenEventName = "webkitfullscreenchange";
<span id="line3511" class="line"></span>        fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror";
<span id="line3512" class="line"></span>    } else if ( document.webkitCancelFullScreen ) {
<span id="line3513" class="line"></span>        // Old webkit
<span id="line3514" class="line"></span>        fullScreenApi.supportsFullScreen = true;
<span id="line3515" class="line"></span>        fullScreenApi.getFullScreenElement = function() {
<span id="line3516" class="line"></span>            return document.webkitCurrentFullScreenElement;
<span id="line3517" class="line"></span>        };
<span id="line3518" class="line"></span>        fullScreenApi.requestFullScreen = function( element ) {
<span id="line3519" class="line"></span>            return element.webkitRequestFullScreen();
<span id="line3520" class="line"></span>        };
<span id="line3521" class="line"></span>        fullScreenApi.exitFullScreen = function() {
<span id="line3522" class="line"></span>            document.webkitCancelFullScreen();
<span id="line3523" class="line"></span>        };
<span id="line3524" class="line"></span>        fullScreenApi.fullScreenEventName = "webkitfullscreenchange";
<span id="line3525" class="line"></span>        fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror";
<span id="line3526" class="line"></span>    } else if ( document.mozCancelFullScreen ) {
<span id="line3527" class="line"></span>        // Firefox
<span id="line3528" class="line"></span>        fullScreenApi.supportsFullScreen = true;
<span id="line3529" class="line"></span>        fullScreenApi.getFullScreenElement = function() {
<span id="line3530" class="line"></span>            return document.mozFullScreenElement;
<span id="line3531" class="line"></span>        };
<span id="line3532" class="line"></span>        fullScreenApi.requestFullScreen = function( element ) {
<span id="line3533" class="line"></span>            return element.mozRequestFullScreen();
<span id="line3534" class="line"></span>        };
<span id="line3535" class="line"></span>        fullScreenApi.exitFullScreen = function() {
<span id="line3536" class="line"></span>            document.mozCancelFullScreen();
<span id="line3537" class="line"></span>        };
<span id="line3538" class="line"></span>        fullScreenApi.fullScreenEventName = "mozfullscreenchange";
<span id="line3539" class="line"></span>        fullScreenApi.fullScreenErrorEventName = "mozfullscreenerror";
<span id="line3540" class="line"></span>    }
<span id="line3541" class="line"></span>    fullScreenApi.isFullScreen = function() {
<span id="line3542" class="line"></span>        return fullScreenApi.getFullScreenElement() !== null;
<span id="line3543" class="line"></span>    };
<span id="line3544" class="line"></span>    fullScreenApi.cancelFullScreen = function() {
<span id="line3545" class="line"></span>        $.console.error("cancelFullScreen is deprecated. Use exitFullScreen instead.");
<span id="line3546" class="line"></span>        fullScreenApi.exitFullScreen();
<span id="line3547" class="line"></span>    };
<span id="line3548" class="line"></span>
<span id="line3549" class="line"></span>    // export api
<span id="line3550" class="line"></span>    $.extend( $, fullScreenApi );
<span id="line3551" class="line"></span>
<span id="line3552" class="line"></span>})( OpenSeadragon );
<span id="line3553" class="line"></span>
<span id="line3554" class="line"></span>/*
<span id="line3555" class="line"></span> * OpenSeadragon - EventSource
<span id="line3556" class="line"></span> *
<span id="line3557" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line3558" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line3559" class="line"></span> *
<span id="line3560" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line3561" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line3562" class="line"></span> * met:
<span id="line3563" class="line"></span> *
<span id="line3564" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line3565" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line3566" class="line"></span> *
<span id="line3567" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line3568" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line3569" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line3570" class="line"></span> *
<span id="line3571" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line3572" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line3573" class="line"></span> *   this software without specific prior written permission.
<span id="line3574" class="line"></span> *
<span id="line3575" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line3576" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line3577" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line3578" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line3579" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line3580" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line3581" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line3582" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line3583" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line3584" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line3585" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line3586" class="line"></span> */
<span id="line3587" class="line"></span>
<span id="line3588" class="line"></span>(function($){
<span id="line3589" class="line"></span>
<span id="line3590" class="line"></span>/**
<span id="line3591" class="line"></span> * @typedef {Object} OpenSeadragon.Event
<span id="line3592" class="line"></span> * @memberof OpenSeadragon
<span id="line3593" class="line"></span> * @property {boolean|function} [stopPropagation=undefined] - If set to true or the functional predicate returns true,
<span id="line3594" class="line"></span> *   the event exits after handling the current call.
<span id="line3595" class="line"></span> */
<span id="line3596" class="line"></span>
<span id="line3597" class="line"></span>/**
<span id="line3598" class="line"></span> * Event handler method signature used by all OpenSeadragon events.
<span id="line3599" class="line"></span> *
<span id="line3600" class="line"></span> * @typedef {function(OpenSeadragon.Event): void} OpenSeadragon.EventHandler
<span id="line3601" class="line"></span> * @memberof OpenSeadragon
<span id="line3602" class="line"></span> * @param {OpenSeadragon.Event} event - The event object containing event-specific properties.
<span id="line3603" class="line"></span> * @returns {void} This handler does not return a value.
<span id="line3604" class="line"></span> */
<span id="line3605" class="line"></span>
<span id="line3606" class="line"></span>/**
<span id="line3607" class="line"></span> * Event handler method signature used by all OpenSeadragon events.
<span id="line3608" class="line"></span> *
<span id="line3609" class="line"></span> * @typedef {function(OpenSeadragon.Event): Promise&lt;void&gt;} OpenSeadragon.AsyncEventHandler
<span id="line3610" class="line"></span> * @memberof OpenSeadragon
<span id="line3611" class="line"></span> * @param {OpenSeadragon.Event} event - The event object containing event-specific properties.
<span id="line3612" class="line"></span> * @returns {Promise&lt;void&gt;} This handler does not return a value.
<span id="line3613" class="line"></span> */
<span id="line3614" class="line"></span>
<span id="line3615" class="line"></span>
<span id="line3616" class="line"></span>/**
<span id="line3617" class="line"></span> * @class EventSource
<span id="line3618" class="line"></span> * @classdesc For use by classes which want to support custom, non-browser events.
<span id="line3619" class="line"></span> *
<span id="line3620" class="line"></span> * @memberof OpenSeadragon
<span id="line3621" class="line"></span> */
<span id="line3622" class="line"></span>$.EventSource = function() {
<span id="line3623" class="line"></span>    this.events = {};
<span id="line3624" class="line"></span>    this._rejectedEventList = {};
<span id="line3625" class="line"></span>};
<span id="line3626" class="line"></span>
<span id="line3627" class="line"></span>/** @lends OpenSeadragon.EventSource.prototype */
<span id="line3628" class="line"></span>$.EventSource.prototype = {
<span id="line3629" class="line"></span>
<span id="line3630" class="line"></span>    /**
<span id="line3631" class="line"></span>     * Add an event handler to be triggered only once (or a given number of times)
<span id="line3632" class="line"></span>     * for a given event. It is not removable with removeHandler().
<span id="line3633" class="line"></span>     * @function
<span id="line3634" class="line"></span>     * @param {String} eventName - Name of event to register.
<span id="line3635" class="line"></span>     * @param {OpenSeadragon.EventHandler|OpenSeadragon.AsyncEventHandler} handler - Function to call when event
<span id="line3636" class="line"></span>     * is triggered.
<span id="line3637" class="line"></span>     * @param {Object} [userData=null] - Arbitrary object to be passed unchanged
<span id="line3638" class="line"></span>     * to the handler.
<span id="line3639" class="line"></span>     * @param {Number} [times=1] - The number of times to handle the event
<span id="line3640" class="line"></span>     * before removing it.
<span id="line3641" class="line"></span>     * @param {Number} [priority=0] - Handler priority. By default, all priorities are 0. Higher number = priority.
<span id="line3642" class="line"></span>     * @returns {Boolean} - True if the handler was added, false if it was rejected
<span id="line3643" class="line"></span>     */
<span id="line3644" class="line"></span>    addOnceHandler: function(eventName, handler, userData, times, priority) {
<span id="line3645" class="line"></span>        const self = this;
<span id="line3646" class="line"></span>        times = times || 1;
<span id="line3647" class="line"></span>        let count = 0;
<span id="line3648" class="line"></span>        const onceHandler = function(event) {
<span id="line3649" class="line"></span>            count++;
<span id="line3650" class="line"></span>            if (count === times) {
<span id="line3651" class="line"></span>                self.removeHandler(eventName, onceHandler);
<span id="line3652" class="line"></span>            }
<span id="line3653" class="line"></span>            return handler(event);
<span id="line3654" class="line"></span>        };
<span id="line3655" class="line"></span>        return this.addHandler(eventName, onceHandler, userData, priority);
<span id="line3656" class="line"></span>    },
<span id="line3657" class="line"></span>
<span id="line3658" class="line"></span>    /**
<span id="line3659" class="line"></span>     * Add an event handler for a given event.
<span id="line3660" class="line"></span>     * @function
<span id="line3661" class="line"></span>     * @param {String} eventName - Name of event to register.
<span id="line3662" class="line"></span>     * @param {OpenSeadragon.EventHandler|OpenSeadragon.AsyncEventHandler} handler - Function to call when event is triggered.
<span id="line3663" class="line"></span>     * @param {Object} [userData=null] - Arbitrary object to be passed unchanged to the handler.
<span id="line3664" class="line"></span>     * @param {Number} [priority=0] - Handler priority. By default, all priorities are 0. Higher number = priority.
<span id="line3665" class="line"></span>     * @returns {Boolean} - True if the handler was added, false if it was rejected
<span id="line3666" class="line"></span>     */
<span id="line3667" class="line"></span>    addHandler: function ( eventName, handler, userData, priority ) {
<span id="line3668" class="line"></span>
<span id="line3669" class="line"></span>        if(Object.prototype.hasOwnProperty.call(this._rejectedEventList, eventName)){
<span id="line3670" class="line"></span>            $.console.error(`Error adding handler for ${eventName}. ${this._rejectedEventList[eventName]}`);
<span id="line3671" class="line"></span>            return false;
<span id="line3672" class="line"></span>        }
<span id="line3673" class="line"></span>
<span id="line3674" class="line"></span>        let events = this.events[ eventName ];
<span id="line3675" class="line"></span>        if ( !events ) {
<span id="line3676" class="line"></span>            this.events[ eventName ] = events = [];
<span id="line3677" class="line"></span>        }
<span id="line3678" class="line"></span>        if ( handler &amp;&amp; $.isFunction( handler ) ) {
<span id="line3679" class="line"></span>            let index = events.length,
<span id="line3680" class="line"></span>                event = { handler: handler, userData: userData || null, priority: priority || 0 };
<span id="line3681" class="line"></span>            events[ index ] = event;
<span id="line3682" class="line"></span>            while ( index &gt; 0 &amp;&amp; events[ index - 1 ].priority &lt; events[ index ].priority ) {
<span id="line3683" class="line"></span>                events[ index ] = events[ index - 1 ];
<span id="line3684" class="line"></span>                events[ index - 1 ] = event;
<span id="line3685" class="line"></span>                index--;
<span id="line3686" class="line"></span>            }
<span id="line3687" class="line"></span>        }
<span id="line3688" class="line"></span>        return true;
<span id="line3689" class="line"></span>    },
<span id="line3690" class="line"></span>
<span id="line3691" class="line"></span>    /**
<span id="line3692" class="line"></span>     * Remove a specific event handler for a given event.
<span id="line3693" class="line"></span>     * @function
<span id="line3694" class="line"></span>     * @param {String} eventName - Name of event for which the handler is to be removed.
<span id="line3695" class="line"></span>     * @param {OpenSeadragon.EventHandler|OpenSeadragon.AsyncEventHandler} handler - Function to be removed.
<span id="line3696" class="line"></span>     */
<span id="line3697" class="line"></span>    removeHandler: function ( eventName, handler ) {
<span id="line3698" class="line"></span>        const events = this.events[ eventName ];
<span id="line3699" class="line"></span>        const handlers = [];
<span id="line3700" class="line"></span>        if ( !events ) {
<span id="line3701" class="line"></span>            return;
<span id="line3702" class="line"></span>        }
<span id="line3703" class="line"></span>        if ( $.isArray( events ) ) {
<span id="line3704" class="line"></span>            for ( let i = 0; i &lt; events.length; i++ ) {
<span id="line3705" class="line"></span>                if ( events[i].handler !== handler ) {
<span id="line3706" class="line"></span>                    handlers.push( events[ i ] );
<span id="line3707" class="line"></span>                }
<span id="line3708" class="line"></span>            }
<span id="line3709" class="line"></span>            this.events[ eventName ] = handlers;
<span id="line3710" class="line"></span>        }
<span id="line3711" class="line"></span>    },
<span id="line3712" class="line"></span>
<span id="line3713" class="line"></span>    /**
<span id="line3714" class="line"></span>     * Get the amount of handlers registered for a given event.
<span id="line3715" class="line"></span>     * @param {String} eventName - Name of event to inspect.
<span id="line3716" class="line"></span>     * @returns {number} amount of events
<span id="line3717" class="line"></span>     */
<span id="line3718" class="line"></span>    numberOfHandlers: function (eventName) {
<span id="line3719" class="line"></span>        const events = this.events[ eventName ];
<span id="line3720" class="line"></span>        if ( !events ) {
<span id="line3721" class="line"></span>            return 0;
<span id="line3722" class="line"></span>        }
<span id="line3723" class="line"></span>        return events.length;
<span id="line3724" class="line"></span>    },
<span id="line3725" class="line"></span>
<span id="line3726" class="line"></span>    /**
<span id="line3727" class="line"></span>     * Remove all event handlers for a given event type. If no type is given all
<span id="line3728" class="line"></span>     * event handlers for every event type are removed.
<span id="line3729" class="line"></span>     * @function
<span id="line3730" class="line"></span>     * @param {String} [eventName] - Name of event for which all handlers are to be removed.
<span id="line3731" class="line"></span>     */
<span id="line3732" class="line"></span>    removeAllHandlers: function( eventName ) {
<span id="line3733" class="line"></span>        if ( eventName ){
<span id="line3734" class="line"></span>            this.events[ eventName ] = [];
<span id="line3735" class="line"></span>        } else{
<span id="line3736" class="line"></span>            for ( let eventType in this.events ) {
<span id="line3737" class="line"></span>                this.events[ eventType ] = [];
<span id="line3738" class="line"></span>            }
<span id="line3739" class="line"></span>        }
<span id="line3740" class="line"></span>    },
<span id="line3741" class="line"></span>
<span id="line3742" class="line"></span>    /**
<span id="line3743" class="line"></span>     * Get a function which iterates the list of all handlers registered for a given event, calling the handler for each.
<span id="line3744" class="line"></span>     * @function
<span id="line3745" class="line"></span>     * @param {String} eventName - Name of event to get handlers for.
<span id="line3746" class="line"></span>     */
<span id="line3747" class="line"></span>    getHandler: function ( eventName) {
<span id="line3748" class="line"></span>        let events = this.events[ eventName ];
<span id="line3749" class="line"></span>        if ( !events || !events.length ) {
<span id="line3750" class="line"></span>            return null;
<span id="line3751" class="line"></span>        }
<span id="line3752" class="line"></span>        events = events.length === 1 ?
<span id="line3753" class="line"></span>            [ events[ 0 ] ] :
<span id="line3754" class="line"></span>            Array.apply( null, events );
<span id="line3755" class="line"></span>        return function ( source, args ) {
<span id="line3756" class="line"></span>            let length = events.length;
<span id="line3757" class="line"></span>            for ( let i = 0; i &lt; length; i++ ) {
<span id="line3758" class="line"></span>                if ( events[ i ] ) {
<span id="line3759" class="line"></span>                    args.eventSource = source;
<span id="line3760" class="line"></span>                    args.userData = events[ i ].userData;
<span id="line3761" class="line"></span>                    events[ i ].handler( args );
<span id="line3762" class="line"></span>
<span id="line3763" class="line"></span>                    if (args.stopPropagation &amp;&amp; (typeof args.stopPropagation !== "function" || args.stopPropagation() === true)) {
<span id="line3764" class="line"></span>                        break;
<span id="line3765" class="line"></span>                    }
<span id="line3766" class="line"></span>                }
<span id="line3767" class="line"></span>            }
<span id="line3768" class="line"></span>        };
<span id="line3769" class="line"></span>    },
<span id="line3770" class="line"></span>
<span id="line3771" class="line"></span>    /**
<span id="line3772" class="line"></span>     * Get a function which iterates the list of all handlers registered for a given event,
<span id="line3773" class="line"></span>     * calling the handler for each and awaiting async ones.
<span id="line3774" class="line"></span>     * @function
<span id="line3775" class="line"></span>     * @param {String} eventName - Name of event to get handlers for.
<span id="line3776" class="line"></span>     * @param {any} bindTarget - Bound target to return with the promise on finish
<span id="line3777" class="line"></span>     */
<span id="line3778" class="line"></span>    getAwaitingHandler: function ( eventName, bindTarget ) {
<span id="line3779" class="line"></span>        let events = this.events[ eventName ];
<span id="line3780" class="line"></span>        if ( !events || !events.length ) {
<span id="line3781" class="line"></span>            return null;
<span id="line3782" class="line"></span>        }
<span id="line3783" class="line"></span>        events = events.length === 1 ?
<span id="line3784" class="line"></span>            [ events[ 0 ] ] :
<span id="line3785" class="line"></span>            Array.apply( null, events );
<span id="line3786" class="line"></span>
<span id="line3787" class="line"></span>        return function ( source, args ) {
<span id="line3788" class="line"></span>            // We return a promise that gets resolved after all the events finish.
<span id="line3789" class="line"></span>            // Returning loop result is not correct, loop promises chain dynamically
<span id="line3790" class="line"></span>            // and outer code could process finishing logics in the middle of event loop.
<span id="line3791" class="line"></span>            return new $.Promise((resolve, reject) =&gt; {
<span id="line3792" class="line"></span>                const length = events.length;
<span id="line3793" class="line"></span>                function loop(index) {
<span id="line3794" class="line"></span>                    if ( index &gt;= length || !events[ index ] ) {
<span id="line3795" class="line"></span>                        resolve(bindTarget);
<span id="line3796" class="line"></span>                        return null;
<span id="line3797" class="line"></span>                    }
<span id="line3798" class="line"></span>                    args.eventSource = source;
<span id="line3799" class="line"></span>                    args.userData = events[ index ].userData;
<span id="line3800" class="line"></span>                    let result;
<span id="line3801" class="line"></span>                    try {
<span id="line3802" class="line"></span>                        result = events[ index ].handler( args );
<span id="line3803" class="line"></span>                    } catch (e) {
<span id="line3804" class="line"></span>                        return reject(e);
<span id="line3805" class="line"></span>                    }
<span id="line3806" class="line"></span>                    result = (!result || $.type(result) !== "promise") ? $.Promise.resolve() : result;
<span id="line3807" class="line"></span>                    return result.then(() =&gt; {
<span id="line3808" class="line"></span>                        if (!args.stopPropagation || (typeof args.stopPropagation === "function" &amp;&amp; args.stopPropagation() === false)) {
<span id="line3809" class="line"></span>                            return loop(index + 1);
<span id="line3810" class="line"></span>                        }
<span id="line3811" class="line"></span>                        return loop(length);
<span id="line3812" class="line"></span>                    });
<span id="line3813" class="line"></span>                }
<span id="line3814" class="line"></span>                loop(0).catch(reject);
<span id="line3815" class="line"></span>            });
<span id="line3816" class="line"></span>        };
<span id="line3817" class="line"></span>    },
<span id="line3818" class="line"></span>
<span id="line3819" class="line"></span>    /**
<span id="line3820" class="line"></span>     * Trigger an event, optionally passing additional information. Does not await async handlers, i.e.
<span id="line3821" class="line"></span>     * OpenSeadragon.AsyncEventHandler.
<span id="line3822" class="line"></span>     * @function
<span id="line3823" class="line"></span>     * @param {String} eventName - Name of event to register.
<span id="line3824" class="line"></span>     * @param {Object|undefined} eventArgs - Event-specific data.
<span id="line3825" class="line"></span>     * @returns {Boolean} True if the event was fired, false if it was rejected because of rejectEventHandler(eventName)
<span id="line3826" class="line"></span>     */
<span id="line3827" class="line"></span>    raiseEvent: function( eventName, eventArgs ) {
<span id="line3828" class="line"></span>        //uncomment if you want to get a log of all events
<span id="line3829" class="line"></span>        //$.console.log( "Event fired:", eventName );
<span id="line3830" class="line"></span>
<span id="line3831" class="line"></span>        if(Object.prototype.hasOwnProperty.call(this._rejectedEventList, eventName)){
<span id="line3832" class="line"></span>            $.console.error(`Error adding handler for ${eventName}. ${this._rejectedEventList[eventName]}`);
<span id="line3833" class="line"></span>            return false;
<span id="line3834" class="line"></span>        }
<span id="line3835" class="line"></span>
<span id="line3836" class="line"></span>        const handler = this.getHandler( eventName );
<span id="line3837" class="line"></span>        if ( handler ) {
<span id="line3838" class="line"></span>            handler( this, eventArgs || {} );
<span id="line3839" class="line"></span>        }
<span id="line3840" class="line"></span>        return true;
<span id="line3841" class="line"></span>    },
<span id="line3842" class="line"></span>
<span id="line3843" class="line"></span>    /**
<span id="line3844" class="line"></span>     * Trigger an event, optionally passing additional information.
<span id="line3845" class="line"></span>     * This events awaits every asynchronous or promise-returning function, i.e.
<span id="line3846" class="line"></span>     * OpenSeadragon.AsyncEventHandler.
<span id="line3847" class="line"></span>     * @param {String} eventName - Name of event to register.
<span id="line3848" class="line"></span>     * @param {Object|undefined} eventArgs - Event-specific data.
<span id="line3849" class="line"></span>     * @param {?} [bindTarget = null] - Promise-resolved value on the event finish
<span id="line3850" class="line"></span>     * @return {OpenSeadragon.Promise|undefined} - Promise resolved upon the event completion.
<span id="line3851" class="line"></span>     */
<span id="line3852" class="line"></span>    raiseEventAwaiting: function ( eventName, eventArgs, bindTarget = null ) {
<span id="line3853" class="line"></span>        //uncomment if you want to get a log of all events
<span id="line3854" class="line"></span>        //$.console.log( "Awaiting event fired:", eventName );
<span id="line3855" class="line"></span>
<span id="line3856" class="line"></span>        const awaitingHandler = this.getAwaitingHandler(eventName, bindTarget);
<span id="line3857" class="line"></span>        if (awaitingHandler) {
<span id="line3858" class="line"></span>            return awaitingHandler(this, eventArgs || {});
<span id="line3859" class="line"></span>        }
<span id="line3860" class="line"></span>        return $.Promise.resolve(bindTarget);
<span id="line3861" class="line"></span>    },
<span id="line3862" class="line"></span>
<span id="line3863" class="line"></span>    /**
<span id="line3864" class="line"></span>     * Set an event name as being disabled, and provide an optional error message
<span id="line3865" class="line"></span>     * to be printed to the console
<span id="line3866" class="line"></span>     * @param {String} eventName - Name of the event
<span id="line3867" class="line"></span>     * @param {String} [errorMessage] - Optional string to print to the console
<span id="line3868" class="line"></span>     * @private
<span id="line3869" class="line"></span>     */
<span id="line3870" class="line"></span>    rejectEventHandler(eventName, errorMessage = ''){
<span id="line3871" class="line"></span>        this._rejectedEventList[eventName] = errorMessage;
<span id="line3872" class="line"></span>    },
<span id="line3873" class="line"></span>
<span id="line3874" class="line"></span>    /**
<span id="line3875" class="line"></span>     * Explicitly allow an event handler to be added for this event type, undoing
<span id="line3876" class="line"></span>     * the effects of rejectEventHandler
<span id="line3877" class="line"></span>     * @param {String} eventName - Name of the event
<span id="line3878" class="line"></span>     * @private
<span id="line3879" class="line"></span>     */
<span id="line3880" class="line"></span>    allowEventHandler(eventName){
<span id="line3881" class="line"></span>        delete this._rejectedEventList[eventName];
<span id="line3882" class="line"></span>    }
<span id="line3883" class="line"></span>};
<span id="line3884" class="line"></span>
<span id="line3885" class="line"></span>}( OpenSeadragon ));
<span id="line3886" class="line"></span>
<span id="line3887" class="line"></span>/*
<span id="line3888" class="line"></span> * OpenSeadragon - MouseTracker
<span id="line3889" class="line"></span> *
<span id="line3890" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line3891" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line3892" class="line"></span> *
<span id="line3893" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line3894" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line3895" class="line"></span> * met:
<span id="line3896" class="line"></span> *
<span id="line3897" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line3898" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line3899" class="line"></span> *
<span id="line3900" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line3901" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line3902" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line3903" class="line"></span> *
<span id="line3904" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line3905" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line3906" class="line"></span> *   this software without specific prior written permission.
<span id="line3907" class="line"></span> *
<span id="line3908" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line3909" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line3910" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line3911" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line3912" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line3913" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line3914" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line3915" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line3916" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line3917" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line3918" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line3919" class="line"></span> */
<span id="line3920" class="line"></span>
<span id="line3921" class="line"></span>(function ( $ ) {
<span id="line3922" class="line"></span>
<span id="line3923" class="line"></span>    // All MouseTracker instances
<span id="line3924" class="line"></span>    const MOUSETRACKERS  = [];
<span id="line3925" class="line"></span>
<span id="line3926" class="line"></span>    // dictionary from hash to private properties
<span id="line3927" class="line"></span>    const THIS           = {};
<span id="line3928" class="line"></span>
<span id="line3929" class="line"></span>
<span id="line3930" class="line"></span>    /**
<span id="line3931" class="line"></span>     * @class MouseTracker
<span id="line3932" class="line"></span>     * @classdesc Provides simplified handling of common pointer device (mouse, touch, pen, etc.) gestures
<span id="line3933" class="line"></span>     *            and keyboard events on a specified element.
<span id="line3934" class="line"></span>     * @memberof OpenSeadragon
<span id="line3935" class="line"></span>     * @param {Object} options
<span id="line3936" class="line"></span>     *      Allows configurable properties to be entirely specified by passing
<span id="line3937" class="line"></span>     *      an options object to the constructor.  The constructor also supports
<span id="line3938" class="line"></span>     *      the original positional arguments 'element', 'clickTimeThreshold',
<span id="line3939" class="line"></span>     *      and 'clickDistThreshold' in that order.
<span id="line3940" class="line"></span>     * @param {Element|String} options.element
<span id="line3941" class="line"></span>     *      A reference to an element or an element id for which the pointer/key
<span id="line3942" class="line"></span>     *      events will be monitored.
<span id="line3943" class="line"></span>     * @param {Boolean} [options.startDisabled=false]
<span id="line3944" class="line"></span>     *      If true, event tracking on the element will not start until
<span id="line3945" class="line"></span>     *      {@link OpenSeadragon.MouseTracker.setTracking|setTracking} is called.
<span id="line3946" class="line"></span>     * @param {Number} [options.clickTimeThreshold=300]
<span id="line3947" class="line"></span>     *      The number of milliseconds within which a pointer down-up event combination
<span id="line3948" class="line"></span>     *      will be treated as a click gesture.
<span id="line3949" class="line"></span>     * @param {Number} [options.clickDistThreshold=5]
<span id="line3950" class="line"></span>     *      The maximum distance allowed between a pointer down event and a pointer up event
<span id="line3951" class="line"></span>     *      to be treated as a click gesture.
<span id="line3952" class="line"></span>     * @param {Number} [options.dblClickTimeThreshold=300]
<span id="line3953" class="line"></span>     *      The number of milliseconds within which two pointer down-up event combinations
<span id="line3954" class="line"></span>     *      will be treated as a double-click gesture.
<span id="line3955" class="line"></span>     * @param {Number} [options.dblClickDistThreshold=20]
<span id="line3956" class="line"></span>     *      The maximum distance allowed between two pointer click events
<span id="line3957" class="line"></span>     *      to be treated as a click gesture.
<span id="line3958" class="line"></span>     * @param {Number} [options.stopDelay=50]
<span id="line3959" class="line"></span>     *      The number of milliseconds without pointer move before the stop
<span id="line3960" class="line"></span>     *      event is fired.
<span id="line3961" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.preProcessEventHandler=null]
<span id="line3962" class="line"></span>     *      An optional handler for controlling DOM event propagation and processing.
<span id="line3963" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.contextMenuHandler=null]
<span id="line3964" class="line"></span>     *      An optional handler for contextmenu.
<span id="line3965" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.enterHandler=null]
<span id="line3966" class="line"></span>     *      An optional handler for pointer enter.
<span id="line3967" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.leaveHandler=null]
<span id="line3968" class="line"></span>     *      An optional handler for pointer leave.
<span id="line3969" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.exitHandler=null]
<span id="line3970" class="line"></span>     *      An optional handler for pointer leave. &lt;span style="color:red;"&gt;Deprecated. Use leaveHandler instead.&lt;/span&gt;
<span id="line3971" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.overHandler=null]
<span id="line3972" class="line"></span>     *      An optional handler for pointer over.
<span id="line3973" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.outHandler=null]
<span id="line3974" class="line"></span>     *      An optional handler for pointer out.
<span id="line3975" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.pressHandler=null]
<span id="line3976" class="line"></span>     *      An optional handler for pointer press.
<span id="line3977" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.nonPrimaryPressHandler=null]
<span id="line3978" class="line"></span>     *      An optional handler for pointer non-primary button press.
<span id="line3979" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.releaseHandler=null]
<span id="line3980" class="line"></span>     *      An optional handler for pointer release.
<span id="line3981" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.nonPrimaryReleaseHandler=null]
<span id="line3982" class="line"></span>     *      An optional handler for pointer non-primary button release.
<span id="line3983" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.moveHandler=null]
<span id="line3984" class="line"></span>     *      An optional handler for pointer move.
<span id="line3985" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.scrollHandler=null]
<span id="line3986" class="line"></span>     *      An optional handler for mouse wheel scroll.
<span id="line3987" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.clickHandler=null]
<span id="line3988" class="line"></span>     *      An optional handler for pointer click.
<span id="line3989" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.dblClickHandler=null]
<span id="line3990" class="line"></span>     *      An optional handler for pointer double-click.
<span id="line3991" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.dragHandler=null]
<span id="line3992" class="line"></span>     *      An optional handler for the drag gesture.
<span id="line3993" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.dragEndHandler=null]
<span id="line3994" class="line"></span>     *      An optional handler for after a drag gesture.
<span id="line3995" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.pinchHandler=null]
<span id="line3996" class="line"></span>     *      An optional handler for the pinch gesture.
<span id="line3997" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.keyDownHandler=null]
<span id="line3998" class="line"></span>     *      An optional handler for keydown.
<span id="line3999" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.keyUpHandler=null]
<span id="line4000" class="line"></span>     *      An optional handler for keyup.
<span id="line4001" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.keyHandler=null]
<span id="line4002" class="line"></span>     *      An optional handler for keypress.
<span id="line4003" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.focusHandler=null]
<span id="line4004" class="line"></span>     *      An optional handler for focus.
<span id="line4005" class="line"></span>     * @param {OpenSeadragon.EventHandler} [options.blurHandler=null]
<span id="line4006" class="line"></span>     *      An optional handler for blur.
<span id="line4007" class="line"></span>     * @param {Object} [options.userData=null]
<span id="line4008" class="line"></span>     *      Arbitrary object to be passed unchanged to any attached handler methods.
<span id="line4009" class="line"></span>     */
<span id="line4010" class="line"></span>    $.MouseTracker = function ( options ) {
<span id="line4011" class="line"></span>
<span id="line4012" class="line"></span>        MOUSETRACKERS.push( this );
<span id="line4013" class="line"></span>
<span id="line4014" class="line"></span>        const args = arguments;
<span id="line4015" class="line"></span>
<span id="line4016" class="line"></span>        if ( !$.isPlainObject( options ) ) {
<span id="line4017" class="line"></span>            options = {
<span id="line4018" class="line"></span>                element:            args[ 0 ],
<span id="line4019" class="line"></span>                clickTimeThreshold: args[ 1 ],
<span id="line4020" class="line"></span>                clickDistThreshold: args[ 2 ]
<span id="line4021" class="line"></span>            };
<span id="line4022" class="line"></span>        }
<span id="line4023" class="line"></span>
<span id="line4024" class="line"></span>        this.hash               = uniqueHash(); // An unique hash for this tracker.
<span id="line4025" class="line"></span>        /**
<span id="line4026" class="line"></span>         * The element for which pointer events are being monitored.
<span id="line4027" class="line"></span>         * @member {Element} element
<span id="line4028" class="line"></span>         * @memberof OpenSeadragon.MouseTracker#
<span id="line4029" class="line"></span>         */
<span id="line4030" class="line"></span>        this.element            = $.getElement( options.element );
<span id="line4031" class="line"></span>        /**
<span id="line4032" class="line"></span>         * The number of milliseconds within which a pointer down-up event combination
<span id="line4033" class="line"></span>         * will be treated as a click gesture.
<span id="line4034" class="line"></span>         * @member {Number} clickTimeThreshold
<span id="line4035" class="line"></span>         * @memberof OpenSeadragon.MouseTracker#
<span id="line4036" class="line"></span>         */
<span id="line4037" class="line"></span>        this.clickTimeThreshold = options.clickTimeThreshold || $.DEFAULT_SETTINGS.clickTimeThreshold;
<span id="line4038" class="line"></span>        /**
<span id="line4039" class="line"></span>         * The maximum distance allowed between a pointer down event and a pointer up event
<span id="line4040" class="line"></span>         * to be treated as a click gesture.
<span id="line4041" class="line"></span>         * @member {Number} clickDistThreshold
<span id="line4042" class="line"></span>         * @memberof OpenSeadragon.MouseTracker#
<span id="line4043" class="line"></span>         */
<span id="line4044" class="line"></span>        this.clickDistThreshold = options.clickDistThreshold || $.DEFAULT_SETTINGS.clickDistThreshold;
<span id="line4045" class="line"></span>        /**
<span id="line4046" class="line"></span>         * The number of milliseconds within which two pointer down-up event combinations
<span id="line4047" class="line"></span>         * will be treated as a double-click gesture.
<span id="line4048" class="line"></span>         * @member {Number} dblClickTimeThreshold
<span id="line4049" class="line"></span>         * @memberof OpenSeadragon.MouseTracker#
<span id="line4050" class="line"></span>         */
<span id="line4051" class="line"></span>        this.dblClickTimeThreshold = options.dblClickTimeThreshold || $.DEFAULT_SETTINGS.dblClickTimeThreshold;
<span id="line4052" class="line"></span>        /**
<span id="line4053" class="line"></span>         * The maximum distance allowed between two pointer click events
<span id="line4054" class="line"></span>         * to be treated as a double-click gesture.
<span id="line4055" class="line"></span>         * @member {Number} dblClickDistThreshold
<span id="line4056" class="line"></span>         * @memberof OpenSeadragon.MouseTracker#
<span id="line4057" class="line"></span>         */
<span id="line4058" class="line"></span>        this.dblClickDistThreshold = options.dblClickDistThreshold || $.DEFAULT_SETTINGS.dblClickDistThreshold;
<span id="line4059" class="line"></span>        /*eslint-disable no-multi-spaces*/
<span id="line4060" class="line"></span>        this.userData              = options.userData          || null;
<span id="line4061" class="line"></span>        this.stopDelay             = options.stopDelay         || 50;
<span id="line4062" class="line"></span>
<span id="line4063" class="line"></span>        this.preProcessEventHandler   = options.preProcessEventHandler   || null;
<span id="line4064" class="line"></span>        this.contextMenuHandler       = options.contextMenuHandler       || null;
<span id="line4065" class="line"></span>        this.enterHandler             = options.enterHandler             || null;
<span id="line4066" class="line"></span>        this.leaveHandler             = options.leaveHandler             || null;
<span id="line4067" class="line"></span>        this.exitHandler              = options.exitHandler              || null; // Deprecated v2.5.0
<span id="line4068" class="line"></span>        this.overHandler              = options.overHandler              || null;
<span id="line4069" class="line"></span>        this.outHandler               = options.outHandler               || null;
<span id="line4070" class="line"></span>        this.pressHandler             = options.pressHandler             || null;
<span id="line4071" class="line"></span>        this.nonPrimaryPressHandler   = options.nonPrimaryPressHandler   || null;
<span id="line4072" class="line"></span>        this.releaseHandler           = options.releaseHandler           || null;
<span id="line4073" class="line"></span>        this.nonPrimaryReleaseHandler = options.nonPrimaryReleaseHandler || null;
<span id="line4074" class="line"></span>        this.moveHandler              = options.moveHandler              || null;
<span id="line4075" class="line"></span>        this.scrollHandler            = options.scrollHandler            || null;
<span id="line4076" class="line"></span>        this.clickHandler             = options.clickHandler             || null;
<span id="line4077" class="line"></span>        this.dblClickHandler          = options.dblClickHandler          || null;
<span id="line4078" class="line"></span>        this.dragHandler              = options.dragHandler              || null;
<span id="line4079" class="line"></span>        this.dragEndHandler           = options.dragEndHandler           || null;
<span id="line4080" class="line"></span>        this.pinchHandler             = options.pinchHandler             || null;
<span id="line4081" class="line"></span>        this.stopHandler              = options.stopHandler              || null;
<span id="line4082" class="line"></span>        this.keyDownHandler           = options.keyDownHandler           || null;
<span id="line4083" class="line"></span>        this.keyUpHandler             = options.keyUpHandler             || null;
<span id="line4084" class="line"></span>        this.keyHandler               = options.keyHandler               || null;
<span id="line4085" class="line"></span>        this.focusHandler             = options.focusHandler             || null;
<span id="line4086" class="line"></span>        this.blurHandler              = options.blurHandler              || null;
<span id="line4087" class="line"></span>        /*eslint-enable no-multi-spaces*/
<span id="line4088" class="line"></span>
<span id="line4089" class="line"></span>        //Store private properties in a scope sealed hash map
<span id="line4090" class="line"></span>        const _this = this;
<span id="line4091" class="line"></span>
<span id="line4092" class="line"></span>        /**
<span id="line4093" class="line"></span>         * @private
<span id="line4094" class="line"></span>         * @property {Boolean} tracking
<span id="line4095" class="line"></span>         *      Are we currently tracking pointer events for this element.
<span id="line4096" class="line"></span>         */
<span id="line4097" class="line"></span>        THIS[ this.hash ] = {
<span id="line4098" class="line"></span>            click:                 function ( event ) { onClick( _this, event ); },
<span id="line4099" class="line"></span>            dblclick:              function ( event ) { onDblClick( _this, event ); },
<span id="line4100" class="line"></span>            keydown:               function ( event ) { onKeyDown( _this, event ); },
<span id="line4101" class="line"></span>            keyup:                 function ( event ) { onKeyUp( _this, event ); },
<span id="line4102" class="line"></span>            keypress:              function ( event ) { onKeyPress( _this, event ); },
<span id="line4103" class="line"></span>            focus:                 function ( event ) { onFocus( _this, event ); },
<span id="line4104" class="line"></span>            blur:                  function ( event ) { onBlur( _this, event ); },
<span id="line4105" class="line"></span>            contextmenu:           function ( event ) { onContextMenu( _this, event ); },
<span id="line4106" class="line"></span>
<span id="line4107" class="line"></span>            wheel:                 function ( event ) { onWheel( _this, event ); },
<span id="line4108" class="line"></span>            mousewheel:            function ( event ) { onMouseWheel( _this, event ); },
<span id="line4109" class="line"></span>            DOMMouseScroll:        function ( event ) { onMouseWheel( _this, event ); },
<span id="line4110" class="line"></span>            MozMousePixelScroll:   function ( event ) { onMouseWheel( _this, event ); },
<span id="line4111" class="line"></span>
<span id="line4112" class="line"></span>            losecapture:           function ( event ) { onLoseCapture( _this, event ); },
<span id="line4113" class="line"></span>
<span id="line4114" class="line"></span>            mouseenter:            function ( event ) { onPointerEnter( _this, event ); },
<span id="line4115" class="line"></span>            mouseleave:            function ( event ) { onPointerLeave( _this, event ); },
<span id="line4116" class="line"></span>            mouseover:             function ( event ) { onPointerOver( _this, event ); },
<span id="line4117" class="line"></span>            mouseout:              function ( event ) { onPointerOut( _this, event ); },
<span id="line4118" class="line"></span>            mousedown:             function ( event ) { onPointerDown( _this, event ); },
<span id="line4119" class="line"></span>            mouseup:               function ( event ) { onPointerUp( _this, event ); },
<span id="line4120" class="line"></span>            mousemove:             function ( event ) { onPointerMove( _this, event ); },
<span id="line4121" class="line"></span>
<span id="line4122" class="line"></span>            touchstart:            function ( event ) { onTouchStart( _this, event ); },
<span id="line4123" class="line"></span>            touchend:              function ( event ) { onTouchEnd( _this, event ); },
<span id="line4124" class="line"></span>            touchmove:             function ( event ) { onTouchMove( _this, event ); },
<span id="line4125" class="line"></span>            touchcancel:           function ( event ) { onTouchCancel( _this, event ); },
<span id="line4126" class="line"></span>
<span id="line4127" class="line"></span>            gesturestart:          function ( event ) { onGestureStart( _this, event ); }, // Safari/Safari iOS
<span id="line4128" class="line"></span>            gesturechange:         function ( event ) { onGestureChange( _this, event ); }, // Safari/Safari iOS
<span id="line4129" class="line"></span>
<span id="line4130" class="line"></span>            gotpointercapture:     function ( event ) { onGotPointerCapture( _this, event ); },
<span id="line4131" class="line"></span>            lostpointercapture:    function ( event ) { onLostPointerCapture( _this, event ); },
<span id="line4132" class="line"></span>            pointerenter:          function ( event ) { onPointerEnter( _this, event ); },
<span id="line4133" class="line"></span>            pointerleave:          function ( event ) { onPointerLeave( _this, event ); },
<span id="line4134" class="line"></span>            pointerover:           function ( event ) { onPointerOver( _this, event ); },
<span id="line4135" class="line"></span>            pointerout:            function ( event ) { onPointerOut( _this, event ); },
<span id="line4136" class="line"></span>            pointerdown:           function ( event ) { onPointerDown( _this, event ); },
<span id="line4137" class="line"></span>            pointerup:             function ( event ) { onPointerUp( _this, event ); },
<span id="line4138" class="line"></span>            pointermove:           function ( event ) { onPointerMove( _this, event ); },
<span id="line4139" class="line"></span>            pointercancel:         function ( event ) { onPointerCancel( _this, event ); },
<span id="line4140" class="line"></span>            pointerupcaptured:     function ( event ) { onPointerUpCaptured( _this, event ); },
<span id="line4141" class="line"></span>            pointermovecaptured:   function ( event ) { onPointerMoveCaptured( _this, event ); },
<span id="line4142" class="line"></span>
<span id="line4143" class="line"></span>            tracking:              false,
<span id="line4144" class="line"></span>
<span id="line4145" class="line"></span>            // Active pointers lists. Array of GesturePointList objects, one for each pointer device type.
<span id="line4146" class="line"></span>            // GesturePointList objects are added each time a pointer is tracked by a new pointer device type (see getActivePointersListByType()).
<span id="line4147" class="line"></span>            // Active pointers are any pointer being tracked for this element which are in the hit-test area
<span id="line4148" class="line"></span>            //     of the element (for hover-capable devices) and/or have contact or a button press initiated in the element.
<span id="line4149" class="line"></span>            activePointersLists:   [],
<span id="line4150" class="line"></span>
<span id="line4151" class="line"></span>            // Tracking for double-click gesture
<span id="line4152" class="line"></span>            lastClickPos:          null,
<span id="line4153" class="line"></span>            dblClickTimeOut:       null,
<span id="line4154" class="line"></span>
<span id="line4155" class="line"></span>            // Tracking for pinch gesture
<span id="line4156" class="line"></span>            pinchGPoints:          [],
<span id="line4157" class="line"></span>            lastPinchDist:         0,
<span id="line4158" class="line"></span>            currentPinchDist:      0,
<span id="line4159" class="line"></span>            lastPinchCenter:       null,
<span id="line4160" class="line"></span>            currentPinchCenter:    null,
<span id="line4161" class="line"></span>
<span id="line4162" class="line"></span>            // Tracking for drag
<span id="line4163" class="line"></span>            sentDragEvent:         false
<span id="line4164" class="line"></span>        };
<span id="line4165" class="line"></span>
<span id="line4166" class="line"></span>        if ( $.MouseTracker.havePointerEvents ) {
<span id="line4167" class="line"></span>            $.setElementPointerEvents( this.element, 'auto' );
<span id="line4168" class="line"></span>        }
<span id="line4169" class="line"></span>
<span id="line4170" class="line"></span>        if (this.exitHandler) {
<span id="line4171" class="line"></span>            $.console.error("MouseTracker.exitHandler is deprecated. Use MouseTracker.leaveHandler instead.");
<span id="line4172" class="line"></span>        }
<span id="line4173" class="line"></span>
<span id="line4174" class="line"></span>        if ( !options.startDisabled ) {
<span id="line4175" class="line"></span>            this.setTracking( true );
<span id="line4176" class="line"></span>        }
<span id="line4177" class="line"></span>    };
<span id="line4178" class="line"></span>
<span id="line4179" class="line"></span>    /** @lends OpenSeadragon.MouseTracker.prototype */
<span id="line4180" class="line"></span>    $.MouseTracker.prototype = {
<span id="line4181" class="line"></span>
<span id="line4182" class="line"></span>        /**
<span id="line4183" class="line"></span>         * Clean up any events or objects created by the tracker.
<span id="line4184" class="line"></span>         * @function
<span id="line4185" class="line"></span>         */
<span id="line4186" class="line"></span>        destroy: function () {
<span id="line4187" class="line"></span>            stopTracking( this );
<span id="line4188" class="line"></span>            this.element = null;
<span id="line4189" class="line"></span>
<span id="line4190" class="line"></span>            for ( let i = 0; i &lt; MOUSETRACKERS.length; i++ ) {
<span id="line4191" class="line"></span>                if ( MOUSETRACKERS[ i ] === this ) {
<span id="line4192" class="line"></span>                    MOUSETRACKERS.splice( i, 1 );
<span id="line4193" class="line"></span>                    break;
<span id="line4194" class="line"></span>                }
<span id="line4195" class="line"></span>            }
<span id="line4196" class="line"></span>
<span id="line4197" class="line"></span>            THIS[ this.hash ] = null;
<span id="line4198" class="line"></span>            delete THIS[ this.hash ];
<span id="line4199" class="line"></span>        },
<span id="line4200" class="line"></span>
<span id="line4201" class="line"></span>        /**
<span id="line4202" class="line"></span>         * Are we currently tracking events on this element.
<span id="line4203" class="line"></span>         * @deprecated Just use this.tracking
<span id="line4204" class="line"></span>         * @function
<span id="line4205" class="line"></span>         * @returns {Boolean} Are we currently tracking events on this element.
<span id="line4206" class="line"></span>         */
<span id="line4207" class="line"></span>        isTracking: function () {
<span id="line4208" class="line"></span>            return THIS[ this.hash ].tracking;
<span id="line4209" class="line"></span>        },
<span id="line4210" class="line"></span>
<span id="line4211" class="line"></span>        /**
<span id="line4212" class="line"></span>         * Enable or disable whether or not we are tracking events on this element.
<span id="line4213" class="line"></span>         * @function
<span id="line4214" class="line"></span>         * @param {Boolean} track True to start tracking, false to stop tracking.
<span id="line4215" class="line"></span>         * @returns {OpenSeadragon.MouseTracker} Chainable.
<span id="line4216" class="line"></span>         */
<span id="line4217" class="line"></span>        setTracking: function ( track ) {
<span id="line4218" class="line"></span>            if ( track ) {
<span id="line4219" class="line"></span>                startTracking( this );
<span id="line4220" class="line"></span>            } else {
<span id="line4221" class="line"></span>                stopTracking( this );
<span id="line4222" class="line"></span>            }
<span id="line4223" class="line"></span>            //chain
<span id="line4224" class="line"></span>            return this;
<span id="line4225" class="line"></span>        },
<span id="line4226" class="line"></span>
<span id="line4227" class="line"></span>        /**
<span id="line4228" class="line"></span>         * Returns the {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} for the given pointer device type,
<span id="line4229" class="line"></span>         * creating and caching a new {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} if one doesn't already exist for the type.
<span id="line4230" class="line"></span>         * @function
<span id="line4231" class="line"></span>         * @param {String} type - The pointer device type: "mouse", "touch", "pen", etc.
<span id="line4232" class="line"></span>         * @returns {OpenSeadragon.MouseTracker.GesturePointList}
<span id="line4233" class="line"></span>         */
<span id="line4234" class="line"></span>        getActivePointersListByType: function ( type ) {
<span id="line4235" class="line"></span>            const delegate = THIS[ this.hash ];
<span id="line4236" class="line"></span>            const len = delegate ? delegate.activePointersLists.length : 0;
<span id="line4237" class="line"></span>            let list;
<span id="line4238" class="line"></span>
<span id="line4239" class="line"></span>            for ( let i = 0; i &lt; len; i++ ) {
<span id="line4240" class="line"></span>                if ( delegate.activePointersLists[ i ].type === type ) {
<span id="line4241" class="line"></span>                    return delegate.activePointersLists[ i ];
<span id="line4242" class="line"></span>                }
<span id="line4243" class="line"></span>            }
<span id="line4244" class="line"></span>
<span id="line4245" class="line"></span>            list = new $.MouseTracker.GesturePointList( type );
<span id="line4246" class="line"></span>            if(delegate){
<span id="line4247" class="line"></span>                delegate.activePointersLists.push( list );
<span id="line4248" class="line"></span>            }
<span id="line4249" class="line"></span>            return list;
<span id="line4250" class="line"></span>        },
<span id="line4251" class="line"></span>
<span id="line4252" class="line"></span>        /**
<span id="line4253" class="line"></span>         * Returns the total number of pointers currently active on the tracked element.
<span id="line4254" class="line"></span>         * @function
<span id="line4255" class="line"></span>         * @returns {Number}
<span id="line4256" class="line"></span>         */
<span id="line4257" class="line"></span>        getActivePointerCount: function () {
<span id="line4258" class="line"></span>            const delegate = THIS[ this.hash ];
<span id="line4259" class="line"></span>            const len = delegate.activePointersLists.length;
<span id="line4260" class="line"></span>            let count = 0;
<span id="line4261" class="line"></span>
<span id="line4262" class="line"></span>            for ( let i = 0; i &lt; len; i++ ) {
<span id="line4263" class="line"></span>                count += delegate.activePointersLists[ i ].getLength();
<span id="line4264" class="line"></span>            }
<span id="line4265" class="line"></span>
<span id="line4266" class="line"></span>            return count;
<span id="line4267" class="line"></span>        },
<span id="line4268" class="line"></span>
<span id="line4269" class="line"></span>        /**
<span id="line4270" class="line"></span>         * Do we currently have any assigned gesture handlers.
<span id="line4271" class="line"></span>         * @returns {Boolean} Do we currently have any assigned gesture handlers.
<span id="line4272" class="line"></span>         */
<span id="line4273" class="line"></span>        get hasGestureHandlers() {
<span id="line4274" class="line"></span>            return !!(this.pressHandler ||
<span id="line4275" class="line"></span>                      this.nonPrimaryPressHandler ||
<span id="line4276" class="line"></span>                      this.releaseHandler ||
<span id="line4277" class="line"></span>                      this.nonPrimaryReleaseHandler ||
<span id="line4278" class="line"></span>                      this.clickHandler ||
<span id="line4279" class="line"></span>                      this.dblClickHandler ||
<span id="line4280" class="line"></span>                      this.dragHandler ||
<span id="line4281" class="line"></span>                      this.dragEndHandler ||
<span id="line4282" class="line"></span>                      this.pinchHandler);
<span id="line4283" class="line"></span>        },
<span id="line4284" class="line"></span>
<span id="line4285" class="line"></span>        /**
<span id="line4286" class="line"></span>         * Do we currently have a scroll handler.
<span id="line4287" class="line"></span>         * @returns {Boolean} Do we currently have a scroll handler.
<span id="line4288" class="line"></span>         */
<span id="line4289" class="line"></span>        get hasScrollHandler() {
<span id="line4290" class="line"></span>            return !!this.scrollHandler;
<span id="line4291" class="line"></span>        },
<span id="line4292" class="line"></span>
<span id="line4293" class="line"></span>        /**
<span id="line4294" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4295" class="line"></span>         * calling the constructor.
<span id="line4296" class="line"></span>         * @function
<span id="line4297" class="line"></span>         * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
<span id="line4298" class="line"></span>         */
<span id="line4299" class="line"></span>        preProcessEventHandler: function () { },
<span id="line4300" class="line"></span>
<span id="line4301" class="line"></span>        /**
<span id="line4302" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4303" class="line"></span>         * calling the constructor.
<span id="line4304" class="line"></span>         * @function
<span id="line4305" class="line"></span>         * @param {Object} event
<span id="line4306" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4307" class="line"></span>         *      A reference to the tracker instance.
<span id="line4308" class="line"></span>         * @param {OpenSeadragon.Point} event.position
<span id="line4309" class="line"></span>         *      The position of the event relative to the tracked element.
<span id="line4310" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4311" class="line"></span>         *      The original event object.
<span id="line4312" class="line"></span>         * @param {Boolean} event.preventDefault
<span id="line4313" class="line"></span>         *      Set to true to prevent the default user-agent's handling of the contextmenu event.
<span id="line4314" class="line"></span>         * @param {Object} event.userData
<span id="line4315" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4316" class="line"></span>         */
<span id="line4317" class="line"></span>        contextMenuHandler: function () { },
<span id="line4318" class="line"></span>
<span id="line4319" class="line"></span>        /**
<span id="line4320" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4321" class="line"></span>         * calling the constructor.
<span id="line4322" class="line"></span>         * @function
<span id="line4323" class="line"></span>         * @param {Object} event
<span id="line4324" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4325" class="line"></span>         *      A reference to the tracker instance.
<span id="line4326" class="line"></span>         * @param {String} event.pointerType
<span id="line4327" class="line"></span>         *     "mouse", "touch", "pen", etc.
<span id="line4328" class="line"></span>         * @param {OpenSeadragon.Point} event.position
<span id="line4329" class="line"></span>         *      The position of the event relative to the tracked element.
<span id="line4330" class="line"></span>         * @param {Number} event.buttons
<span id="line4331" class="line"></span>         *      Current buttons pressed.
<span id="line4332" class="line"></span>         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
<span id="line4333" class="line"></span>         * @param {Number} event.pointers
<span id="line4334" class="line"></span>         *      Number of pointers (all types) active in the tracked element.
<span id="line4335" class="line"></span>         * @param {Boolean} event.insideElementPressed
<span id="line4336" class="line"></span>         *      True if the left mouse button is currently being pressed and was
<span id="line4337" class="line"></span>         *      initiated inside the tracked element, otherwise false.
<span id="line4338" class="line"></span>         * @param {Boolean} event.buttonDownAny
<span id="line4339" class="line"></span>         *      Was the button down anywhere in the screen during the event. &lt;span style="color:red;"&gt;Deprecated. Use buttons instead.&lt;/span&gt;
<span id="line4340" class="line"></span>         * @param {Boolean} event.isTouchEvent
<span id="line4341" class="line"></span>         *      True if the original event is a touch event, otherwise false. &lt;span style="color:red;"&gt;Deprecated. Use pointerType and/or originalEvent instead.&lt;/span&gt;
<span id="line4342" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4343" class="line"></span>         *      The original event object.
<span id="line4344" class="line"></span>         * @param {Object} event.userData
<span id="line4345" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4346" class="line"></span>         */
<span id="line4347" class="line"></span>        enterHandler: function () { },
<span id="line4348" class="line"></span>
<span id="line4349" class="line"></span>        /**
<span id="line4350" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4351" class="line"></span>         * calling the constructor.
<span id="line4352" class="line"></span>         * @function
<span id="line4353" class="line"></span>         * @since v2.5.0
<span id="line4354" class="line"></span>         * @param {Object} event
<span id="line4355" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4356" class="line"></span>         *      A reference to the tracker instance.
<span id="line4357" class="line"></span>         * @param {String} event.pointerType
<span id="line4358" class="line"></span>         *     "mouse", "touch", "pen", etc.
<span id="line4359" class="line"></span>         * @param {OpenSeadragon.Point} event.position
<span id="line4360" class="line"></span>         *      The position of the event relative to the tracked element.
<span id="line4361" class="line"></span>         * @param {Number} event.buttons
<span id="line4362" class="line"></span>         *      Current buttons pressed.
<span id="line4363" class="line"></span>         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
<span id="line4364" class="line"></span>         * @param {Number} event.pointers
<span id="line4365" class="line"></span>         *      Number of pointers (all types) active in the tracked element.
<span id="line4366" class="line"></span>         * @param {Boolean} event.insideElementPressed
<span id="line4367" class="line"></span>         *      True if the left mouse button is currently being pressed and was
<span id="line4368" class="line"></span>         *      initiated inside the tracked element, otherwise false.
<span id="line4369" class="line"></span>         * @param {Boolean} event.buttonDownAny
<span id="line4370" class="line"></span>         *      Was the button down anywhere in the screen during the event. &lt;span style="color:red;"&gt;Deprecated. Use buttons instead.&lt;/span&gt;
<span id="line4371" class="line"></span>         * @param {Boolean} event.isTouchEvent
<span id="line4372" class="line"></span>         *      True if the original event is a touch event, otherwise false. &lt;span style="color:red;"&gt;Deprecated. Use pointerType and/or originalEvent instead.&lt;/span&gt;
<span id="line4373" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4374" class="line"></span>         *      The original event object.
<span id="line4375" class="line"></span>         * @param {Object} event.userData
<span id="line4376" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4377" class="line"></span>         */
<span id="line4378" class="line"></span>        leaveHandler: function () { },
<span id="line4379" class="line"></span>
<span id="line4380" class="line"></span>        /**
<span id="line4381" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4382" class="line"></span>         * calling the constructor.
<span id="line4383" class="line"></span>         * @function
<span id="line4384" class="line"></span>         * @deprecated v2.5.0 Use leaveHandler instead
<span id="line4385" class="line"></span>         * @param {Object} event
<span id="line4386" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4387" class="line"></span>         *      A reference to the tracker instance.
<span id="line4388" class="line"></span>         * @param {String} event.pointerType
<span id="line4389" class="line"></span>         *     "mouse", "touch", "pen", etc.
<span id="line4390" class="line"></span>         * @param {OpenSeadragon.Point} event.position
<span id="line4391" class="line"></span>         *      The position of the event relative to the tracked element.
<span id="line4392" class="line"></span>         * @param {Number} event.buttons
<span id="line4393" class="line"></span>         *      Current buttons pressed.
<span id="line4394" class="line"></span>         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
<span id="line4395" class="line"></span>         * @param {Number} event.pointers
<span id="line4396" class="line"></span>         *      Number of pointers (all types) active in the tracked element.
<span id="line4397" class="line"></span>         * @param {Boolean} event.insideElementPressed
<span id="line4398" class="line"></span>         *      True if the left mouse button is currently being pressed and was
<span id="line4399" class="line"></span>         *      initiated inside the tracked element, otherwise false.
<span id="line4400" class="line"></span>         * @param {Boolean} event.buttonDownAny
<span id="line4401" class="line"></span>         *      Was the button down anywhere in the screen during the event. &lt;span style="color:red;"&gt;Deprecated. Use buttons instead.&lt;/span&gt;
<span id="line4402" class="line"></span>         * @param {Boolean} event.isTouchEvent
<span id="line4403" class="line"></span>         *      True if the original event is a touch event, otherwise false. &lt;span style="color:red;"&gt;Deprecated. Use pointerType and/or originalEvent instead.&lt;/span&gt;
<span id="line4404" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4405" class="line"></span>         *      The original event object.
<span id="line4406" class="line"></span>         * @param {Object} event.userData
<span id="line4407" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4408" class="line"></span>         */
<span id="line4409" class="line"></span>        exitHandler: function () { },
<span id="line4410" class="line"></span>
<span id="line4411" class="line"></span>        /**
<span id="line4412" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4413" class="line"></span>         * calling the constructor.
<span id="line4414" class="line"></span>         * @function
<span id="line4415" class="line"></span>         * @since v2.5.0
<span id="line4416" class="line"></span>         * @param {Object} event
<span id="line4417" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4418" class="line"></span>         *      A reference to the tracker instance.
<span id="line4419" class="line"></span>         * @param {String} event.pointerType
<span id="line4420" class="line"></span>         *     "mouse", "touch", "pen", etc.
<span id="line4421" class="line"></span>         * @param {OpenSeadragon.Point} event.position
<span id="line4422" class="line"></span>         *      The position of the event relative to the tracked element.
<span id="line4423" class="line"></span>         * @param {Number} event.buttons
<span id="line4424" class="line"></span>         *      Current buttons pressed.
<span id="line4425" class="line"></span>         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
<span id="line4426" class="line"></span>         * @param {Number} event.pointers
<span id="line4427" class="line"></span>         *      Number of pointers (all types) active in the tracked element.
<span id="line4428" class="line"></span>         * @param {Boolean} event.insideElementPressed
<span id="line4429" class="line"></span>         *      True if the left mouse button is currently being pressed and was
<span id="line4430" class="line"></span>         *      initiated inside the tracked element, otherwise false.
<span id="line4431" class="line"></span>         * @param {Boolean} event.buttonDownAny
<span id="line4432" class="line"></span>         *      Was the button down anywhere in the screen during the event. &lt;span style="color:red;"&gt;Deprecated. Use buttons instead.&lt;/span&gt;
<span id="line4433" class="line"></span>         * @param {Boolean} event.isTouchEvent
<span id="line4434" class="line"></span>         *      True if the original event is a touch event, otherwise false. &lt;span style="color:red;"&gt;Deprecated. Use pointerType and/or originalEvent instead.&lt;/span&gt;
<span id="line4435" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4436" class="line"></span>         *      The original event object.
<span id="line4437" class="line"></span>         * @param {Object} event.userData
<span id="line4438" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4439" class="line"></span>         */
<span id="line4440" class="line"></span>        overHandler: function () { },
<span id="line4441" class="line"></span>
<span id="line4442" class="line"></span>        /**
<span id="line4443" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4444" class="line"></span>         * calling the constructor.
<span id="line4445" class="line"></span>         * @function
<span id="line4446" class="line"></span>         * @since v2.5.0
<span id="line4447" class="line"></span>         * @param {Object} event
<span id="line4448" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4449" class="line"></span>         *      A reference to the tracker instance.
<span id="line4450" class="line"></span>         * @param {String} event.pointerType
<span id="line4451" class="line"></span>         *     "mouse", "touch", "pen", etc.
<span id="line4452" class="line"></span>         * @param {OpenSeadragon.Point} event.position
<span id="line4453" class="line"></span>         *      The position of the event relative to the tracked element.
<span id="line4454" class="line"></span>         * @param {Number} event.buttons
<span id="line4455" class="line"></span>         *      Current buttons pressed.
<span id="line4456" class="line"></span>         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
<span id="line4457" class="line"></span>         * @param {Number} event.pointers
<span id="line4458" class="line"></span>         *      Number of pointers (all types) active in the tracked element.
<span id="line4459" class="line"></span>         * @param {Boolean} event.insideElementPressed
<span id="line4460" class="line"></span>         *      True if the left mouse button is currently being pressed and was
<span id="line4461" class="line"></span>         *      initiated inside the tracked element, otherwise false.
<span id="line4462" class="line"></span>         * @param {Boolean} event.buttonDownAny
<span id="line4463" class="line"></span>         *      Was the button down anywhere in the screen during the event. &lt;span style="color:red;"&gt;Deprecated. Use buttons instead.&lt;/span&gt;
<span id="line4464" class="line"></span>         * @param {Boolean} event.isTouchEvent
<span id="line4465" class="line"></span>         *      True if the original event is a touch event, otherwise false. &lt;span style="color:red;"&gt;Deprecated. Use pointerType and/or originalEvent instead.&lt;/span&gt;
<span id="line4466" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4467" class="line"></span>         *      The original event object.
<span id="line4468" class="line"></span>         * @param {Object} event.userData
<span id="line4469" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4470" class="line"></span>         */
<span id="line4471" class="line"></span>        outHandler: function () { },
<span id="line4472" class="line"></span>
<span id="line4473" class="line"></span>        /**
<span id="line4474" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4475" class="line"></span>         * calling the constructor.
<span id="line4476" class="line"></span>         * @function
<span id="line4477" class="line"></span>         * @param {Object} event
<span id="line4478" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4479" class="line"></span>         *      A reference to the tracker instance.
<span id="line4480" class="line"></span>         * @param {String} event.pointerType
<span id="line4481" class="line"></span>         *     "mouse", "touch", "pen", etc.
<span id="line4482" class="line"></span>         * @param {OpenSeadragon.Point} event.position
<span id="line4483" class="line"></span>         *      The position of the event relative to the tracked element.
<span id="line4484" class="line"></span>         * @param {Number} event.buttons
<span id="line4485" class="line"></span>         *      Current buttons pressed.
<span id="line4486" class="line"></span>         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
<span id="line4487" class="line"></span>         * @param {Boolean} event.isTouchEvent
<span id="line4488" class="line"></span>         *      True if the original event is a touch event, otherwise false. &lt;span style="color:red;"&gt;Deprecated. Use pointerType and/or originalEvent instead.&lt;/span&gt;
<span id="line4489" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4490" class="line"></span>         *      The original event object.
<span id="line4491" class="line"></span>         * @param {Object} event.userData
<span id="line4492" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4493" class="line"></span>         */
<span id="line4494" class="line"></span>        pressHandler: function () { },
<span id="line4495" class="line"></span>
<span id="line4496" class="line"></span>        /**
<span id="line4497" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4498" class="line"></span>         * calling the constructor.
<span id="line4499" class="line"></span>         * @function
<span id="line4500" class="line"></span>         * @param {Object} event
<span id="line4501" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4502" class="line"></span>         *      A reference to the tracker instance.
<span id="line4503" class="line"></span>         * @param {String} event.pointerType
<span id="line4504" class="line"></span>         *     "mouse", "touch", "pen", etc.
<span id="line4505" class="line"></span>         * @param {OpenSeadragon.Point} event.position
<span id="line4506" class="line"></span>         *      The position of the event relative to the tracked element.
<span id="line4507" class="line"></span>         * @param {Number} event.button
<span id="line4508" class="line"></span>         *      Button which caused the event.
<span id="line4509" class="line"></span>         *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
<span id="line4510" class="line"></span>         * @param {Number} event.buttons
<span id="line4511" class="line"></span>         *      Current buttons pressed.
<span id="line4512" class="line"></span>         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
<span id="line4513" class="line"></span>         * @param {Boolean} event.isTouchEvent
<span id="line4514" class="line"></span>         *      True if the original event is a touch event, otherwise false. &lt;span style="color:red;"&gt;Deprecated. Use pointerType and/or originalEvent instead.&lt;/span&gt;
<span id="line4515" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4516" class="line"></span>         *      The original event object.
<span id="line4517" class="line"></span>         * @param {Object} event.userData
<span id="line4518" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4519" class="line"></span>         */
<span id="line4520" class="line"></span>        nonPrimaryPressHandler: function () { },
<span id="line4521" class="line"></span>
<span id="line4522" class="line"></span>        /**
<span id="line4523" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4524" class="line"></span>         * calling the constructor.
<span id="line4525" class="line"></span>         * @function
<span id="line4526" class="line"></span>         * @param {Object} event
<span id="line4527" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4528" class="line"></span>         *      A reference to the tracker instance.
<span id="line4529" class="line"></span>         * @param {String} event.pointerType
<span id="line4530" class="line"></span>         *     "mouse", "touch", "pen", etc.
<span id="line4531" class="line"></span>         * @param {OpenSeadragon.Point} event.position
<span id="line4532" class="line"></span>         *      The position of the event relative to the tracked element.
<span id="line4533" class="line"></span>         * @param {Number} event.buttons
<span id="line4534" class="line"></span>         *      Current buttons pressed.
<span id="line4535" class="line"></span>         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
<span id="line4536" class="line"></span>         * @param {Boolean} event.insideElementPressed
<span id="line4537" class="line"></span>         *      True if the left mouse button is currently being pressed and was
<span id="line4538" class="line"></span>         *      initiated inside the tracked element, otherwise false.
<span id="line4539" class="line"></span>         * @param {Boolean} event.insideElementReleased
<span id="line4540" class="line"></span>         *      True if the cursor inside the tracked element when the button was released.
<span id="line4541" class="line"></span>         * @param {Boolean} event.isTouchEvent
<span id="line4542" class="line"></span>         *      True if the original event is a touch event, otherwise false. &lt;span style="color:red;"&gt;Deprecated. Use pointerType and/or originalEvent instead.&lt;/span&gt;
<span id="line4543" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4544" class="line"></span>         *      The original event object.
<span id="line4545" class="line"></span>         * @param {Object} event.userData
<span id="line4546" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4547" class="line"></span>         */
<span id="line4548" class="line"></span>        releaseHandler: function () { },
<span id="line4549" class="line"></span>
<span id="line4550" class="line"></span>        /**
<span id="line4551" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4552" class="line"></span>         * calling the constructor.
<span id="line4553" class="line"></span>         * @function
<span id="line4554" class="line"></span>         * @param {Object} event
<span id="line4555" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4556" class="line"></span>         *      A reference to the tracker instance.
<span id="line4557" class="line"></span>         * @param {String} event.pointerType
<span id="line4558" class="line"></span>         *     "mouse", "touch", "pen", etc.
<span id="line4559" class="line"></span>         * @param {OpenSeadragon.Point} event.position
<span id="line4560" class="line"></span>         *      The position of the event relative to the tracked element.
<span id="line4561" class="line"></span>         * @param {Number} event.button
<span id="line4562" class="line"></span>         *      Button which caused the event.
<span id="line4563" class="line"></span>         *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
<span id="line4564" class="line"></span>         * @param {Number} event.buttons
<span id="line4565" class="line"></span>         *      Current buttons pressed.
<span id="line4566" class="line"></span>         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
<span id="line4567" class="line"></span>         * @param {Boolean} event.isTouchEvent
<span id="line4568" class="line"></span>         *      True if the original event is a touch event, otherwise false. &lt;span style="color:red;"&gt;Deprecated. Use pointerType and/or originalEvent instead.&lt;/span&gt;
<span id="line4569" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4570" class="line"></span>         *      The original event object.
<span id="line4571" class="line"></span>         * @param {Object} event.userData
<span id="line4572" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4573" class="line"></span>         */
<span id="line4574" class="line"></span>        nonPrimaryReleaseHandler: function () { },
<span id="line4575" class="line"></span>
<span id="line4576" class="line"></span>        /**
<span id="line4577" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4578" class="line"></span>         * calling the constructor.
<span id="line4579" class="line"></span>         * @function
<span id="line4580" class="line"></span>         * @param {Object} event
<span id="line4581" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4582" class="line"></span>         *      A reference to the tracker instance.
<span id="line4583" class="line"></span>         * @param {String} event.pointerType
<span id="line4584" class="line"></span>         *     "mouse", "touch", "pen", etc.
<span id="line4585" class="line"></span>         * @param {OpenSeadragon.Point} event.position
<span id="line4586" class="line"></span>         *      The position of the event relative to the tracked element.
<span id="line4587" class="line"></span>         * @param {Number} event.buttons
<span id="line4588" class="line"></span>         *      Current buttons pressed.
<span id="line4589" class="line"></span>         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
<span id="line4590" class="line"></span>         * @param {Boolean} event.isTouchEvent
<span id="line4591" class="line"></span>         *      True if the original event is a touch event, otherwise false. &lt;span style="color:red;"&gt;Deprecated. Use pointerType and/or originalEvent instead.&lt;/span&gt;
<span id="line4592" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4593" class="line"></span>         *      The original event object.
<span id="line4594" class="line"></span>         * @param {Object} event.userData
<span id="line4595" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4596" class="line"></span>         */
<span id="line4597" class="line"></span>        moveHandler: function () { },
<span id="line4598" class="line"></span>
<span id="line4599" class="line"></span>        /**
<span id="line4600" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4601" class="line"></span>         * calling the constructor.
<span id="line4602" class="line"></span>         * @function
<span id="line4603" class="line"></span>         * @param {Object} event
<span id="line4604" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4605" class="line"></span>         *      A reference to the tracker instance.
<span id="line4606" class="line"></span>         * @param {String} event.pointerType
<span id="line4607" class="line"></span>         *     "mouse", "touch", "pen", etc.
<span id="line4608" class="line"></span>         * @param {OpenSeadragon.Point} event.position
<span id="line4609" class="line"></span>         *      The position of the event relative to the tracked element.
<span id="line4610" class="line"></span>         * @param {Number} event.scroll
<span id="line4611" class="line"></span>         *      The scroll delta for the event.
<span id="line4612" class="line"></span>         * @param {Boolean} event.shift
<span id="line4613" class="line"></span>         *      True if the shift key was pressed during this event.
<span id="line4614" class="line"></span>         * @param {Boolean} event.isTouchEvent
<span id="line4615" class="line"></span>         *      True if the original event is a touch event, otherwise false. &lt;span style="color:red;"&gt;Deprecated. Use pointerType and/or originalEvent instead. Touch devices no longer generate scroll event.&lt;/span&gt;
<span id="line4616" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4617" class="line"></span>         *      The original event object.
<span id="line4618" class="line"></span>         * @param {Boolean} event.preventDefault
<span id="line4619" class="line"></span>         *      Set to true to prevent the default user-agent's handling of the wheel event.
<span id="line4620" class="line"></span>         * @param {Object} event.userData
<span id="line4621" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4622" class="line"></span>         */
<span id="line4623" class="line"></span>        scrollHandler: function () { },
<span id="line4624" class="line"></span>
<span id="line4625" class="line"></span>        /**
<span id="line4626" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4627" class="line"></span>         * calling the constructor.
<span id="line4628" class="line"></span>         * @function
<span id="line4629" class="line"></span>         * @param {Object} event
<span id="line4630" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4631" class="line"></span>         *      A reference to the tracker instance.
<span id="line4632" class="line"></span>         * @param {String} event.pointerType
<span id="line4633" class="line"></span>         *     "mouse", "touch", "pen", etc.
<span id="line4634" class="line"></span>         * @param {OpenSeadragon.Point} event.position
<span id="line4635" class="line"></span>         *      The position of the event relative to the tracked element.
<span id="line4636" class="line"></span>         * @param {Boolean} event.quick
<span id="line4637" class="line"></span>         *      True only if the clickDistThreshold and clickTimeThreshold are both passed. Useful for ignoring drag events.
<span id="line4638" class="line"></span>         * @param {Boolean} event.shift
<span id="line4639" class="line"></span>         *      True if the shift key was pressed during this event.
<span id="line4640" class="line"></span>         * @param {Boolean} event.isTouchEvent
<span id="line4641" class="line"></span>         *      True if the original event is a touch event, otherwise false. &lt;span style="color:red;"&gt;Deprecated. Use pointerType and/or originalEvent instead.&lt;/span&gt;
<span id="line4642" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4643" class="line"></span>         *      The original event object.
<span id="line4644" class="line"></span>         * @param {Element} event.originalTarget
<span id="line4645" class="line"></span>         *      The DOM element clicked on.
<span id="line4646" class="line"></span>         * @param {Object} event.userData
<span id="line4647" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4648" class="line"></span>         */
<span id="line4649" class="line"></span>        clickHandler: function () { },
<span id="line4650" class="line"></span>
<span id="line4651" class="line"></span>        /**
<span id="line4652" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4653" class="line"></span>         * calling the constructor.
<span id="line4654" class="line"></span>         * @function
<span id="line4655" class="line"></span>         * @param {Object} event
<span id="line4656" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4657" class="line"></span>         *      A reference to the tracker instance.
<span id="line4658" class="line"></span>         * @param {String} event.pointerType
<span id="line4659" class="line"></span>         *     "mouse", "touch", "pen", etc.
<span id="line4660" class="line"></span>         * @param {OpenSeadragon.Point} event.position
<span id="line4661" class="line"></span>         *      The position of the event relative to the tracked element.
<span id="line4662" class="line"></span>         * @param {Boolean} event.shift
<span id="line4663" class="line"></span>         *      True if the shift key was pressed during this event.
<span id="line4664" class="line"></span>         * @param {Boolean} event.isTouchEvent
<span id="line4665" class="line"></span>         *      True if the original event is a touch event, otherwise false. &lt;span style="color:red;"&gt;Deprecated. Use pointerType and/or originalEvent instead.&lt;/span&gt;
<span id="line4666" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4667" class="line"></span>         *      The original event object.
<span id="line4668" class="line"></span>         * @param {Object} event.userData
<span id="line4669" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4670" class="line"></span>         */
<span id="line4671" class="line"></span>        dblClickHandler: function () { },
<span id="line4672" class="line"></span>
<span id="line4673" class="line"></span>        /**
<span id="line4674" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4675" class="line"></span>         * calling the constructor.
<span id="line4676" class="line"></span>         * @function
<span id="line4677" class="line"></span>         * @param {Object} event
<span id="line4678" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4679" class="line"></span>         *      A reference to the tracker instance.
<span id="line4680" class="line"></span>         * @param {String} event.pointerType
<span id="line4681" class="line"></span>         *     "mouse", "touch", "pen", etc.
<span id="line4682" class="line"></span>         * @param {OpenSeadragon.Point} event.position
<span id="line4683" class="line"></span>         *      The position of the event relative to the tracked element.
<span id="line4684" class="line"></span>         * @param {Number} event.buttons
<span id="line4685" class="line"></span>         *      Current buttons pressed.
<span id="line4686" class="line"></span>         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
<span id="line4687" class="line"></span>         * @param {OpenSeadragon.Point} event.delta
<span id="line4688" class="line"></span>         *      The x,y components of the difference between the current position and the last drag event position.  Useful for ignoring or weighting the events.
<span id="line4689" class="line"></span>         * @param {Number} event.speed
<span id="line4690" class="line"></span>         *     Current computed speed, in pixels per second.
<span id="line4691" class="line"></span>         * @param {Number} event.direction
<span id="line4692" class="line"></span>         *     Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed &gt; 0.
<span id="line4693" class="line"></span>         * @param {Boolean} event.shift
<span id="line4694" class="line"></span>         *      True if the shift key was pressed during this event.
<span id="line4695" class="line"></span>         * @param {Boolean} event.isTouchEvent
<span id="line4696" class="line"></span>         *      True if the original event is a touch event, otherwise false. &lt;span style="color:red;"&gt;Deprecated. Use pointerType and/or originalEvent instead.&lt;/span&gt;
<span id="line4697" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4698" class="line"></span>         *      The original event object.
<span id="line4699" class="line"></span>         * @param {Object} event.userData
<span id="line4700" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4701" class="line"></span>         */
<span id="line4702" class="line"></span>        dragHandler: function () { },
<span id="line4703" class="line"></span>
<span id="line4704" class="line"></span>        /**
<span id="line4705" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4706" class="line"></span>         * calling the constructor.
<span id="line4707" class="line"></span>         * @function
<span id="line4708" class="line"></span>         * @param {Object} event
<span id="line4709" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4710" class="line"></span>         *      A reference to the tracker instance.
<span id="line4711" class="line"></span>         * @param {String} event.pointerType
<span id="line4712" class="line"></span>         *     "mouse", "touch", "pen", etc.
<span id="line4713" class="line"></span>         * @param {OpenSeadragon.Point} event.position
<span id="line4714" class="line"></span>         *      The position of the event relative to the tracked element.
<span id="line4715" class="line"></span>         * @param {Number} event.speed
<span id="line4716" class="line"></span>         *     Speed at the end of a drag gesture, in pixels per second.
<span id="line4717" class="line"></span>         * @param {Number} event.direction
<span id="line4718" class="line"></span>         *     Direction at the end of a drag gesture, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed &gt; 0.
<span id="line4719" class="line"></span>         * @param {Boolean} event.shift
<span id="line4720" class="line"></span>         *      True if the shift key was pressed during this event.
<span id="line4721" class="line"></span>         * @param {Boolean} event.isTouchEvent
<span id="line4722" class="line"></span>         *      True if the original event is a touch event, otherwise false. &lt;span style="color:red;"&gt;Deprecated. Use pointerType and/or originalEvent instead.&lt;/span&gt;
<span id="line4723" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4724" class="line"></span>         *      The original event object.
<span id="line4725" class="line"></span>         * @param {Object} event.userData
<span id="line4726" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4727" class="line"></span>         */
<span id="line4728" class="line"></span>        dragEndHandler: function () { },
<span id="line4729" class="line"></span>
<span id="line4730" class="line"></span>        /**
<span id="line4731" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4732" class="line"></span>         * calling the constructor.
<span id="line4733" class="line"></span>         * @function
<span id="line4734" class="line"></span>         * @param {Object} event
<span id="line4735" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4736" class="line"></span>         *      A reference to the tracker instance.
<span id="line4737" class="line"></span>         * @param {String} event.pointerType
<span id="line4738" class="line"></span>         *     "mouse", "touch", "pen", etc.
<span id="line4739" class="line"></span>         * @param {Array.&lt;OpenSeadragon.MouseTracker.GesturePoint&gt;} event.gesturePoints
<span id="line4740" class="line"></span>         *      Gesture points associated with the gesture. Velocity data can be found here.
<span id="line4741" class="line"></span>         * @param {OpenSeadragon.Point} event.lastCenter
<span id="line4742" class="line"></span>         *      The previous center point of the two pinch contact points relative to the tracked element.
<span id="line4743" class="line"></span>         * @param {OpenSeadragon.Point} event.center
<span id="line4744" class="line"></span>         *      The center point of the two pinch contact points relative to the tracked element.
<span id="line4745" class="line"></span>         * @param {Number} event.lastDistance
<span id="line4746" class="line"></span>         *      The previous distance between the two pinch contact points in CSS pixels.
<span id="line4747" class="line"></span>         * @param {Number} event.distance
<span id="line4748" class="line"></span>         *      The distance between the two pinch contact points in CSS pixels.
<span id="line4749" class="line"></span>         * @param {Boolean} event.shift
<span id="line4750" class="line"></span>         *      True if the shift key was pressed during this event.
<span id="line4751" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4752" class="line"></span>         *      The original event object.
<span id="line4753" class="line"></span>         * @param {Object} event.userData
<span id="line4754" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4755" class="line"></span>         */
<span id="line4756" class="line"></span>        pinchHandler: function () { },
<span id="line4757" class="line"></span>
<span id="line4758" class="line"></span>        /**
<span id="line4759" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4760" class="line"></span>         * calling the constructor.
<span id="line4761" class="line"></span>         * @function
<span id="line4762" class="line"></span>         * @param {Object} event
<span id="line4763" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4764" class="line"></span>         *      A reference to the tracker instance.
<span id="line4765" class="line"></span>         * @param {String} event.pointerType
<span id="line4766" class="line"></span>         *     "mouse", "touch", "pen", etc.
<span id="line4767" class="line"></span>         * @param {OpenSeadragon.Point} event.position
<span id="line4768" class="line"></span>         *      The position of the event relative to the tracked element.
<span id="line4769" class="line"></span>         * @param {Number} event.buttons
<span id="line4770" class="line"></span>         *      Current buttons pressed.
<span id="line4771" class="line"></span>         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
<span id="line4772" class="line"></span>         * @param {Boolean} event.isTouchEvent
<span id="line4773" class="line"></span>         *      True if the original event is a touch event, otherwise false. &lt;span style="color:red;"&gt;Deprecated. Use pointerType and/or originalEvent instead.&lt;/span&gt;
<span id="line4774" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4775" class="line"></span>         *      The original event object.
<span id="line4776" class="line"></span>         * @param {Object} event.userData
<span id="line4777" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4778" class="line"></span>         */
<span id="line4779" class="line"></span>        stopHandler: function () { },
<span id="line4780" class="line"></span>
<span id="line4781" class="line"></span>        /**
<span id="line4782" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4783" class="line"></span>         * calling the constructor.
<span id="line4784" class="line"></span>         * @function
<span id="line4785" class="line"></span>         * @param {Object} event
<span id="line4786" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4787" class="line"></span>         *      A reference to the tracker instance.
<span id="line4788" class="line"></span>         * @param {Number} event.keyCode
<span id="line4789" class="line"></span>         *      The key code that was pressed.
<span id="line4790" class="line"></span>         * @param {Boolean} event.ctrl
<span id="line4791" class="line"></span>         *      True if the ctrl key was pressed during this event.
<span id="line4792" class="line"></span>         * @param {Boolean} event.shift
<span id="line4793" class="line"></span>         *      True if the shift key was pressed during this event.
<span id="line4794" class="line"></span>         * @param {Boolean} event.alt
<span id="line4795" class="line"></span>         *      True if the alt key was pressed during this event.
<span id="line4796" class="line"></span>         * @param {Boolean} event.meta
<span id="line4797" class="line"></span>         *      True if the meta key was pressed during this event.
<span id="line4798" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4799" class="line"></span>         *      The original event object.
<span id="line4800" class="line"></span>         * @param {Boolean} event.preventDefault
<span id="line4801" class="line"></span>         *      Set to true to prevent the default user-agent's handling of the keydown event.
<span id="line4802" class="line"></span>         * @param {Object} event.userData
<span id="line4803" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4804" class="line"></span>         */
<span id="line4805" class="line"></span>        keyDownHandler: function () { },
<span id="line4806" class="line"></span>
<span id="line4807" class="line"></span>        /**
<span id="line4808" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4809" class="line"></span>         * calling the constructor.
<span id="line4810" class="line"></span>         * @function
<span id="line4811" class="line"></span>         * @param {Object} event
<span id="line4812" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4813" class="line"></span>         *      A reference to the tracker instance.
<span id="line4814" class="line"></span>         * @param {Number} event.keyCode
<span id="line4815" class="line"></span>         *      The key code that was pressed.
<span id="line4816" class="line"></span>         * @param {Boolean} event.ctrl
<span id="line4817" class="line"></span>         *      True if the ctrl key was pressed during this event.
<span id="line4818" class="line"></span>         * @param {Boolean} event.shift
<span id="line4819" class="line"></span>         *      True if the shift key was pressed during this event.
<span id="line4820" class="line"></span>         * @param {Boolean} event.alt
<span id="line4821" class="line"></span>         *      True if the alt key was pressed during this event.
<span id="line4822" class="line"></span>         * @param {Boolean} event.meta
<span id="line4823" class="line"></span>         *      True if the meta key was pressed during this event.
<span id="line4824" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4825" class="line"></span>         *      The original event object.
<span id="line4826" class="line"></span>         * @param {Boolean} event.preventDefault
<span id="line4827" class="line"></span>         *      Set to true to prevent the default user-agent's handling of the keyup event.
<span id="line4828" class="line"></span>         * @param {Object} event.userData
<span id="line4829" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4830" class="line"></span>         */
<span id="line4831" class="line"></span>        keyUpHandler: function () { },
<span id="line4832" class="line"></span>
<span id="line4833" class="line"></span>        /**
<span id="line4834" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4835" class="line"></span>         * calling the constructor.
<span id="line4836" class="line"></span>         * @function
<span id="line4837" class="line"></span>         * @param {Object} event
<span id="line4838" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4839" class="line"></span>         *      A reference to the tracker instance.
<span id="line4840" class="line"></span>         * @param {Number} event.keyCode
<span id="line4841" class="line"></span>         *      The key code that was pressed.
<span id="line4842" class="line"></span>         * @param {Boolean} event.ctrl
<span id="line4843" class="line"></span>         *      True if the ctrl key was pressed during this event.
<span id="line4844" class="line"></span>         * @param {Boolean} event.shift
<span id="line4845" class="line"></span>         *      True if the shift key was pressed during this event.
<span id="line4846" class="line"></span>         * @param {Boolean} event.alt
<span id="line4847" class="line"></span>         *      True if the alt key was pressed during this event.
<span id="line4848" class="line"></span>         * @param {Boolean} event.meta
<span id="line4849" class="line"></span>         *      True if the meta key was pressed during this event.
<span id="line4850" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4851" class="line"></span>         *      The original event object.
<span id="line4852" class="line"></span>         * @param {Boolean} event.preventDefault
<span id="line4853" class="line"></span>         *      Set to true to prevent the default user-agent's handling of the keypress event.
<span id="line4854" class="line"></span>         * @param {Object} event.userData
<span id="line4855" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4856" class="line"></span>         */
<span id="line4857" class="line"></span>        keyHandler: function () { },
<span id="line4858" class="line"></span>
<span id="line4859" class="line"></span>        /**
<span id="line4860" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4861" class="line"></span>         * calling the constructor.
<span id="line4862" class="line"></span>         * @function
<span id="line4863" class="line"></span>         * @param {Object} event
<span id="line4864" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4865" class="line"></span>         *      A reference to the tracker instance.
<span id="line4866" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4867" class="line"></span>         *      The original event object.
<span id="line4868" class="line"></span>         * @param {Object} event.userData
<span id="line4869" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4870" class="line"></span>         */
<span id="line4871" class="line"></span>        focusHandler: function () { },
<span id="line4872" class="line"></span>
<span id="line4873" class="line"></span>        /**
<span id="line4874" class="line"></span>         * Implement or assign implementation to these handlers during or after
<span id="line4875" class="line"></span>         * calling the constructor.
<span id="line4876" class="line"></span>         * @function
<span id="line4877" class="line"></span>         * @param {Object} event
<span id="line4878" class="line"></span>         * @param {OpenSeadragon.MouseTracker} event.eventSource
<span id="line4879" class="line"></span>         *      A reference to the tracker instance.
<span id="line4880" class="line"></span>         * @param {Object} event.originalEvent
<span id="line4881" class="line"></span>         *      The original event object.
<span id="line4882" class="line"></span>         * @param {Object} event.userData
<span id="line4883" class="line"></span>         *      Arbitrary user-defined object.
<span id="line4884" class="line"></span>         */
<span id="line4885" class="line"></span>        blurHandler: function () { }
<span id="line4886" class="line"></span>    };
<span id="line4887" class="line"></span>
<span id="line4888" class="line"></span>    // https://github.com/openseadragon/openseadragon/pull/790
<span id="line4889" class="line"></span>    /**
<span id="line4890" class="line"></span>     * True if inside an iframe, otherwise false.
<span id="line4891" class="line"></span>     * @member {Boolean} isInIframe
<span id="line4892" class="line"></span>     * @private
<span id="line4893" class="line"></span>     * @inner
<span id="line4894" class="line"></span>     */
<span id="line4895" class="line"></span>    const isInIframe = (function() {
<span id="line4896" class="line"></span>        try {
<span id="line4897" class="line"></span>            return window.self !== window.top;
<span id="line4898" class="line"></span>        } catch (e) {
<span id="line4899" class="line"></span>            return true;
<span id="line4900" class="line"></span>        }
<span id="line4901" class="line"></span>    })();
<span id="line4902" class="line"></span>
<span id="line4903" class="line"></span>    // https://github.com/openseadragon/openseadragon/pull/790
<span id="line4904" class="line"></span>    /**
<span id="line4905" class="line"></span>     * @function
<span id="line4906" class="line"></span>     * @private
<span id="line4907" class="line"></span>     * @inner
<span id="line4908" class="line"></span>     * @returns {Boolean} True if the target supports DOM Level 2 event subscription methods, otherwise false.
<span id="line4909" class="line"></span>     */
<span id="line4910" class="line"></span>    function canAccessEvents (target) {
<span id="line4911" class="line"></span>        try {
<span id="line4912" class="line"></span>            return target.addEventListener &amp;&amp; target.removeEventListener;
<span id="line4913" class="line"></span>        } catch (e) {
<span id="line4914" class="line"></span>            return false;
<span id="line4915" class="line"></span>        }
<span id="line4916" class="line"></span>    }
<span id="line4917" class="line"></span>
<span id="line4918" class="line"></span>    /**
<span id="line4919" class="line"></span>     * Provides continuous computation of velocity (speed and direction) of active pointers.
<span id="line4920" class="line"></span>     * This is a singleton, used by all MouseTracker instances, as it is unlikely there will ever be more than
<span id="line4921" class="line"></span>     * two active gesture pointers at a time.
<span id="line4922" class="line"></span>     *
<span id="line4923" class="line"></span>     * @private
<span id="line4924" class="line"></span>     * @member gesturePointVelocityTracker
<span id="line4925" class="line"></span>     * @memberof OpenSeadragon.MouseTracker
<span id="line4926" class="line"></span>     */
<span id="line4927" class="line"></span>    $.MouseTracker.gesturePointVelocityTracker = (function () {
<span id="line4928" class="line"></span>        const trackerPoints = [];
<span id="line4929" class="line"></span>        let intervalId = 0;
<span id="line4930" class="line"></span>        let lastTime = 0;
<span id="line4931" class="line"></span>
<span id="line4932" class="line"></span>        // Generates a unique identifier for a tracked gesture point
<span id="line4933" class="line"></span>        const _generateGuid = function ( tracker, gPoint ) {
<span id="line4934" class="line"></span>            return tracker.hash.toString() + gPoint.type + gPoint.id.toString();
<span id="line4935" class="line"></span>        };
<span id="line4936" class="line"></span>
<span id="line4937" class="line"></span>        // Interval timer callback. Computes velocity for all tracked gesture points.
<span id="line4938" class="line"></span>        const _doTracking = function () {
<span id="line4939" class="line"></span>            const len = trackerPoints.length;
<span id="line4940" class="line"></span>            const now = $.now();
<span id="line4941" class="line"></span>            let distance;
<span id="line4942" class="line"></span>            let speed;
<span id="line4943" class="line"></span>
<span id="line4944" class="line"></span>            const elapsedTime = now - lastTime;
<span id="line4945" class="line"></span>            lastTime = now;
<span id="line4946" class="line"></span>
<span id="line4947" class="line"></span>            for ( let i = 0; i &lt; len; i++ ) {
<span id="line4948" class="line"></span>                const trackPoint = trackerPoints[ i ];
<span id="line4949" class="line"></span>                const gPoint = trackPoint.gPoint;
<span id="line4950" class="line"></span>                // Math.atan2 gives us just what we need for a velocity vector, as we can simply
<span id="line4951" class="line"></span>                //   use cos()/sin() to extract the x/y velocity components.
<span id="line4952" class="line"></span>                gPoint.direction = Math.atan2( gPoint.currentPos.y - trackPoint.lastPos.y, gPoint.currentPos.x - trackPoint.lastPos.x );
<span id="line4953" class="line"></span>                // speed = distance / elapsed time
<span id="line4954" class="line"></span>                distance = trackPoint.lastPos.distanceTo( gPoint.currentPos );
<span id="line4955" class="line"></span>                trackPoint.lastPos = gPoint.currentPos;
<span id="line4956" class="line"></span>                speed = 1000 * distance / ( elapsedTime + 1 );
<span id="line4957" class="line"></span>                // Simple biased average, favors the most recent speed computation. Smooths out erratic gestures a bit.
<span id="line4958" class="line"></span>                gPoint.speed = 0.75 * speed + 0.25 * gPoint.speed;
<span id="line4959" class="line"></span>            }
<span id="line4960" class="line"></span>        };
<span id="line4961" class="line"></span>
<span id="line4962" class="line"></span>        // Public. Add a gesture point to be tracked
<span id="line4963" class="line"></span>        const addPoint = function ( tracker, gPoint ) {
<span id="line4964" class="line"></span>            const guid = _generateGuid( tracker, gPoint );
<span id="line4965" class="line"></span>
<span id="line4966" class="line"></span>            trackerPoints.push(
<span id="line4967" class="line"></span>                {
<span id="line4968" class="line"></span>                    guid: guid,
<span id="line4969" class="line"></span>                    gPoint: gPoint,
<span id="line4970" class="line"></span>                    lastPos: gPoint.currentPos
<span id="line4971" class="line"></span>                } );
<span id="line4972" class="line"></span>
<span id="line4973" class="line"></span>            // Only fire up the interval timer when there's gesture pointers to track
<span id="line4974" class="line"></span>            if ( trackerPoints.length === 1 ) {
<span id="line4975" class="line"></span>                lastTime = $.now();
<span id="line4976" class="line"></span>                intervalId = window.setInterval( _doTracking, 50 );
<span id="line4977" class="line"></span>            }
<span id="line4978" class="line"></span>        };
<span id="line4979" class="line"></span>
<span id="line4980" class="line"></span>        // Public. Stop tracking a gesture point
<span id="line4981" class="line"></span>        const removePoint = function ( tracker, gPoint ) {
<span id="line4982" class="line"></span>            const guid = _generateGuid( tracker, gPoint );
<span id="line4983" class="line"></span>            let len = trackerPoints.length;
<span id="line4984" class="line"></span>
<span id="line4985" class="line"></span>            for ( let i = 0; i &lt; len; i++ ) {
<span id="line4986" class="line"></span>                if ( trackerPoints[ i ].guid === guid ) {
<span id="line4987" class="line"></span>                    trackerPoints.splice( i, 1 );
<span id="line4988" class="line"></span>                    // Only run the interval timer if theres gesture pointers to track
<span id="line4989" class="line"></span>                    len--;
<span id="line4990" class="line"></span>                    if ( len === 0 ) {
<span id="line4991" class="line"></span>                        window.clearInterval( intervalId );
<span id="line4992" class="line"></span>                    }
<span id="line4993" class="line"></span>                    break;
<span id="line4994" class="line"></span>                }
<span id="line4995" class="line"></span>            }
<span id="line4996" class="line"></span>        };
<span id="line4997" class="line"></span>
<span id="line4998" class="line"></span>        return {
<span id="line4999" class="line"></span>            addPoint:    addPoint,
<span id="line5000" class="line"></span>            removePoint: removePoint
<span id="line5001" class="line"></span>        };
<span id="line5002" class="line"></span>    } )();
<span id="line5003" class="line"></span>
<span id="line5004" class="line"></span>
<span id="line5005" class="line"></span>///////////////////////////////////////////////////////////////////////////////
<span id="line5006" class="line"></span>// Pointer event model and feature detection
<span id="line5007" class="line"></span>///////////////////////////////////////////////////////////////////////////////
<span id="line5008" class="line"></span>
<span id="line5009" class="line"></span>    $.MouseTracker.captureElement = document;
<span id="line5010" class="line"></span>
<span id="line5011" class="line"></span>    /**
<span id="line5012" class="line"></span>     * Detect available mouse wheel event name.
<span id="line5013" class="line"></span>     */
<span id="line5014" class="line"></span>    $.MouseTracker.wheelEventName = ( 'onwheel' in document.createElement( 'div' ) ) ? 'wheel' : // Modern browsers support 'wheel'
<span id="line5015" class="line"></span>                                    document.onmousewheel !== undefined ? 'mousewheel' :         // Webkit (and unsupported IE) support at least 'mousewheel'
<span id="line5016" class="line"></span>                                    'DOMMouseScroll';                                            // Assume old Firefox (deprecated)
<span id="line5017" class="line"></span>
<span id="line5018" class="line"></span>    /**
<span id="line5019" class="line"></span>     * Detect browser pointer device event model(s) and build appropriate list of events to subscribe to.
<span id="line5020" class="line"></span>     */
<span id="line5021" class="line"></span>    $.MouseTracker.subscribeEvents = [ "click", "dblclick", "keydown", "keyup", "keypress", "focus", "blur", "contextmenu", $.MouseTracker.wheelEventName ];
<span id="line5022" class="line"></span>
<span id="line5023" class="line"></span>    if( $.MouseTracker.wheelEventName === "DOMMouseScroll" ) {
<span id="line5024" class="line"></span>        // Older Firefox
<span id="line5025" class="line"></span>        $.MouseTracker.subscribeEvents.push( "MozMousePixelScroll" );
<span id="line5026" class="line"></span>    }
<span id="line5027" class="line"></span>
<span id="line5028" class="line"></span>    if ( window.PointerEvent ) {
<span id="line5029" class="line"></span>        // W3C Pointer Event implementations (see http://www.w3.org/TR/pointerevents)
<span id="line5030" class="line"></span>        $.MouseTracker.havePointerEvents = true;
<span id="line5031" class="line"></span>        $.MouseTracker.subscribeEvents.push( "pointerenter", "pointerleave", "pointerover", "pointerout", "pointerdown", "pointerup", "pointermove", "pointercancel" );
<span id="line5032" class="line"></span>        // Pointer events capture support
<span id="line5033" class="line"></span>        $.MouseTracker.havePointerCapture = (function () {
<span id="line5034" class="line"></span>            const divElement = document.createElement( 'div' );
<span id="line5035" class="line"></span>            return $.isFunction( divElement.setPointerCapture ) &amp;&amp; $.isFunction( divElement.releasePointerCapture );
<span id="line5036" class="line"></span>        }());
<span id="line5037" class="line"></span>        if ( $.MouseTracker.havePointerCapture ) {
<span id="line5038" class="line"></span>            $.MouseTracker.subscribeEvents.push( "gotpointercapture", "lostpointercapture" );
<span id="line5039" class="line"></span>        }
<span id="line5040" class="line"></span>    } else {
<span id="line5041" class="line"></span>        // Legacy W3C mouse events
<span id="line5042" class="line"></span>        $.MouseTracker.havePointerEvents = false;
<span id="line5043" class="line"></span>        $.MouseTracker.subscribeEvents.push( "mouseenter", "mouseleave", "mouseover", "mouseout", "mousedown", "mouseup", "mousemove" );
<span id="line5044" class="line"></span>        $.MouseTracker.mousePointerId = "legacy-mouse";
<span id="line5045" class="line"></span>        // Legacy mouse events capture support (IE/Firefox only?)
<span id="line5046" class="line"></span>        $.MouseTracker.havePointerCapture = (function () {
<span id="line5047" class="line"></span>            const divElement = document.createElement( 'div' );
<span id="line5048" class="line"></span>            return $.isFunction( divElement.setCapture ) &amp;&amp; $.isFunction( divElement.releaseCapture );
<span id="line5049" class="line"></span>        }());
<span id="line5050" class="line"></span>        if ( $.MouseTracker.havePointerCapture ) {
<span id="line5051" class="line"></span>            $.MouseTracker.subscribeEvents.push( "losecapture" );
<span id="line5052" class="line"></span>        }
<span id="line5053" class="line"></span>        // Legacy touch events
<span id="line5054" class="line"></span>        if ( 'ontouchstart' in window ) {
<span id="line5055" class="line"></span>            // iOS, Android, and other W3c Touch Event implementations
<span id="line5056" class="line"></span>            //    (see http://www.w3.org/TR/touch-events/)
<span id="line5057" class="line"></span>            //    (see https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html)
<span id="line5058" class="line"></span>            //    (see https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html)
<span id="line5059" class="line"></span>            $.MouseTracker.subscribeEvents.push( "touchstart", "touchend", "touchmove", "touchcancel" );
<span id="line5060" class="line"></span>        }
<span id="line5061" class="line"></span>        if ( 'ongesturestart' in window ) {
<span id="line5062" class="line"></span>            // iOS (see https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html)
<span id="line5063" class="line"></span>            //   Subscribe to these to prevent default gesture handling
<span id="line5064" class="line"></span>            $.MouseTracker.subscribeEvents.push( "gesturestart", "gesturechange" );
<span id="line5065" class="line"></span>        }
<span id="line5066" class="line"></span>    }
<span id="line5067" class="line"></span>
<span id="line5068" class="line"></span>
<span id="line5069" class="line"></span>///////////////////////////////////////////////////////////////////////////////
<span id="line5070" class="line"></span>// Classes and typedefs
<span id="line5071" class="line"></span>///////////////////////////////////////////////////////////////////////////////
<span id="line5072" class="line"></span>
<span id="line5073" class="line"></span>    /**
<span id="line5074" class="line"></span>     * Used for the processing/disposition of DOM events (propagation, default handling, capture, etc.)
<span id="line5075" class="line"></span>     *
<span id="line5076" class="line"></span>     * @typedef {Object} EventProcessInfo
<span id="line5077" class="line"></span>     * @memberof OpenSeadragon.MouseTracker
<span id="line5078" class="line"></span>     * @since v2.5.0
<span id="line5079" class="line"></span>     *
<span id="line5080" class="line"></span>     * @property {OpenSeadragon.MouseTracker} eventSource
<span id="line5081" class="line"></span>     *      A reference to the tracker instance.
<span id="line5082" class="line"></span>     * @property {Object} originalEvent
<span id="line5083" class="line"></span>     *      The original DOM event object.
<span id="line5084" class="line"></span>     * @property {Number} eventPhase
<span id="line5085" class="line"></span>     *      0 == NONE, 1 == CAPTURING_PHASE, 2 == AT_TARGET, 3 == BUBBLING_PHASE.
<span id="line5086" class="line"></span>     * @property {String} eventType
<span id="line5087" class="line"></span>     *     "keydown", "keyup", "keypress", "focus", "blur", "contextmenu", "gotpointercapture", "lostpointercapture", "pointerenter", "pointerleave", "pointerover", "pointerout", "pointerdown", "pointerup", "pointermove", "pointercancel", "wheel", "click", "dblclick".
<span id="line5088" class="line"></span>     * @property {String} pointerType
<span id="line5089" class="line"></span>     *     "mouse", "touch", "pen", etc.
<span id="line5090" class="line"></span>     * @property {Boolean} isEmulated
<span id="line5091" class="line"></span>     *      True if this is an emulated event. If true, originalEvent is either the event that caused
<span id="line5092" class="line"></span>     *      the emulated event, a synthetic event object created with values from the actual DOM event,
<span id="line5093" class="line"></span>     *      or null if no DOM event applies. Emulated events can occur on eventType "wheel" on legacy mouse-scroll
<span id="line5094" class="line"></span>     *      event emitting user agents.
<span id="line5095" class="line"></span>     * @property {Boolean} isStoppable
<span id="line5096" class="line"></span>     *      True if propagation of the event (e.g. bubbling) can be stopped with stopPropagation/stopImmediatePropagation.
<span id="line5097" class="line"></span>     * @property {Boolean} isCancelable
<span id="line5098" class="line"></span>     *      True if the event's default handling by the browser can be prevented with preventDefault.
<span id="line5099" class="line"></span>     * @property {Boolean} defaultPrevented
<span id="line5100" class="line"></span>     *      True if the event's default handling has already been prevented by a descendent element.
<span id="line5101" class="line"></span>     * @property {Boolean} preventDefault
<span id="line5102" class="line"></span>     *      Set to true to prevent the event's default handling by the browser.
<span id="line5103" class="line"></span>     * @property {Boolean} preventGesture
<span id="line5104" class="line"></span>     *      Set to true to prevent this MouseTracker from generating a gesture from the event.
<span id="line5105" class="line"></span>     *      Valid on eventType "pointerdown".
<span id="line5106" class="line"></span>     * @property {Boolean} stopPropagation
<span id="line5107" class="line"></span>     *      Set to true prevent the event from propagating to ancestor/descendent elements on capture/bubble phase.
<span id="line5108" class="line"></span>     * @property {Boolean} shouldCapture
<span id="line5109" class="line"></span>     *      (Internal Use) Set to true if the pointer should be captured (events (re)targeted to tracker element).
<span id="line5110" class="line"></span>     * @property {Boolean} shouldReleaseCapture
<span id="line5111" class="line"></span>     *      (Internal Use) Set to true if the captured pointer should be released.
<span id="line5112" class="line"></span>     * @property {Object} userData
<span id="line5113" class="line"></span>     *      Arbitrary user-defined object.
<span id="line5114" class="line"></span>     */
<span id="line5115" class="line"></span>
<span id="line5116" class="line"></span>
<span id="line5117" class="line"></span>    /**
<span id="line5118" class="line"></span>     * Represents a point of contact on the screen made by a mouse cursor, pen, touch, or other pointer device.
<span id="line5119" class="line"></span>     *
<span id="line5120" class="line"></span>     * @typedef {Object} GesturePoint
<span id="line5121" class="line"></span>     * @memberof OpenSeadragon.MouseTracker
<span id="line5122" class="line"></span>     *
<span id="line5123" class="line"></span>     * @property {Number} id
<span id="line5124" class="line"></span>     *     Identifier unique from all other active GesturePoints for a given pointer device.
<span id="line5125" class="line"></span>     * @property {String} type
<span id="line5126" class="line"></span>     *     The pointer device type: "mouse", "touch", "pen", etc.
<span id="line5127" class="line"></span>     * @property {Boolean} captured
<span id="line5128" class="line"></span>     *     True if events for the gesture point are captured to the tracked element.
<span id="line5129" class="line"></span>     * @property {Boolean} isPrimary
<span id="line5130" class="line"></span>     *     True if the gesture point is a master pointer amongst the set of active pointers for each pointer type. True for mouse and primary (first) touch/pen pointers.
<span id="line5131" class="line"></span>     * @property {Boolean} insideElementPressed
<span id="line5132" class="line"></span>     *     True if button pressed or contact point initiated inside the screen area of the tracked element.
<span id="line5133" class="line"></span>     * @property {Boolean} insideElement
<span id="line5134" class="line"></span>     *     True if pointer or contact point is currently inside the bounds of the tracked element.
<span id="line5135" class="line"></span>     * @property {Number} speed
<span id="line5136" class="line"></span>     *     Current computed speed, in pixels per second.
<span id="line5137" class="line"></span>     * @property {Number} direction
<span id="line5138" class="line"></span>     *     Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed &gt; 0.
<span id="line5139" class="line"></span>     * @property {OpenSeadragon.Point} contactPos
<span id="line5140" class="line"></span>     *     The initial pointer contact position, relative to the page including any scrolling. Only valid if the pointer has contact (pressed, touch contact, pen contact).
<span id="line5141" class="line"></span>     * @property {Number} contactTime
<span id="line5142" class="line"></span>     *     The initial pointer contact time, in milliseconds. Only valid if the pointer has contact (pressed, touch contact, pen contact).
<span id="line5143" class="line"></span>     * @property {OpenSeadragon.Point} lastPos
<span id="line5144" class="line"></span>     *     The last pointer position, relative to the page including any scrolling.
<span id="line5145" class="line"></span>     * @property {Number} lastTime
<span id="line5146" class="line"></span>     *     The last pointer contact time, in milliseconds.
<span id="line5147" class="line"></span>     * @property {OpenSeadragon.Point} currentPos
<span id="line5148" class="line"></span>     *     The current pointer position, relative to the page including any scrolling.
<span id="line5149" class="line"></span>     * @property {Number} currentTime
<span id="line5150" class="line"></span>     *     The current pointer contact time, in milliseconds.
<span id="line5151" class="line"></span>     */
<span id="line5152" class="line"></span>
<span id="line5153" class="line"></span>
<span id="line5154" class="line"></span>    /**
<span id="line5155" class="line"></span>     * @class GesturePointList
<span id="line5156" class="line"></span>     * @classdesc Provides an abstraction for a set of active {@link OpenSeadragon.MouseTracker.GesturePoint|GesturePoint} objects for a given pointer device type.
<span id="line5157" class="line"></span>     *            Active pointers are any pointer being tracked for this element which are in the hit-test area
<span id="line5158" class="line"></span>     *            of the element (for hover-capable devices) and/or have contact or a button press initiated in the element.
<span id="line5159" class="line"></span>     * @memberof OpenSeadragon.MouseTracker
<span id="line5160" class="line"></span>     * @param {String} type - The pointer device type: "mouse", "touch", "pen", etc.
<span id="line5161" class="line"></span>     */
<span id="line5162" class="line"></span>    $.MouseTracker.GesturePointList = function ( type ) {
<span id="line5163" class="line"></span>        this._gPoints = [];
<span id="line5164" class="line"></span>        /**
<span id="line5165" class="line"></span>         * The pointer device type: "mouse", "touch", "pen", etc.
<span id="line5166" class="line"></span>         * @member {String} type
<span id="line5167" class="line"></span>         * @memberof OpenSeadragon.MouseTracker.GesturePointList#
<span id="line5168" class="line"></span>         */
<span id="line5169" class="line"></span>        this.type = type;
<span id="line5170" class="line"></span>        /**
<span id="line5171" class="line"></span>         * Current buttons pressed for the device.
<span id="line5172" class="line"></span>         * Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
<span id="line5173" class="line"></span>         * @member {Number} buttons
<span id="line5174" class="line"></span>         * @memberof OpenSeadragon.MouseTracker.GesturePointList#
<span id="line5175" class="line"></span>         */
<span id="line5176" class="line"></span>        this.buttons = 0;
<span id="line5177" class="line"></span>        /**
<span id="line5178" class="line"></span>         * Current number of contact points (touch points, mouse down, etc.) for the device.
<span id="line5179" class="line"></span>         * @member {Number} contacts
<span id="line5180" class="line"></span>         * @memberof OpenSeadragon.MouseTracker.GesturePointList#
<span id="line5181" class="line"></span>         */
<span id="line5182" class="line"></span>        this.contacts = 0;
<span id="line5183" class="line"></span>        /**
<span id="line5184" class="line"></span>         * Current number of clicks for the device. Used for multiple click gesture tracking.
<span id="line5185" class="line"></span>         * @member {Number} clicks
<span id="line5186" class="line"></span>         * @memberof OpenSeadragon.MouseTracker.GesturePointList#
<span id="line5187" class="line"></span>         */
<span id="line5188" class="line"></span>        this.clicks = 0;
<span id="line5189" class="line"></span>        /**
<span id="line5190" class="line"></span>         * Current number of captured pointers for the device.
<span id="line5191" class="line"></span>         * @member {Number} captureCount
<span id="line5192" class="line"></span>         * @memberof OpenSeadragon.MouseTracker.GesturePointList#
<span id="line5193" class="line"></span>         */
<span id="line5194" class="line"></span>        this.captureCount = 0;
<span id="line5195" class="line"></span>    };
<span id="line5196" class="line"></span>
<span id="line5197" class="line"></span>    /** @lends OpenSeadragon.MouseTracker.GesturePointList.prototype */
<span id="line5198" class="line"></span>    $.MouseTracker.GesturePointList.prototype = {
<span id="line5199" class="line"></span>        /**
<span id="line5200" class="line"></span>         * @function
<span id="line5201" class="line"></span>         * @returns {Number} Number of gesture points in the list.
<span id="line5202" class="line"></span>         */
<span id="line5203" class="line"></span>        getLength: function () {
<span id="line5204" class="line"></span>            return this._gPoints.length;
<span id="line5205" class="line"></span>        },
<span id="line5206" class="line"></span>        /**
<span id="line5207" class="line"></span>         * @function
<span id="line5208" class="line"></span>         * @returns {Array.&lt;OpenSeadragon.MouseTracker.GesturePoint&gt;} The list of gesture points in the list as an array (read-only).
<span id="line5209" class="line"></span>         */
<span id="line5210" class="line"></span>        asArray: function () {
<span id="line5211" class="line"></span>            return this._gPoints;
<span id="line5212" class="line"></span>        },
<span id="line5213" class="line"></span>        /**
<span id="line5214" class="line"></span>         * @function
<span id="line5215" class="line"></span>         * @param {OpenSeadragon.MouseTracker.GesturePoint} gesturePoint - A gesture point to add to the list.
<span id="line5216" class="line"></span>         * @returns {Number} Number of gesture points in the list.
<span id="line5217" class="line"></span>         */
<span id="line5218" class="line"></span>        add: function ( gp ) {
<span id="line5219" class="line"></span>            return this._gPoints.push( gp );
<span id="line5220" class="line"></span>        },
<span id="line5221" class="line"></span>        /**
<span id="line5222" class="line"></span>         * @function
<span id="line5223" class="line"></span>         * @param {Number} id - The id of the gesture point to remove from the list.
<span id="line5224" class="line"></span>         * @returns {Number} Number of gesture points in the list.
<span id="line5225" class="line"></span>         */
<span id="line5226" class="line"></span>        removeById: function ( id ) {
<span id="line5227" class="line"></span>            const len = this._gPoints.length;
<span id="line5228" class="line"></span>            for ( let i = 0; i &lt; len; i++ ) {
<span id="line5229" class="line"></span>                if ( this._gPoints[ i ].id === id ) {
<span id="line5230" class="line"></span>                    this._gPoints.splice( i, 1 );
<span id="line5231" class="line"></span>                    break;
<span id="line5232" class="line"></span>                }
<span id="line5233" class="line"></span>            }
<span id="line5234" class="line"></span>            return this._gPoints.length;
<span id="line5235" class="line"></span>        },
<span id="line5236" class="line"></span>        /**
<span id="line5237" class="line"></span>         * @function
<span id="line5238" class="line"></span>         * @param {Number} index - The index of the gesture point to retrieve from the list.
<span id="line5239" class="line"></span>         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point at the given index, or null if not found.
<span id="line5240" class="line"></span>         */
<span id="line5241" class="line"></span>        getByIndex: function ( index ) {
<span id="line5242" class="line"></span>            if ( index &lt; this._gPoints.length) {
<span id="line5243" class="line"></span>                return this._gPoints[ index ];
<span id="line5244" class="line"></span>            }
<span id="line5245" class="line"></span>
<span id="line5246" class="line"></span>            return null;
<span id="line5247" class="line"></span>        },
<span id="line5248" class="line"></span>        /**
<span id="line5249" class="line"></span>         * @function
<span id="line5250" class="line"></span>         * @param {Number} id - The id of the gesture point to retrieve from the list.
<span id="line5251" class="line"></span>         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point with the given id, or null if not found.
<span id="line5252" class="line"></span>         */
<span id="line5253" class="line"></span>        getById: function ( id ) {
<span id="line5254" class="line"></span>            const len = this._gPoints.length;
<span id="line5255" class="line"></span>            for ( let i = 0; i &lt; len; i++ ) {
<span id="line5256" class="line"></span>                if ( this._gPoints[ i ].id === id ) {
<span id="line5257" class="line"></span>                    return this._gPoints[ i ];
<span id="line5258" class="line"></span>                }
<span id="line5259" class="line"></span>            }
<span id="line5260" class="line"></span>            return null;
<span id="line5261" class="line"></span>        },
<span id="line5262" class="line"></span>        /**
<span id="line5263" class="line"></span>         * @function
<span id="line5264" class="line"></span>         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The primary gesture point in the list, or null if not found.
<span id="line5265" class="line"></span>         */
<span id="line5266" class="line"></span>        getPrimary: function ( id ) {
<span id="line5267" class="line"></span>            const len = this._gPoints.length;
<span id="line5268" class="line"></span>            for ( let i = 0; i &lt; len; i++ ) {
<span id="line5269" class="line"></span>                if ( this._gPoints[ i ].isPrimary ) {
<span id="line5270" class="line"></span>                    return this._gPoints[ i ];
<span id="line5271" class="line"></span>                }
<span id="line5272" class="line"></span>            }
<span id="line5273" class="line"></span>            return null;
<span id="line5274" class="line"></span>        },
<span id="line5275" class="line"></span>
<span id="line5276" class="line"></span>        /**
<span id="line5277" class="line"></span>         * Increment this pointer list's contact count.
<span id="line5278" class="line"></span>         * It will evaluate whether this pointer type is allowed to have multiple contacts.
<span id="line5279" class="line"></span>         * @function
<span id="line5280" class="line"></span>         */
<span id="line5281" class="line"></span>        addContact: function() {
<span id="line5282" class="line"></span>            ++this.contacts;
<span id="line5283" class="line"></span>
<span id="line5284" class="line"></span>            if (this.contacts &gt; 1 &amp;&amp; (this.type === "mouse" || this.type === "pen")) {
<span id="line5285" class="line"></span>                $.console.warn('GesturePointList.addContact() Implausible contacts value');
<span id="line5286" class="line"></span>                this.contacts = 1;
<span id="line5287" class="line"></span>            }
<span id="line5288" class="line"></span>        },
<span id="line5289" class="line"></span>
<span id="line5290" class="line"></span>        /**
<span id="line5291" class="line"></span>         * Decrement this pointer list's contact count.
<span id="line5292" class="line"></span>         * It will make sure the count does not go below 0.
<span id="line5293" class="line"></span>         * @function
<span id="line5294" class="line"></span>         */
<span id="line5295" class="line"></span>        removeContact: function() {
<span id="line5296" class="line"></span>            --this.contacts;
<span id="line5297" class="line"></span>
<span id="line5298" class="line"></span>            if (this.contacts &lt; 0) {
<span id="line5299" class="line"></span>                this.contacts = 0;
<span id="line5300" class="line"></span>            }
<span id="line5301" class="line"></span>        }
<span id="line5302" class="line"></span>    };
<span id="line5303" class="line"></span>
<span id="line5304" class="line"></span>
<span id="line5305" class="line"></span>///////////////////////////////////////////////////////////////////////////////
<span id="line5306" class="line"></span>// Utility functions
<span id="line5307" class="line"></span>///////////////////////////////////////////////////////////////////////////////
<span id="line5308" class="line"></span>
<span id="line5309" class="line"></span>    /**
<span id="line5310" class="line"></span>     * Removes all tracked pointers.
<span id="line5311" class="line"></span>     * @private
<span id="line5312" class="line"></span>     * @inner
<span id="line5313" class="line"></span>     */
<span id="line5314" class="line"></span>    function clearTrackedPointers( tracker ) {
<span id="line5315" class="line"></span>        const delegate = THIS[ tracker.hash ];
<span id="line5316" class="line"></span>        const pointerListCount = delegate.activePointersLists.length;
<span id="line5317" class="line"></span>
<span id="line5318" class="line"></span>        for ( let i = 0; i &lt; pointerListCount; i++ ) {
<span id="line5319" class="line"></span>            const pointsList = delegate.activePointersLists[ i ];
<span id="line5320" class="line"></span>
<span id="line5321" class="line"></span>            if ( pointsList.getLength() &gt; 0 ) {
<span id="line5322" class="line"></span>                // Make an array containing references to the gPoints in the pointer list
<span id="line5323" class="line"></span>                //   (because calls to stopTrackingPointer() are going to modify the pointer list)
<span id="line5324" class="line"></span>                const gPointsToRemove = [];
<span id="line5325" class="line"></span>                const gPoints = pointsList.asArray();
<span id="line5326" class="line"></span>                for ( let j = 0; j &lt; gPoints.length; j++ ) {
<span id="line5327" class="line"></span>                    gPointsToRemove.push( gPoints[ j ] );
<span id="line5328" class="line"></span>                }
<span id="line5329" class="line"></span>
<span id="line5330" class="line"></span>                // Release and remove all gPoints from the pointer list
<span id="line5331" class="line"></span>                for ( let j = 0; j &lt; gPointsToRemove.length; j++ ) {
<span id="line5332" class="line"></span>                    stopTrackingPointer( tracker, pointsList, gPointsToRemove[ j ] );
<span id="line5333" class="line"></span>                }
<span id="line5334" class="line"></span>            }
<span id="line5335" class="line"></span>        }
<span id="line5336" class="line"></span>
<span id="line5337" class="line"></span>        for ( let i = 0; i &lt; pointerListCount; i++ ) {
<span id="line5338" class="line"></span>            delegate.activePointersLists.pop();
<span id="line5339" class="line"></span>        }
<span id="line5340" class="line"></span>
<span id="line5341" class="line"></span>        delegate.sentDragEvent = false;
<span id="line5342" class="line"></span>    }
<span id="line5343" class="line"></span>
<span id="line5344" class="line"></span>    /**
<span id="line5345" class="line"></span>     * Starts tracking pointer events on the tracked element.
<span id="line5346" class="line"></span>     * @private
<span id="line5347" class="line"></span>     * @inner
<span id="line5348" class="line"></span>     */
<span id="line5349" class="line"></span>    function startTracking( tracker ) {
<span id="line5350" class="line"></span>        const delegate = THIS[ tracker.hash ];
<span id="line5351" class="line"></span>
<span id="line5352" class="line"></span>        if ( !delegate.tracking ) {
<span id="line5353" class="line"></span>            for ( let i = 0; i &lt; $.MouseTracker.subscribeEvents.length; i++ ) {
<span id="line5354" class="line"></span>                const event = $.MouseTracker.subscribeEvents[ i ];
<span id="line5355" class="line"></span>                $.addEvent(
<span id="line5356" class="line"></span>                    tracker.element,
<span id="line5357" class="line"></span>                    event,
<span id="line5358" class="line"></span>                    delegate[ event ],
<span id="line5359" class="line"></span>                    event === $.MouseTracker.wheelEventName ? { passive: false, capture: false } : false
<span id="line5360" class="line"></span>                );
<span id="line5361" class="line"></span>            }
<span id="line5362" class="line"></span>
<span id="line5363" class="line"></span>            clearTrackedPointers( tracker );
<span id="line5364" class="line"></span>
<span id="line5365" class="line"></span>            delegate.tracking = true;
<span id="line5366" class="line"></span>        }
<span id="line5367" class="line"></span>    }
<span id="line5368" class="line"></span>
<span id="line5369" class="line"></span>    /**
<span id="line5370" class="line"></span>     * Stops tracking pointer events on the tracked element.
<span id="line5371" class="line"></span>     * @private
<span id="line5372" class="line"></span>     * @inner
<span id="line5373" class="line"></span>     */
<span id="line5374" class="line"></span>    function stopTracking( tracker ) {
<span id="line5375" class="line"></span>        const delegate = THIS[ tracker.hash ];
<span id="line5376" class="line"></span>
<span id="line5377" class="line"></span>        if ( delegate.tracking ) {
<span id="line5378" class="line"></span>            for ( let i = 0; i &lt; $.MouseTracker.subscribeEvents.length; i++ ) {
<span id="line5379" class="line"></span>                const event = $.MouseTracker.subscribeEvents[ i ];
<span id="line5380" class="line"></span>                $.removeEvent(
<span id="line5381" class="line"></span>                    tracker.element,
<span id="line5382" class="line"></span>                    event,
<span id="line5383" class="line"></span>                    delegate[ event ],
<span id="line5384" class="line"></span>                    false
<span id="line5385" class="line"></span>                );
<span id="line5386" class="line"></span>            }
<span id="line5387" class="line"></span>
<span id="line5388" class="line"></span>            clearTrackedPointers( tracker );
<span id="line5389" class="line"></span>
<span id="line5390" class="line"></span>            delegate.tracking = false;
<span id="line5391" class="line"></span>        }
<span id="line5392" class="line"></span>    }
<span id="line5393" class="line"></span>
<span id="line5394" class="line"></span>    /**
<span id="line5395" class="line"></span>     * @private
<span id="line5396" class="line"></span>     * @inner
<span id="line5397" class="line"></span>     */
<span id="line5398" class="line"></span>    function getCaptureEventParams( tracker, pointerType ) {
<span id="line5399" class="line"></span>        const delegate = THIS[ tracker.hash ];
<span id="line5400" class="line"></span>
<span id="line5401" class="line"></span>        if ( pointerType === 'pointerevent' ) {
<span id="line5402" class="line"></span>            return {
<span id="line5403" class="line"></span>                upName: 'pointerup',
<span id="line5404" class="line"></span>                upHandler: delegate.pointerupcaptured,
<span id="line5405" class="line"></span>                moveName: 'pointermove',
<span id="line5406" class="line"></span>                moveHandler: delegate.pointermovecaptured
<span id="line5407" class="line"></span>            };
<span id="line5408" class="line"></span>        } else if ( pointerType === 'mouse' ) {
<span id="line5409" class="line"></span>            return {
<span id="line5410" class="line"></span>                upName: 'pointerup',
<span id="line5411" class="line"></span>                upHandler: delegate.pointerupcaptured,
<span id="line5412" class="line"></span>                moveName: 'pointermove',
<span id="line5413" class="line"></span>                moveHandler: delegate.pointermovecaptured
<span id="line5414" class="line"></span>            };
<span id="line5415" class="line"></span>        } else if ( pointerType === 'touch' ) {
<span id="line5416" class="line"></span>            return {
<span id="line5417" class="line"></span>                upName: 'touchend',
<span id="line5418" class="line"></span>                upHandler: delegate.touchendcaptured,
<span id="line5419" class="line"></span>                moveName: 'touchmove',
<span id="line5420" class="line"></span>                moveHandler: delegate.touchmovecaptured
<span id="line5421" class="line"></span>            };
<span id="line5422" class="line"></span>        } else {
<span id="line5423" class="line"></span>            throw new Error( "MouseTracker.getCaptureEventParams: Unknown pointer type." );
<span id="line5424" class="line"></span>        }
<span id="line5425" class="line"></span>    }
<span id="line5426" class="line"></span>
<span id="line5427" class="line"></span>    /**
<span id="line5428" class="line"></span>     * Begin capturing pointer events to the tracked element.
<span id="line5429" class="line"></span>     * @private
<span id="line5430" class="line"></span>     * @inner
<span id="line5431" class="line"></span>     */
<span id="line5432" class="line"></span>    function capturePointer( tracker, gPoint ) {
<span id="line5433" class="line"></span>        if ( $.MouseTracker.havePointerCapture ) {
<span id="line5434" class="line"></span>            if ( $.MouseTracker.havePointerEvents ) {
<span id="line5435" class="line"></span>                // Can throw NotFoundError (InvalidPointerId Firefox &lt; 82)
<span id="line5436" class="line"></span>                //   (should never happen so we'll log a warning)
<span id="line5437" class="line"></span>                try {
<span id="line5438" class="line"></span>                    tracker.element.setPointerCapture( gPoint.id );
<span id="line5439" class="line"></span>                    //$.console.log('element.setPointerCapture() called');
<span id="line5440" class="line"></span>                } catch ( e ) {
<span id="line5441" class="line"></span>                    $.console.warn('setPointerCapture() called on invalid pointer ID');
<span id="line5442" class="line"></span>                    return;
<span id="line5443" class="line"></span>                }
<span id="line5444" class="line"></span>            } else {
<span id="line5445" class="line"></span>                tracker.element.setCapture( true );
<span id="line5446" class="line"></span>                //$.console.log('element.setCapture() called');
<span id="line5447" class="line"></span>            }
<span id="line5448" class="line"></span>        } else {
<span id="line5449" class="line"></span>            // Emulate mouse capture by hanging listeners on the document object.
<span id="line5450" class="line"></span>            //    (Note we listen on the capture phase so the captured handlers will get called first)
<span id="line5451" class="line"></span>            // eslint-disable-next-line no-use-before-define
<span id="line5452" class="line"></span>            //$.console.log('Emulated mouse capture set');
<span id="line5453" class="line"></span>            const eventParams = getCaptureEventParams( tracker, $.MouseTracker.havePointerEvents ? 'pointerevent' : gPoint.type );
<span id="line5454" class="line"></span>            // https://github.com/openseadragon/openseadragon/pull/790
<span id="line5455" class="line"></span>            if (isInIframe &amp;&amp; canAccessEvents(window.top)) {
<span id="line5456" class="line"></span>                $.addEvent(
<span id="line5457" class="line"></span>                    window.top,
<span id="line5458" class="line"></span>                    eventParams.upName,
<span id="line5459" class="line"></span>                    eventParams.upHandler,
<span id="line5460" class="line"></span>                    true
<span id="line5461" class="line"></span>                );
<span id="line5462" class="line"></span>            }
<span id="line5463" class="line"></span>            $.addEvent(
<span id="line5464" class="line"></span>                $.MouseTracker.captureElement,
<span id="line5465" class="line"></span>                eventParams.upName,
<span id="line5466" class="line"></span>                eventParams.upHandler,
<span id="line5467" class="line"></span>                true
<span id="line5468" class="line"></span>            );
<span id="line5469" class="line"></span>            $.addEvent(
<span id="line5470" class="line"></span>                $.MouseTracker.captureElement,
<span id="line5471" class="line"></span>                eventParams.moveName,
<span id="line5472" class="line"></span>                eventParams.moveHandler,
<span id="line5473" class="line"></span>                true
<span id="line5474" class="line"></span>            );
<span id="line5475" class="line"></span>        }
<span id="line5476" class="line"></span>
<span id="line5477" class="line"></span>        updatePointerCaptured( tracker, gPoint, true );
<span id="line5478" class="line"></span>    }
<span id="line5479" class="line"></span>
<span id="line5480" class="line"></span>
<span id="line5481" class="line"></span>    /**
<span id="line5482" class="line"></span>     * Stop capturing pointer events to the tracked element.
<span id="line5483" class="line"></span>     * @private
<span id="line5484" class="line"></span>     * @inner
<span id="line5485" class="line"></span>     */
<span id="line5486" class="line"></span>    function releasePointer( tracker, gPoint ) {
<span id="line5487" class="line"></span>        if ( $.MouseTracker.havePointerCapture ) {
<span id="line5488" class="line"></span>            if ( $.MouseTracker.havePointerEvents ) {
<span id="line5489" class="line"></span>                const pointsList = tracker.getActivePointersListByType( gPoint.type );
<span id="line5490" class="line"></span>                const cachedGPoint = pointsList.getById( gPoint.id );
<span id="line5491" class="line"></span>                if ( !cachedGPoint || !cachedGPoint.captured ) {
<span id="line5492" class="line"></span>                    return;
<span id="line5493" class="line"></span>                }
<span id="line5494" class="line"></span>                // Can throw NotFoundError (InvalidPointerId Firefox &lt; 82)
<span id="line5495" class="line"></span>                //   (should never happen, but it does on Firefox 79 touch so we won't log a warning)
<span id="line5496" class="line"></span>                try {
<span id="line5497" class="line"></span>                    tracker.element.releasePointerCapture( gPoint.id );
<span id="line5498" class="line"></span>                    //$.console.log('element.releasePointerCapture() called');
<span id="line5499" class="line"></span>                } catch ( e ) {
<span id="line5500" class="line"></span>                    //$.console.warn('releasePointerCapture() called on invalid pointer ID');
<span id="line5501" class="line"></span>                }
<span id="line5502" class="line"></span>            } else {
<span id="line5503" class="line"></span>                tracker.element.releaseCapture();
<span id="line5504" class="line"></span>                //$.console.log('element.releaseCapture() called');
<span id="line5505" class="line"></span>            }
<span id="line5506" class="line"></span>        } else {
<span id="line5507" class="line"></span>            // Emulate mouse capture by hanging listeners on the document object.
<span id="line5508" class="line"></span>            //    (Note we listen on the capture phase so the captured handlers will get called first)
<span id="line5509" class="line"></span>            //$.console.log('Emulated mouse capture release');
<span id="line5510" class="line"></span>            const eventParams = getCaptureEventParams( tracker, $.MouseTracker.havePointerEvents ? 'pointerevent' : gPoint.type );
<span id="line5511" class="line"></span>            // https://github.com/openseadragon/openseadragon/pull/790
<span id="line5512" class="line"></span>            if (isInIframe &amp;&amp; canAccessEvents(window.top)) {
<span id="line5513" class="line"></span>                $.removeEvent(
<span id="line5514" class="line"></span>                    window.top,
<span id="line5515" class="line"></span>                    eventParams.upName,
<span id="line5516" class="line"></span>                    eventParams.upHandler,
<span id="line5517" class="line"></span>                    true
<span id="line5518" class="line"></span>                );
<span id="line5519" class="line"></span>            }
<span id="line5520" class="line"></span>            $.removeEvent(
<span id="line5521" class="line"></span>                $.MouseTracker.captureElement,
<span id="line5522" class="line"></span>                eventParams.moveName,
<span id="line5523" class="line"></span>                eventParams.moveHandler,
<span id="line5524" class="line"></span>                true
<span id="line5525" class="line"></span>            );
<span id="line5526" class="line"></span>            $.removeEvent(
<span id="line5527" class="line"></span>                $.MouseTracker.captureElement,
<span id="line5528" class="line"></span>                eventParams.upName,
<span id="line5529" class="line"></span>                eventParams.upHandler,
<span id="line5530" class="line"></span>                true
<span id="line5531" class="line"></span>            );
<span id="line5532" class="line"></span>        }
<span id="line5533" class="line"></span>
<span id="line5534" class="line"></span>        updatePointerCaptured( tracker, gPoint, false );
<span id="line5535" class="line"></span>    }
<span id="line5536" class="line"></span>
<span id="line5537" class="line"></span>
<span id="line5538" class="line"></span>    /**
<span id="line5539" class="line"></span>     * Note: Called for both pointer events and legacy mouse events
<span id="line5540" class="line"></span>     *         ($.MouseTracker.havePointerEvents determines which)
<span id="line5541" class="line"></span>     * @private
<span id="line5542" class="line"></span>     * @inner
<span id="line5543" class="line"></span>     */
<span id="line5544" class="line"></span>    function getPointerId( event ) {
<span id="line5545" class="line"></span>        return ( $.MouseTracker.havePointerEvents ) ? event.pointerId : $.MouseTracker.mousePointerId;
<span id="line5546" class="line"></span>    }
<span id="line5547" class="line"></span>
<span id="line5548" class="line"></span>
<span id="line5549" class="line"></span>    /**
<span id="line5550" class="line"></span>     * Gets a W3C Pointer Events model compatible pointer type string from a DOM pointer event.
<span id="line5551" class="line"></span>     *
<span id="line5552" class="line"></span>     * Note: Called for both pointer events and legacy mouse events
<span id="line5553" class="line"></span>     *         ($.MouseTracker.havePointerEvents determines which)
<span id="line5554" class="line"></span>     * @private
<span id="line5555" class="line"></span>     * @inner
<span id="line5556" class="line"></span>     */
<span id="line5557" class="line"></span>    function getPointerType( event ) {
<span id="line5558" class="line"></span>        return $.MouseTracker.havePointerEvents &amp;&amp; event.pointerType ? event.pointerType : 'mouse';
<span id="line5559" class="line"></span>    }
<span id="line5560" class="line"></span>
<span id="line5561" class="line"></span>
<span id="line5562" class="line"></span>    /**
<span id="line5563" class="line"></span>     * Note: Called for both pointer events and legacy mouse events
<span id="line5564" class="line"></span>     *         ($.MouseTracker.havePointerEvents determines which)
<span id="line5565" class="line"></span>     * @private
<span id="line5566" class="line"></span>     * @inner
<span id="line5567" class="line"></span>     */
<span id="line5568" class="line"></span>    function getIsPrimary( event ) {
<span id="line5569" class="line"></span>        return ( $.MouseTracker.havePointerEvents ) ? event.isPrimary : true;
<span id="line5570" class="line"></span>    }
<span id="line5571" class="line"></span>
<span id="line5572" class="line"></span>
<span id="line5573" class="line"></span>    /**
<span id="line5574" class="line"></span>     * @private
<span id="line5575" class="line"></span>     * @inner
<span id="line5576" class="line"></span>     */
<span id="line5577" class="line"></span>    function getMouseAbsolute( event ) {
<span id="line5578" class="line"></span>        return $.getMousePosition( event );
<span id="line5579" class="line"></span>    }
<span id="line5580" class="line"></span>
<span id="line5581" class="line"></span>    /**
<span id="line5582" class="line"></span>     * @private
<span id="line5583" class="line"></span>     * @inner
<span id="line5584" class="line"></span>     */
<span id="line5585" class="line"></span>    function getMouseRelative( event, element ) {
<span id="line5586" class="line"></span>        return getPointRelativeToAbsolute( getMouseAbsolute( event ), element );
<span id="line5587" class="line"></span>    }
<span id="line5588" class="line"></span>
<span id="line5589" class="line"></span>    /**
<span id="line5590" class="line"></span>     * @private
<span id="line5591" class="line"></span>     * @inner
<span id="line5592" class="line"></span>     */
<span id="line5593" class="line"></span>    function getPointRelativeToAbsolute( point, element ) {
<span id="line5594" class="line"></span>        const offset = $.getElementOffset( element );
<span id="line5595" class="line"></span>        return point.minus( offset );
<span id="line5596" class="line"></span>    }
<span id="line5597" class="line"></span>
<span id="line5598" class="line"></span>    /**
<span id="line5599" class="line"></span>     * @private
<span id="line5600" class="line"></span>     * @inner
<span id="line5601" class="line"></span>     */
<span id="line5602" class="line"></span>    function getCenterPoint( point1, point2 ) {
<span id="line5603" class="line"></span>        return new $.Point( ( point1.x + point2.x ) / 2, ( point1.y + point2.y ) / 2 );
<span id="line5604" class="line"></span>    }
<span id="line5605" class="line"></span>
<span id="line5606" class="line"></span>
<span id="line5607" class="line"></span>///////////////////////////////////////////////////////////////////////////////
<span id="line5608" class="line"></span>// Device-specific DOM event handlers
<span id="line5609" class="line"></span>///////////////////////////////////////////////////////////////////////////////
<span id="line5610" class="line"></span>
<span id="line5611" class="line"></span>    /**
<span id="line5612" class="line"></span>     * @private
<span id="line5613" class="line"></span>     * @inner
<span id="line5614" class="line"></span>     */
<span id="line5615" class="line"></span>    function onClick( tracker, event ) {
<span id="line5616" class="line"></span>        //$.console.log('click ' + (tracker.userData ? tracker.userData.toString() : ''));
<span id="line5617" class="line"></span>
<span id="line5618" class="line"></span>        const eventInfo = {
<span id="line5619" class="line"></span>            originalEvent: event,
<span id="line5620" class="line"></span>            eventType: 'click',
<span id="line5621" class="line"></span>            pointerType: 'mouse',
<span id="line5622" class="line"></span>            isEmulated: false
<span id="line5623" class="line"></span>        };
<span id="line5624" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line5625" class="line"></span>
<span id="line5626" class="line"></span>        if ( eventInfo.preventDefault &amp;&amp; !eventInfo.defaultPrevented ) {
<span id="line5627" class="line"></span>            $.cancelEvent( event );
<span id="line5628" class="line"></span>        }
<span id="line5629" class="line"></span>        if ( eventInfo.stopPropagation ) {
<span id="line5630" class="line"></span>            $.stopEvent( event );
<span id="line5631" class="line"></span>        }
<span id="line5632" class="line"></span>    }
<span id="line5633" class="line"></span>
<span id="line5634" class="line"></span>
<span id="line5635" class="line"></span>    /**
<span id="line5636" class="line"></span>     * @private
<span id="line5637" class="line"></span>     * @inner
<span id="line5638" class="line"></span>     */
<span id="line5639" class="line"></span>    function onDblClick( tracker, event ) {
<span id="line5640" class="line"></span>        //$.console.log('dblclick ' + (tracker.userData ? tracker.userData.toString() : ''));
<span id="line5641" class="line"></span>
<span id="line5642" class="line"></span>        const eventInfo = {
<span id="line5643" class="line"></span>            originalEvent: event,
<span id="line5644" class="line"></span>            eventType: 'dblclick',
<span id="line5645" class="line"></span>            pointerType: 'mouse',
<span id="line5646" class="line"></span>            isEmulated: false
<span id="line5647" class="line"></span>        };
<span id="line5648" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line5649" class="line"></span>
<span id="line5650" class="line"></span>        if ( eventInfo.preventDefault &amp;&amp; !eventInfo.defaultPrevented ) {
<span id="line5651" class="line"></span>            $.cancelEvent( event );
<span id="line5652" class="line"></span>        }
<span id="line5653" class="line"></span>        if ( eventInfo.stopPropagation ) {
<span id="line5654" class="line"></span>            $.stopEvent( event );
<span id="line5655" class="line"></span>        }
<span id="line5656" class="line"></span>    }
<span id="line5657" class="line"></span>
<span id="line5658" class="line"></span>
<span id="line5659" class="line"></span>    /**
<span id="line5660" class="line"></span>     * @private
<span id="line5661" class="line"></span>     * @inner
<span id="line5662" class="line"></span>     */
<span id="line5663" class="line"></span>    function onKeyDown( tracker, event ) {
<span id="line5664" class="line"></span>        //$.console.log( "keydown %s %s %s %s %s", event.keyCode, event.charCode, event.ctrlKey, event.shiftKey, event.altKey );
<span id="line5665" class="line"></span>        let eventArgs = null;
<span id="line5666" class="line"></span>
<span id="line5667" class="line"></span>        const eventInfo = {
<span id="line5668" class="line"></span>            originalEvent: event,
<span id="line5669" class="line"></span>            eventType: 'keydown',
<span id="line5670" class="line"></span>            pointerType: '',
<span id="line5671" class="line"></span>            isEmulated: false
<span id="line5672" class="line"></span>        };
<span id="line5673" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line5674" class="line"></span>
<span id="line5675" class="line"></span>        if ( tracker.keyDownHandler &amp;&amp; !eventInfo.preventGesture &amp;&amp; !eventInfo.defaultPrevented ) {
<span id="line5676" class="line"></span>            eventArgs = {
<span id="line5677" class="line"></span>                eventSource:          tracker,
<span id="line5678" class="line"></span>                keyCode:              event.keyCode ? event.keyCode : event.charCode,
<span id="line5679" class="line"></span>                ctrl:                 event.ctrlKey,
<span id="line5680" class="line"></span>                shift:                event.shiftKey,
<span id="line5681" class="line"></span>                alt:                  event.altKey,
<span id="line5682" class="line"></span>                meta:                 event.metaKey,
<span id="line5683" class="line"></span>                originalEvent:        event,
<span id="line5684" class="line"></span>                preventDefault:       eventInfo.preventDefault || eventInfo.defaultPrevented,
<span id="line5685" class="line"></span>                userData:             tracker.userData
<span id="line5686" class="line"></span>            };
<span id="line5687" class="line"></span>
<span id="line5688" class="line"></span>            tracker.keyDownHandler( eventArgs );
<span id="line5689" class="line"></span>        }
<span id="line5690" class="line"></span>
<span id="line5691" class="line"></span>        if ( ( eventArgs &amp;&amp; eventArgs.preventDefault ) || ( eventInfo.preventDefault &amp;&amp; !eventInfo.defaultPrevented ) ) {
<span id="line5692" class="line"></span>                $.cancelEvent( event );
<span id="line5693" class="line"></span>        }
<span id="line5694" class="line"></span>        if ( eventInfo.stopPropagation ) {
<span id="line5695" class="line"></span>            $.stopEvent( event );
<span id="line5696" class="line"></span>        }
<span id="line5697" class="line"></span>    }
<span id="line5698" class="line"></span>
<span id="line5699" class="line"></span>
<span id="line5700" class="line"></span>    /**
<span id="line5701" class="line"></span>     * @private
<span id="line5702" class="line"></span>     * @inner
<span id="line5703" class="line"></span>     */
<span id="line5704" class="line"></span>    function onKeyUp( tracker, event ) {
<span id="line5705" class="line"></span>        //$.console.log( "keyup %s %s %s %s %s", event.keyCode, event.charCode, event.ctrlKey, event.shiftKey, event.altKey );
<span id="line5706" class="line"></span>
<span id="line5707" class="line"></span>        let eventArgs = null;
<span id="line5708" class="line"></span>
<span id="line5709" class="line"></span>        const eventInfo = {
<span id="line5710" class="line"></span>            originalEvent: event,
<span id="line5711" class="line"></span>            eventType: 'keyup',
<span id="line5712" class="line"></span>            pointerType: '',
<span id="line5713" class="line"></span>            isEmulated: false
<span id="line5714" class="line"></span>        };
<span id="line5715" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line5716" class="line"></span>
<span id="line5717" class="line"></span>        if ( tracker.keyUpHandler &amp;&amp; !eventInfo.preventGesture &amp;&amp; !eventInfo.defaultPrevented ) {
<span id="line5718" class="line"></span>            eventArgs = {
<span id="line5719" class="line"></span>                eventSource:          tracker,
<span id="line5720" class="line"></span>                keyCode:              event.keyCode ? event.keyCode : event.charCode,
<span id="line5721" class="line"></span>                ctrl:                 event.ctrlKey,
<span id="line5722" class="line"></span>                shift:                event.shiftKey,
<span id="line5723" class="line"></span>                alt:                  event.altKey,
<span id="line5724" class="line"></span>                meta:                 event.metaKey,
<span id="line5725" class="line"></span>                originalEvent:        event,
<span id="line5726" class="line"></span>                preventDefault:       eventInfo.preventDefault || eventInfo.defaultPrevented,
<span id="line5727" class="line"></span>                userData:             tracker.userData
<span id="line5728" class="line"></span>            };
<span id="line5729" class="line"></span>
<span id="line5730" class="line"></span>            tracker.keyUpHandler( eventArgs );
<span id="line5731" class="line"></span>        }
<span id="line5732" class="line"></span>
<span id="line5733" class="line"></span>        if ( ( eventArgs &amp;&amp; eventArgs.preventDefault ) || ( eventInfo.preventDefault &amp;&amp; !eventInfo.defaultPrevented ) ) {
<span id="line5734" class="line"></span>            $.cancelEvent( event );
<span id="line5735" class="line"></span>        }
<span id="line5736" class="line"></span>        if ( eventInfo.stopPropagation ) {
<span id="line5737" class="line"></span>            $.stopEvent( event );
<span id="line5738" class="line"></span>        }
<span id="line5739" class="line"></span>    }
<span id="line5740" class="line"></span>
<span id="line5741" class="line"></span>
<span id="line5742" class="line"></span>    /**
<span id="line5743" class="line"></span>     * @private
<span id="line5744" class="line"></span>     * @inner
<span id="line5745" class="line"></span>     */
<span id="line5746" class="line"></span>    function onKeyPress( tracker, event ) {
<span id="line5747" class="line"></span>        //$.console.log( "keypress %s %s %s %s %s", event.keyCode, event.charCode, event.ctrlKey, event.shiftKey, event.altKey );
<span id="line5748" class="line"></span>
<span id="line5749" class="line"></span>        let eventArgs = null;
<span id="line5750" class="line"></span>
<span id="line5751" class="line"></span>        const eventInfo = {
<span id="line5752" class="line"></span>            originalEvent: event,
<span id="line5753" class="line"></span>            eventType: 'keypress',
<span id="line5754" class="line"></span>            pointerType: '',
<span id="line5755" class="line"></span>            isEmulated: false
<span id="line5756" class="line"></span>        };
<span id="line5757" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line5758" class="line"></span>
<span id="line5759" class="line"></span>        if ( tracker.keyHandler &amp;&amp; !eventInfo.preventGesture &amp;&amp; !eventInfo.defaultPrevented ) {
<span id="line5760" class="line"></span>            eventArgs = {
<span id="line5761" class="line"></span>                eventSource:          tracker,
<span id="line5762" class="line"></span>                keyCode:              event.keyCode ? event.keyCode : event.charCode,
<span id="line5763" class="line"></span>                ctrl:                 event.ctrlKey,
<span id="line5764" class="line"></span>                shift:                event.shiftKey,
<span id="line5765" class="line"></span>                alt:                  event.altKey,
<span id="line5766" class="line"></span>                meta:                 event.metaKey,
<span id="line5767" class="line"></span>                originalEvent:        event,
<span id="line5768" class="line"></span>                preventDefault:       eventInfo.preventDefault || eventInfo.defaultPrevented,
<span id="line5769" class="line"></span>                userData:             tracker.userData
<span id="line5770" class="line"></span>            };
<span id="line5771" class="line"></span>
<span id="line5772" class="line"></span>            tracker.keyHandler( eventArgs );
<span id="line5773" class="line"></span>        }
<span id="line5774" class="line"></span>
<span id="line5775" class="line"></span>        if ( ( eventArgs &amp;&amp; eventArgs.preventDefault ) || ( eventInfo.preventDefault &amp;&amp; !eventInfo.defaultPrevented ) ) {
<span id="line5776" class="line"></span>            $.cancelEvent( event );
<span id="line5777" class="line"></span>        }
<span id="line5778" class="line"></span>        if ( eventInfo.stopPropagation ) {
<span id="line5779" class="line"></span>            $.stopEvent( event );
<span id="line5780" class="line"></span>        }
<span id="line5781" class="line"></span>    }
<span id="line5782" class="line"></span>
<span id="line5783" class="line"></span>
<span id="line5784" class="line"></span>    /**
<span id="line5785" class="line"></span>     * @private
<span id="line5786" class="line"></span>     * @inner
<span id="line5787" class="line"></span>     */
<span id="line5788" class="line"></span>    function onFocus( tracker, event ) {
<span id="line5789" class="line"></span>        //$.console.log('focus  ' + (tracker.userData ? tracker.userData.toString() : ''));
<span id="line5790" class="line"></span>
<span id="line5791" class="line"></span>        // focus doesn't bubble and is not cancelable, but we call
<span id="line5792" class="line"></span>        //   preProcessEvent() so it's dispatched to preProcessEventHandler
<span id="line5793" class="line"></span>        //   if necessary
<span id="line5794" class="line"></span>        const eventInfo = {
<span id="line5795" class="line"></span>            originalEvent: event,
<span id="line5796" class="line"></span>            eventType: 'focus',
<span id="line5797" class="line"></span>            pointerType: '',
<span id="line5798" class="line"></span>            isEmulated: false
<span id="line5799" class="line"></span>        };
<span id="line5800" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line5801" class="line"></span>
<span id="line5802" class="line"></span>        if ( tracker.focusHandler &amp;&amp; !eventInfo.preventGesture ) {
<span id="line5803" class="line"></span>            tracker.focusHandler(
<span id="line5804" class="line"></span>                {
<span id="line5805" class="line"></span>                    eventSource:          tracker,
<span id="line5806" class="line"></span>                    originalEvent:        event,
<span id="line5807" class="line"></span>                    userData:             tracker.userData
<span id="line5808" class="line"></span>                }
<span id="line5809" class="line"></span>            );
<span id="line5810" class="line"></span>        }
<span id="line5811" class="line"></span>    }
<span id="line5812" class="line"></span>
<span id="line5813" class="line"></span>
<span id="line5814" class="line"></span>    /**
<span id="line5815" class="line"></span>     * @private
<span id="line5816" class="line"></span>     * @inner
<span id="line5817" class="line"></span>     */
<span id="line5818" class="line"></span>    function onBlur( tracker, event ) {
<span id="line5819" class="line"></span>        //$.console.log('blur  ' + (tracker.userData ? tracker.userData.toString() : ''));
<span id="line5820" class="line"></span>
<span id="line5821" class="line"></span>        // blur doesn't bubble and is not cancelable, but we call
<span id="line5822" class="line"></span>        //   preProcessEvent() so it's dispatched to preProcessEventHandler
<span id="line5823" class="line"></span>        //   if necessary
<span id="line5824" class="line"></span>        const eventInfo = {
<span id="line5825" class="line"></span>            originalEvent: event,
<span id="line5826" class="line"></span>            eventType: 'blur',
<span id="line5827" class="line"></span>            pointerType: '',
<span id="line5828" class="line"></span>            isEmulated: false
<span id="line5829" class="line"></span>        };
<span id="line5830" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line5831" class="line"></span>
<span id="line5832" class="line"></span>        if ( tracker.blurHandler &amp;&amp; !eventInfo.preventGesture ) {
<span id="line5833" class="line"></span>            tracker.blurHandler(
<span id="line5834" class="line"></span>                {
<span id="line5835" class="line"></span>                    eventSource:          tracker,
<span id="line5836" class="line"></span>                    originalEvent:        event,
<span id="line5837" class="line"></span>                    userData:             tracker.userData
<span id="line5838" class="line"></span>                }
<span id="line5839" class="line"></span>            );
<span id="line5840" class="line"></span>        }
<span id="line5841" class="line"></span>    }
<span id="line5842" class="line"></span>
<span id="line5843" class="line"></span>
<span id="line5844" class="line"></span>    /**
<span id="line5845" class="line"></span>     * @private
<span id="line5846" class="line"></span>     * @inner
<span id="line5847" class="line"></span>     */
<span id="line5848" class="line"></span>    function onContextMenu( tracker, event ) {
<span id="line5849" class="line"></span>        //$.console.log('contextmenu ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));
<span id="line5850" class="line"></span>
<span id="line5851" class="line"></span>        let eventArgs = null;
<span id="line5852" class="line"></span>
<span id="line5853" class="line"></span>        const eventInfo = {
<span id="line5854" class="line"></span>            originalEvent: event,
<span id="line5855" class="line"></span>            eventType: 'contextmenu',
<span id="line5856" class="line"></span>            pointerType: 'mouse',
<span id="line5857" class="line"></span>            isEmulated: false
<span id="line5858" class="line"></span>        };
<span id="line5859" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line5860" class="line"></span>
<span id="line5861" class="line"></span>        // ContextMenu
<span id="line5862" class="line"></span>        if ( tracker.contextMenuHandler &amp;&amp; !eventInfo.preventGesture &amp;&amp; !eventInfo.defaultPrevented ) {
<span id="line5863" class="line"></span>            eventArgs = {
<span id="line5864" class="line"></span>                eventSource:          tracker,
<span id="line5865" class="line"></span>                position:             getPointRelativeToAbsolute( getMouseAbsolute( event ), tracker.element ),
<span id="line5866" class="line"></span>                originalEvent:        eventInfo.originalEvent,
<span id="line5867" class="line"></span>                preventDefault:       eventInfo.preventDefault || eventInfo.defaultPrevented,
<span id="line5868" class="line"></span>                userData:             tracker.userData
<span id="line5869" class="line"></span>            };
<span id="line5870" class="line"></span>
<span id="line5871" class="line"></span>            tracker.contextMenuHandler( eventArgs );
<span id="line5872" class="line"></span>        }
<span id="line5873" class="line"></span>
<span id="line5874" class="line"></span>        if ( ( eventArgs &amp;&amp; eventArgs.preventDefault ) || ( eventInfo.preventDefault &amp;&amp; !eventInfo.defaultPrevented ) ) {
<span id="line5875" class="line"></span>            $.cancelEvent( event );
<span id="line5876" class="line"></span>        }
<span id="line5877" class="line"></span>        if ( eventInfo.stopPropagation ) {
<span id="line5878" class="line"></span>            $.stopEvent( event );
<span id="line5879" class="line"></span>        }
<span id="line5880" class="line"></span>    }
<span id="line5881" class="line"></span>
<span id="line5882" class="line"></span>
<span id="line5883" class="line"></span>    /**
<span id="line5884" class="line"></span>     * Handler for 'wheel' events
<span id="line5885" class="line"></span>     *
<span id="line5886" class="line"></span>     * @private
<span id="line5887" class="line"></span>     * @inner
<span id="line5888" class="line"></span>     */
<span id="line5889" class="line"></span>    function onWheel( tracker, event ) {
<span id="line5890" class="line"></span>        handleWheelEvent( tracker, event, event );
<span id="line5891" class="line"></span>    }
<span id="line5892" class="line"></span>
<span id="line5893" class="line"></span>
<span id="line5894" class="line"></span>    /**
<span id="line5895" class="line"></span>     * Handler for 'mousewheel', 'DOMMouseScroll', and 'MozMousePixelScroll' events
<span id="line5896" class="line"></span>     *
<span id="line5897" class="line"></span>     * @private
<span id="line5898" class="line"></span>     * @inner
<span id="line5899" class="line"></span>     */
<span id="line5900" class="line"></span>    function onMouseWheel( tracker, event ) {
<span id="line5901" class="line"></span>        // Simulate a 'wheel' event
<span id="line5902" class="line"></span>        const simulatedEvent = {
<span id="line5903" class="line"></span>            target:     event.target || event.srcElement,
<span id="line5904" class="line"></span>            type:       "wheel",
<span id="line5905" class="line"></span>            shiftKey:   event.shiftKey || false,
<span id="line5906" class="line"></span>            clientX:    event.clientX,
<span id="line5907" class="line"></span>            clientY:    event.clientY,
<span id="line5908" class="line"></span>            pageX:      event.pageX ? event.pageX : event.clientX,
<span id="line5909" class="line"></span>            pageY:      event.pageY ? event.pageY : event.clientY,
<span id="line5910" class="line"></span>            deltaMode:  event.type === "MozMousePixelScroll" ? 0 : 1, // 0=pixel, 1=line, 2=page
<span id="line5911" class="line"></span>            deltaX:     0,
<span id="line5912" class="line"></span>            deltaZ:     0
<span id="line5913" class="line"></span>        };
<span id="line5914" class="line"></span>
<span id="line5915" class="line"></span>        // Calculate deltaY
<span id="line5916" class="line"></span>        if ( $.MouseTracker.wheelEventName === "mousewheel" ) {
<span id="line5917" class="line"></span>            simulatedEvent.deltaY = -event.wheelDelta / $.DEFAULT_SETTINGS.pixelsPerWheelLine;
<span id="line5918" class="line"></span>        } else {
<span id="line5919" class="line"></span>            simulatedEvent.deltaY = event.detail;
<span id="line5920" class="line"></span>        }
<span id="line5921" class="line"></span>
<span id="line5922" class="line"></span>        handleWheelEvent( tracker, simulatedEvent, event );
<span id="line5923" class="line"></span>    }
<span id="line5924" class="line"></span>
<span id="line5925" class="line"></span>
<span id="line5926" class="line"></span>    /**
<span id="line5927" class="line"></span>     * Handles 'wheel' events.
<span id="line5928" class="line"></span>     * The event may be simulated by the legacy mouse wheel event handler (onMouseWheel()).
<span id="line5929" class="line"></span>     *
<span id="line5930" class="line"></span>     * @private
<span id="line5931" class="line"></span>     * @inner
<span id="line5932" class="line"></span>     */
<span id="line5933" class="line"></span>    function handleWheelEvent( tracker, event, originalEvent ) {
<span id="line5934" class="line"></span>        let nDelta = 0;
<span id="line5935" class="line"></span>        let eventInfo;
<span id="line5936" class="line"></span>
<span id="line5937" class="line"></span>        let eventArgs = null;
<span id="line5938" class="line"></span>
<span id="line5939" class="line"></span>        // The nDelta variable is gated to provide smooth z-index scrolling
<span id="line5940" class="line"></span>        //   since the mouse wheel allows for substantial deltas meant for rapid
<span id="line5941" class="line"></span>        //   y-index scrolling.
<span id="line5942" class="line"></span>        // event.deltaMode: 0=pixel, 1=line, 2=page
<span id="line5943" class="line"></span>        // TODO: Deltas in pixel mode should be accumulated then a scroll value computed after $.DEFAULT_SETTINGS.pixelsPerWheelLine threshold reached
<span id="line5944" class="line"></span>        nDelta = event.deltaY ? (event.deltaY &lt; 0 ? 1 : -1) : 0;
<span id="line5945" class="line"></span>
<span id="line5946" class="line"></span>        eventInfo = {
<span id="line5947" class="line"></span>            originalEvent: event,
<span id="line5948" class="line"></span>            eventType: 'wheel',
<span id="line5949" class="line"></span>            pointerType: 'mouse',
<span id="line5950" class="line"></span>            isEmulated: event !== originalEvent
<span id="line5951" class="line"></span>        };
<span id="line5952" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line5953" class="line"></span>
<span id="line5954" class="line"></span>        if ( tracker.scrollHandler &amp;&amp; !eventInfo.preventGesture &amp;&amp; !eventInfo.defaultPrevented ) {
<span id="line5955" class="line"></span>            eventArgs = {
<span id="line5956" class="line"></span>                eventSource:          tracker,
<span id="line5957" class="line"></span>                pointerType:          'mouse',
<span id="line5958" class="line"></span>                position:             getMouseRelative( event, tracker.element ),
<span id="line5959" class="line"></span>                scroll:               nDelta,
<span id="line5960" class="line"></span>                shift:                event.shiftKey,
<span id="line5961" class="line"></span>                isTouchEvent:         false,
<span id="line5962" class="line"></span>                originalEvent:        originalEvent,
<span id="line5963" class="line"></span>                preventDefault:       eventInfo.preventDefault || eventInfo.defaultPrevented,
<span id="line5964" class="line"></span>                userData:             tracker.userData
<span id="line5965" class="line"></span>            };
<span id="line5966" class="line"></span>
<span id="line5967" class="line"></span>
<span id="line5968" class="line"></span>            tracker.scrollHandler( eventArgs );
<span id="line5969" class="line"></span>        }
<span id="line5970" class="line"></span>
<span id="line5971" class="line"></span>        if ( eventInfo.stopPropagation ) {
<span id="line5972" class="line"></span>            $.stopEvent( originalEvent );
<span id="line5973" class="line"></span>        }
<span id="line5974" class="line"></span>        if ( ( eventArgs &amp;&amp; eventArgs.preventDefault ) || ( eventInfo.preventDefault &amp;&amp; !eventInfo.defaultPrevented ) ) {
<span id="line5975" class="line"></span>                $.cancelEvent( originalEvent );
<span id="line5976" class="line"></span>        }
<span id="line5977" class="line"></span>}
<span id="line5978" class="line"></span>
<span id="line5979" class="line"></span>
<span id="line5980" class="line"></span>    /**
<span id="line5981" class="line"></span>     * TODO Never actually seen this event fired, and documentation is tough to find
<span id="line5982" class="line"></span>     * @private
<span id="line5983" class="line"></span>     * @inner
<span id="line5984" class="line"></span>     */
<span id="line5985" class="line"></span>    function onLoseCapture( tracker, event ) {
<span id="line5986" class="line"></span>        //$.console.log('losecapture ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));
<span id="line5987" class="line"></span>
<span id="line5988" class="line"></span>        const gPoint = {
<span id="line5989" class="line"></span>            id: $.MouseTracker.mousePointerId,
<span id="line5990" class="line"></span>            type: 'mouse'
<span id="line5991" class="line"></span>        };
<span id="line5992" class="line"></span>
<span id="line5993" class="line"></span>        const eventInfo = {
<span id="line5994" class="line"></span>            originalEvent: event,
<span id="line5995" class="line"></span>            eventType: 'lostpointercapture',
<span id="line5996" class="line"></span>            pointerType: 'mouse',
<span id="line5997" class="line"></span>            isEmulated: false
<span id="line5998" class="line"></span>        };
<span id="line5999" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line6000" class="line"></span>
<span id="line6001" class="line"></span>        if ( event.target === tracker.element ) {
<span id="line6002" class="line"></span>            updatePointerCaptured( tracker, gPoint, false );
<span id="line6003" class="line"></span>        }
<span id="line6004" class="line"></span>
<span id="line6005" class="line"></span>        if ( eventInfo.stopPropagation ) {
<span id="line6006" class="line"></span>            $.stopEvent( event );
<span id="line6007" class="line"></span>        }
<span id="line6008" class="line"></span>    }
<span id="line6009" class="line"></span>
<span id="line6010" class="line"></span>
<span id="line6011" class="line"></span>    /**
<span id="line6012" class="line"></span>     * @private
<span id="line6013" class="line"></span>     * @inner
<span id="line6014" class="line"></span>     */
<span id="line6015" class="line"></span>    function onTouchStart( tracker, event ) {
<span id="line6016" class="line"></span>        const touchCount = event.changedTouches.length;
<span id="line6017" class="line"></span>        const pointsList = tracker.getActivePointersListByType( 'touch' );
<span id="line6018" class="line"></span>
<span id="line6019" class="line"></span>        const time = $.now();
<span id="line6020" class="line"></span>
<span id="line6021" class="line"></span>        //$.console.log('touchstart ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));
<span id="line6022" class="line"></span>
<span id="line6023" class="line"></span>        if ( pointsList.getLength() &gt; event.touches.length - touchCount ) {
<span id="line6024" class="line"></span>            $.console.warn('Tracked touch contact count doesn\'t match event.touches.length');
<span id="line6025" class="line"></span>        }
<span id="line6026" class="line"></span>
<span id="line6027" class="line"></span>        const eventInfo = {
<span id="line6028" class="line"></span>            originalEvent: event,
<span id="line6029" class="line"></span>            eventType: 'pointerdown',
<span id="line6030" class="line"></span>            pointerType: 'touch',
<span id="line6031" class="line"></span>            isEmulated: false
<span id="line6032" class="line"></span>        };
<span id="line6033" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line6034" class="line"></span>
<span id="line6035" class="line"></span>        for ( let i = 0; i &lt; touchCount; i++ ) {
<span id="line6036" class="line"></span>            const gPoint = {
<span id="line6037" class="line"></span>                id: event.changedTouches[ i ].identifier,
<span id="line6038" class="line"></span>                type: 'touch',
<span id="line6039" class="line"></span>                // Simulate isPrimary
<span id="line6040" class="line"></span>                isPrimary: pointsList.getLength() === 0,
<span id="line6041" class="line"></span>                currentPos: getMouseAbsolute( event.changedTouches[ i ] ),
<span id="line6042" class="line"></span>                currentTime: time
<span id="line6043" class="line"></span>            };
<span id="line6044" class="line"></span>
<span id="line6045" class="line"></span>            // simulate touchenter on our tracked element
<span id="line6046" class="line"></span>            updatePointerEnter( tracker, eventInfo, gPoint );
<span id="line6047" class="line"></span>
<span id="line6048" class="line"></span>            updatePointerDown( tracker, eventInfo, gPoint, 0 );
<span id="line6049" class="line"></span>
<span id="line6050" class="line"></span>            updatePointerCaptured( tracker, gPoint, true );
<span id="line6051" class="line"></span>        }
<span id="line6052" class="line"></span>
<span id="line6053" class="line"></span>        if ( eventInfo.preventDefault &amp;&amp; !eventInfo.defaultPrevented ) {
<span id="line6054" class="line"></span>            $.cancelEvent( event );
<span id="line6055" class="line"></span>        }
<span id="line6056" class="line"></span>        if ( eventInfo.stopPropagation ) {
<span id="line6057" class="line"></span>            $.stopEvent( event );
<span id="line6058" class="line"></span>        }
<span id="line6059" class="line"></span>    }
<span id="line6060" class="line"></span>
<span id="line6061" class="line"></span>
<span id="line6062" class="line"></span>    /**
<span id="line6063" class="line"></span>     * @private
<span id="line6064" class="line"></span>     * @inner
<span id="line6065" class="line"></span>     */
<span id="line6066" class="line"></span>    function onTouchEnd( tracker, event ) {
<span id="line6067" class="line"></span>        const touchCount = event.changedTouches.length;
<span id="line6068" class="line"></span>        const time = $.now();
<span id="line6069" class="line"></span>
<span id="line6070" class="line"></span>        //$.console.log('touchend ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));
<span id="line6071" class="line"></span>
<span id="line6072" class="line"></span>        const eventInfo = {
<span id="line6073" class="line"></span>            originalEvent: event,
<span id="line6074" class="line"></span>            eventType: 'pointerup',
<span id="line6075" class="line"></span>            pointerType: 'touch',
<span id="line6076" class="line"></span>            isEmulated: false
<span id="line6077" class="line"></span>        };
<span id="line6078" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line6079" class="line"></span>
<span id="line6080" class="line"></span>        for ( let i = 0; i &lt; touchCount; i++ ) {
<span id="line6081" class="line"></span>            const gPoint = {
<span id="line6082" class="line"></span>                id: event.changedTouches[ i ].identifier,
<span id="line6083" class="line"></span>                type: 'touch',
<span id="line6084" class="line"></span>                currentPos: getMouseAbsolute( event.changedTouches[ i ] ),
<span id="line6085" class="line"></span>                currentTime: time
<span id="line6086" class="line"></span>            };
<span id="line6087" class="line"></span>
<span id="line6088" class="line"></span>            updatePointerUp( tracker, eventInfo, gPoint, 0 );
<span id="line6089" class="line"></span>
<span id="line6090" class="line"></span>            updatePointerCaptured( tracker, gPoint, false );
<span id="line6091" class="line"></span>
<span id="line6092" class="line"></span>            // simulate touchleave on our tracked element
<span id="line6093" class="line"></span>            updatePointerLeave( tracker, eventInfo, gPoint );
<span id="line6094" class="line"></span>        }
<span id="line6095" class="line"></span>
<span id="line6096" class="line"></span>        if ( eventInfo.preventDefault &amp;&amp; !eventInfo.defaultPrevented ) {
<span id="line6097" class="line"></span>            $.cancelEvent( event );
<span id="line6098" class="line"></span>        }
<span id="line6099" class="line"></span>        if ( eventInfo.stopPropagation ) {
<span id="line6100" class="line"></span>            $.stopEvent( event );
<span id="line6101" class="line"></span>        }
<span id="line6102" class="line"></span>    }
<span id="line6103" class="line"></span>
<span id="line6104" class="line"></span>
<span id="line6105" class="line"></span>    /**
<span id="line6106" class="line"></span>     * @private
<span id="line6107" class="line"></span>     * @inner
<span id="line6108" class="line"></span>     */
<span id="line6109" class="line"></span>    function onTouchMove( tracker, event ) {
<span id="line6110" class="line"></span>        const touchCount = event.changedTouches.length;
<span id="line6111" class="line"></span>        const time = $.now();
<span id="line6112" class="line"></span>
<span id="line6113" class="line"></span>        const eventInfo = {
<span id="line6114" class="line"></span>            originalEvent: event,
<span id="line6115" class="line"></span>            eventType: 'pointermove',
<span id="line6116" class="line"></span>            pointerType: 'touch',
<span id="line6117" class="line"></span>            isEmulated: false
<span id="line6118" class="line"></span>        };
<span id="line6119" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line6120" class="line"></span>
<span id="line6121" class="line"></span>        for ( let i = 0; i &lt; touchCount; i++ ) {
<span id="line6122" class="line"></span>            const gPoint = {
<span id="line6123" class="line"></span>                id: event.changedTouches[ i ].identifier,
<span id="line6124" class="line"></span>                type: 'touch',
<span id="line6125" class="line"></span>                currentPos: getMouseAbsolute( event.changedTouches[ i ] ),
<span id="line6126" class="line"></span>                currentTime: time
<span id="line6127" class="line"></span>            };
<span id="line6128" class="line"></span>
<span id="line6129" class="line"></span>            updatePointerMove( tracker, eventInfo, gPoint );
<span id="line6130" class="line"></span>        }
<span id="line6131" class="line"></span>
<span id="line6132" class="line"></span>        if ( eventInfo.preventDefault &amp;&amp; !eventInfo.defaultPrevented ) {
<span id="line6133" class="line"></span>            $.cancelEvent( event );
<span id="line6134" class="line"></span>        }
<span id="line6135" class="line"></span>        if ( eventInfo.stopPropagation ) {
<span id="line6136" class="line"></span>            $.stopEvent( event );
<span id="line6137" class="line"></span>        }
<span id="line6138" class="line"></span>    }
<span id="line6139" class="line"></span>
<span id="line6140" class="line"></span>
<span id="line6141" class="line"></span>    /**
<span id="line6142" class="line"></span>     * @private
<span id="line6143" class="line"></span>     * @inner
<span id="line6144" class="line"></span>     */
<span id="line6145" class="line"></span>    function onTouchCancel( tracker, event ) {
<span id="line6146" class="line"></span>        const touchCount = event.changedTouches.length;
<span id="line6147" class="line"></span>        //$.console.log('touchcancel ' + (tracker.userData ? tracker.userData.toString() : ''));
<span id="line6148" class="line"></span>
<span id="line6149" class="line"></span>        const eventInfo = {
<span id="line6150" class="line"></span>            originalEvent: event,
<span id="line6151" class="line"></span>            eventType: 'pointercancel',
<span id="line6152" class="line"></span>            pointerType: 'touch',
<span id="line6153" class="line"></span>            isEmulated: false
<span id="line6154" class="line"></span>        };
<span id="line6155" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line6156" class="line"></span>
<span id="line6157" class="line"></span>        for ( let i = 0; i &lt; touchCount; i++ ) {
<span id="line6158" class="line"></span>            const gPoint = {
<span id="line6159" class="line"></span>                id: event.changedTouches[ i ].identifier,
<span id="line6160" class="line"></span>                type: 'touch'
<span id="line6161" class="line"></span>            };
<span id="line6162" class="line"></span>
<span id="line6163" class="line"></span>            //TODO need to only do this if our element is target?
<span id="line6164" class="line"></span>            updatePointerCancel( tracker, eventInfo, gPoint );
<span id="line6165" class="line"></span>        }
<span id="line6166" class="line"></span>
<span id="line6167" class="line"></span>        if ( eventInfo.stopPropagation ) {
<span id="line6168" class="line"></span>            $.stopEvent( event );
<span id="line6169" class="line"></span>        }
<span id="line6170" class="line"></span>    }
<span id="line6171" class="line"></span>
<span id="line6172" class="line"></span>
<span id="line6173" class="line"></span>    /**
<span id="line6174" class="line"></span>     * @private
<span id="line6175" class="line"></span>     * @inner
<span id="line6176" class="line"></span>     */
<span id="line6177" class="line"></span>    function onGestureStart( tracker, event ) {
<span id="line6178" class="line"></span>        if ( !$.eventIsCanceled( event ) ) {
<span id="line6179" class="line"></span>            event.preventDefault();
<span id="line6180" class="line"></span>        }
<span id="line6181" class="line"></span>        return false;
<span id="line6182" class="line"></span>    }
<span id="line6183" class="line"></span>
<span id="line6184" class="line"></span>
<span id="line6185" class="line"></span>    /**
<span id="line6186" class="line"></span>     * @private
<span id="line6187" class="line"></span>     * @inner
<span id="line6188" class="line"></span>     */
<span id="line6189" class="line"></span>    function onGestureChange( tracker, event ) {
<span id="line6190" class="line"></span>        if ( !$.eventIsCanceled( event ) ) {
<span id="line6191" class="line"></span>            event.preventDefault();
<span id="line6192" class="line"></span>        }
<span id="line6193" class="line"></span>        return false;
<span id="line6194" class="line"></span>    }
<span id="line6195" class="line"></span>
<span id="line6196" class="line"></span>
<span id="line6197" class="line"></span>    /**
<span id="line6198" class="line"></span>     * @private
<span id="line6199" class="line"></span>     * @inner
<span id="line6200" class="line"></span>     */
<span id="line6201" class="line"></span>    function onGotPointerCapture( tracker, event ) {
<span id="line6202" class="line"></span>        //$.console.log('gotpointercapture ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));
<span id="line6203" class="line"></span>
<span id="line6204" class="line"></span>        const eventInfo = {
<span id="line6205" class="line"></span>            originalEvent: event,
<span id="line6206" class="line"></span>            eventType: 'gotpointercapture',
<span id="line6207" class="line"></span>            pointerType: getPointerType( event ),
<span id="line6208" class="line"></span>            isEmulated: false
<span id="line6209" class="line"></span>        };
<span id="line6210" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line6211" class="line"></span>
<span id="line6212" class="line"></span>        if ( event.target === tracker.element ) {
<span id="line6213" class="line"></span>            //$.console.log('gotpointercapture ' + (tracker.userData ? tracker.userData.toString() : ''));
<span id="line6214" class="line"></span>            updatePointerCaptured( tracker, {
<span id="line6215" class="line"></span>                id: event.pointerId,
<span id="line6216" class="line"></span>                type: getPointerType( event )
<span id="line6217" class="line"></span>            }, true );
<span id="line6218" class="line"></span>        }
<span id="line6219" class="line"></span>
<span id="line6220" class="line"></span>        if ( eventInfo.stopPropagation ) {
<span id="line6221" class="line"></span>            $.stopEvent( event );
<span id="line6222" class="line"></span>        }
<span id="line6223" class="line"></span>    }
<span id="line6224" class="line"></span>
<span id="line6225" class="line"></span>
<span id="line6226" class="line"></span>    /**
<span id="line6227" class="line"></span>     * @private
<span id="line6228" class="line"></span>     * @inner
<span id="line6229" class="line"></span>     */
<span id="line6230" class="line"></span>    function onLostPointerCapture( tracker, event ) {
<span id="line6231" class="line"></span>        //$.console.log('lostpointercapture ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));
<span id="line6232" class="line"></span>
<span id="line6233" class="line"></span>        const eventInfo = {
<span id="line6234" class="line"></span>            originalEvent: event,
<span id="line6235" class="line"></span>            eventType: 'lostpointercapture',
<span id="line6236" class="line"></span>            pointerType: getPointerType( event ),
<span id="line6237" class="line"></span>            isEmulated: false
<span id="line6238" class="line"></span>        };
<span id="line6239" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line6240" class="line"></span>
<span id="line6241" class="line"></span>        if ( event.target === tracker.element ) {
<span id="line6242" class="line"></span>            //$.console.log('lostpointercapture ' + (tracker.userData ? tracker.userData.toString() : ''));
<span id="line6243" class="line"></span>            updatePointerCaptured( tracker, {
<span id="line6244" class="line"></span>                id: event.pointerId,
<span id="line6245" class="line"></span>                type: getPointerType( event )
<span id="line6246" class="line"></span>            }, false );
<span id="line6247" class="line"></span>        }
<span id="line6248" class="line"></span>
<span id="line6249" class="line"></span>        if ( eventInfo.stopPropagation ) {
<span id="line6250" class="line"></span>            $.stopEvent( event );
<span id="line6251" class="line"></span>        }
<span id="line6252" class="line"></span>    }
<span id="line6253" class="line"></span>
<span id="line6254" class="line"></span>
<span id="line6255" class="line"></span>    /**
<span id="line6256" class="line"></span>     * Note: Called for both pointer events and legacy mouse events
<span id="line6257" class="line"></span>     *         ($.MouseTracker.havePointerEvents determines which)
<span id="line6258" class="line"></span>     *
<span id="line6259" class="line"></span>     * @private
<span id="line6260" class="line"></span>     * @inner
<span id="line6261" class="line"></span>     */
<span id="line6262" class="line"></span>    function onPointerEnter( tracker, event ) {
<span id="line6263" class="line"></span>        //$.console.log('pointerenter ' + (tracker.userData ? tracker.userData.toString() : ''));
<span id="line6264" class="line"></span>
<span id="line6265" class="line"></span>        const gPoint = {
<span id="line6266" class="line"></span>            id: getPointerId( event ),
<span id="line6267" class="line"></span>            type: getPointerType( event ),
<span id="line6268" class="line"></span>            isPrimary: getIsPrimary( event ),
<span id="line6269" class="line"></span>            currentPos: getMouseAbsolute( event ),
<span id="line6270" class="line"></span>            currentTime: $.now()
<span id="line6271" class="line"></span>        };
<span id="line6272" class="line"></span>
<span id="line6273" class="line"></span>        // pointerenter doesn't bubble and is not cancelable, but we call
<span id="line6274" class="line"></span>        //   preProcessEvent() so it's dispatched to preProcessEventHandler
<span id="line6275" class="line"></span>        //   if necessary
<span id="line6276" class="line"></span>        const eventInfo = {
<span id="line6277" class="line"></span>            originalEvent: event,
<span id="line6278" class="line"></span>            eventType: 'pointerenter',
<span id="line6279" class="line"></span>            pointerType: gPoint.type,
<span id="line6280" class="line"></span>            isEmulated: false
<span id="line6281" class="line"></span>        };
<span id="line6282" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line6283" class="line"></span>
<span id="line6284" class="line"></span>        updatePointerEnter( tracker, eventInfo, gPoint );
<span id="line6285" class="line"></span>    }
<span id="line6286" class="line"></span>
<span id="line6287" class="line"></span>
<span id="line6288" class="line"></span>    /**
<span id="line6289" class="line"></span>     * Note: Called for both pointer events and legacy mouse events
<span id="line6290" class="line"></span>     *         ($.MouseTracker.havePointerEvents determines which)
<span id="line6291" class="line"></span>     *
<span id="line6292" class="line"></span>     * @private
<span id="line6293" class="line"></span>     * @inner
<span id="line6294" class="line"></span>     */
<span id="line6295" class="line"></span>    function onPointerLeave( tracker, event ) {
<span id="line6296" class="line"></span>        //$.console.log('pointerleave ' + (tracker.userData ? tracker.userData.toString() : ''));
<span id="line6297" class="line"></span>
<span id="line6298" class="line"></span>        const gPoint = {
<span id="line6299" class="line"></span>            id: getPointerId( event ),
<span id="line6300" class="line"></span>            type: getPointerType( event ),
<span id="line6301" class="line"></span>            isPrimary: getIsPrimary( event ),
<span id="line6302" class="line"></span>            currentPos: getMouseAbsolute( event ),
<span id="line6303" class="line"></span>            currentTime: $.now()
<span id="line6304" class="line"></span>        };
<span id="line6305" class="line"></span>
<span id="line6306" class="line"></span>        // pointerleave doesn't bubble and is not cancelable, but we call
<span id="line6307" class="line"></span>        //   preProcessEvent() so it's dispatched to preProcessEventHandler
<span id="line6308" class="line"></span>        //   if necessary
<span id="line6309" class="line"></span>        const eventInfo = {
<span id="line6310" class="line"></span>            originalEvent: event,
<span id="line6311" class="line"></span>            eventType: 'pointerleave',
<span id="line6312" class="line"></span>            pointerType: gPoint.type,
<span id="line6313" class="line"></span>            isEmulated: false
<span id="line6314" class="line"></span>        };
<span id="line6315" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line6316" class="line"></span>
<span id="line6317" class="line"></span>        updatePointerLeave( tracker, eventInfo, gPoint );
<span id="line6318" class="line"></span>    }
<span id="line6319" class="line"></span>
<span id="line6320" class="line"></span>
<span id="line6321" class="line"></span>    /**
<span id="line6322" class="line"></span>     * Note: Called for both pointer events and legacy mouse events
<span id="line6323" class="line"></span>     *         ($.MouseTracker.havePointerEvents determines which)
<span id="line6324" class="line"></span>     *
<span id="line6325" class="line"></span>     * @private
<span id="line6326" class="line"></span>     * @inner
<span id="line6327" class="line"></span>     */
<span id="line6328" class="line"></span>    function onPointerOver( tracker, event ) {
<span id="line6329" class="line"></span>        //$.console.log('pointerover ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));
<span id="line6330" class="line"></span>
<span id="line6331" class="line"></span>        const gPoint = {
<span id="line6332" class="line"></span>            id: getPointerId( event ),
<span id="line6333" class="line"></span>            type: getPointerType( event ),
<span id="line6334" class="line"></span>            isPrimary: getIsPrimary( event ),
<span id="line6335" class="line"></span>            currentPos: getMouseAbsolute( event ),
<span id="line6336" class="line"></span>            currentTime: $.now()
<span id="line6337" class="line"></span>        };
<span id="line6338" class="line"></span>
<span id="line6339" class="line"></span>        const eventInfo = {
<span id="line6340" class="line"></span>            originalEvent: event,
<span id="line6341" class="line"></span>            eventType: 'pointerover',
<span id="line6342" class="line"></span>            pointerType: gPoint.type,
<span id="line6343" class="line"></span>            isEmulated: false
<span id="line6344" class="line"></span>        };
<span id="line6345" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line6346" class="line"></span>
<span id="line6347" class="line"></span>        updatePointerOver( tracker, eventInfo, gPoint );
<span id="line6348" class="line"></span>
<span id="line6349" class="line"></span>        if ( eventInfo.preventDefault &amp;&amp; !eventInfo.defaultPrevented ) {
<span id="line6350" class="line"></span>            $.cancelEvent( event );
<span id="line6351" class="line"></span>        }
<span id="line6352" class="line"></span>        if ( eventInfo.stopPropagation ) {
<span id="line6353" class="line"></span>            $.stopEvent( event );
<span id="line6354" class="line"></span>        }
<span id="line6355" class="line"></span>    }
<span id="line6356" class="line"></span>
<span id="line6357" class="line"></span>
<span id="line6358" class="line"></span>    /**
<span id="line6359" class="line"></span>     * Note: Called for both pointer events and legacy mouse events
<span id="line6360" class="line"></span>     *         ($.MouseTracker.havePointerEvents determines which)
<span id="line6361" class="line"></span>     *
<span id="line6362" class="line"></span>     * @private
<span id="line6363" class="line"></span>     * @inner
<span id="line6364" class="line"></span>     */
<span id="line6365" class="line"></span>    function onPointerOut( tracker, event ) {
<span id="line6366" class="line"></span>        //$.console.log('pointerout ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));
<span id="line6367" class="line"></span>
<span id="line6368" class="line"></span>        const gPoint = {
<span id="line6369" class="line"></span>            id: getPointerId( event ),
<span id="line6370" class="line"></span>            type: getPointerType( event ),
<span id="line6371" class="line"></span>            isPrimary: getIsPrimary( event ),
<span id="line6372" class="line"></span>            currentPos: getMouseAbsolute( event ),
<span id="line6373" class="line"></span>            currentTime: $.now()
<span id="line6374" class="line"></span>        };
<span id="line6375" class="line"></span>
<span id="line6376" class="line"></span>        const eventInfo = {
<span id="line6377" class="line"></span>            originalEvent: event,
<span id="line6378" class="line"></span>            eventType: 'pointerout',
<span id="line6379" class="line"></span>            pointerType: gPoint.type,
<span id="line6380" class="line"></span>            isEmulated: false
<span id="line6381" class="line"></span>        };
<span id="line6382" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line6383" class="line"></span>
<span id="line6384" class="line"></span>        updatePointerOut( tracker, eventInfo, gPoint );
<span id="line6385" class="line"></span>
<span id="line6386" class="line"></span>        if ( eventInfo.preventDefault &amp;&amp; !eventInfo.defaultPrevented ) {
<span id="line6387" class="line"></span>            $.cancelEvent( event );
<span id="line6388" class="line"></span>        }
<span id="line6389" class="line"></span>        if ( eventInfo.stopPropagation ) {
<span id="line6390" class="line"></span>            $.stopEvent( event );
<span id="line6391" class="line"></span>        }
<span id="line6392" class="line"></span>    }
<span id="line6393" class="line"></span>
<span id="line6394" class="line"></span>
<span id="line6395" class="line"></span>    /**
<span id="line6396" class="line"></span>     * Note: Called for both pointer events and legacy mouse events
<span id="line6397" class="line"></span>     *         ($.MouseTracker.havePointerEvents determines which)
<span id="line6398" class="line"></span>     *
<span id="line6399" class="line"></span>     * @private
<span id="line6400" class="line"></span>     * @inner
<span id="line6401" class="line"></span>     */
<span id="line6402" class="line"></span>    function onPointerDown( tracker, event ) {
<span id="line6403" class="line"></span>        const gPoint = {
<span id="line6404" class="line"></span>            id: getPointerId( event ),
<span id="line6405" class="line"></span>            type: getPointerType( event ),
<span id="line6406" class="line"></span>            isPrimary: getIsPrimary( event ),
<span id="line6407" class="line"></span>            currentPos: getMouseAbsolute( event ),
<span id="line6408" class="line"></span>            currentTime: $.now()
<span id="line6409" class="line"></span>        };
<span id="line6410" class="line"></span>
<span id="line6411" class="line"></span>        // Most browsers implicitly capture touch pointer events
<span id="line6412" class="line"></span>        // Note no IE versions (unsupported) have element.hasPointerCapture() so
<span id="line6413" class="line"></span>        //    no implicit pointer capture possible
<span id="line6414" class="line"></span>        // var implicitlyCaptured = ($.MouseTracker.havePointerEvents &amp;&amp;
<span id="line6415" class="line"></span>        //                         event.target.hasPointerCapture &amp;&amp;
<span id="line6416" class="line"></span>        //                         $.Browser.vendor !== $.BROWSERS.IE) ?
<span id="line6417" class="line"></span>        //                         event.target.hasPointerCapture(event.pointerId) : false;
<span id="line6418" class="line"></span>        const implicitlyCaptured = $.MouseTracker.havePointerEvents &amp;&amp;
<span id="line6419" class="line"></span>                                gPoint.type === 'touch';
<span id="line6420" class="line"></span>
<span id="line6421" class="line"></span>        //$.console.log('pointerdown ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));
<span id="line6422" class="line"></span>
<span id="line6423" class="line"></span>        const eventInfo = {
<span id="line6424" class="line"></span>            originalEvent: event,
<span id="line6425" class="line"></span>            eventType: 'pointerdown',
<span id="line6426" class="line"></span>            pointerType: gPoint.type,
<span id="line6427" class="line"></span>            isEmulated: false
<span id="line6428" class="line"></span>        };
<span id="line6429" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line6430" class="line"></span>
<span id="line6431" class="line"></span>        updatePointerDown( tracker, eventInfo, gPoint, event.button );
<span id="line6432" class="line"></span>
<span id="line6433" class="line"></span>        if ( eventInfo.preventDefault &amp;&amp; !eventInfo.defaultPrevented ) {
<span id="line6434" class="line"></span>            $.cancelEvent( event );
<span id="line6435" class="line"></span>        }
<span id="line6436" class="line"></span>        if ( eventInfo.stopPropagation ) {
<span id="line6437" class="line"></span>            $.stopEvent( event );
<span id="line6438" class="line"></span>        }
<span id="line6439" class="line"></span>        if ( eventInfo.shouldCapture ) {
<span id="line6440" class="line"></span>            if ( implicitlyCaptured ) {
<span id="line6441" class="line"></span>                updatePointerCaptured( tracker, gPoint, true );
<span id="line6442" class="line"></span>            } else {
<span id="line6443" class="line"></span>                capturePointer( tracker, gPoint );
<span id="line6444" class="line"></span>            }
<span id="line6445" class="line"></span>        }
<span id="line6446" class="line"></span>    }
<span id="line6447" class="line"></span>
<span id="line6448" class="line"></span>
<span id="line6449" class="line"></span>    /**
<span id="line6450" class="line"></span>     * Note: Called for both pointer events and legacy mouse events
<span id="line6451" class="line"></span>     *         ($.MouseTracker.havePointerEvents determines which)
<span id="line6452" class="line"></span>     *
<span id="line6453" class="line"></span>     * @private
<span id="line6454" class="line"></span>     * @inner
<span id="line6455" class="line"></span>     */
<span id="line6456" class="line"></span>    function onPointerUp( tracker, event ) {
<span id="line6457" class="line"></span>        handlePointerUp( tracker, event );
<span id="line6458" class="line"></span>    }
<span id="line6459" class="line"></span>
<span id="line6460" class="line"></span>
<span id="line6461" class="line"></span>    /**
<span id="line6462" class="line"></span>     * Note: Called for both pointer events and legacy mouse events
<span id="line6463" class="line"></span>     *         ($.MouseTracker.havePointerEvents determines which)
<span id="line6464" class="line"></span>     *
<span id="line6465" class="line"></span>     * This handler is attached to the window object (on the capture phase) to emulate mouse capture.
<span id="line6466" class="line"></span>     * onPointerUp is still attached to the tracked element, so stop propagation to avoid processing twice.
<span id="line6467" class="line"></span>     *
<span id="line6468" class="line"></span>     * @private
<span id="line6469" class="line"></span>     * @inner
<span id="line6470" class="line"></span>     */
<span id="line6471" class="line"></span>    function onPointerUpCaptured( tracker, event ) {
<span id="line6472" class="line"></span>        const pointsList = tracker.getActivePointersListByType( getPointerType( event ) );
<span id="line6473" class="line"></span>        if ( pointsList.getById( event.pointerId ) ) {
<span id="line6474" class="line"></span>            handlePointerUp( tracker, event );
<span id="line6475" class="line"></span>        }
<span id="line6476" class="line"></span>        $.stopEvent( event );
<span id="line6477" class="line"></span>    }
<span id="line6478" class="line"></span>
<span id="line6479" class="line"></span>
<span id="line6480" class="line"></span>    /**
<span id="line6481" class="line"></span>     * Note: Called for both pointer events and legacy mouse events
<span id="line6482" class="line"></span>     *         ($.MouseTracker.havePointerEvents determines which)
<span id="line6483" class="line"></span>     *
<span id="line6484" class="line"></span>     * @private
<span id="line6485" class="line"></span>     * @inner
<span id="line6486" class="line"></span>     */
<span id="line6487" class="line"></span>    function handlePointerUp( tracker, event ) {
<span id="line6488" class="line"></span>        //$.console.log('pointerup ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));
<span id="line6489" class="line"></span>
<span id="line6490" class="line"></span>        const gPoint = {
<span id="line6491" class="line"></span>            id: getPointerId( event ),
<span id="line6492" class="line"></span>            type: getPointerType( event ),
<span id="line6493" class="line"></span>            isPrimary: getIsPrimary( event ),
<span id="line6494" class="line"></span>            currentPos: getMouseAbsolute( event ),
<span id="line6495" class="line"></span>            currentTime: $.now()
<span id="line6496" class="line"></span>        };
<span id="line6497" class="line"></span>
<span id="line6498" class="line"></span>        const eventInfo = {
<span id="line6499" class="line"></span>            originalEvent: event,
<span id="line6500" class="line"></span>            eventType: 'pointerup',
<span id="line6501" class="line"></span>            pointerType: gPoint.type,
<span id="line6502" class="line"></span>            isEmulated: false
<span id="line6503" class="line"></span>        };
<span id="line6504" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line6505" class="line"></span>
<span id="line6506" class="line"></span>        updatePointerUp( tracker, eventInfo, gPoint, event.button );
<span id="line6507" class="line"></span>
<span id="line6508" class="line"></span>        if ( eventInfo.preventDefault &amp;&amp; !eventInfo.defaultPrevented ) {
<span id="line6509" class="line"></span>            $.cancelEvent( event );
<span id="line6510" class="line"></span>        }
<span id="line6511" class="line"></span>        if ( eventInfo.stopPropagation ) {
<span id="line6512" class="line"></span>            $.stopEvent( event );
<span id="line6513" class="line"></span>        }
<span id="line6514" class="line"></span>
<span id="line6515" class="line"></span>        // Per spec, pointerup events are supposed to release capture. Not all browser
<span id="line6516" class="line"></span>        //   versions have adhered to the spec, and there's no harm in releasing
<span id="line6517" class="line"></span>        //   explicitly
<span id="line6518" class="line"></span>        if ( eventInfo.shouldReleaseCapture ) {
<span id="line6519" class="line"></span>            if ( event.target === tracker.element ) {
<span id="line6520" class="line"></span>                releasePointer( tracker, gPoint );
<span id="line6521" class="line"></span>            } else {
<span id="line6522" class="line"></span>                updatePointerCaptured( tracker, gPoint, false );
<span id="line6523" class="line"></span>            }
<span id="line6524" class="line"></span>        }
<span id="line6525" class="line"></span>    }
<span id="line6526" class="line"></span>
<span id="line6527" class="line"></span>
<span id="line6528" class="line"></span>    /**
<span id="line6529" class="line"></span>     * Note: Called for both pointer events and legacy mouse events
<span id="line6530" class="line"></span>     *         ($.MouseTracker.havePointerEvents determines which)
<span id="line6531" class="line"></span>     *
<span id="line6532" class="line"></span>     * @private
<span id="line6533" class="line"></span>     * @inner
<span id="line6534" class="line"></span>     */
<span id="line6535" class="line"></span>    function onPointerMove( tracker, event ) {
<span id="line6536" class="line"></span>        handlePointerMove( tracker, event );
<span id="line6537" class="line"></span>    }
<span id="line6538" class="line"></span>
<span id="line6539" class="line"></span>
<span id="line6540" class="line"></span>    /**
<span id="line6541" class="line"></span>     * Note: Called for both pointer events and legacy mouse events
<span id="line6542" class="line"></span>     *         ($.MouseTracker.havePointerEvents determines which)
<span id="line6543" class="line"></span>     *
<span id="line6544" class="line"></span>     * This handler is attached to the window object (on the capture phase) to emulate mouse capture.
<span id="line6545" class="line"></span>     * onPointerMove is still attached to the tracked element, so stop propagation to avoid processing twice.
<span id="line6546" class="line"></span>     *
<span id="line6547" class="line"></span>     * @private
<span id="line6548" class="line"></span>     * @inner
<span id="line6549" class="line"></span>     */
<span id="line6550" class="line"></span>    function onPointerMoveCaptured( tracker, event ) {
<span id="line6551" class="line"></span>        const pointsList = tracker.getActivePointersListByType( getPointerType( event ) );
<span id="line6552" class="line"></span>        if ( pointsList.getById( event.pointerId ) ) {
<span id="line6553" class="line"></span>            handlePointerMove( tracker, event );
<span id="line6554" class="line"></span>        }
<span id="line6555" class="line"></span>        $.stopEvent( event );
<span id="line6556" class="line"></span>    }
<span id="line6557" class="line"></span>
<span id="line6558" class="line"></span>
<span id="line6559" class="line"></span>    /**
<span id="line6560" class="line"></span>     * Note: Called for both pointer events and legacy mouse events
<span id="line6561" class="line"></span>     *         ($.MouseTracker.havePointerEvents determines which)
<span id="line6562" class="line"></span>     *
<span id="line6563" class="line"></span>     * @private
<span id="line6564" class="line"></span>     * @inner
<span id="line6565" class="line"></span>     */
<span id="line6566" class="line"></span>    function handlePointerMove( tracker, event ) {
<span id="line6567" class="line"></span>        // Pointer changed coordinates, button state, pressure, tilt, or contact geometry (e.g. width and height)
<span id="line6568" class="line"></span>
<span id="line6569" class="line"></span>        const gPoint = {
<span id="line6570" class="line"></span>            id: getPointerId( event ),
<span id="line6571" class="line"></span>            type: getPointerType( event ),
<span id="line6572" class="line"></span>            isPrimary: getIsPrimary( event ),
<span id="line6573" class="line"></span>            currentPos: getMouseAbsolute( event ),
<span id="line6574" class="line"></span>            currentTime: $.now()
<span id="line6575" class="line"></span>        };
<span id="line6576" class="line"></span>
<span id="line6577" class="line"></span>        const eventInfo = {
<span id="line6578" class="line"></span>            originalEvent: event,
<span id="line6579" class="line"></span>            eventType: 'pointermove',
<span id="line6580" class="line"></span>            pointerType: gPoint.type,
<span id="line6581" class="line"></span>            isEmulated: false
<span id="line6582" class="line"></span>        };
<span id="line6583" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line6584" class="line"></span>
<span id="line6585" class="line"></span>        updatePointerMove( tracker, eventInfo, gPoint );
<span id="line6586" class="line"></span>
<span id="line6587" class="line"></span>        if ( eventInfo.preventDefault &amp;&amp; !eventInfo.defaultPrevented ) {
<span id="line6588" class="line"></span>            $.cancelEvent( event );
<span id="line6589" class="line"></span>        }
<span id="line6590" class="line"></span>        if ( eventInfo.stopPropagation ) {
<span id="line6591" class="line"></span>            $.stopEvent( event );
<span id="line6592" class="line"></span>        }
<span id="line6593" class="line"></span>    }
<span id="line6594" class="line"></span>
<span id="line6595" class="line"></span>
<span id="line6596" class="line"></span>    /**
<span id="line6597" class="line"></span>     * @private
<span id="line6598" class="line"></span>     * @inner
<span id="line6599" class="line"></span>     */
<span id="line6600" class="line"></span>    function onPointerCancel( tracker, event ) {
<span id="line6601" class="line"></span>        //$.console.log('pointercancel ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));
<span id="line6602" class="line"></span>
<span id="line6603" class="line"></span>        const gPoint = {
<span id="line6604" class="line"></span>            id: event.pointerId,
<span id="line6605" class="line"></span>            type: getPointerType( event )
<span id="line6606" class="line"></span>        };
<span id="line6607" class="line"></span>
<span id="line6608" class="line"></span>        const eventInfo = {
<span id="line6609" class="line"></span>            originalEvent: event,
<span id="line6610" class="line"></span>            eventType: 'pointercancel',
<span id="line6611" class="line"></span>            pointerType: gPoint.type,
<span id="line6612" class="line"></span>            isEmulated: false
<span id="line6613" class="line"></span>        };
<span id="line6614" class="line"></span>        preProcessEvent( tracker, eventInfo );
<span id="line6615" class="line"></span>
<span id="line6616" class="line"></span>        //TODO need to only do this if our element is target?
<span id="line6617" class="line"></span>        updatePointerCancel( tracker, eventInfo, gPoint );
<span id="line6618" class="line"></span>
<span id="line6619" class="line"></span>        if ( eventInfo.stopPropagation ) {
<span id="line6620" class="line"></span>            $.stopEvent( event );
<span id="line6621" class="line"></span>        }
<span id="line6622" class="line"></span>    }
<span id="line6623" class="line"></span>
<span id="line6624" class="line"></span>
<span id="line6625" class="line"></span>///////////////////////////////////////////////////////////////////////////////
<span id="line6626" class="line"></span>// Device-agnostic DOM event handlers
<span id="line6627" class="line"></span>///////////////////////////////////////////////////////////////////////////////
<span id="line6628" class="line"></span>
<span id="line6629" class="line"></span>    /**
<span id="line6630" class="line"></span>     * @function
<span id="line6631" class="line"></span>     * @private
<span id="line6632" class="line"></span>     * @inner
<span id="line6633" class="line"></span>     * @param {OpenSeadragon.MouseTracker.GesturePointList} pointsList
<span id="line6634" class="line"></span>     *     The GesturePointList to track the pointer in.
<span id="line6635" class="line"></span>     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
<span id="line6636" class="line"></span>     *      Gesture point to track.
<span id="line6637" class="line"></span>     * @returns {Number} Number of gesture points in pointsList.
<span id="line6638" class="line"></span>     */
<span id="line6639" class="line"></span>    function startTrackingPointer( pointsList, gPoint ) {
<span id="line6640" class="line"></span>        //$.console.log('startTrackingPointer *** ' + pointsList.type + ' ' + gPoint.id.toString());
<span id="line6641" class="line"></span>        gPoint.speed = 0;
<span id="line6642" class="line"></span>        gPoint.direction = 0;
<span id="line6643" class="line"></span>        gPoint.contactPos = gPoint.currentPos;
<span id="line6644" class="line"></span>        gPoint.contactTime = gPoint.currentTime;
<span id="line6645" class="line"></span>        gPoint.lastPos = gPoint.currentPos;
<span id="line6646" class="line"></span>        gPoint.lastTime = gPoint.currentTime;
<span id="line6647" class="line"></span>
<span id="line6648" class="line"></span>        return pointsList.add( gPoint );
<span id="line6649" class="line"></span>    }
<span id="line6650" class="line"></span>
<span id="line6651" class="line"></span>
<span id="line6652" class="line"></span>    /**
<span id="line6653" class="line"></span>     * @function
<span id="line6654" class="line"></span>     * @private
<span id="line6655" class="line"></span>     * @inner
<span id="line6656" class="line"></span>     * @param {OpenSeadragon.MouseTracker} tracker
<span id="line6657" class="line"></span>     *     A reference to the MouseTracker instance.
<span id="line6658" class="line"></span>     * @param {OpenSeadragon.MouseTracker.GesturePointList} pointsList
<span id="line6659" class="line"></span>     *     The GesturePointList to stop tracking the pointer on.
<span id="line6660" class="line"></span>     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
<span id="line6661" class="line"></span>     *      Gesture point to stop tracking.
<span id="line6662" class="line"></span>     * @returns {Number} Number of gesture points in pointsList.
<span id="line6663" class="line"></span>     */
<span id="line6664" class="line"></span>    function stopTrackingPointer( tracker, pointsList, gPoint ) {
<span id="line6665" class="line"></span>        //$.console.log('stopTrackingPointer *** ' + pointsList.type + ' ' + gPoint.id.toString());
<span id="line6666" class="line"></span>        let listLength;
<span id="line6667" class="line"></span>        const trackedGPoint = pointsList.getById( gPoint.id );
<span id="line6668" class="line"></span>
<span id="line6669" class="line"></span>        if ( trackedGPoint ) {
<span id="line6670" class="line"></span>            if ( trackedGPoint.captured ) {
<span id="line6671" class="line"></span>                $.console.warn('stopTrackingPointer() called on captured pointer');
<span id="line6672" class="line"></span>                releasePointer( tracker, trackedGPoint );
<span id="line6673" class="line"></span>            }
<span id="line6674" class="line"></span>
<span id="line6675" class="line"></span>            // If child element relinquishes capture to a parent we may get here
<span id="line6676" class="line"></span>            //   from a pointerleave event while a pointerup event will never be received.
<span id="line6677" class="line"></span>            //   In that case, we'll clean up the contact count
<span id="line6678" class="line"></span>            pointsList.removeContact();
<span id="line6679" class="line"></span>
<span id="line6680" class="line"></span>            listLength = pointsList.removeById( gPoint.id );
<span id="line6681" class="line"></span>        } else {
<span id="line6682" class="line"></span>            listLength = pointsList.getLength();
<span id="line6683" class="line"></span>        }
<span id="line6684" class="line"></span>
<span id="line6685" class="line"></span>        return listLength;
<span id="line6686" class="line"></span>    }
<span id="line6687" class="line"></span>
<span id="line6688" class="line"></span>
<span id="line6689" class="line"></span>    /**
<span id="line6690" class="line"></span>     * @function
<span id="line6691" class="line"></span>     * @private
<span id="line6692" class="line"></span>     * @inner
<span id="line6693" class="line"></span>     */
<span id="line6694" class="line"></span>    function getEventProcessDefaults( tracker, eventInfo ) {
<span id="line6695" class="line"></span>        switch ( eventInfo.eventType ) {
<span id="line6696" class="line"></span>            case 'pointermove':
<span id="line6697" class="line"></span>                eventInfo.isStoppable = true;
<span id="line6698" class="line"></span>                eventInfo.isCancelable = true;
<span id="line6699" class="line"></span>                eventInfo.preventDefault = false;
<span id="line6700" class="line"></span>                eventInfo.preventGesture = !tracker.hasGestureHandlers;
<span id="line6701" class="line"></span>                eventInfo.stopPropagation = false;
<span id="line6702" class="line"></span>                break;
<span id="line6703" class="line"></span>            case 'pointerover':
<span id="line6704" class="line"></span>            case 'pointerout':
<span id="line6705" class="line"></span>            case 'contextmenu':
<span id="line6706" class="line"></span>            case 'keydown':
<span id="line6707" class="line"></span>            case 'keyup':
<span id="line6708" class="line"></span>            case 'keypress':
<span id="line6709" class="line"></span>                eventInfo.isStoppable = true;
<span id="line6710" class="line"></span>                eventInfo.isCancelable = true;
<span id="line6711" class="line"></span>                eventInfo.preventDefault = false; // onContextMenu(), onKeyDown(), onKeyUp(), onKeyPress() may set true
<span id="line6712" class="line"></span>                eventInfo.preventGesture = false;
<span id="line6713" class="line"></span>                eventInfo.stopPropagation = false;
<span id="line6714" class="line"></span>                break;
<span id="line6715" class="line"></span>            case 'pointerdown':
<span id="line6716" class="line"></span>                eventInfo.isStoppable = true;
<span id="line6717" class="line"></span>                eventInfo.isCancelable = true;
<span id="line6718" class="line"></span>                eventInfo.preventDefault = false; // updatePointerDown() may set true (tracker.hasGestureHandlers)
<span id="line6719" class="line"></span>                eventInfo.preventGesture = !tracker.hasGestureHandlers;
<span id="line6720" class="line"></span>                eventInfo.stopPropagation = false;
<span id="line6721" class="line"></span>                break;
<span id="line6722" class="line"></span>            case 'pointerup':
<span id="line6723" class="line"></span>                eventInfo.isStoppable = true;
<span id="line6724" class="line"></span>                eventInfo.isCancelable = true;
<span id="line6725" class="line"></span>                eventInfo.preventDefault = false;
<span id="line6726" class="line"></span>                eventInfo.preventGesture = !tracker.hasGestureHandlers;
<span id="line6727" class="line"></span>                eventInfo.stopPropagation = false;
<span id="line6728" class="line"></span>                break;
<span id="line6729" class="line"></span>            case 'wheel':
<span id="line6730" class="line"></span>                eventInfo.isStoppable = true;
<span id="line6731" class="line"></span>                eventInfo.isCancelable = true;
<span id="line6732" class="line"></span>                eventInfo.preventDefault = false; // handleWheelEvent() may set true
<span id="line6733" class="line"></span>                eventInfo.preventGesture = !tracker.hasScrollHandler;
<span id="line6734" class="line"></span>                eventInfo.stopPropagation = false;
<span id="line6735" class="line"></span>                break;
<span id="line6736" class="line"></span>            case 'gotpointercapture':
<span id="line6737" class="line"></span>            case 'lostpointercapture':
<span id="line6738" class="line"></span>            case 'pointercancel':
<span id="line6739" class="line"></span>                eventInfo.isStoppable = true;
<span id="line6740" class="line"></span>                eventInfo.isCancelable = false;
<span id="line6741" class="line"></span>                eventInfo.preventDefault = false;
<span id="line6742" class="line"></span>                eventInfo.preventGesture = false;
<span id="line6743" class="line"></span>                eventInfo.stopPropagation = false;
<span id="line6744" class="line"></span>                break;
<span id="line6745" class="line"></span>            case 'click':
<span id="line6746" class="line"></span>                eventInfo.isStoppable = true;
<span id="line6747" class="line"></span>                eventInfo.isCancelable = true;
<span id="line6748" class="line"></span>                eventInfo.preventDefault = !!tracker.clickHandler;
<span id="line6749" class="line"></span>                eventInfo.preventGesture = false;
<span id="line6750" class="line"></span>                eventInfo.stopPropagation = false;
<span id="line6751" class="line"></span>                break;
<span id="line6752" class="line"></span>            case 'dblclick':
<span id="line6753" class="line"></span>                eventInfo.isStoppable = true;
<span id="line6754" class="line"></span>                eventInfo.isCancelable = true;
<span id="line6755" class="line"></span>                eventInfo.preventDefault = !!tracker.dblClickHandler;
<span id="line6756" class="line"></span>                eventInfo.preventGesture = false;
<span id="line6757" class="line"></span>                eventInfo.stopPropagation = false;
<span id="line6758" class="line"></span>                break;
<span id="line6759" class="line"></span>            case 'focus':
<span id="line6760" class="line"></span>            case 'blur':
<span id="line6761" class="line"></span>            case 'pointerenter':
<span id="line6762" class="line"></span>            case 'pointerleave':
<span id="line6763" class="line"></span>            default:
<span id="line6764" class="line"></span>                eventInfo.isStoppable = false;
<span id="line6765" class="line"></span>                eventInfo.isCancelable = false;
<span id="line6766" class="line"></span>                eventInfo.preventDefault = false;
<span id="line6767" class="line"></span>                eventInfo.preventGesture = false;
<span id="line6768" class="line"></span>                eventInfo.stopPropagation = false;
<span id="line6769" class="line"></span>                break;
<span id="line6770" class="line"></span>        }
<span id="line6771" class="line"></span>    }
<span id="line6772" class="line"></span>
<span id="line6773" class="line"></span>
<span id="line6774" class="line"></span>    /**
<span id="line6775" class="line"></span>     * Sets up for and calls preProcessEventHandler. Call with the following parameters -
<span id="line6776" class="line"></span>     * this function will fill in the rest of the preProcessEventHandler event object
<span id="line6777" class="line"></span>     * properties
<span id="line6778" class="line"></span>     *
<span id="line6779" class="line"></span>     * @function
<span id="line6780" class="line"></span>     * @private
<span id="line6781" class="line"></span>     * @inner
<span id="line6782" class="line"></span>     * @param {OpenSeadragon.MouseTracker} tracker
<span id="line6783" class="line"></span>     *     A reference to the MouseTracker instance.
<span id="line6784" class="line"></span>     * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
<span id="line6785" class="line"></span>     * @param {Object} eventInfo.originalEvent
<span id="line6786" class="line"></span>     * @param {String} eventInfo.eventType
<span id="line6787" class="line"></span>     * @param {String} eventInfo.pointerType
<span id="line6788" class="line"></span>     * @param {Boolean} eventInfo.isEmulated
<span id="line6789" class="line"></span>     */
<span id="line6790" class="line"></span>    function preProcessEvent( tracker, eventInfo ) {
<span id="line6791" class="line"></span>        eventInfo.eventSource = tracker;
<span id="line6792" class="line"></span>        eventInfo.eventPhase = eventInfo.originalEvent ?
<span id="line6793" class="line"></span>                        ((typeof eventInfo.originalEvent.eventPhase !== 'undefined') ?
<span id="line6794" class="line"></span>                                            eventInfo.originalEvent.eventPhase : 0) : 0;
<span id="line6795" class="line"></span>        eventInfo.defaultPrevented = $.eventIsCanceled( eventInfo.originalEvent );
<span id="line6796" class="line"></span>        eventInfo.shouldCapture = false;
<span id="line6797" class="line"></span>        eventInfo.shouldReleaseCapture = false;
<span id="line6798" class="line"></span>        eventInfo.userData = tracker.userData;
<span id="line6799" class="line"></span>
<span id="line6800" class="line"></span>        getEventProcessDefaults( tracker, eventInfo );
<span id="line6801" class="line"></span>
<span id="line6802" class="line"></span>        if ( tracker.preProcessEventHandler ) {
<span id="line6803" class="line"></span>            tracker.preProcessEventHandler( eventInfo );
<span id="line6804" class="line"></span>        }
<span id="line6805" class="line"></span>    }
<span id="line6806" class="line"></span>
<span id="line6807" class="line"></span>
<span id="line6808" class="line"></span>    /**
<span id="line6809" class="line"></span>     * Sets or resets the captured property on the tracked pointer matching the passed gPoint's id/type
<span id="line6810" class="line"></span>     *
<span id="line6811" class="line"></span>     * @function
<span id="line6812" class="line"></span>     * @private
<span id="line6813" class="line"></span>     * @inner
<span id="line6814" class="line"></span>     * @param {OpenSeadragon.MouseTracker} tracker
<span id="line6815" class="line"></span>     *     A reference to the MouseTracker instance.
<span id="line6816" class="line"></span>     * @param {Object} gPoint
<span id="line6817" class="line"></span>     *     An object with id and type properties describing the pointer to update.
<span id="line6818" class="line"></span>     * @param {Boolean} isCaptured
<span id="line6819" class="line"></span>     *      Value to set the captured property to.
<span id="line6820" class="line"></span>     */
<span id="line6821" class="line"></span>    function updatePointerCaptured( tracker, gPoint, isCaptured ) {
<span id="line6822" class="line"></span>        const pointsList = tracker.getActivePointersListByType( gPoint.type );
<span id="line6823" class="line"></span>        const updateGPoint = pointsList.getById( gPoint.id );
<span id="line6824" class="line"></span>
<span id="line6825" class="line"></span>        if ( updateGPoint ) {
<span id="line6826" class="line"></span>            if ( isCaptured &amp;&amp; !updateGPoint.captured ) {
<span id="line6827" class="line"></span>                updateGPoint.captured = true;
<span id="line6828" class="line"></span>                pointsList.captureCount++;
<span id="line6829" class="line"></span>            } else if ( !isCaptured &amp;&amp; updateGPoint.captured ) {
<span id="line6830" class="line"></span>                updateGPoint.captured = false;
<span id="line6831" class="line"></span>                pointsList.captureCount--;
<span id="line6832" class="line"></span>                if ( pointsList.captureCount &lt; 0 ) {
<span id="line6833" class="line"></span>                    pointsList.captureCount = 0;
<span id="line6834" class="line"></span>                    $.console.warn('updatePointerCaptured() - pointsList.captureCount went negative');
<span id="line6835" class="line"></span>                }
<span id="line6836" class="line"></span>            }
<span id="line6837" class="line"></span>        } else {
<span id="line6838" class="line"></span>            $.console.warn('updatePointerCaptured() called on untracked pointer');
<span id="line6839" class="line"></span>        }
<span id="line6840" class="line"></span>    }
<span id="line6841" class="line"></span>
<span id="line6842" class="line"></span>
<span id="line6843" class="line"></span>    /**
<span id="line6844" class="line"></span>     * @function
<span id="line6845" class="line"></span>     * @private
<span id="line6846" class="line"></span>     * @inner
<span id="line6847" class="line"></span>     * @param {OpenSeadragon.MouseTracker} tracker
<span id="line6848" class="line"></span>     *     A reference to the MouseTracker instance.
<span id="line6849" class="line"></span>     * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
<span id="line6850" class="line"></span>     *     Processing info for originating DOM event.
<span id="line6851" class="line"></span>     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
<span id="line6852" class="line"></span>     *      Gesture point associated with the event.
<span id="line6853" class="line"></span>     */
<span id="line6854" class="line"></span>    function updatePointerEnter( tracker, eventInfo, gPoint ) {
<span id="line6855" class="line"></span>        const pointsList = tracker.getActivePointersListByType( gPoint.type );
<span id="line6856" class="line"></span>        const updateGPoint = pointsList.getById( gPoint.id );
<span id="line6857" class="line"></span>
<span id="line6858" class="line"></span>        if ( updateGPoint ) {
<span id="line6859" class="line"></span>            // Already tracking the pointer...update it
<span id="line6860" class="line"></span>            updateGPoint.insideElement = true;
<span id="line6861" class="line"></span>            updateGPoint.lastPos = updateGPoint.currentPos;
<span id="line6862" class="line"></span>            updateGPoint.lastTime = updateGPoint.currentTime;
<span id="line6863" class="line"></span>            updateGPoint.currentPos = gPoint.currentPos;
<span id="line6864" class="line"></span>            updateGPoint.currentTime = gPoint.currentTime;
<span id="line6865" class="line"></span>
<span id="line6866" class="line"></span>            gPoint = updateGPoint;
<span id="line6867" class="line"></span>        } else {
<span id="line6868" class="line"></span>            // Initialize for tracking and add to the tracking list
<span id="line6869" class="line"></span>            gPoint.captured = false; // Handled by updatePointerCaptured()
<span id="line6870" class="line"></span>            gPoint.insideElementPressed = false;
<span id="line6871" class="line"></span>            gPoint.insideElement = true;
<span id="line6872" class="line"></span>            startTrackingPointer( pointsList, gPoint );
<span id="line6873" class="line"></span>        }
<span id="line6874" class="line"></span>
<span id="line6875" class="line"></span>        // Enter (doesn't bubble and not cancelable)
<span id="line6876" class="line"></span>        if ( tracker.enterHandler ) {
<span id="line6877" class="line"></span>            tracker.enterHandler(
<span id="line6878" class="line"></span>                {
<span id="line6879" class="line"></span>                    eventSource:          tracker,
<span id="line6880" class="line"></span>                    pointerType:          gPoint.type,
<span id="line6881" class="line"></span>                    position:             getPointRelativeToAbsolute( gPoint.currentPos, tracker.element ),
<span id="line6882" class="line"></span>                    buttons:              pointsList.buttons,
<span id="line6883" class="line"></span>                    pointers:             tracker.getActivePointerCount(),
<span id="line6884" class="line"></span>                    insideElementPressed: gPoint.insideElementPressed,
<span id="line6885" class="line"></span>                    buttonDownAny:        pointsList.buttons !== 0,
<span id="line6886" class="line"></span>                    isTouchEvent:         gPoint.type === 'touch',
<span id="line6887" class="line"></span>                    originalEvent:        eventInfo.originalEvent,
<span id="line6888" class="line"></span>                    userData:             tracker.userData
<span id="line6889" class="line"></span>                }
<span id="line6890" class="line"></span>            );
<span id="line6891" class="line"></span>        }
<span id="line6892" class="line"></span>    }
<span id="line6893" class="line"></span>
<span id="line6894" class="line"></span>
<span id="line6895" class="line"></span>    /**
<span id="line6896" class="line"></span>     * @function
<span id="line6897" class="line"></span>     * @private
<span id="line6898" class="line"></span>     * @inner
<span id="line6899" class="line"></span>     * @param {OpenSeadragon.MouseTracker} tracker
<span id="line6900" class="line"></span>     *     A reference to the MouseTracker instance.
<span id="line6901" class="line"></span>     * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
<span id="line6902" class="line"></span>     *     Processing info for originating DOM event.
<span id="line6903" class="line"></span>     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
<span id="line6904" class="line"></span>     *      Gesture point associated with the event.
<span id="line6905" class="line"></span>     */
<span id="line6906" class="line"></span>    function updatePointerLeave( tracker, eventInfo, gPoint ) {
<span id="line6907" class="line"></span>        const pointsList = tracker.getActivePointersListByType(gPoint.type);
<span id="line6908" class="line"></span>        const updateGPoint = pointsList.getById( gPoint.id );
<span id="line6909" class="line"></span>
<span id="line6910" class="line"></span>        if ( updateGPoint ) {
<span id="line6911" class="line"></span>            // Already tracking the pointer. If captured then update it, else stop tracking it
<span id="line6912" class="line"></span>            if ( updateGPoint.captured ) {
<span id="line6913" class="line"></span>                updateGPoint.insideElement = false;
<span id="line6914" class="line"></span>                updateGPoint.lastPos = updateGPoint.currentPos;
<span id="line6915" class="line"></span>                updateGPoint.lastTime = updateGPoint.currentTime;
<span id="line6916" class="line"></span>                updateGPoint.currentPos = gPoint.currentPos;
<span id="line6917" class="line"></span>                updateGPoint.currentTime = gPoint.currentTime;
<span id="line6918" class="line"></span>            } else {
<span id="line6919" class="line"></span>                stopTrackingPointer( tracker, pointsList, updateGPoint );
<span id="line6920" class="line"></span>            }
<span id="line6921" class="line"></span>
<span id="line6922" class="line"></span>            gPoint = updateGPoint;
<span id="line6923" class="line"></span>        } else {
<span id="line6924" class="line"></span>            gPoint.captured = false; // Handled by updatePointerCaptured()
<span id="line6925" class="line"></span>            gPoint.insideElementPressed = false;
<span id="line6926" class="line"></span>        }
<span id="line6927" class="line"></span>
<span id="line6928" class="line"></span>        // Leave (doesn't bubble and not cancelable)
<span id="line6929" class="line"></span>        //   Note: exitHandler is deprecated (v2.5.0), replaced by leaveHandler
<span id="line6930" class="line"></span>        if ( tracker.leaveHandler || tracker.exitHandler ) {
<span id="line6931" class="line"></span>            const dispatchEventObj = {
<span id="line6932" class="line"></span>                eventSource:          tracker,
<span id="line6933" class="line"></span>                pointerType:          gPoint.type,
<span id="line6934" class="line"></span>                // GitHub PR: https://github.com/openseadragon/openseadragon/pull/1754 (gPoint.currentPos &amp;&amp; )
<span id="line6935" class="line"></span>                position:             gPoint.currentPos &amp;&amp; getPointRelativeToAbsolute( gPoint.currentPos, tracker.element ),
<span id="line6936" class="line"></span>                buttons:              pointsList.buttons,
<span id="line6937" class="line"></span>                pointers:             tracker.getActivePointerCount(),
<span id="line6938" class="line"></span>                insideElementPressed: gPoint.insideElementPressed,
<span id="line6939" class="line"></span>                buttonDownAny:        pointsList.buttons !== 0,
<span id="line6940" class="line"></span>                isTouchEvent:         gPoint.type === 'touch',
<span id="line6941" class="line"></span>                originalEvent:        eventInfo.originalEvent,
<span id="line6942" class="line"></span>                userData:             tracker.userData
<span id="line6943" class="line"></span>            };
<span id="line6944" class="line"></span>
<span id="line6945" class="line"></span>            if ( tracker.leaveHandler ) {
<span id="line6946" class="line"></span>                tracker.leaveHandler( dispatchEventObj );
<span id="line6947" class="line"></span>            }
<span id="line6948" class="line"></span>            // Deprecated
<span id="line6949" class="line"></span>            if ( tracker.exitHandler ) {
<span id="line6950" class="line"></span>                tracker.exitHandler( dispatchEventObj );
<span id="line6951" class="line"></span>            }
<span id="line6952" class="line"></span>        }
<span id="line6953" class="line"></span>    }
<span id="line6954" class="line"></span>
<span id="line6955" class="line"></span>
<span id="line6956" class="line"></span>    /**
<span id="line6957" class="line"></span>     * @function
<span id="line6958" class="line"></span>     * @private
<span id="line6959" class="line"></span>     * @inner
<span id="line6960" class="line"></span>     * @param {OpenSeadragon.MouseTracker} tracker
<span id="line6961" class="line"></span>     *     A reference to the MouseTracker instance.
<span id="line6962" class="line"></span>     * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
<span id="line6963" class="line"></span>     *     Processing info for originating DOM event.
<span id="line6964" class="line"></span>     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
<span id="line6965" class="line"></span>     *      Gesture point associated with the event.
<span id="line6966" class="line"></span>     */
<span id="line6967" class="line"></span>    function updatePointerOver( tracker, eventInfo, gPoint ) {
<span id="line6968" class="line"></span>        const pointsList = tracker.getActivePointersListByType( gPoint.type );
<span id="line6969" class="line"></span>        const updateGPoint = pointsList.getById( gPoint.id );
<span id="line6970" class="line"></span>
<span id="line6971" class="line"></span>        if ( updateGPoint ) {
<span id="line6972" class="line"></span>            gPoint = updateGPoint;
<span id="line6973" class="line"></span>        } else {
<span id="line6974" class="line"></span>            gPoint.captured = false;
<span id="line6975" class="line"></span>            gPoint.insideElementPressed = false;
<span id="line6976" class="line"></span>            //gPoint.insideElement = true; // Tracked by updatePointerEnter
<span id="line6977" class="line"></span>        }
<span id="line6978" class="line"></span>
<span id="line6979" class="line"></span>        if ( tracker.overHandler ) {
<span id="line6980" class="line"></span>            // Over
<span id="line6981" class="line"></span>            tracker.overHandler(
<span id="line6982" class="line"></span>                {
<span id="line6983" class="line"></span>                    eventSource:          tracker,
<span id="line6984" class="line"></span>                    pointerType:          gPoint.type,
<span id="line6985" class="line"></span>                    position:             getPointRelativeToAbsolute( gPoint.currentPos, tracker.element ),
<span id="line6986" class="line"></span>                    buttons:              pointsList.buttons,
<span id="line6987" class="line"></span>                    pointers:             tracker.getActivePointerCount(),
<span id="line6988" class="line"></span>                    insideElementPressed: gPoint.insideElementPressed,
<span id="line6989" class="line"></span>                    buttonDownAny:        pointsList.buttons !== 0,
<span id="line6990" class="line"></span>                    isTouchEvent:         gPoint.type === 'touch',
<span id="line6991" class="line"></span>                    originalEvent:        eventInfo.originalEvent,
<span id="line6992" class="line"></span>                    userData:             tracker.userData
<span id="line6993" class="line"></span>                }
<span id="line6994" class="line"></span>            );
<span id="line6995" class="line"></span>        }
<span id="line6996" class="line"></span>    }
<span id="line6997" class="line"></span>
<span id="line6998" class="line"></span>    /**
<span id="line6999" class="line"></span>     * @function
<span id="line7000" class="line"></span>     * @private
<span id="line7001" class="line"></span>     * @inner
<span id="line7002" class="line"></span>     * @param {OpenSeadragon.MouseTracker} tracker
<span id="line7003" class="line"></span>     *     A reference to the MouseTracker instance.
<span id="line7004" class="line"></span>     * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
<span id="line7005" class="line"></span>     *     Processing info for originating DOM event.
<span id="line7006" class="line"></span>     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
<span id="line7007" class="line"></span>     *      Gesture point associated with the event.
<span id="line7008" class="line"></span>     */
<span id="line7009" class="line"></span>    function updatePointerOut( tracker, eventInfo, gPoint ) {
<span id="line7010" class="line"></span>        const pointsList = tracker.getActivePointersListByType(gPoint.type);
<span id="line7011" class="line"></span>        const updateGPoint = pointsList.getById( gPoint.id );
<span id="line7012" class="line"></span>
<span id="line7013" class="line"></span>        if ( updateGPoint ) {
<span id="line7014" class="line"></span>            gPoint = updateGPoint;
<span id="line7015" class="line"></span>        } else {
<span id="line7016" class="line"></span>            gPoint.captured = false;
<span id="line7017" class="line"></span>            gPoint.insideElementPressed = false;
<span id="line7018" class="line"></span>            //gPoint.insideElement = true; // Tracked by updatePointerEnter
<span id="line7019" class="line"></span>        }
<span id="line7020" class="line"></span>
<span id="line7021" class="line"></span>        if ( tracker.outHandler ) {
<span id="line7022" class="line"></span>            // Out
<span id="line7023" class="line"></span>            tracker.outHandler( {
<span id="line7024" class="line"></span>                eventSource:          tracker,
<span id="line7025" class="line"></span>                pointerType:          gPoint.type,
<span id="line7026" class="line"></span>                position:             gPoint.currentPos &amp;&amp; getPointRelativeToAbsolute( gPoint.currentPos, tracker.element ),
<span id="line7027" class="line"></span>                buttons:              pointsList.buttons,
<span id="line7028" class="line"></span>                pointers:             tracker.getActivePointerCount(),
<span id="line7029" class="line"></span>                insideElementPressed: gPoint.insideElementPressed,
<span id="line7030" class="line"></span>                buttonDownAny:        pointsList.buttons !== 0,
<span id="line7031" class="line"></span>                isTouchEvent:         gPoint.type === 'touch',
<span id="line7032" class="line"></span>                originalEvent:        eventInfo.originalEvent,
<span id="line7033" class="line"></span>                userData:             tracker.userData
<span id="line7034" class="line"></span>            } );
<span id="line7035" class="line"></span>        }
<span id="line7036" class="line"></span>    }
<span id="line7037" class="line"></span>
<span id="line7038" class="line"></span>
<span id="line7039" class="line"></span>    /**
<span id="line7040" class="line"></span>     * @function
<span id="line7041" class="line"></span>     * @private
<span id="line7042" class="line"></span>     * @inner
<span id="line7043" class="line"></span>     * @param {OpenSeadragon.MouseTracker} tracker
<span id="line7044" class="line"></span>     *     A reference to the MouseTracker instance.
<span id="line7045" class="line"></span>     * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
<span id="line7046" class="line"></span>     *     Processing info for originating DOM event.
<span id="line7047" class="line"></span>     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
<span id="line7048" class="line"></span>     *      Gesture point associated with the event.
<span id="line7049" class="line"></span>     * @param {Number} buttonChanged
<span id="line7050" class="line"></span>     *      The button involved in the event: -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
<span id="line7051" class="line"></span>     *      Note on chorded button presses (a button pressed when another button is already pressed): In the W3C Pointer Events model,
<span id="line7052" class="line"></span>     *      only one pointerdown/pointerup event combo is fired. Chorded button state changes instead fire pointermove events.
<span id="line7053" class="line"></span>     */
<span id="line7054" class="line"></span>    function updatePointerDown( tracker, eventInfo, gPoint, buttonChanged ) {
<span id="line7055" class="line"></span>        const delegate = THIS[ tracker.hash ];
<span id="line7056" class="line"></span>        const pointsList = tracker.getActivePointersListByType( gPoint.type );
<span id="line7057" class="line"></span>
<span id="line7058" class="line"></span>        if ( typeof eventInfo.originalEvent.buttons !== 'undefined' ) {
<span id="line7059" class="line"></span>            pointsList.buttons = eventInfo.originalEvent.buttons;
<span id="line7060" class="line"></span>        } else {
<span id="line7061" class="line"></span>            if ( buttonChanged === 0 ) {
<span id="line7062" class="line"></span>                // Primary
<span id="line7063" class="line"></span>                pointsList.buttons |= 1;
<span id="line7064" class="line"></span>            } else if ( buttonChanged === 1 ) {
<span id="line7065" class="line"></span>                // Aux
<span id="line7066" class="line"></span>                pointsList.buttons |= 4;
<span id="line7067" class="line"></span>            } else if ( buttonChanged === 2 ) {
<span id="line7068" class="line"></span>                // Secondary
<span id="line7069" class="line"></span>                pointsList.buttons |= 2;
<span id="line7070" class="line"></span>            } else if ( buttonChanged === 3 ) {
<span id="line7071" class="line"></span>                // X1 (Back)
<span id="line7072" class="line"></span>                pointsList.buttons |= 8;
<span id="line7073" class="line"></span>            } else if ( buttonChanged === 4 ) {
<span id="line7074" class="line"></span>                // X2 (Forward)
<span id="line7075" class="line"></span>                pointsList.buttons |= 16;
<span id="line7076" class="line"></span>            } else if ( buttonChanged === 5 ) {
<span id="line7077" class="line"></span>                // Pen Eraser
<span id="line7078" class="line"></span>                pointsList.buttons |= 32;
<span id="line7079" class="line"></span>            }
<span id="line7080" class="line"></span>        }
<span id="line7081" class="line"></span>
<span id="line7082" class="line"></span>        // Only capture and track primary button, pen, and touch contacts
<span id="line7083" class="line"></span>        if ( buttonChanged !== 0 ) {
<span id="line7084" class="line"></span>            eventInfo.shouldCapture = false;
<span id="line7085" class="line"></span>            eventInfo.shouldReleaseCapture = false;
<span id="line7086" class="line"></span>
<span id="line7087" class="line"></span>            // Aux Press
<span id="line7088" class="line"></span>            if ( tracker.nonPrimaryPressHandler &amp;&amp;
<span id="line7089" class="line"></span>                                !eventInfo.preventGesture &amp;&amp;
<span id="line7090" class="line"></span>                                !eventInfo.defaultPrevented ) {
<span id="line7091" class="line"></span>                eventInfo.preventDefault = true;
<span id="line7092" class="line"></span>
<span id="line7093" class="line"></span>                tracker.nonPrimaryPressHandler(
<span id="line7094" class="line"></span>                    {
<span id="line7095" class="line"></span>                        eventSource:          tracker,
<span id="line7096" class="line"></span>                        pointerType:          gPoint.type,
<span id="line7097" class="line"></span>                        position:             getPointRelativeToAbsolute( gPoint.currentPos, tracker.element ),
<span id="line7098" class="line"></span>                        button:               buttonChanged,
<span id="line7099" class="line"></span>                        buttons:              pointsList.buttons,
<span id="line7100" class="line"></span>                        isTouchEvent:         gPoint.type === 'touch',
<span id="line7101" class="line"></span>                        originalEvent:        eventInfo.originalEvent,
<span id="line7102" class="line"></span>                        userData:             tracker.userData
<span id="line7103" class="line"></span>                    }
<span id="line7104" class="line"></span>                );
<span id="line7105" class="line"></span>            }
<span id="line7106" class="line"></span>
<span id="line7107" class="line"></span>            return;
<span id="line7108" class="line"></span>        }
<span id="line7109" class="line"></span>
<span id="line7110" class="line"></span>        const updateGPoint = pointsList.getById( gPoint.id );
<span id="line7111" class="line"></span>
<span id="line7112" class="line"></span>        if ( updateGPoint ) {
<span id="line7113" class="line"></span>            // Already tracking the pointer...update it
<span id="line7114" class="line"></span>            //updateGPoint.captured = true; // Handled by updatePointerCaptured()
<span id="line7115" class="line"></span>            updateGPoint.insideElementPressed = true;
<span id="line7116" class="line"></span>            updateGPoint.insideElement = true;
<span id="line7117" class="line"></span>            updateGPoint.originalTarget = eventInfo.originalEvent.target;
<span id="line7118" class="line"></span>            updateGPoint.contactPos = gPoint.currentPos;
<span id="line7119" class="line"></span>            updateGPoint.contactTime = gPoint.currentTime;
<span id="line7120" class="line"></span>            updateGPoint.lastPos = updateGPoint.currentPos;
<span id="line7121" class="line"></span>            updateGPoint.lastTime = updateGPoint.currentTime;
<span id="line7122" class="line"></span>            updateGPoint.currentPos = gPoint.currentPos;
<span id="line7123" class="line"></span>            updateGPoint.currentTime = gPoint.currentTime;
<span id="line7124" class="line"></span>
<span id="line7125" class="line"></span>            gPoint = updateGPoint;
<span id="line7126" class="line"></span>        } else {
<span id="line7127" class="line"></span>            // Initialize for tracking and add to the tracking list (no pointerenter event occurred before this)
<span id="line7128" class="line"></span>            // NOTE: pointerdown event on untracked pointer
<span id="line7129" class="line"></span>            gPoint.captured = false; // Handled by updatePointerCaptured()
<span id="line7130" class="line"></span>            gPoint.insideElementPressed = true;
<span id="line7131" class="line"></span>            gPoint.insideElement = true;
<span id="line7132" class="line"></span>            gPoint.originalTarget = eventInfo.originalEvent.target;
<span id="line7133" class="line"></span>            startTrackingPointer( pointsList, gPoint );
<span id="line7134" class="line"></span>        }
<span id="line7135" class="line"></span>
<span id="line7136" class="line"></span>        pointsList.addContact();
<span id="line7137" class="line"></span>        //$.console.log('contacts++ ', pointsList.contacts);
<span id="line7138" class="line"></span>
<span id="line7139" class="line"></span>        if ( !eventInfo.preventGesture &amp;&amp; !eventInfo.defaultPrevented ) {
<span id="line7140" class="line"></span>            eventInfo.shouldCapture = true;
<span id="line7141" class="line"></span>            eventInfo.shouldReleaseCapture = false;
<span id="line7142" class="line"></span>            eventInfo.preventDefault = true;
<span id="line7143" class="line"></span>
<span id="line7144" class="line"></span>            if ( tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler ) {
<span id="line7145" class="line"></span>                $.MouseTracker.gesturePointVelocityTracker.addPoint( tracker, gPoint );
<span id="line7146" class="line"></span>            }
<span id="line7147" class="line"></span>
<span id="line7148" class="line"></span>            if ( pointsList.contacts === 1 ) {
<span id="line7149" class="line"></span>                // Press
<span id="line7150" class="line"></span>                if ( tracker.pressHandler &amp;&amp; !eventInfo.preventGesture ) {
<span id="line7151" class="line"></span>                    tracker.pressHandler(
<span id="line7152" class="line"></span>                        {
<span id="line7153" class="line"></span>                            eventSource:          tracker,
<span id="line7154" class="line"></span>                            pointerType:          gPoint.type,
<span id="line7155" class="line"></span>                            position:             getPointRelativeToAbsolute( gPoint.contactPos, tracker.element ),
<span id="line7156" class="line"></span>                            buttons:              pointsList.buttons,
<span id="line7157" class="line"></span>                            isTouchEvent:         gPoint.type === 'touch',
<span id="line7158" class="line"></span>                            originalEvent:        eventInfo.originalEvent,
<span id="line7159" class="line"></span>                            userData:             tracker.userData
<span id="line7160" class="line"></span>                        }
<span id="line7161" class="line"></span>                    );
<span id="line7162" class="line"></span>                }
<span id="line7163" class="line"></span>            } else if ( pointsList.contacts === 2 ) {
<span id="line7164" class="line"></span>                if ( tracker.pinchHandler &amp;&amp; gPoint.type === 'touch' ) {
<span id="line7165" class="line"></span>                    // Initialize for pinch
<span id="line7166" class="line"></span>                    delegate.pinchGPoints = pointsList.asArray();
<span id="line7167" class="line"></span>                    delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[ 0 ].currentPos.distanceTo( delegate.pinchGPoints[ 1 ].currentPos );
<span id="line7168" class="line"></span>                    delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint( delegate.pinchGPoints[ 0 ].currentPos, delegate.pinchGPoints[ 1 ].currentPos );
<span id="line7169" class="line"></span>                }
<span id="line7170" class="line"></span>            }
<span id="line7171" class="line"></span>        } else {
<span id="line7172" class="line"></span>            eventInfo.shouldCapture = false;
<span id="line7173" class="line"></span>            eventInfo.shouldReleaseCapture = false;
<span id="line7174" class="line"></span>        }
<span id="line7175" class="line"></span>    }
<span id="line7176" class="line"></span>
<span id="line7177" class="line"></span>
<span id="line7178" class="line"></span>    /**
<span id="line7179" class="line"></span>     * @function
<span id="line7180" class="line"></span>     * @private
<span id="line7181" class="line"></span>     * @inner
<span id="line7182" class="line"></span>     * @param {OpenSeadragon.MouseTracker} tracker
<span id="line7183" class="line"></span>     *     A reference to the MouseTracker instance.
<span id="line7184" class="line"></span>     * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
<span id="line7185" class="line"></span>     *     Processing info for originating DOM event.
<span id="line7186" class="line"></span>     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
<span id="line7187" class="line"></span>     *      Gesture points associated with the event.
<span id="line7188" class="line"></span>     * @param {Number} buttonChanged
<span id="line7189" class="line"></span>     *      The button involved in the event: -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
<span id="line7190" class="line"></span>     *      Note on chorded button presses (a button pressed when another button is already pressed): In the W3C Pointer Events model,
<span id="line7191" class="line"></span>     *      only one pointerdown/pointerup event combo is fired. Chorded button state changes instead fire pointermove events.
<span id="line7192" class="line"></span>     */
<span id="line7193" class="line"></span>    function updatePointerUp( tracker, eventInfo, gPoint, buttonChanged ) {
<span id="line7194" class="line"></span>        const delegate = THIS[ tracker.hash ];
<span id="line7195" class="line"></span>        const pointsList = tracker.getActivePointersListByType( gPoint.type );
<span id="line7196" class="line"></span>        let releasePoint;
<span id="line7197" class="line"></span>        let releaseTime;
<span id="line7198" class="line"></span>        let wasCaptured = false;
<span id="line7199" class="line"></span>        let quick;
<span id="line7200" class="line"></span>
<span id="line7201" class="line"></span>        if ( typeof eventInfo.originalEvent.buttons !== 'undefined' ) {
<span id="line7202" class="line"></span>            pointsList.buttons = eventInfo.originalEvent.buttons;
<span id="line7203" class="line"></span>        } else {
<span id="line7204" class="line"></span>            if ( buttonChanged === 0 ) {
<span id="line7205" class="line"></span>                // Primary
<span id="line7206" class="line"></span>                pointsList.buttons ^= ~1;
<span id="line7207" class="line"></span>            } else if ( buttonChanged === 1 ) {
<span id="line7208" class="line"></span>                // Aux
<span id="line7209" class="line"></span>                pointsList.buttons ^= ~4;
<span id="line7210" class="line"></span>            } else if ( buttonChanged === 2 ) {
<span id="line7211" class="line"></span>                // Secondary
<span id="line7212" class="line"></span>                pointsList.buttons ^= ~2;
<span id="line7213" class="line"></span>            } else if ( buttonChanged === 3 ) {
<span id="line7214" class="line"></span>                // X1 (Back)
<span id="line7215" class="line"></span>                pointsList.buttons ^= ~8;
<span id="line7216" class="line"></span>            } else if ( buttonChanged === 4 ) {
<span id="line7217" class="line"></span>                // X2 (Forward)
<span id="line7218" class="line"></span>                pointsList.buttons ^= ~16;
<span id="line7219" class="line"></span>            } else if ( buttonChanged === 5 ) {
<span id="line7220" class="line"></span>                // Pen Eraser
<span id="line7221" class="line"></span>                pointsList.buttons ^= ~32;
<span id="line7222" class="line"></span>            }
<span id="line7223" class="line"></span>        }
<span id="line7224" class="line"></span>
<span id="line7225" class="line"></span>        eventInfo.shouldCapture = false;
<span id="line7226" class="line"></span>
<span id="line7227" class="line"></span>        // Only capture and track primary button, pen, and touch contacts
<span id="line7228" class="line"></span>        if ( buttonChanged !== 0 ) {
<span id="line7229" class="line"></span>            eventInfo.shouldReleaseCapture = false;
<span id="line7230" class="line"></span>
<span id="line7231" class="line"></span>            // Aux Release
<span id="line7232" class="line"></span>            if ( tracker.nonPrimaryReleaseHandler &amp;&amp;
<span id="line7233" class="line"></span>                                !eventInfo.preventGesture &amp;&amp;
<span id="line7234" class="line"></span>                                !eventInfo.defaultPrevented ) {
<span id="line7235" class="line"></span>                eventInfo.preventDefault = true;
<span id="line7236" class="line"></span>
<span id="line7237" class="line"></span>                tracker.nonPrimaryReleaseHandler(
<span id="line7238" class="line"></span>                    {
<span id="line7239" class="line"></span>                        eventSource:           tracker,
<span id="line7240" class="line"></span>                        pointerType:           gPoint.type,
<span id="line7241" class="line"></span>                        position:              getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
<span id="line7242" class="line"></span>                        button:                buttonChanged,
<span id="line7243" class="line"></span>                        buttons:               pointsList.buttons,
<span id="line7244" class="line"></span>                        isTouchEvent:          gPoint.type === 'touch',
<span id="line7245" class="line"></span>                        originalEvent:         eventInfo.originalEvent,
<span id="line7246" class="line"></span>                        userData:              tracker.userData
<span id="line7247" class="line"></span>                    }
<span id="line7248" class="line"></span>                );
<span id="line7249" class="line"></span>            }
<span id="line7250" class="line"></span>
<span id="line7251" class="line"></span>            return;
<span id="line7252" class="line"></span>        }
<span id="line7253" class="line"></span>
<span id="line7254" class="line"></span>        let updateGPoint = pointsList.getById( gPoint.id );
<span id="line7255" class="line"></span>
<span id="line7256" class="line"></span>        if ( updateGPoint ) {
<span id="line7257" class="line"></span>            pointsList.removeContact();
<span id="line7258" class="line"></span>            //$.console.log('contacts-- ', pointsList.contacts);
<span id="line7259" class="line"></span>
<span id="line7260" class="line"></span>            // Update the pointer, stop tracking it if not still in this element
<span id="line7261" class="line"></span>            if ( updateGPoint.captured ) {
<span id="line7262" class="line"></span>                //updateGPoint.captured = false; // Handled by updatePointerCaptured()
<span id="line7263" class="line"></span>                wasCaptured = true;
<span id="line7264" class="line"></span>            }
<span id="line7265" class="line"></span>            updateGPoint.lastPos = updateGPoint.currentPos;
<span id="line7266" class="line"></span>            updateGPoint.lastTime = updateGPoint.currentTime;
<span id="line7267" class="line"></span>            updateGPoint.currentPos = gPoint.currentPos;
<span id="line7268" class="line"></span>            updateGPoint.currentTime = gPoint.currentTime;
<span id="line7269" class="line"></span>            if ( !updateGPoint.insideElement ) {
<span id="line7270" class="line"></span>                stopTrackingPointer( tracker, pointsList, updateGPoint );
<span id="line7271" class="line"></span>            }
<span id="line7272" class="line"></span>
<span id="line7273" class="line"></span>            releasePoint = updateGPoint.currentPos;
<span id="line7274" class="line"></span>            releaseTime = updateGPoint.currentTime;
<span id="line7275" class="line"></span>        } else {
<span id="line7276" class="line"></span>            // NOTE: updatePointerUp(): pointerup on untracked gPoint
<span id="line7277" class="line"></span>            // ...we'll start to track pointer again
<span id="line7278" class="line"></span>            gPoint.captured = false; // Handled by updatePointerCaptured()
<span id="line7279" class="line"></span>            gPoint.insideElementPressed = false;
<span id="line7280" class="line"></span>            gPoint.insideElement = true;
<span id="line7281" class="line"></span>            startTrackingPointer( pointsList, gPoint );
<span id="line7282" class="line"></span>
<span id="line7283" class="line"></span>            updateGPoint = gPoint;
<span id="line7284" class="line"></span>        }
<span id="line7285" class="line"></span>
<span id="line7286" class="line"></span>        if ( !eventInfo.preventGesture &amp;&amp; !eventInfo.defaultPrevented ) {
<span id="line7287" class="line"></span>            if ( wasCaptured ) {
<span id="line7288" class="line"></span>                // Pointer was activated in our element but could have been removed in any element since events are captured to our element
<span id="line7289" class="line"></span>
<span id="line7290" class="line"></span>                eventInfo.shouldReleaseCapture = true;
<span id="line7291" class="line"></span>                eventInfo.preventDefault = true;
<span id="line7292" class="line"></span>
<span id="line7293" class="line"></span>                if ( tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler ) {
<span id="line7294" class="line"></span>                    $.MouseTracker.gesturePointVelocityTracker.removePoint( tracker, updateGPoint );
<span id="line7295" class="line"></span>                }
<span id="line7296" class="line"></span>
<span id="line7297" class="line"></span>                if ( pointsList.contacts === 0 ) {
<span id="line7298" class="line"></span>
<span id="line7299" class="line"></span>                    // Release (pressed in our element)
<span id="line7300" class="line"></span>                    if ( tracker.releaseHandler &amp;&amp; releasePoint ) {
<span id="line7301" class="line"></span>                        tracker.releaseHandler(
<span id="line7302" class="line"></span>                            {
<span id="line7303" class="line"></span>                                eventSource:           tracker,
<span id="line7304" class="line"></span>                                pointerType:           updateGPoint.type,
<span id="line7305" class="line"></span>                                position:              getPointRelativeToAbsolute( releasePoint, tracker.element ),
<span id="line7306" class="line"></span>                                buttons:               pointsList.buttons,
<span id="line7307" class="line"></span>                                insideElementPressed:  updateGPoint.insideElementPressed,
<span id="line7308" class="line"></span>                                insideElementReleased: updateGPoint.insideElement,
<span id="line7309" class="line"></span>                                isTouchEvent:          updateGPoint.type === 'touch',
<span id="line7310" class="line"></span>                                originalEvent:         eventInfo.originalEvent,
<span id="line7311" class="line"></span>                                userData:              tracker.userData
<span id="line7312" class="line"></span>                            }
<span id="line7313" class="line"></span>                        );
<span id="line7314" class="line"></span>                    }
<span id="line7315" class="line"></span>
<span id="line7316" class="line"></span>                    // Drag End
<span id="line7317" class="line"></span>                    if ( tracker.dragEndHandler &amp;&amp; delegate.sentDragEvent ) {
<span id="line7318" class="line"></span>                        tracker.dragEndHandler(
<span id="line7319" class="line"></span>                            {
<span id="line7320" class="line"></span>                                eventSource:          tracker,
<span id="line7321" class="line"></span>                                pointerType:          updateGPoint.type,
<span id="line7322" class="line"></span>                                position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),
<span id="line7323" class="line"></span>                                speed:                updateGPoint.speed,
<span id="line7324" class="line"></span>                                direction:            updateGPoint.direction,
<span id="line7325" class="line"></span>                                shift:                eventInfo.originalEvent.shiftKey,
<span id="line7326" class="line"></span>                                isTouchEvent:         updateGPoint.type === 'touch',
<span id="line7327" class="line"></span>                                originalEvent:        eventInfo.originalEvent,
<span id="line7328" class="line"></span>                                userData:             tracker.userData
<span id="line7329" class="line"></span>                            }
<span id="line7330" class="line"></span>                        );
<span id="line7331" class="line"></span>                    }
<span id="line7332" class="line"></span>
<span id="line7333" class="line"></span>                    // We want to clear this flag regardless of whether we fired the dragEndHandler
<span id="line7334" class="line"></span>                    delegate.sentDragEvent = false;
<span id="line7335" class="line"></span>
<span id="line7336" class="line"></span>                    // Click / Double-Click
<span id="line7337" class="line"></span>                    if ( ( tracker.clickHandler || tracker.dblClickHandler ) &amp;&amp; updateGPoint.insideElement ) {
<span id="line7338" class="line"></span>                        quick = releaseTime - updateGPoint.contactTime &lt;= tracker.clickTimeThreshold &amp;&amp;
<span id="line7339" class="line"></span>                                        updateGPoint.contactPos.distanceTo( releasePoint ) &lt;= tracker.clickDistThreshold;
<span id="line7340" class="line"></span>
<span id="line7341" class="line"></span>                        // Click
<span id="line7342" class="line"></span>                        if ( tracker.clickHandler ) {
<span id="line7343" class="line"></span>                            tracker.clickHandler(
<span id="line7344" class="line"></span>                                {
<span id="line7345" class="line"></span>                                    eventSource:          tracker,
<span id="line7346" class="line"></span>                                    pointerType:          updateGPoint.type,
<span id="line7347" class="line"></span>                                    position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),
<span id="line7348" class="line"></span>                                    quick:                quick,
<span id="line7349" class="line"></span>                                    shift:                eventInfo.originalEvent.shiftKey,
<span id="line7350" class="line"></span>                                    isTouchEvent:         updateGPoint.type === 'touch',
<span id="line7351" class="line"></span>                                    originalEvent:        eventInfo.originalEvent,
<span id="line7352" class="line"></span>                                    originalTarget:       updateGPoint.originalTarget,
<span id="line7353" class="line"></span>                                    userData:             tracker.userData
<span id="line7354" class="line"></span>                                }
<span id="line7355" class="line"></span>                            );
<span id="line7356" class="line"></span>                        }
<span id="line7357" class="line"></span>
<span id="line7358" class="line"></span>                        // Double-Click
<span id="line7359" class="line"></span>                        if ( tracker.dblClickHandler &amp;&amp; quick ) {
<span id="line7360" class="line"></span>                            pointsList.clicks++;
<span id="line7361" class="line"></span>                            if ( pointsList.clicks === 1 ) {
<span id="line7362" class="line"></span>                                delegate.lastClickPos = releasePoint;
<span id="line7363" class="line"></span>                                /*jshint loopfunc:true*/
<span id="line7364" class="line"></span>                                delegate.dblClickTimeOut = setTimeout( function() {
<span id="line7365" class="line"></span>                                    pointsList.clicks = 0;
<span id="line7366" class="line"></span>                                }, tracker.dblClickTimeThreshold );
<span id="line7367" class="line"></span>                                /*jshint loopfunc:false*/
<span id="line7368" class="line"></span>                            } else if ( pointsList.clicks === 2 ) {
<span id="line7369" class="line"></span>                                clearTimeout( delegate.dblClickTimeOut );
<span id="line7370" class="line"></span>                                pointsList.clicks = 0;
<span id="line7371" class="line"></span>                                if ( delegate.lastClickPos.distanceTo( releasePoint ) &lt;= tracker.dblClickDistThreshold ) {
<span id="line7372" class="line"></span>                                    tracker.dblClickHandler(
<span id="line7373" class="line"></span>                                        {
<span id="line7374" class="line"></span>                                            eventSource:          tracker,
<span id="line7375" class="line"></span>                                            pointerType:          updateGPoint.type,
<span id="line7376" class="line"></span>                                            position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),
<span id="line7377" class="line"></span>                                            shift:                eventInfo.originalEvent.shiftKey,
<span id="line7378" class="line"></span>                                            isTouchEvent:         updateGPoint.type === 'touch',
<span id="line7379" class="line"></span>                                            originalEvent:        eventInfo.originalEvent,
<span id="line7380" class="line"></span>                                            userData:             tracker.userData
<span id="line7381" class="line"></span>                                        }
<span id="line7382" class="line"></span>                                    );
<span id="line7383" class="line"></span>                                }
<span id="line7384" class="line"></span>                                delegate.lastClickPos = null;
<span id="line7385" class="line"></span>                            }
<span id="line7386" class="line"></span>                        }
<span id="line7387" class="line"></span>                    }
<span id="line7388" class="line"></span>                } else if ( pointsList.contacts === 2 ) {
<span id="line7389" class="line"></span>                    if ( tracker.pinchHandler &amp;&amp; updateGPoint.type === 'touch' ) {
<span id="line7390" class="line"></span>                        // Reset for pinch
<span id="line7391" class="line"></span>                        delegate.pinchGPoints = pointsList.asArray();
<span id="line7392" class="line"></span>                        delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[ 0 ].currentPos.distanceTo( delegate.pinchGPoints[ 1 ].currentPos );
<span id="line7393" class="line"></span>                        delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint( delegate.pinchGPoints[ 0 ].currentPos, delegate.pinchGPoints[ 1 ].currentPos );
<span id="line7394" class="line"></span>                    }
<span id="line7395" class="line"></span>                }
<span id="line7396" class="line"></span>            } else {
<span id="line7397" class="line"></span>                // Pointer was activated in another element but removed in our element
<span id="line7398" class="line"></span>
<span id="line7399" class="line"></span>                eventInfo.shouldReleaseCapture = false;
<span id="line7400" class="line"></span>
<span id="line7401" class="line"></span>                // Release (pressed in another element)
<span id="line7402" class="line"></span>                if ( tracker.releaseHandler &amp;&amp; releasePoint ) {
<span id="line7403" class="line"></span>                    tracker.releaseHandler(
<span id="line7404" class="line"></span>                        {
<span id="line7405" class="line"></span>                            eventSource:           tracker,
<span id="line7406" class="line"></span>                            pointerType:           updateGPoint.type,
<span id="line7407" class="line"></span>                            position:              getPointRelativeToAbsolute( releasePoint, tracker.element ),
<span id="line7408" class="line"></span>                            buttons:               pointsList.buttons,
<span id="line7409" class="line"></span>                            insideElementPressed:  updateGPoint.insideElementPressed,
<span id="line7410" class="line"></span>                            insideElementReleased: updateGPoint.insideElement,
<span id="line7411" class="line"></span>                            isTouchEvent:          updateGPoint.type === 'touch',
<span id="line7412" class="line"></span>                            originalEvent:         eventInfo.originalEvent,
<span id="line7413" class="line"></span>                            userData:              tracker.userData
<span id="line7414" class="line"></span>                        }
<span id="line7415" class="line"></span>                    );
<span id="line7416" class="line"></span>                    eventInfo.preventDefault = true;
<span id="line7417" class="line"></span>                }
<span id="line7418" class="line"></span>            }
<span id="line7419" class="line"></span>        }
<span id="line7420" class="line"></span>    }
<span id="line7421" class="line"></span>
<span id="line7422" class="line"></span>
<span id="line7423" class="line"></span>    /**
<span id="line7424" class="line"></span>     * Call when pointer(s) change coordinates, button state, pressure, tilt, or contact geometry (e.g. width and height)
<span id="line7425" class="line"></span>     *
<span id="line7426" class="line"></span>     * @function
<span id="line7427" class="line"></span>     * @private
<span id="line7428" class="line"></span>     * @inner
<span id="line7429" class="line"></span>     * @param {OpenSeadragon.MouseTracker} tracker
<span id="line7430" class="line"></span>     *     A reference to the MouseTracker instance.
<span id="line7431" class="line"></span>     * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
<span id="line7432" class="line"></span>     *     Processing info for originating DOM event.
<span id="line7433" class="line"></span>     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
<span id="line7434" class="line"></span>     *      Gesture points associated with the event.
<span id="line7435" class="line"></span>     */
<span id="line7436" class="line"></span>    function updatePointerMove( tracker, eventInfo, gPoint ) {
<span id="line7437" class="line"></span>        const delegate = THIS[ tracker.hash ];
<span id="line7438" class="line"></span>        const pointsList = tracker.getActivePointersListByType( gPoint.type );
<span id="line7439" class="line"></span>        let delta;
<span id="line7440" class="line"></span>
<span id="line7441" class="line"></span>        if ( typeof eventInfo.originalEvent.buttons !== 'undefined' ) {
<span id="line7442" class="line"></span>            pointsList.buttons = eventInfo.originalEvent.buttons;
<span id="line7443" class="line"></span>        }
<span id="line7444" class="line"></span>
<span id="line7445" class="line"></span>        let updateGPoint = pointsList.getById( gPoint.id );
<span id="line7446" class="line"></span>
<span id="line7447" class="line"></span>        if ( updateGPoint ) {
<span id="line7448" class="line"></span>            // Already tracking the pointer...update it
<span id="line7449" class="line"></span>            updateGPoint.lastPos = updateGPoint.currentPos;
<span id="line7450" class="line"></span>            updateGPoint.lastTime = updateGPoint.currentTime;
<span id="line7451" class="line"></span>            updateGPoint.currentPos = gPoint.currentPos;
<span id="line7452" class="line"></span>            updateGPoint.currentTime = gPoint.currentTime;
<span id="line7453" class="line"></span>        } else {
<span id="line7454" class="line"></span>            // Should never get here, but due to user agent bugs (e.g. legacy touch) it sometimes happens
<span id="line7455" class="line"></span>            return;
<span id="line7456" class="line"></span>        }
<span id="line7457" class="line"></span>
<span id="line7458" class="line"></span>        eventInfo.shouldCapture = false;
<span id="line7459" class="line"></span>        eventInfo.shouldReleaseCapture = false;
<span id="line7460" class="line"></span>
<span id="line7461" class="line"></span>        // Stop (mouse only)
<span id="line7462" class="line"></span>        if ( tracker.stopHandler &amp;&amp; gPoint.type === 'mouse' ) {
<span id="line7463" class="line"></span>            clearTimeout( tracker.stopTimeOut );
<span id="line7464" class="line"></span>            tracker.stopTimeOut = setTimeout( function() {
<span id="line7465" class="line"></span>                handlePointerStop( tracker, eventInfo.originalEvent, gPoint.type );
<span id="line7466" class="line"></span>            }, tracker.stopDelay );
<span id="line7467" class="line"></span>        }
<span id="line7468" class="line"></span>
<span id="line7469" class="line"></span>        if ( pointsList.contacts === 0 ) {
<span id="line7470" class="line"></span>            // Move (no contacts: hovering mouse or other hover-capable device)
<span id="line7471" class="line"></span>            if ( tracker.moveHandler ) {
<span id="line7472" class="line"></span>                tracker.moveHandler(
<span id="line7473" class="line"></span>                    {
<span id="line7474" class="line"></span>                        eventSource:          tracker,
<span id="line7475" class="line"></span>                        pointerType:          gPoint.type,
<span id="line7476" class="line"></span>                        position:             getPointRelativeToAbsolute( gPoint.currentPos, tracker.element ),
<span id="line7477" class="line"></span>                        buttons:              pointsList.buttons,
<span id="line7478" class="line"></span>                        isTouchEvent:         gPoint.type === 'touch',
<span id="line7479" class="line"></span>                        originalEvent:        eventInfo.originalEvent,
<span id="line7480" class="line"></span>                        userData:             tracker.userData
<span id="line7481" class="line"></span>                    }
<span id="line7482" class="line"></span>                );
<span id="line7483" class="line"></span>            }
<span id="line7484" class="line"></span>        } else if ( pointsList.contacts === 1 ) {
<span id="line7485" class="line"></span>            // Move (1 contact)
<span id="line7486" class="line"></span>            if ( tracker.moveHandler ) {
<span id="line7487" class="line"></span>                updateGPoint = pointsList.asArray()[ 0 ];
<span id="line7488" class="line"></span>                tracker.moveHandler(
<span id="line7489" class="line"></span>                    {
<span id="line7490" class="line"></span>                        eventSource:          tracker,
<span id="line7491" class="line"></span>                        pointerType:          updateGPoint.type,
<span id="line7492" class="line"></span>                        position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),
<span id="line7493" class="line"></span>                        buttons:              pointsList.buttons,
<span id="line7494" class="line"></span>                        isTouchEvent:         updateGPoint.type === 'touch',
<span id="line7495" class="line"></span>                        originalEvent:        eventInfo.originalEvent,
<span id="line7496" class="line"></span>                        userData:             tracker.userData
<span id="line7497" class="line"></span>                    }
<span id="line7498" class="line"></span>                );
<span id="line7499" class="line"></span>            }
<span id="line7500" class="line"></span>
<span id="line7501" class="line"></span>            // Drag
<span id="line7502" class="line"></span>            if ( tracker.dragHandler &amp;&amp; !eventInfo.preventGesture &amp;&amp; !eventInfo.defaultPrevented ) {
<span id="line7503" class="line"></span>                updateGPoint = pointsList.asArray()[ 0 ];
<span id="line7504" class="line"></span>                delta = updateGPoint.currentPos.minus( updateGPoint.lastPos );
<span id="line7505" class="line"></span>                tracker.dragHandler(
<span id="line7506" class="line"></span>                    {
<span id="line7507" class="line"></span>                        eventSource:          tracker,
<span id="line7508" class="line"></span>                        pointerType:          updateGPoint.type,
<span id="line7509" class="line"></span>                        position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),
<span id="line7510" class="line"></span>                        buttons:              pointsList.buttons,
<span id="line7511" class="line"></span>                        delta:                delta,
<span id="line7512" class="line"></span>                        speed:                updateGPoint.speed,
<span id="line7513" class="line"></span>                        direction:            updateGPoint.direction,
<span id="line7514" class="line"></span>                        shift:                eventInfo.originalEvent.shiftKey,
<span id="line7515" class="line"></span>                        isTouchEvent:         updateGPoint.type === 'touch',
<span id="line7516" class="line"></span>                        originalEvent:        eventInfo.originalEvent,
<span id="line7517" class="line"></span>                        userData:             tracker.userData
<span id="line7518" class="line"></span>                    }
<span id="line7519" class="line"></span>                );
<span id="line7520" class="line"></span>                eventInfo.preventDefault = true;
<span id="line7521" class="line"></span>                delegate.sentDragEvent = true;
<span id="line7522" class="line"></span>            }
<span id="line7523" class="line"></span>        } else if ( pointsList.contacts === 2 ) {
<span id="line7524" class="line"></span>            // Move (2 contacts, use center)
<span id="line7525" class="line"></span>            if ( tracker.moveHandler ) {
<span id="line7526" class="line"></span>                const gPointArray = pointsList.asArray();
<span id="line7527" class="line"></span>                tracker.moveHandler(
<span id="line7528" class="line"></span>                    {
<span id="line7529" class="line"></span>                        eventSource:          tracker,
<span id="line7530" class="line"></span>                        pointerType:          gPointArray[ 0 ].type,
<span id="line7531" class="line"></span>                        position:             getPointRelativeToAbsolute( getCenterPoint( gPointArray[ 0 ].currentPos, gPointArray[ 1 ].currentPos ), tracker.element ),
<span id="line7532" class="line"></span>                        buttons:              pointsList.buttons,
<span id="line7533" class="line"></span>                        isTouchEvent:         gPointArray[ 0 ].type === 'touch',
<span id="line7534" class="line"></span>                        originalEvent:        eventInfo.originalEvent,
<span id="line7535" class="line"></span>                        userData:             tracker.userData
<span id="line7536" class="line"></span>                    }
<span id="line7537" class="line"></span>                );
<span id="line7538" class="line"></span>            }
<span id="line7539" class="line"></span>
<span id="line7540" class="line"></span>            // Pinch
<span id="line7541" class="line"></span>            if ( tracker.pinchHandler &amp;&amp; gPoint.type === 'touch' &amp;&amp;
<span id="line7542" class="line"></span>                                !eventInfo.preventGesture &amp;&amp; !eventInfo.defaultPrevented ) {
<span id="line7543" class="line"></span>                delta = delegate.pinchGPoints[ 0 ].currentPos.distanceTo( delegate.pinchGPoints[ 1 ].currentPos );
<span id="line7544" class="line"></span>                if ( delta !== delegate.currentPinchDist ) {
<span id="line7545" class="line"></span>                    delegate.lastPinchDist = delegate.currentPinchDist;
<span id="line7546" class="line"></span>                    delegate.currentPinchDist = delta;
<span id="line7547" class="line"></span>                    delegate.lastPinchCenter = delegate.currentPinchCenter;
<span id="line7548" class="line"></span>                    delegate.currentPinchCenter = getCenterPoint( delegate.pinchGPoints[ 0 ].currentPos, delegate.pinchGPoints[ 1 ].currentPos );
<span id="line7549" class="line"></span>                    tracker.pinchHandler(
<span id="line7550" class="line"></span>                        {
<span id="line7551" class="line"></span>                            eventSource:          tracker,
<span id="line7552" class="line"></span>                            pointerType:          'touch',
<span id="line7553" class="line"></span>                            gesturePoints:        delegate.pinchGPoints,
<span id="line7554" class="line"></span>                            lastCenter:           getPointRelativeToAbsolute( delegate.lastPinchCenter, tracker.element ),
<span id="line7555" class="line"></span>                            center:               getPointRelativeToAbsolute( delegate.currentPinchCenter, tracker.element ),
<span id="line7556" class="line"></span>                            lastDistance:         delegate.lastPinchDist,
<span id="line7557" class="line"></span>                            distance:             delegate.currentPinchDist,
<span id="line7558" class="line"></span>                            shift:                eventInfo.originalEvent.shiftKey,
<span id="line7559" class="line"></span>                            originalEvent:        eventInfo.originalEvent,
<span id="line7560" class="line"></span>                            userData:             tracker.userData
<span id="line7561" class="line"></span>                        }
<span id="line7562" class="line"></span>                    );
<span id="line7563" class="line"></span>                    eventInfo.preventDefault = true;
<span id="line7564" class="line"></span>                }
<span id="line7565" class="line"></span>            }
<span id="line7566" class="line"></span>        }
<span id="line7567" class="line"></span>    }
<span id="line7568" class="line"></span>
<span id="line7569" class="line"></span>
<span id="line7570" class="line"></span>    /**
<span id="line7571" class="line"></span>     * @function
<span id="line7572" class="line"></span>     * @private
<span id="line7573" class="line"></span>     * @inner
<span id="line7574" class="line"></span>     * @param {OpenSeadragon.MouseTracker} tracker
<span id="line7575" class="line"></span>     *     A reference to the MouseTracker instance.
<span id="line7576" class="line"></span>     * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
<span id="line7577" class="line"></span>     *     Processing info for originating DOM event.
<span id="line7578" class="line"></span>     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
<span id="line7579" class="line"></span>     *      Gesture points associated with the event.
<span id="line7580" class="line"></span>     */
<span id="line7581" class="line"></span>    function updatePointerCancel( tracker, eventInfo, gPoint ) {
<span id="line7582" class="line"></span>        const pointsList = tracker.getActivePointersListByType( gPoint.type );
<span id="line7583" class="line"></span>        const updateGPoint = pointsList.getById( gPoint.id );
<span id="line7584" class="line"></span>
<span id="line7585" class="line"></span>        if ( updateGPoint ) {
<span id="line7586" class="line"></span>            stopTrackingPointer( tracker, pointsList, updateGPoint );
<span id="line7587" class="line"></span>        }
<span id="line7588" class="line"></span>    }
<span id="line7589" class="line"></span>
<span id="line7590" class="line"></span>
<span id="line7591" class="line"></span>    /**
<span id="line7592" class="line"></span>     * @private
<span id="line7593" class="line"></span>     * @inner
<span id="line7594" class="line"></span>     */
<span id="line7595" class="line"></span>    function handlePointerStop( tracker, originalMoveEvent, pointerType ) {
<span id="line7596" class="line"></span>        if ( tracker.stopHandler ) {
<span id="line7597" class="line"></span>            tracker.stopHandler( {
<span id="line7598" class="line"></span>                eventSource:          tracker,
<span id="line7599" class="line"></span>                pointerType:          pointerType,
<span id="line7600" class="line"></span>                position:             getMouseRelative( originalMoveEvent, tracker.element ),
<span id="line7601" class="line"></span>                buttons:              tracker.getActivePointersListByType( pointerType ).buttons,
<span id="line7602" class="line"></span>                isTouchEvent:         pointerType === 'touch',
<span id="line7603" class="line"></span>                originalEvent:        originalMoveEvent,
<span id="line7604" class="line"></span>                userData:             tracker.userData
<span id="line7605" class="line"></span>            } );
<span id="line7606" class="line"></span>        }
<span id="line7607" class="line"></span>    }
<span id="line7608" class="line"></span>
<span id="line7609" class="line"></span>
<span id="line7610" class="line"></span>    /**
<span id="line7611" class="line"></span>     * @function
<span id="line7612" class="line"></span>     * @private
<span id="line7613" class="line"></span>     * @inner
<span id="line7614" class="line"></span>     */
<span id="line7615" class="line"></span>    function uniqueHash( ) {
<span id="line7616" class="line"></span>        let uniqueId = Date.now().toString(36) + Math.random().toString(36).substring(2);
<span id="line7617" class="line"></span>        while (uniqueId in THIS) {
<span id="line7618" class="line"></span>            // rehash when not unique
<span id="line7619" class="line"></span>            uniqueId = Date.now().toString(36) + Math.random().toString(36).substring(2);
<span id="line7620" class="line"></span>        }
<span id="line7621" class="line"></span>        return uniqueId;
<span id="line7622" class="line"></span>    }
<span id="line7623" class="line"></span>
<span id="line7624" class="line"></span>}(OpenSeadragon));
<span id="line7625" class="line"></span>
<span id="line7626" class="line"></span>/*
<span id="line7627" class="line"></span> * OpenSeadragon - Control
<span id="line7628" class="line"></span> *
<span id="line7629" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line7630" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line7631" class="line"></span> *
<span id="line7632" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line7633" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line7634" class="line"></span> * met:
<span id="line7635" class="line"></span> *
<span id="line7636" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line7637" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line7638" class="line"></span> *
<span id="line7639" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line7640" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line7641" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line7642" class="line"></span> *
<span id="line7643" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line7644" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line7645" class="line"></span> *   this software without specific prior written permission.
<span id="line7646" class="line"></span> *
<span id="line7647" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line7648" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line7649" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line7650" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line7651" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line7652" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line7653" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line7654" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line7655" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line7656" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line7657" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line7658" class="line"></span> */
<span id="line7659" class="line"></span>
<span id="line7660" class="line"></span>(function( $ ){
<span id="line7661" class="line"></span>
<span id="line7662" class="line"></span>/**
<span id="line7663" class="line"></span> * An enumeration of supported locations where controls can be anchored.
<span id="line7664" class="line"></span> * The anchoring is always relative to the container.
<span id="line7665" class="line"></span> * @member ControlAnchor
<span id="line7666" class="line"></span> * @memberof OpenSeadragon
<span id="line7667" class="line"></span> * @static
<span id="line7668" class="line"></span> * @type {Object}
<span id="line7669" class="line"></span> * @property {Number} NONE
<span id="line7670" class="line"></span> * @property {Number} TOP_LEFT
<span id="line7671" class="line"></span> * @property {Number} TOP_RIGHT
<span id="line7672" class="line"></span> * @property {Number} BOTTOM_LEFT
<span id="line7673" class="line"></span> * @property {Number} BOTTOM_RIGHT
<span id="line7674" class="line"></span> * @property {Number} ABSOLUTE
<span id="line7675" class="line"></span> */
<span id="line7676" class="line"></span>$.ControlAnchor = {
<span id="line7677" class="line"></span>    NONE: 0,
<span id="line7678" class="line"></span>    TOP_LEFT: 1,
<span id="line7679" class="line"></span>    TOP_RIGHT: 2,
<span id="line7680" class="line"></span>    BOTTOM_RIGHT: 3,
<span id="line7681" class="line"></span>    BOTTOM_LEFT: 4,
<span id="line7682" class="line"></span>    ABSOLUTE: 5
<span id="line7683" class="line"></span>};
<span id="line7684" class="line"></span>
<span id="line7685" class="line"></span>/**
<span id="line7686" class="line"></span> * @class Control
<span id="line7687" class="line"></span> * @classdesc A Control represents any interface element which is meant to allow the user
<span id="line7688" class="line"></span> * to interact with the zoomable interface. Any control can be anchored to any
<span id="line7689" class="line"></span> * element.
<span id="line7690" class="line"></span> *
<span id="line7691" class="line"></span> * @memberof OpenSeadragon
<span id="line7692" class="line"></span> * @param {Element} element - the control element to be anchored in the container.
<span id="line7693" class="line"></span> * @param {Object } options - All required and optional settings for configuring a control element.
<span id="line7694" class="line"></span> * @param {OpenSeadragon.ControlAnchor} [options.anchor=OpenSeadragon.ControlAnchor.NONE] - the position of the control
<span id="line7695" class="line"></span> *  relative to the container.
<span id="line7696" class="line"></span> * @param {Boolean} [options.attachToViewer=true] - Whether the control should be added directly to the viewer, or
<span id="line7697" class="line"></span> *  directly to the container
<span id="line7698" class="line"></span> * @param {Boolean} [options.autoFade=true] - Whether the control should have the autofade behavior
<span id="line7699" class="line"></span> * @param {Element} container - the element to control will be anchored too.
<span id="line7700" class="line"></span> */
<span id="line7701" class="line"></span>$.Control = function ( element, options, container ) {
<span id="line7702" class="line"></span>
<span id="line7703" class="line"></span>    const parent = element.parentNode;
<span id="line7704" class="line"></span>    if (typeof options === 'number')
<span id="line7705" class="line"></span>    {
<span id="line7706" class="line"></span>        $.console.error("Passing an anchor directly into the OpenSeadragon.Control constructor is deprecated; " +
<span id="line7707" class="line"></span>                        "please use an options object instead.  " +
<span id="line7708" class="line"></span>                        "Support for this deprecated variant is scheduled for removal in December 2013");
<span id="line7709" class="line"></span>         options = {anchor: options};
<span id="line7710" class="line"></span>    }
<span id="line7711" class="line"></span>    options.attachToViewer = (typeof options.attachToViewer === 'undefined') ? true : options.attachToViewer;
<span id="line7712" class="line"></span>    /**
<span id="line7713" class="line"></span>     * True if the control should have autofade behavior.
<span id="line7714" class="line"></span>     * @member {Boolean} autoFade
<span id="line7715" class="line"></span>     * @memberof OpenSeadragon.Control#
<span id="line7716" class="line"></span>     */
<span id="line7717" class="line"></span>    this.autoFade = (typeof options.autoFade === 'undefined') ? true : options.autoFade;
<span id="line7718" class="line"></span>    /**
<span id="line7719" class="line"></span>     * The element providing the user interface with some type of control (e.g. a zoom-in button).
<span id="line7720" class="line"></span>     * @member {Element} element
<span id="line7721" class="line"></span>     * @memberof OpenSeadragon.Control#
<span id="line7722" class="line"></span>     */
<span id="line7723" class="line"></span>    this.element    = element;
<span id="line7724" class="line"></span>    /**
<span id="line7725" class="line"></span>     * The position of the Control relative to its container.
<span id="line7726" class="line"></span>     * @member {OpenSeadragon.ControlAnchor} anchor
<span id="line7727" class="line"></span>     * @memberof OpenSeadragon.Control#
<span id="line7728" class="line"></span>     */
<span id="line7729" class="line"></span>    this.anchor     = options.anchor;
<span id="line7730" class="line"></span>    /**
<span id="line7731" class="line"></span>     * The Control's containing element.
<span id="line7732" class="line"></span>     * @member {Element} container
<span id="line7733" class="line"></span>     * @memberof OpenSeadragon.Control#
<span id="line7734" class="line"></span>     */
<span id="line7735" class="line"></span>    this.container  = container;
<span id="line7736" class="line"></span>    /**
<span id="line7737" class="line"></span>     * A neutral element surrounding the control element.
<span id="line7738" class="line"></span>     * @member {Element} wrapper
<span id="line7739" class="line"></span>     * @memberof OpenSeadragon.Control#
<span id="line7740" class="line"></span>     */
<span id="line7741" class="line"></span>    if ( this.anchor === $.ControlAnchor.ABSOLUTE ) {
<span id="line7742" class="line"></span>        this.wrapper    = $.makeNeutralElement( "div" );
<span id="line7743" class="line"></span>        this.wrapper.style.position = "absolute";
<span id="line7744" class="line"></span>        this.wrapper.style.top = typeof (options.top) === "number" ? (options.top + 'px') : options.top;
<span id="line7745" class="line"></span>        this.wrapper.style.left  = typeof (options.left) === "number" ? (options.left + 'px') : options.left;
<span id="line7746" class="line"></span>        this.wrapper.style.height = typeof (options.height) === "number" ? (options.height + 'px') : options.height;
<span id="line7747" class="line"></span>        this.wrapper.style.width  = typeof (options.width) === "number" ? (options.width + 'px') : options.width;
<span id="line7748" class="line"></span>        this.wrapper.style.margin = "0px";
<span id="line7749" class="line"></span>        this.wrapper.style.padding = "0px";
<span id="line7750" class="line"></span>
<span id="line7751" class="line"></span>        this.element.style.position = "relative";
<span id="line7752" class="line"></span>        this.element.style.top = "0px";
<span id="line7753" class="line"></span>        this.element.style.left = "0px";
<span id="line7754" class="line"></span>        this.element.style.height = "100%";
<span id="line7755" class="line"></span>        this.element.style.width = "100%";
<span id="line7756" class="line"></span>    } else {
<span id="line7757" class="line"></span>        this.wrapper    = $.makeNeutralElement( "div" );
<span id="line7758" class="line"></span>        this.wrapper.style.display = "inline-block";
<span id="line7759" class="line"></span>        if ( this.anchor === $.ControlAnchor.NONE ) {
<span id="line7760" class="line"></span>            // IE6 fix
<span id="line7761" class="line"></span>            this.wrapper.style.width = this.wrapper.style.height = "100%";
<span id="line7762" class="line"></span>        }
<span id="line7763" class="line"></span>    }
<span id="line7764" class="line"></span>    this.wrapper.appendChild( this.element );
<span id="line7765" class="line"></span>
<span id="line7766" class="line"></span>    if (options.attachToViewer ) {
<span id="line7767" class="line"></span>        if ( this.anchor === $.ControlAnchor.TOP_RIGHT ||
<span id="line7768" class="line"></span>             this.anchor === $.ControlAnchor.BOTTOM_RIGHT ) {
<span id="line7769" class="line"></span>            this.container.insertBefore(
<span id="line7770" class="line"></span>                this.wrapper,
<span id="line7771" class="line"></span>                this.container.firstChild
<span id="line7772" class="line"></span>            );
<span id="line7773" class="line"></span>        } else {
<span id="line7774" class="line"></span>            this.container.appendChild( this.wrapper );
<span id="line7775" class="line"></span>        }
<span id="line7776" class="line"></span>    } else {
<span id="line7777" class="line"></span>        parent.appendChild( this.wrapper );
<span id="line7778" class="line"></span>    }
<span id="line7779" class="line"></span>
<span id="line7780" class="line"></span>};
<span id="line7781" class="line"></span>
<span id="line7782" class="line"></span>/** @lends OpenSeadragon.Control.prototype */
<span id="line7783" class="line"></span>$.Control.prototype = {
<span id="line7784" class="line"></span>
<span id="line7785" class="line"></span>    /**
<span id="line7786" class="line"></span>     * Removes the control from the container.
<span id="line7787" class="line"></span>     * @function
<span id="line7788" class="line"></span>     */
<span id="line7789" class="line"></span>    destroy: function() {
<span id="line7790" class="line"></span>        this.wrapper.removeChild( this.element );
<span id="line7791" class="line"></span>        if (this.anchor !== $.ControlAnchor.NONE) {
<span id="line7792" class="line"></span>            this.container.removeChild(this.wrapper);
<span id="line7793" class="line"></span>        }
<span id="line7794" class="line"></span>    },
<span id="line7795" class="line"></span>
<span id="line7796" class="line"></span>    /**
<span id="line7797" class="line"></span>     * Determines if the control is currently visible.
<span id="line7798" class="line"></span>     * @function
<span id="line7799" class="line"></span>     * @returns {Boolean} true if currently visible, false otherwise.
<span id="line7800" class="line"></span>     */
<span id="line7801" class="line"></span>    isVisible: function() {
<span id="line7802" class="line"></span>        return this.wrapper.style.display !== "none";
<span id="line7803" class="line"></span>    },
<span id="line7804" class="line"></span>
<span id="line7805" class="line"></span>    /**
<span id="line7806" class="line"></span>     * Toggles the visibility of the control.
<span id="line7807" class="line"></span>     * @function
<span id="line7808" class="line"></span>     * @param {Boolean} visible - true to make visible, false to hide.
<span id="line7809" class="line"></span>     */
<span id="line7810" class="line"></span>    setVisible: function( visible ) {
<span id="line7811" class="line"></span>        this.wrapper.style.display = visible ?
<span id="line7812" class="line"></span>            ( this.anchor === $.ControlAnchor.ABSOLUTE ? 'block' : 'inline-block' ) :
<span id="line7813" class="line"></span>            "none";
<span id="line7814" class="line"></span>    },
<span id="line7815" class="line"></span>
<span id="line7816" class="line"></span>    /**
<span id="line7817" class="line"></span>     * Sets the opacity level for the control.
<span id="line7818" class="line"></span>     * @function
<span id="line7819" class="line"></span>     * @param {Number} opactiy - a value between 1 and 0 inclusively.
<span id="line7820" class="line"></span>     */
<span id="line7821" class="line"></span>    setOpacity: function( opacity ) {
<span id="line7822" class="line"></span>        $.setElementOpacity( this.wrapper, opacity, true );
<span id="line7823" class="line"></span>    }
<span id="line7824" class="line"></span>};
<span id="line7825" class="line"></span>
<span id="line7826" class="line"></span>}( OpenSeadragon ));
<span id="line7827" class="line"></span>
<span id="line7828" class="line"></span>/*
<span id="line7829" class="line"></span> * OpenSeadragon - ControlDock
<span id="line7830" class="line"></span> *
<span id="line7831" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line7832" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line7833" class="line"></span> *
<span id="line7834" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line7835" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line7836" class="line"></span> * met:
<span id="line7837" class="line"></span> *
<span id="line7838" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line7839" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line7840" class="line"></span> *
<span id="line7841" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line7842" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line7843" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line7844" class="line"></span> *
<span id="line7845" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line7846" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line7847" class="line"></span> *   this software without specific prior written permission.
<span id="line7848" class="line"></span> *
<span id="line7849" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line7850" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line7851" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line7852" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line7853" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line7854" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line7855" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line7856" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line7857" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line7858" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line7859" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line7860" class="line"></span> */
<span id="line7861" class="line"></span>
<span id="line7862" class="line"></span>(function( $ ){
<span id="line7863" class="line"></span>    /**
<span id="line7864" class="line"></span>     * @class ControlDock
<span id="line7865" class="line"></span>     * @classdesc Provides a container element (a &amp;lt;form&amp;gt; element) with support for the layout of control elements.
<span id="line7866" class="line"></span>     *
<span id="line7867" class="line"></span>     * @memberof OpenSeadragon
<span id="line7868" class="line"></span>     */
<span id="line7869" class="line"></span>    $.ControlDock = function( options ){
<span id="line7870" class="line"></span>        const layouts = [ 'topleft', 'topright', 'bottomright', 'bottomleft'];
<span id="line7871" class="line"></span>
<span id="line7872" class="line"></span>        $.extend( true, this, {
<span id="line7873" class="line"></span>            id: 'controldock-' + $.now() + '-' + Math.floor(Math.random() * 1000000),
<span id="line7874" class="line"></span>            container: $.makeNeutralElement( 'div' ),
<span id="line7875" class="line"></span>            controls: []
<span id="line7876" class="line"></span>        }, options );
<span id="line7877" class="line"></span>
<span id="line7878" class="line"></span>        // Disable the form's submit; otherwise button clicks and return keys
<span id="line7879" class="line"></span>        // can trigger it.
<span id="line7880" class="line"></span>        this.container.onsubmit = function() {
<span id="line7881" class="line"></span>            return false;
<span id="line7882" class="line"></span>        };
<span id="line7883" class="line"></span>
<span id="line7884" class="line"></span>        if( this.element ){
<span id="line7885" class="line"></span>            this.element = $.getElement( this.element );
<span id="line7886" class="line"></span>            this.element.appendChild( this.container );
<span id="line7887" class="line"></span>            if( $.getElementStyle(this.element).position === 'static' ){
<span id="line7888" class="line"></span>                this.element.style.position = 'relative';
<span id="line7889" class="line"></span>            }
<span id="line7890" class="line"></span>            this.container.style.width = '100%';
<span id="line7891" class="line"></span>            this.container.style.height = '100%';
<span id="line7892" class="line"></span>        }
<span id="line7893" class="line"></span>
<span id="line7894" class="line"></span>        for( let i = 0; i &lt; layouts.length; i++ ){
<span id="line7895" class="line"></span>            let layout = layouts[ i ];
<span id="line7896" class="line"></span>            this.controls[ layout ] = $.makeNeutralElement( "div" );
<span id="line7897" class="line"></span>            this.controls[ layout ].style.position = 'absolute';
<span id="line7898" class="line"></span>            if ( layout.match( 'left' ) ){
<span id="line7899" class="line"></span>                this.controls[ layout ].style.left = '0px';
<span id="line7900" class="line"></span>            }
<span id="line7901" class="line"></span>            if ( layout.match( 'right' ) ){
<span id="line7902" class="line"></span>                this.controls[ layout ].style.right = '0px';
<span id="line7903" class="line"></span>            }
<span id="line7904" class="line"></span>            if ( layout.match( 'top' ) ){
<span id="line7905" class="line"></span>                this.controls[ layout ].style.top = '0px';
<span id="line7906" class="line"></span>            }
<span id="line7907" class="line"></span>            if ( layout.match( 'bottom' ) ){
<span id="line7908" class="line"></span>                this.controls[ layout ].style.bottom = '0px';
<span id="line7909" class="line"></span>            }
<span id="line7910" class="line"></span>        }
<span id="line7911" class="line"></span>
<span id="line7912" class="line"></span>        this.container.appendChild( this.controls.topleft );
<span id="line7913" class="line"></span>        this.container.appendChild( this.controls.topright );
<span id="line7914" class="line"></span>        this.container.appendChild( this.controls.bottomright );
<span id="line7915" class="line"></span>        this.container.appendChild( this.controls.bottomleft );
<span id="line7916" class="line"></span>    };
<span id="line7917" class="line"></span>
<span id="line7918" class="line"></span>    /** @lends OpenSeadragon.ControlDock.prototype */
<span id="line7919" class="line"></span>    $.ControlDock.prototype = {
<span id="line7920" class="line"></span>
<span id="line7921" class="line"></span>        /**
<span id="line7922" class="line"></span>         * @function
<span id="line7923" class="line"></span>         */
<span id="line7924" class="line"></span>        addControl: function ( element, controlOptions ) {
<span id="line7925" class="line"></span>            element = $.getElement( element );
<span id="line7926" class="line"></span>            let div = null;
<span id="line7927" class="line"></span>
<span id="line7928" class="line"></span>            if ( getControlIndex( this, element ) &gt;= 0 ) {
<span id="line7929" class="line"></span>                return;     // they're trying to add a duplicate control
<span id="line7930" class="line"></span>            }
<span id="line7931" class="line"></span>
<span id="line7932" class="line"></span>            switch ( controlOptions.anchor ) {
<span id="line7933" class="line"></span>                case $.ControlAnchor.TOP_RIGHT:
<span id="line7934" class="line"></span>                    div = this.controls.topright;
<span id="line7935" class="line"></span>                    element.style.position = "relative";
<span id="line7936" class="line"></span>                    element.style.paddingRight = "0px";
<span id="line7937" class="line"></span>                    element.style.paddingTop = "0px";
<span id="line7938" class="line"></span>                    break;
<span id="line7939" class="line"></span>                case $.ControlAnchor.BOTTOM_RIGHT:
<span id="line7940" class="line"></span>                    div = this.controls.bottomright;
<span id="line7941" class="line"></span>                    element.style.position = "relative";
<span id="line7942" class="line"></span>                    element.style.paddingRight = "0px";
<span id="line7943" class="line"></span>                    element.style.paddingBottom = "0px";
<span id="line7944" class="line"></span>                    break;
<span id="line7945" class="line"></span>                case $.ControlAnchor.BOTTOM_LEFT:
<span id="line7946" class="line"></span>                    div = this.controls.bottomleft;
<span id="line7947" class="line"></span>                    element.style.position = "relative";
<span id="line7948" class="line"></span>                    element.style.paddingLeft = "0px";
<span id="line7949" class="line"></span>                    element.style.paddingBottom = "0px";
<span id="line7950" class="line"></span>                    break;
<span id="line7951" class="line"></span>                case $.ControlAnchor.TOP_LEFT:
<span id="line7952" class="line"></span>                    div = this.controls.topleft;
<span id="line7953" class="line"></span>                    element.style.position = "relative";
<span id="line7954" class="line"></span>                    element.style.paddingLeft = "0px";
<span id="line7955" class="line"></span>                    element.style.paddingTop = "0px";
<span id="line7956" class="line"></span>                    break;
<span id="line7957" class="line"></span>                case $.ControlAnchor.ABSOLUTE:
<span id="line7958" class="line"></span>                    div = this.container;
<span id="line7959" class="line"></span>                    element.style.margin = "0px";
<span id="line7960" class="line"></span>                    element.style.padding = "0px";
<span id="line7961" class="line"></span>                    break;
<span id="line7962" class="line"></span>                default:
<span id="line7963" class="line"></span>                case $.ControlAnchor.NONE:
<span id="line7964" class="line"></span>                    div = this.container;
<span id="line7965" class="line"></span>                    element.style.margin = "0px";
<span id="line7966" class="line"></span>                    element.style.padding = "0px";
<span id="line7967" class="line"></span>                    break;
<span id="line7968" class="line"></span>            }
<span id="line7969" class="line"></span>
<span id="line7970" class="line"></span>            this.controls.push(
<span id="line7971" class="line"></span>                new $.Control( element, controlOptions, div )
<span id="line7972" class="line"></span>            );
<span id="line7973" class="line"></span>            element.style.display = "inline-block";
<span id="line7974" class="line"></span>        },
<span id="line7975" class="line"></span>
<span id="line7976" class="line"></span>
<span id="line7977" class="line"></span>        /**
<span id="line7978" class="line"></span>         * @function
<span id="line7979" class="line"></span>         * @returns {OpenSeadragon.ControlDock} Chainable.
<span id="line7980" class="line"></span>         */
<span id="line7981" class="line"></span>        removeControl: function ( element ) {
<span id="line7982" class="line"></span>            element = $.getElement( element );
<span id="line7983" class="line"></span>            const i = getControlIndex( this, element );
<span id="line7984" class="line"></span>
<span id="line7985" class="line"></span>            if ( i &gt;= 0 ) {
<span id="line7986" class="line"></span>                this.controls[ i ].destroy();
<span id="line7987" class="line"></span>                this.controls.splice( i, 1 );
<span id="line7988" class="line"></span>            }
<span id="line7989" class="line"></span>
<span id="line7990" class="line"></span>            return this;
<span id="line7991" class="line"></span>        },
<span id="line7992" class="line"></span>
<span id="line7993" class="line"></span>        /**
<span id="line7994" class="line"></span>         * @function
<span id="line7995" class="line"></span>         * @returns {OpenSeadragon.ControlDock} Chainable.
<span id="line7996" class="line"></span>         */
<span id="line7997" class="line"></span>        clearControls: function () {
<span id="line7998" class="line"></span>            while ( this.controls.length &gt; 0 ) {
<span id="line7999" class="line"></span>                this.controls.pop().destroy();
<span id="line8000" class="line"></span>            }
<span id="line8001" class="line"></span>
<span id="line8002" class="line"></span>            return this;
<span id="line8003" class="line"></span>        },
<span id="line8004" class="line"></span>
<span id="line8005" class="line"></span>
<span id="line8006" class="line"></span>        /**
<span id="line8007" class="line"></span>         * @function
<span id="line8008" class="line"></span>         * @returns {Boolean}
<span id="line8009" class="line"></span>         */
<span id="line8010" class="line"></span>        areControlsEnabled: function () {
<span id="line8011" class="line"></span>            for ( let i = this.controls.length - 1; i &gt;= 0; i-- ) {
<span id="line8012" class="line"></span>                if ( this.controls[ i ].isVisible() ) {
<span id="line8013" class="line"></span>                    return true;
<span id="line8014" class="line"></span>                }
<span id="line8015" class="line"></span>            }
<span id="line8016" class="line"></span>
<span id="line8017" class="line"></span>            return false;
<span id="line8018" class="line"></span>        },
<span id="line8019" class="line"></span>
<span id="line8020" class="line"></span>
<span id="line8021" class="line"></span>        /**
<span id="line8022" class="line"></span>         * @function
<span id="line8023" class="line"></span>         * @returns {OpenSeadragon.ControlDock} Chainable.
<span id="line8024" class="line"></span>         */
<span id="line8025" class="line"></span>        setControlsEnabled: function( enabled ) {
<span id="line8026" class="line"></span>            for (let i = this.controls.length - 1; i &gt;= 0; i-- ) {
<span id="line8027" class="line"></span>                this.controls[ i ].setVisible( enabled );
<span id="line8028" class="line"></span>            }
<span id="line8029" class="line"></span>
<span id="line8030" class="line"></span>            return this;
<span id="line8031" class="line"></span>        }
<span id="line8032" class="line"></span>
<span id="line8033" class="line"></span>    };
<span id="line8034" class="line"></span>
<span id="line8035" class="line"></span>
<span id="line8036" class="line"></span>    ///////////////////////////////////////////////////////////////////////////////
<span id="line8037" class="line"></span>    // Utility methods
<span id="line8038" class="line"></span>    ///////////////////////////////////////////////////////////////////////////////
<span id="line8039" class="line"></span>    function getControlIndex( dock, element ) {
<span id="line8040" class="line"></span>        const controls = dock.controls;
<span id="line8041" class="line"></span>
<span id="line8042" class="line"></span>        for (let i = controls.length - 1; i &gt;= 0; i-- ) {
<span id="line8043" class="line"></span>            if ( controls[ i ].element === element ) {
<span id="line8044" class="line"></span>                return i;
<span id="line8045" class="line"></span>            }
<span id="line8046" class="line"></span>        }
<span id="line8047" class="line"></span>
<span id="line8048" class="line"></span>        return -1;
<span id="line8049" class="line"></span>    }
<span id="line8050" class="line"></span>
<span id="line8051" class="line"></span>}( OpenSeadragon ));
<span id="line8052" class="line"></span>
<span id="line8053" class="line"></span>/*
<span id="line8054" class="line"></span> * OpenSeadragon - Placement
<span id="line8055" class="line"></span> *
<span id="line8056" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line8057" class="line"></span> *
<span id="line8058" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line8059" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line8060" class="line"></span> * met:
<span id="line8061" class="line"></span> *
<span id="line8062" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line8063" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line8064" class="line"></span> *
<span id="line8065" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line8066" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line8067" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line8068" class="line"></span> *
<span id="line8069" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line8070" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line8071" class="line"></span> *   this software without specific prior written permission.
<span id="line8072" class="line"></span> *
<span id="line8073" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line8074" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line8075" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line8076" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line8077" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line8078" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line8079" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line8080" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line8081" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line8082" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line8083" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line8084" class="line"></span> */
<span id="line8085" class="line"></span>
<span id="line8086" class="line"></span>(function($) {
<span id="line8087" class="line"></span>
<span id="line8088" class="line"></span>    /**
<span id="line8089" class="line"></span>     * An enumeration of positions to anchor an element.
<span id="line8090" class="line"></span>     * @member Placement
<span id="line8091" class="line"></span>     * @memberOf OpenSeadragon
<span id="line8092" class="line"></span>     * @static
<span id="line8093" class="line"></span>     * @readonly
<span id="line8094" class="line"></span>     * @property {OpenSeadragon.Placement} CENTER
<span id="line8095" class="line"></span>     * @property {OpenSeadragon.Placement} TOP_LEFT
<span id="line8096" class="line"></span>     * @property {OpenSeadragon.Placement} TOP
<span id="line8097" class="line"></span>     * @property {OpenSeadragon.Placement} TOP_RIGHT
<span id="line8098" class="line"></span>     * @property {OpenSeadragon.Placement} RIGHT
<span id="line8099" class="line"></span>     * @property {OpenSeadragon.Placement} BOTTOM_RIGHT
<span id="line8100" class="line"></span>     * @property {OpenSeadragon.Placement} BOTTOM
<span id="line8101" class="line"></span>     * @property {OpenSeadragon.Placement} BOTTOM_LEFT
<span id="line8102" class="line"></span>     * @property {OpenSeadragon.Placement} LEFT
<span id="line8103" class="line"></span>     */
<span id="line8104" class="line"></span>    $.Placement = $.freezeObject({
<span id="line8105" class="line"></span>        CENTER:       0,
<span id="line8106" class="line"></span>        TOP_LEFT:     1,
<span id="line8107" class="line"></span>        TOP:          2,
<span id="line8108" class="line"></span>        TOP_RIGHT:    3,
<span id="line8109" class="line"></span>        RIGHT:        4,
<span id="line8110" class="line"></span>        BOTTOM_RIGHT: 5,
<span id="line8111" class="line"></span>        BOTTOM:       6,
<span id="line8112" class="line"></span>        BOTTOM_LEFT:  7,
<span id="line8113" class="line"></span>        LEFT:         8,
<span id="line8114" class="line"></span>        properties: {
<span id="line8115" class="line"></span>            0: {
<span id="line8116" class="line"></span>                isLeft: false,
<span id="line8117" class="line"></span>                isHorizontallyCentered: true,
<span id="line8118" class="line"></span>                isRight: false,
<span id="line8119" class="line"></span>                isTop: false,
<span id="line8120" class="line"></span>                isVerticallyCentered: true,
<span id="line8121" class="line"></span>                isBottom: false
<span id="line8122" class="line"></span>            },
<span id="line8123" class="line"></span>            1: {
<span id="line8124" class="line"></span>                isLeft: true,
<span id="line8125" class="line"></span>                isHorizontallyCentered: false,
<span id="line8126" class="line"></span>                isRight: false,
<span id="line8127" class="line"></span>                isTop: true,
<span id="line8128" class="line"></span>                isVerticallyCentered: false,
<span id="line8129" class="line"></span>                isBottom: false
<span id="line8130" class="line"></span>            },
<span id="line8131" class="line"></span>            2: {
<span id="line8132" class="line"></span>                isLeft: false,
<span id="line8133" class="line"></span>                isHorizontallyCentered: true,
<span id="line8134" class="line"></span>                isRight: false,
<span id="line8135" class="line"></span>                isTop: true,
<span id="line8136" class="line"></span>                isVerticallyCentered: false,
<span id="line8137" class="line"></span>                isBottom: false
<span id="line8138" class="line"></span>            },
<span id="line8139" class="line"></span>            3: {
<span id="line8140" class="line"></span>                isLeft: false,
<span id="line8141" class="line"></span>                isHorizontallyCentered: false,
<span id="line8142" class="line"></span>                isRight: true,
<span id="line8143" class="line"></span>                isTop: true,
<span id="line8144" class="line"></span>                isVerticallyCentered: false,
<span id="line8145" class="line"></span>                isBottom: false
<span id="line8146" class="line"></span>            },
<span id="line8147" class="line"></span>            4: {
<span id="line8148" class="line"></span>                isLeft: false,
<span id="line8149" class="line"></span>                isHorizontallyCentered: false,
<span id="line8150" class="line"></span>                isRight: true,
<span id="line8151" class="line"></span>                isTop: false,
<span id="line8152" class="line"></span>                isVerticallyCentered: true,
<span id="line8153" class="line"></span>                isBottom: false
<span id="line8154" class="line"></span>            },
<span id="line8155" class="line"></span>            5: {
<span id="line8156" class="line"></span>                isLeft: false,
<span id="line8157" class="line"></span>                isHorizontallyCentered: false,
<span id="line8158" class="line"></span>                isRight: true,
<span id="line8159" class="line"></span>                isTop: false,
<span id="line8160" class="line"></span>                isVerticallyCentered: false,
<span id="line8161" class="line"></span>                isBottom: true
<span id="line8162" class="line"></span>            },
<span id="line8163" class="line"></span>            6: {
<span id="line8164" class="line"></span>                isLeft: false,
<span id="line8165" class="line"></span>                isHorizontallyCentered: true,
<span id="line8166" class="line"></span>                isRight: false,
<span id="line8167" class="line"></span>                isTop: false,
<span id="line8168" class="line"></span>                isVerticallyCentered: false,
<span id="line8169" class="line"></span>                isBottom: true
<span id="line8170" class="line"></span>            },
<span id="line8171" class="line"></span>            7: {
<span id="line8172" class="line"></span>                isLeft: true,
<span id="line8173" class="line"></span>                isHorizontallyCentered: false,
<span id="line8174" class="line"></span>                isRight: false,
<span id="line8175" class="line"></span>                isTop: false,
<span id="line8176" class="line"></span>                isVerticallyCentered: false,
<span id="line8177" class="line"></span>                isBottom: true
<span id="line8178" class="line"></span>            },
<span id="line8179" class="line"></span>            8: {
<span id="line8180" class="line"></span>                isLeft: true,
<span id="line8181" class="line"></span>                isHorizontallyCentered: false,
<span id="line8182" class="line"></span>                isRight: false,
<span id="line8183" class="line"></span>                isTop: false,
<span id="line8184" class="line"></span>                isVerticallyCentered: true,
<span id="line8185" class="line"></span>                isBottom: false
<span id="line8186" class="line"></span>            }
<span id="line8187" class="line"></span>        }
<span id="line8188" class="line"></span>    });
<span id="line8189" class="line"></span>
<span id="line8190" class="line"></span>}(OpenSeadragon));
<span id="line8191" class="line"></span>
<span id="line8192" class="line"></span>/*
<span id="line8193" class="line"></span> * OpenSeadragon - Viewer
<span id="line8194" class="line"></span> *
<span id="line8195" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line8196" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line8197" class="line"></span> *
<span id="line8198" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line8199" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line8200" class="line"></span> * met:
<span id="line8201" class="line"></span> *
<span id="line8202" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line8203" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line8204" class="line"></span> *
<span id="line8205" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line8206" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line8207" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line8208" class="line"></span> *
<span id="line8209" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line8210" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line8211" class="line"></span> *   this software without specific prior written permission.
<span id="line8212" class="line"></span> *
<span id="line8213" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line8214" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line8215" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line8216" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line8217" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line8218" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line8219" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line8220" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line8221" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line8222" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line8223" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line8224" class="line"></span> */
<span id="line8225" class="line"></span>
<span id="line8226" class="line"></span>(function( $ ){
<span id="line8227" class="line"></span>
<span id="line8228" class="line"></span>// dictionary from hash to private properties
<span id="line8229" class="line"></span>const THIS = {};
<span id="line8230" class="line"></span>let nextHash = 1;
<span id="line8231" class="line"></span>
<span id="line8232" class="line"></span>/**
<span id="line8233" class="line"></span> *
<span id="line8234" class="line"></span> * The main point of entry into creating a zoomable image on the page.&lt;br&gt;
<span id="line8235" class="line"></span> * &lt;br&gt;
<span id="line8236" class="line"></span> * We have provided an idiomatic javascript constructor which takes
<span id="line8237" class="line"></span> * a single object, but still support the legacy positional arguments.&lt;br&gt;
<span id="line8238" class="line"></span> * &lt;br&gt;
<span id="line8239" class="line"></span> * The options below are given in order that they appeared in the constructor
<span id="line8240" class="line"></span> * as arguments and we translate a positional call into an idiomatic call.&lt;br&gt;
<span id="line8241" class="line"></span> * &lt;br&gt;
<span id="line8242" class="line"></span> * To create a viewer, you can use either of this methods:&lt;br&gt;
<span id="line8243" class="line"></span> * &lt;ul&gt;
<span id="line8244" class="line"></span> * &lt;li&gt;&lt;code&gt;var viewer = new OpenSeadragon.Viewer(options);&lt;/code&gt;&lt;/li&gt;
<span id="line8245" class="line"></span> * &lt;li&gt;&lt;code&gt;var viewer = OpenSeadragon(options);&lt;/code&gt;&lt;/li&gt;
<span id="line8246" class="line"></span> * &lt;/ul&gt;
<span id="line8247" class="line"></span> * @class Viewer
<span id="line8248" class="line"></span> * @classdesc The main OpenSeadragon viewer class.
<span id="line8249" class="line"></span> *
<span id="line8250" class="line"></span> * @memberof OpenSeadragon
<span id="line8251" class="line"></span> * @extends OpenSeadragon.EventSource
<span id="line8252" class="line"></span> * @extends OpenSeadragon.ControlDock
<span id="line8253" class="line"></span> * @param {OpenSeadragon.Options} options - Viewer options.
<span id="line8254" class="line"></span> *
<span id="line8255" class="line"></span> **/
<span id="line8256" class="line"></span>$.Viewer = function( options ) {
<span id="line8257" class="line"></span>
<span id="line8258" class="line"></span>    const args  = arguments;
<span id="line8259" class="line"></span>    const _this = this;
<span id="line8260" class="line"></span>    let i;
<span id="line8261" class="line"></span>
<span id="line8262" class="line"></span>
<span id="line8263" class="line"></span>    //backward compatibility for positional args while preferring more
<span id="line8264" class="line"></span>    //idiomatic javascript options object as the only argument
<span id="line8265" class="line"></span>    if( !$.isPlainObject( options ) ){
<span id="line8266" class="line"></span>        options = {
<span id="line8267" class="line"></span>            id:                 args[ 0 ],
<span id="line8268" class="line"></span>            xmlPath:            args.length &gt; 1 ? args[ 1 ] : undefined,
<span id="line8269" class="line"></span>            prefixUrl:          args.length &gt; 2 ? args[ 2 ] : undefined,
<span id="line8270" class="line"></span>            controls:           args.length &gt; 3 ? args[ 3 ] : undefined,
<span id="line8271" class="line"></span>            overlays:           args.length &gt; 4 ? args[ 4 ] : undefined
<span id="line8272" class="line"></span>        };
<span id="line8273" class="line"></span>    }
<span id="line8274" class="line"></span>
<span id="line8275" class="line"></span>    //options.config and the general config argument are deprecated
<span id="line8276" class="line"></span>    //in favor of the more direct specification of optional settings
<span id="line8277" class="line"></span>    //being pass directly on the options object
<span id="line8278" class="line"></span>    if ( options.config ){
<span id="line8279" class="line"></span>        $.extend( true, options, options.config );
<span id="line8280" class="line"></span>        delete options.config;
<span id="line8281" class="line"></span>    }
<span id="line8282" class="line"></span>
<span id="line8283" class="line"></span>    // Move deprecated drawer options from the base options object into a sub-object
<span id="line8284" class="line"></span>    // This is an array to make it easy to add additional properties to convert to
<span id="line8285" class="line"></span>    // drawer options later if it makes sense to set at the drawer level rather than
<span id="line8286" class="line"></span>    // per tiled image (for example, subPixelRoundingForTransparency).
<span id="line8287" class="line"></span>    const drawerOptionList = [
<span id="line8288" class="line"></span>            'useCanvas', // deprecated
<span id="line8289" class="line"></span>        ];
<span id="line8290" class="line"></span>    options.drawerOptions = Object.assign({},
<span id="line8291" class="line"></span>        drawerOptionList.reduce((drawerOptions, option) =&gt; {
<span id="line8292" class="line"></span>            drawerOptions[option] = options[option];
<span id="line8293" class="line"></span>            delete options[option];
<span id="line8294" class="line"></span>            return drawerOptions;
<span id="line8295" class="line"></span>        }, {}),
<span id="line8296" class="line"></span>        options.drawerOptions);
<span id="line8297" class="line"></span>
<span id="line8298" class="line"></span>    //Public properties
<span id="line8299" class="line"></span>    //Allow the options object to override global defaults
<span id="line8300" class="line"></span>    $.extend( true, this, {
<span id="line8301" class="line"></span>
<span id="line8302" class="line"></span>        //internal state and dom identifiers
<span id="line8303" class="line"></span>        id:             options.id,
<span id="line8304" class="line"></span>        hash:           options.hash || nextHash++,
<span id="line8305" class="line"></span>        /**
<span id="line8306" class="line"></span>         * Parent viewer reference. Base Viewer has null reference, child viewers (such as navigator
<span id="line8307" class="line"></span>         * or reference strip) must reference the parent viewer they were spawned from.
<span id="line8308" class="line"></span>         * @member {OpenSeadragon.Viewer} viewer
<span id="line8309" class="line"></span>         * @memberof OpenSeadragon.Viewer#
<span id="line8310" class="line"></span>         */
<span id="line8311" class="line"></span>        viewer:         null,
<span id="line8312" class="line"></span>        /**
<span id="line8313" class="line"></span>         * Index for page to be shown first next time open() is called (only used in sequenceMode).
<span id="line8314" class="line"></span>         * @member {Number} initialPage
<span id="line8315" class="line"></span>         * @memberof OpenSeadragon.Viewer#
<span id="line8316" class="line"></span>         */
<span id="line8317" class="line"></span>        initialPage:    0,
<span id="line8318" class="line"></span>
<span id="line8319" class="line"></span>        //dom nodes
<span id="line8320" class="line"></span>        /**
<span id="line8321" class="line"></span>         * The parent element of this Viewer instance, passed in when the Viewer was created.
<span id="line8322" class="line"></span>         * @member {Element} element
<span id="line8323" class="line"></span>         * @memberof OpenSeadragon.Viewer#
<span id="line8324" class="line"></span>         */
<span id="line8325" class="line"></span>        element:        null,
<span id="line8326" class="line"></span>        /**
<span id="line8327" class="line"></span>         * A &amp;lt;div&amp;gt; element (provided by {@link OpenSeadragon.ControlDock}), the base element of this Viewer instance.&lt;br&gt;&lt;br&gt;
<span id="line8328" class="line"></span>         * Child element of {@link OpenSeadragon.Viewer#element}.
<span id="line8329" class="line"></span>         * @member {Element} container
<span id="line8330" class="line"></span>         * @memberof OpenSeadragon.Viewer#
<span id="line8331" class="line"></span>         */
<span id="line8332" class="line"></span>        container:      null,
<span id="line8333" class="line"></span>        /**
<span id="line8334" class="line"></span>         * A &amp;lt;div&amp;gt; element, the element where user-input events are handled for panning and zooming.&lt;br&gt;&lt;br&gt;
<span id="line8335" class="line"></span>         * Child element of {@link OpenSeadragon.Viewer#container},
<span id="line8336" class="line"></span>         * positioned on top of {@link OpenSeadragon.Viewer#keyboardCommandArea}.&lt;br&gt;&lt;br&gt;
<span id="line8337" class="line"></span>         * The parent of {@link OpenSeadragon.Drawer#canvas} instances.
<span id="line8338" class="line"></span>         * @member {Element} canvas
<span id="line8339" class="line"></span>         * @memberof OpenSeadragon.Viewer#
<span id="line8340" class="line"></span>         */
<span id="line8341" class="line"></span>        canvas:         null,
<span id="line8342" class="line"></span>
<span id="line8343" class="line"></span>        // Overlays list. An overlay allows to add html on top of the viewer.
<span id="line8344" class="line"></span>        overlays:           [],
<span id="line8345" class="line"></span>        // Container inside the canvas where overlays are drawn.
<span id="line8346" class="line"></span>        overlaysContainer:  null,
<span id="line8347" class="line"></span>
<span id="line8348" class="line"></span>        //private state properties
<span id="line8349" class="line"></span>
<span id="line8350" class="line"></span>        // When we go full-screen we insert ourselves into the body and make
<span id="line8351" class="line"></span>        // everything else hidden. This is basically the same as
<span id="line8352" class="line"></span>        // `requestFullScreen` but works in all browsers: iPhone is known to not
<span id="line8353" class="line"></span>        // allow full-screen with the requestFullScreen API.  This holds the
<span id="line8354" class="line"></span>        // children of the body and their display values, so we can undo our
<span id="line8355" class="line"></span>        // changes when we go out of full-screen
<span id="line8356" class="line"></span>        previousDisplayValuesOfBodyChildren:   [],
<span id="line8357" class="line"></span>
<span id="line8358" class="line"></span>        //This was originally initialized in the constructor and so could never
<span id="line8359" class="line"></span>        //have anything in it.  now it can because we allow it to be specified
<span id="line8360" class="line"></span>        //in the options and is only empty by default if not specified. Also
<span id="line8361" class="line"></span>        //this array was returned from get_controls which I find confusing
<span id="line8362" class="line"></span>        //since this object has a controls property which is treated in other
<span id="line8363" class="line"></span>        //functions like clearControls.  I'm removing the accessors.
<span id="line8364" class="line"></span>        customControls: [],
<span id="line8365" class="line"></span>
<span id="line8366" class="line"></span>        //These are originally not part options but declared as members
<span id="line8367" class="line"></span>        //in initialize.  It's still considered idiomatic to put them here
<span id="line8368" class="line"></span>        //source is here for backwards compatibility. It is not an official
<span id="line8369" class="line"></span>        //part of the API and should not be relied upon.
<span id="line8370" class="line"></span>        source:         null,
<span id="line8371" class="line"></span>        /**
<span id="line8372" class="line"></span>         * Handles rendering of tiles in the viewer. Created for each TileSource opened.
<span id="line8373" class="line"></span>         * @member {OpenSeadragon.Drawer} drawer
<span id="line8374" class="line"></span>         * @memberof OpenSeadragon.Viewer#
<span id="line8375" class="line"></span>         */
<span id="line8376" class="line"></span>        drawer:             null,
<span id="line8377" class="line"></span>        /**
<span id="line8378" class="line"></span>         * Resolved list of drawer type strings (after expanding 'auto', de-duplicating, and
<span id="line8379" class="line"></span>         * normalizing: constructors are replaced by their getType() result). Used to decide
<span id="line8380" class="line"></span>         * allowed fallbacks: WebGL drawer only falls back to canvas when the string 'canvas' is
<span id="line8381" class="line"></span>         * in this list (see per-tile and context-loss fallback). Normalized so includes('canvas')
<span id="line8382" class="line"></span>         * is reliable even when custom drawer constructors were passed in options.
<span id="line8383" class="line"></span>         * @member {string[]} drawerCandidates
<span id="line8384" class="line"></span>         * @memberof OpenSeadragon.Viewer#
<span id="line8385" class="line"></span>         */
<span id="line8386" class="line"></span>        drawerCandidates:   null,
<span id="line8387" class="line"></span>        /**
<span id="line8388" class="line"></span>         * Keeps track of all of the tiled images in the scene.
<span id="line8389" class="line"></span>         * @member {OpenSeadragon.World} world
<span id="line8390" class="line"></span>         * @memberof OpenSeadragon.Viewer#
<span id="line8391" class="line"></span>         */
<span id="line8392" class="line"></span>        world:              null,
<span id="line8393" class="line"></span>        /**
<span id="line8394" class="line"></span>         * Handles coordinate-related functionality - zoom, pan, rotation, etc. Created for each TileSource opened.
<span id="line8395" class="line"></span>         * @member {OpenSeadragon.Viewport} viewport
<span id="line8396" class="line"></span>         * @memberof OpenSeadragon.Viewer#
<span id="line8397" class="line"></span>         */
<span id="line8398" class="line"></span>        viewport:       null,
<span id="line8399" class="line"></span>        /**
<span id="line8400" class="line"></span>         * @member {OpenSeadragon.Navigator} navigator
<span id="line8401" class="line"></span>         * @memberof OpenSeadragon.Viewer#
<span id="line8402" class="line"></span>         */
<span id="line8403" class="line"></span>        navigator:      null,
<span id="line8404" class="line"></span>
<span id="line8405" class="line"></span>        //A collection viewport is a separate viewport used to provide
<span id="line8406" class="line"></span>        //simultaneous rendering of sets of tiles
<span id="line8407" class="line"></span>        collectionViewport:     null,
<span id="line8408" class="line"></span>        collectionDrawer:       null,
<span id="line8409" class="line"></span>
<span id="line8410" class="line"></span>        //UI image resources
<span id="line8411" class="line"></span>        //TODO: rename navImages to uiImages
<span id="line8412" class="line"></span>        navImages:      null,
<span id="line8413" class="line"></span>
<span id="line8414" class="line"></span>        //interface button controls
<span id="line8415" class="line"></span>        buttonGroup:        null,
<span id="line8416" class="line"></span>
<span id="line8417" class="line"></span>        //TODO: this is defunct so safely remove it
<span id="line8418" class="line"></span>        profiler:       null
<span id="line8419" class="line"></span>
<span id="line8420" class="line"></span>    }, $.DEFAULT_SETTINGS, options );
<span id="line8421" class="line"></span>
<span id="line8422" class="line"></span>    if ( typeof ( this.hash) === "undefined" ) {
<span id="line8423" class="line"></span>        throw new Error("A hash must be defined, either by specifying options.id or options.hash.");
<span id="line8424" class="line"></span>    }
<span id="line8425" class="line"></span>    if ( typeof ( THIS[ this.hash ] ) !== "undefined" ) {
<span id="line8426" class="line"></span>        // We don't want to throw an error here, as the user might have discarded
<span id="line8427" class="line"></span>        // the previous viewer with the same hash and now want to recreate it.
<span id="line8428" class="line"></span>        $.console.warn("Hash " + this.hash + " has already been used.");
<span id="line8429" class="line"></span>    }
<span id="line8430" class="line"></span>
<span id="line8431" class="line"></span>    //Private state properties
<span id="line8432" class="line"></span>    THIS[ this.hash ] = {
<span id="line8433" class="line"></span>        fsBoundsDelta:     new $.Point( 1, 1 ),
<span id="line8434" class="line"></span>        prevContainerSize: null,
<span id="line8435" class="line"></span>        animating:         false,
<span id="line8436" class="line"></span>        forceRedraw:       false,
<span id="line8437" class="line"></span>        needsResize:       false,
<span id="line8438" class="line"></span>        forceResize:       false,
<span id="line8439" class="line"></span>        mouseInside:       false,
<span id="line8440" class="line"></span>        group:             null,
<span id="line8441" class="line"></span>        // whether we should be continuously zooming
<span id="line8442" class="line"></span>        zooming:           false,
<span id="line8443" class="line"></span>        // how much we should be continuously zooming by
<span id="line8444" class="line"></span>        zoomFactor:        null,
<span id="line8445" class="line"></span>        lastZoomTime:      null,
<span id="line8446" class="line"></span>        fullPage:          false,
<span id="line8447" class="line"></span>        onfullscreenchange: null,
<span id="line8448" class="line"></span>        lastClickTime: null,
<span id="line8449" class="line"></span>        draggingToZoom: false,
<span id="line8450" class="line"></span>    };
<span id="line8451" class="line"></span>
<span id="line8452" class="line"></span>    this._sequenceIndex = 0;
<span id="line8453" class="line"></span>    this._firstOpen = true;
<span id="line8454" class="line"></span>    this._updateRequestId = null;
<span id="line8455" class="line"></span>    this._loadQueue = [];
<span id="line8456" class="line"></span>    this.currentOverlays = [];
<span id="line8457" class="line"></span>    this._updatePixelDensityRatioBind = null;
<span id="line8458" class="line"></span>
<span id="line8459" class="line"></span>    this._lastScrollTime = $.now(); // variable used to help normalize the scroll event speed of different devices
<span id="line8460" class="line"></span>
<span id="line8461" class="line"></span>    this._fullyLoaded = false; // variable used to track the viewer's aggregate loading state.
<span id="line8462" class="line"></span>
<span id="line8463" class="line"></span>    this._navActionFrames = {};     // tracks cumulative pan distance per key press
<span id="line8464" class="line"></span>    this._navActionVirtuallyHeld = {};   // marks keys virtually held after early release
<span id="line8465" class="line"></span>    this._minNavActionFrames = 10;      // minimum pan distance per tap or key press
<span id="line8466" class="line"></span>
<span id="line8467" class="line"></span>    this._activeActions = { // variable to keep track of currently pressed action
<span id="line8468" class="line"></span>        // Basic arrow key panning (no modifiers)
<span id="line8469" class="line"></span>        panUp: false,
<span id="line8470" class="line"></span>        panDown: false,
<span id="line8471" class="line"></span>        panLeft: false,
<span id="line8472" class="line"></span>        panRight: false,
<span id="line8473" class="line"></span>
<span id="line8474" class="line"></span>        // Modifier-based actions
<span id="line8475" class="line"></span>        zoomIn: false,    // Shift + Up
<span id="line8476" class="line"></span>        zoomOut: false    // Shift + Down
<span id="line8477" class="line"></span>    };
<span id="line8478" class="line"></span>
<span id="line8479" class="line"></span>
<span id="line8480" class="line"></span>    //Inherit some behaviors and properties
<span id="line8481" class="line"></span>    $.EventSource.call( this );
<span id="line8482" class="line"></span>
<span id="line8483" class="line"></span>    this.addHandler( 'open-failed', function ( event ) {
<span id="line8484" class="line"></span>        const msg = $.getString( "Errors.OpenFailed", event.eventSource, event.message);
<span id="line8485" class="line"></span>        _this._showMessage( msg );
<span id="line8486" class="line"></span>    });
<span id="line8487" class="line"></span>
<span id="line8488" class="line"></span>    $.ControlDock.call( this, options );
<span id="line8489" class="line"></span>
<span id="line8490" class="line"></span>    //Deal with tile sources
<span id="line8491" class="line"></span>    if (this.xmlPath) {
<span id="line8492" class="line"></span>        //Deprecated option.  Now it is preferred to use the tileSources option
<span id="line8493" class="line"></span>        this.tileSources = [ this.xmlPath ];
<span id="line8494" class="line"></span>    }
<span id="line8495" class="line"></span>
<span id="line8496" class="line"></span>    this.element              = this.element || document.getElementById( this.id );
<span id="line8497" class="line"></span>    this.canvas               = $.makeNeutralElement( "div" );
<span id="line8498" class="line"></span>    this.canvas.className = "openseadragon-canvas";
<span id="line8499" class="line"></span>
<span id="line8500" class="line"></span>    // Injecting mobile-only CSS to remove focus outline
<span id="line8501" class="line"></span>    if (!document.querySelector('style[data-openseadragon-mobile-css]')) {
<span id="line8502" class="line"></span>        const style = document.createElement('style');
<span id="line8503" class="line"></span>        style.setAttribute('data-openseadragon-mobile-css', 'true');
<span id="line8504" class="line"></span>        style.textContent =
<span id="line8505" class="line"></span>            '@media (hover: none) {' +
<span id="line8506" class="line"></span>            '    .openseadragon-canvas:focus {' +
<span id="line8507" class="line"></span>            '        outline: none !important;' +
<span id="line8508" class="line"></span>            '    }' +
<span id="line8509" class="line"></span>            '}';
<span id="line8510" class="line"></span>        document.head.appendChild(style);
<span id="line8511" class="line"></span>    }
<span id="line8512" class="line"></span>
<span id="line8513" class="line"></span>    (function( style ){
<span id="line8514" class="line"></span>        style.width    = "100%";
<span id="line8515" class="line"></span>        style.height   = "100%";
<span id="line8516" class="line"></span>        style.overflow = "hidden";
<span id="line8517" class="line"></span>        style.position = "absolute";
<span id="line8518" class="line"></span>        style.top      = "0px";
<span id="line8519" class="line"></span>        style.left     = "0px";
<span id="line8520" class="line"></span>    }(this.canvas.style));
<span id="line8521" class="line"></span>    $.setElementTouchActionNone( this.canvas );
<span id="line8522" class="line"></span>    if (options.tabIndex !== "") {
<span id="line8523" class="line"></span>        this.canvas.tabIndex = (options.tabIndex === undefined ? 0 : options.tabIndex);
<span id="line8524" class="line"></span>    }
<span id="line8525" class="line"></span>
<span id="line8526" class="line"></span>    //the container is created through applying the ControlDock constructor above
<span id="line8527" class="line"></span>    this.container.className = "openseadragon-container";
<span id="line8528" class="line"></span>    (function( style ){
<span id="line8529" class="line"></span>        style.width     = "100%";
<span id="line8530" class="line"></span>        style.height    = "100%";
<span id="line8531" class="line"></span>        style.position  = "relative";
<span id="line8532" class="line"></span>        style.overflow  = "hidden";
<span id="line8533" class="line"></span>        style.left      = "0px";
<span id="line8534" class="line"></span>        style.top       = "0px";
<span id="line8535" class="line"></span>        style.textAlign = "left";  // needed to protect against
<span id="line8536" class="line"></span>    }( this.container.style ));
<span id="line8537" class="line"></span>    $.setElementTouchActionNone( this.container );
<span id="line8538" class="line"></span>
<span id="line8539" class="line"></span>    this.container.insertBefore( this.canvas, this.container.firstChild );
<span id="line8540" class="line"></span>    this.element.appendChild( this.container );
<span id="line8541" class="line"></span>    //Used for toggling between fullscreen and default container size
<span id="line8542" class="line"></span>    //TODO: these can be closure private and shared across Viewer
<span id="line8543" class="line"></span>    //      instances.
<span id="line8544" class="line"></span>    this.bodyWidth      = document.body.style.width;
<span id="line8545" class="line"></span>    this.bodyHeight     = document.body.style.height;
<span id="line8546" class="line"></span>    this.bodyOverflow   = document.body.style.overflow;
<span id="line8547" class="line"></span>    this.docOverflow    = document.documentElement.style.overflow;
<span id="line8548" class="line"></span>
<span id="line8549" class="line"></span>    this.innerTracker = new $.MouseTracker({
<span id="line8550" class="line"></span>        userData:                 'Viewer.innerTracker',
<span id="line8551" class="line"></span>        element:                  this.canvas,
<span id="line8552" class="line"></span>        startDisabled:            !this.mouseNavEnabled,
<span id="line8553" class="line"></span>        clickTimeThreshold:       this.clickTimeThreshold,
<span id="line8554" class="line"></span>        clickDistThreshold:       this.clickDistThreshold,
<span id="line8555" class="line"></span>        dblClickTimeThreshold:    this.dblClickTimeThreshold,
<span id="line8556" class="line"></span>        dblClickDistThreshold:    this.dblClickDistThreshold,
<span id="line8557" class="line"></span>        contextMenuHandler:       $.delegate( this, onCanvasContextMenu ),
<span id="line8558" class="line"></span>        keyDownHandler:           $.delegate( this, onCanvasKeyDown ),
<span id="line8559" class="line"></span>        keyUpHandler:             $.delegate(this, onCanvasKeyUp),
<span id="line8560" class="line"></span>        keyHandler:               $.delegate( this, onCanvasKeyPress ),
<span id="line8561" class="line"></span>        clickHandler:             $.delegate( this, onCanvasClick ),
<span id="line8562" class="line"></span>        dblClickHandler:          $.delegate( this, onCanvasDblClick ),
<span id="line8563" class="line"></span>        dragHandler:              $.delegate( this, onCanvasDrag ),
<span id="line8564" class="line"></span>        dragEndHandler:           $.delegate( this, onCanvasDragEnd ),
<span id="line8565" class="line"></span>        enterHandler:             $.delegate( this, onCanvasEnter ),
<span id="line8566" class="line"></span>        leaveHandler:             $.delegate( this, onCanvasLeave ),
<span id="line8567" class="line"></span>        pressHandler:             $.delegate( this, onCanvasPress ),
<span id="line8568" class="line"></span>        releaseHandler:           $.delegate( this, onCanvasRelease ),
<span id="line8569" class="line"></span>        nonPrimaryPressHandler:   $.delegate( this, onCanvasNonPrimaryPress ),
<span id="line8570" class="line"></span>        nonPrimaryReleaseHandler: $.delegate( this, onCanvasNonPrimaryRelease ),
<span id="line8571" class="line"></span>        scrollHandler:            $.delegate( this, onCanvasScroll ),
<span id="line8572" class="line"></span>        pinchHandler:             $.delegate( this, onCanvasPinch ),
<span id="line8573" class="line"></span>        focusHandler:             $.delegate( this, onCanvasFocus ),
<span id="line8574" class="line"></span>        blurHandler:              $.delegate( this, onCanvasBlur ),
<span id="line8575" class="line"></span>    });
<span id="line8576" class="line"></span>
<span id="line8577" class="line"></span>    this.outerTracker = new $.MouseTracker({
<span id="line8578" class="line"></span>        userData:              'Viewer.outerTracker',
<span id="line8579" class="line"></span>        element:               this.container,
<span id="line8580" class="line"></span>        startDisabled:         !this.mouseNavEnabled,
<span id="line8581" class="line"></span>        clickTimeThreshold:    this.clickTimeThreshold,
<span id="line8582" class="line"></span>        clickDistThreshold:    this.clickDistThreshold,
<span id="line8583" class="line"></span>        dblClickTimeThreshold: this.dblClickTimeThreshold,
<span id="line8584" class="line"></span>        dblClickDistThreshold: this.dblClickDistThreshold,
<span id="line8585" class="line"></span>        enterHandler:          $.delegate( this, onContainerEnter ),
<span id="line8586" class="line"></span>        leaveHandler:          $.delegate( this, onContainerLeave )
<span id="line8587" class="line"></span>    });
<span id="line8588" class="line"></span>
<span id="line8589" class="line"></span>    if( this.toolbar ){
<span id="line8590" class="line"></span>        this.toolbar = new $.ControlDock({ element: this.toolbar });
<span id="line8591" class="line"></span>    }
<span id="line8592" class="line"></span>
<span id="line8593" class="line"></span>    this.bindStandardControls();
<span id="line8594" class="line"></span>
<span id="line8595" class="line"></span>    THIS[ this.hash ].prevContainerSize = _getSafeElemSize( this.container );
<span id="line8596" class="line"></span>
<span id="line8597" class="line"></span>    if(window.ResizeObserver){
<span id="line8598" class="line"></span>        this._autoResizePolling = false;
<span id="line8599" class="line"></span>        this._resizeObserver = new ResizeObserver(function(){
<span id="line8600" class="line"></span>            THIS[_this.hash].needsResize = true;
<span id="line8601" class="line"></span>        });
<span id="line8602" class="line"></span>
<span id="line8603" class="line"></span>        this._resizeObserver.observe(this.container, {});
<span id="line8604" class="line"></span>    } else {
<span id="line8605" class="line"></span>        this._autoResizePolling = true;
<span id="line8606" class="line"></span>    }
<span id="line8607" class="line"></span>
<span id="line8608" class="line"></span>    // Create the world
<span id="line8609" class="line"></span>    this.world = new $.World({
<span id="line8610" class="line"></span>        viewer: this
<span id="line8611" class="line"></span>    });
<span id="line8612" class="line"></span>
<span id="line8613" class="line"></span>    this.world.addHandler('add-item', function(event) {
<span id="line8614" class="line"></span>        // For backwards compatibility, we maintain the source property
<span id="line8615" class="line"></span>        _this.source = _this.world.getItemAt(0).source;
<span id="line8616" class="line"></span>
<span id="line8617" class="line"></span>        THIS[ _this.hash ].forceRedraw = true;
<span id="line8618" class="line"></span>
<span id="line8619" class="line"></span>        if (!_this._updateRequestId) {
<span id="line8620" class="line"></span>            _this._updateRequestId = scheduleUpdate( _this, updateMulti );
<span id="line8621" class="line"></span>        }
<span id="line8622" class="line"></span>
<span id="line8623" class="line"></span>        const tiledImage = event.item;
<span id="line8624" class="line"></span>        const fullyLoadedHandler =  function() {
<span id="line8625" class="line"></span>            const newFullyLoaded = _this._areAllFullyLoaded();
<span id="line8626" class="line"></span>            if (newFullyLoaded !== _this._fullyLoaded) {
<span id="line8627" class="line"></span>                _this._fullyLoaded = newFullyLoaded;
<span id="line8628" class="line"></span>
<span id="line8629" class="line"></span>                /**
<span id="line8630" class="line"></span>                 * Fired when the viewer's aggregate "fully loaded" state changes (when all
<span id="line8631" class="line"></span>                 * TiledImages in the world have loaded tiles for the current view resolution).
<span id="line8632" class="line"></span>                 *
<span id="line8633" class="line"></span>                 * @event fully-loaded-change
<span id="line8634" class="line"></span>                 * @memberof OpenSeadragon.Viewer
<span id="line8635" class="line"></span>                 * @type {object}
<span id="line8636" class="line"></span>                 * @property {Boolean} fullyLoaded - The new aggregate "fully loaded" value
<span id="line8637" class="line"></span>                 * @property {OpenSeadragon.Viewer} eventSource - Reference to the Viewer instance
<span id="line8638" class="line"></span>                 * @property {?Object} userData - Arbitrary subscriber-defined object
<span id="line8639" class="line"></span>                 */
<span id="line8640" class="line"></span>                _this.raiseEvent('fully-loaded-change', {
<span id="line8641" class="line"></span>                    fullyLoaded: newFullyLoaded
<span id="line8642" class="line"></span>                });
<span id="line8643" class="line"></span>            }
<span id="line8644" class="line"></span>        };
<span id="line8645" class="line"></span>        tiledImage._fullyLoadedHandlerForViewer = fullyLoadedHandler;
<span id="line8646" class="line"></span>        tiledImage.addHandler('fully-loaded-change', fullyLoadedHandler);
<span id="line8647" class="line"></span>    });
<span id="line8648" class="line"></span>
<span id="line8649" class="line"></span>    this.world.addHandler('remove-item', function(event) {
<span id="line8650" class="line"></span>        const tiledImage = event.item;
<span id="line8651" class="line"></span>
<span id="line8652" class="line"></span>        // SAFE cleanup with existence check
<span id="line8653" class="line"></span>        if (tiledImage._fullyLoadedHandlerForViewer) {
<span id="line8654" class="line"></span>            tiledImage.removeHandler('fully-loaded-change', tiledImage._fullyLoadedHandlerForViewer);
<span id="line8655" class="line"></span>            delete tiledImage._fullyLoadedHandlerForViewer; // Remove the reference
<span id="line8656" class="line"></span>        }
<span id="line8657" class="line"></span>
<span id="line8658" class="line"></span>        // For backwards compatibility, we maintain the source property
<span id="line8659" class="line"></span>        if (_this.world.getItemCount()) {
<span id="line8660" class="line"></span>            _this.source = _this.world.getItemAt(0).source;
<span id="line8661" class="line"></span>        } else {
<span id="line8662" class="line"></span>            _this.source = null;
<span id="line8663" class="line"></span>        }
<span id="line8664" class="line"></span>
<span id="line8665" class="line"></span>        THIS[ _this.hash ].forceRedraw = true;
<span id="line8666" class="line"></span>    });
<span id="line8667" class="line"></span>
<span id="line8668" class="line"></span>    this.world.addHandler('metrics-change', function(event) {
<span id="line8669" class="line"></span>        if (_this.viewport) {
<span id="line8670" class="line"></span>            _this.viewport._setContentBounds(_this.world.getHomeBounds(), _this.world.getContentFactor());
<span id="line8671" class="line"></span>        }
<span id="line8672" class="line"></span>    });
<span id="line8673" class="line"></span>
<span id="line8674" class="line"></span>    this.world.addHandler('item-index-change', function(event) {
<span id="line8675" class="line"></span>        // For backwards compatibility, we maintain the source property
<span id="line8676" class="line"></span>        _this.source = _this.world.getItemAt(0).source;
<span id="line8677" class="line"></span>    });
<span id="line8678" class="line"></span>
<span id="line8679" class="line"></span>    // Create the viewport
<span id="line8680" class="line"></span>    this.viewport = new $.Viewport({
<span id="line8681" class="line"></span>        containerSize:                      THIS[ this.hash ].prevContainerSize,
<span id="line8682" class="line"></span>        springStiffness:                    this.springStiffness,
<span id="line8683" class="line"></span>        animationTime:                      this.animationTime,
<span id="line8684" class="line"></span>        minZoomImageRatio:                  this.minZoomImageRatio,
<span id="line8685" class="line"></span>        maxZoomPixelRatio:                  this.maxZoomPixelRatio,
<span id="line8686" class="line"></span>        visibilityRatio:                    this.visibilityRatio,
<span id="line8687" class="line"></span>        wrapHorizontal:                     this.wrapHorizontal,
<span id="line8688" class="line"></span>        wrapVertical:                       this.wrapVertical,
<span id="line8689" class="line"></span>        defaultZoomLevel:                   this.defaultZoomLevel,
<span id="line8690" class="line"></span>        minZoomLevel:                       this.minZoomLevel,
<span id="line8691" class="line"></span>        maxZoomLevel:                       this.maxZoomLevel,
<span id="line8692" class="line"></span>        viewer:                             this,
<span id="line8693" class="line"></span>        degrees:                            this.degrees,
<span id="line8694" class="line"></span>        flipped:                            this.flipped,
<span id="line8695" class="line"></span>        overlayPreserveContentDirection:    this.overlayPreserveContentDirection,
<span id="line8696" class="line"></span>        navigatorRotate:                    this.navigatorRotate,
<span id="line8697" class="line"></span>        homeFillsViewer:                    this.homeFillsViewer,
<span id="line8698" class="line"></span>        margins:                            this.viewportMargins,
<span id="line8699" class="line"></span>        silenceMultiImageWarnings:          this.silenceMultiImageWarnings
<span id="line8700" class="line"></span>    });
<span id="line8701" class="line"></span>
<span id="line8702" class="line"></span>    this.viewport._setContentBounds(this.world.getHomeBounds(), this.world.getContentFactor());
<span id="line8703" class="line"></span>
<span id="line8704" class="line"></span>    // Create the image loader
<span id="line8705" class="line"></span>    this.imageLoader = new $.ImageLoader({
<span id="line8706" class="line"></span>        jobLimit: this.imageLoaderLimit,
<span id="line8707" class="line"></span>        timeout: options.timeout,
<span id="line8708" class="line"></span>        tileRetryMax: this.tileRetryMax,
<span id="line8709" class="line"></span>        tileRetryDelay: this.tileRetryDelay
<span id="line8710" class="line"></span>    });
<span id="line8711" class="line"></span>
<span id="line8712" class="line"></span>    // Create the tile cache
<span id="line8713" class="line"></span>    this.tileCache = new $.TileCache({
<span id="line8714" class="line"></span>        viewer: this,
<span id="line8715" class="line"></span>        maxImageCacheCount: this.maxImageCacheCount
<span id="line8716" class="line"></span>    });
<span id="line8717" class="line"></span>
<span id="line8718" class="line"></span>    //Create the drawer based on selected options
<span id="line8719" class="line"></span>    if (Object.prototype.hasOwnProperty.call(this.drawerOptions, 'useCanvas') ){
<span id="line8720" class="line"></span>        $.console.error('useCanvas is deprecated, use the "drawer" option to indicate preferred drawer(s)');
<span id="line8721" class="line"></span>
<span id="line8722" class="line"></span>        // for backwards compatibility, use HTMLDrawer if useCanvas is defined and is falsey
<span id="line8723" class="line"></span>        if (!this.drawerOptions.useCanvas){
<span id="line8724" class="line"></span>            this.drawer = $.HTMLDrawer;
<span id="line8725" class="line"></span>        }
<span id="line8726" class="line"></span>
<span id="line8727" class="line"></span>        delete this.drawerOptions.useCanvas;
<span id="line8728" class="line"></span>    }
<span id="line8729" class="line"></span>    let drawerCandidates = Array.isArray(this.drawer) ? this.drawer : [this.drawer];
<span id="line8730" class="line"></span>    if (drawerCandidates.length === 0){
<span id="line8731" class="line"></span>        // if an empty array was passed in, throw a warning and use the defaults
<span id="line8732" class="line"></span>        // note: if the drawer option is not specified, the defaults will already be set so this won't apply
<span id="line8733" class="line"></span>        drawerCandidates = [$.DEFAULT_SETTINGS.drawer].flat(); // ensure it is a list
<span id="line8734" class="line"></span>        $.console.warn('No valid drawers were selected. Using the default value.');
<span id="line8735" class="line"></span>    }
<span id="line8736" class="line"></span>
<span id="line8737" class="line"></span>    // 'auto' is expanded in the candidate list in a platform-dependent way: on iOS-like devices
<span id="line8738" class="line"></span>    // to ['canvas'] only, on other platforms to ['webgl', 'canvas'] so that if WebGL fails at
<span id="line8739" class="line"></span>    // creation, canvas is tried next. Same detection as getAutoDrawerCandidates() / determineDrawer('auto').
<span id="line8740" class="line"></span>    drawerCandidates = drawerCandidates.flatMap(
<span id="line8741" class="line"></span>        function(c) {
<span id="line8742" class="line"></span>            return c === 'auto' ? getAutoDrawerCandidates() : [c];
<span id="line8743" class="line"></span>        }
<span id="line8744" class="line"></span>    );
<span id="line8745" class="line"></span>    drawerCandidates = drawerCandidates.filter(
<span id="line8746" class="line"></span>        function(c, i, arr) {
<span id="line8747" class="line"></span>            return arr.indexOf(c) === i;
<span id="line8748" class="line"></span>        }
<span id="line8749" class="line"></span>    );
<span id="line8750" class="line"></span>    this.drawerCandidates = drawerCandidates.map(getDrawerTypeString).filter(Boolean);
<span id="line8751" class="line"></span>
<span id="line8752" class="line"></span>    this.drawer = null;
<span id="line8753" class="line"></span>    for (const drawerCandidate of drawerCandidates){
<span id="line8754" class="line"></span>        const success = this.requestDrawer(drawerCandidate, {mainDrawer: true, redrawImmediately: false});
<span id="line8755" class="line"></span>        if(success){
<span id="line8756" class="line"></span>            break;
<span id="line8757" class="line"></span>        }
<span id="line8758" class="line"></span>    }
<span id="line8759" class="line"></span>
<span id="line8760" class="line"></span>    if (!this.drawer){
<span id="line8761" class="line"></span>        $.console.error('No drawer could be created!');
<span id="line8762" class="line"></span>        throw('Error with creating the selected drawer(s)');
<span id="line8763" class="line"></span>    }
<span id="line8764" class="line"></span>
<span id="line8765" class="line"></span>    // Pass the imageSmoothingEnabled option along to the drawer
<span id="line8766" class="line"></span>    this.drawer.setImageSmoothingEnabled(this.imageSmoothingEnabled);
<span id="line8767" class="line"></span>
<span id="line8768" class="line"></span>    // Overlay container
<span id="line8769" class="line"></span>    this.overlaysContainer    = $.makeNeutralElement( "div" );
<span id="line8770" class="line"></span>    this.canvas.appendChild( this.overlaysContainer );
<span id="line8771" class="line"></span>
<span id="line8772" class="line"></span>    // Now that we have a drawer, see if it supports rotate. If not we need to remove the rotate buttons
<span id="line8773" class="line"></span>    if (!this.drawer.canRotate()) {
<span id="line8774" class="line"></span>        // Disable/remove the rotate left/right buttons since they aren't supported
<span id="line8775" class="line"></span>        if (this.rotateLeft) {
<span id="line8776" class="line"></span>            i = this.buttonGroup.buttons.indexOf(this.rotateLeft);
<span id="line8777" class="line"></span>            this.buttonGroup.buttons.splice(i, 1);
<span id="line8778" class="line"></span>            this.buttonGroup.element.removeChild(this.rotateLeft.element);
<span id="line8779" class="line"></span>        }
<span id="line8780" class="line"></span>        if (this.rotateRight) {
<span id="line8781" class="line"></span>            i = this.buttonGroup.buttons.indexOf(this.rotateRight);
<span id="line8782" class="line"></span>            this.buttonGroup.buttons.splice(i, 1);
<span id="line8783" class="line"></span>            this.buttonGroup.element.removeChild(this.rotateRight.element);
<span id="line8784" class="line"></span>        }
<span id="line8785" class="line"></span>    }
<span id="line8786" class="line"></span>
<span id="line8787" class="line"></span>    this._addUpdatePixelDensityRatioEvent();
<span id="line8788" class="line"></span>
<span id="line8789" class="line"></span>    if ('navigatorAutoResize' in this) {
<span id="line8790" class="line"></span>        $.console.warn('navigatorAutoResize is deprecated, this value will be ignored.');
<span id="line8791" class="line"></span>    }
<span id="line8792" class="line"></span>
<span id="line8793" class="line"></span>    //Instantiate a navigator if configured
<span id="line8794" class="line"></span>    if ( this.showNavigator){
<span id="line8795" class="line"></span>        this.navigator = new $.Navigator({
<span id="line8796" class="line"></span>            element:           this.navigatorElement,
<span id="line8797" class="line"></span>            id:                this.navigatorId,
<span id="line8798" class="line"></span>            position:          this.navigatorPosition,
<span id="line8799" class="line"></span>            sizeRatio:         this.navigatorSizeRatio,
<span id="line8800" class="line"></span>            maintainSizeRatio: this.navigatorMaintainSizeRatio,
<span id="line8801" class="line"></span>            top:               this.navigatorTop,
<span id="line8802" class="line"></span>            left:              this.navigatorLeft,
<span id="line8803" class="line"></span>            width:             this.navigatorWidth,
<span id="line8804" class="line"></span>            height:            this.navigatorHeight,
<span id="line8805" class="line"></span>            autoFade:          this.navigatorAutoFade,
<span id="line8806" class="line"></span>            prefixUrl:         this.prefixUrl,
<span id="line8807" class="line"></span>            viewer:            this,
<span id="line8808" class="line"></span>            navigatorRotate:   this.navigatorRotate,
<span id="line8809" class="line"></span>            background:        this.navigatorBackground,
<span id="line8810" class="line"></span>            opacity:           this.navigatorOpacity,
<span id="line8811" class="line"></span>            borderColor:       this.navigatorBorderColor,
<span id="line8812" class="line"></span>            displayRegionColor: this.navigatorDisplayRegionColor,
<span id="line8813" class="line"></span>            crossOriginPolicy: this.crossOriginPolicy,
<span id="line8814" class="line"></span>            animationTime:     this.animationTime,
<span id="line8815" class="line"></span>            drawer:            this.drawer.getType(),
<span id="line8816" class="line"></span>            drawerOptions:     this.drawerOptions,
<span id="line8817" class="line"></span>            loadTilesWithAjax: this.loadTilesWithAjax,
<span id="line8818" class="line"></span>            ajaxHeaders:       this.ajaxHeaders,
<span id="line8819" class="line"></span>            ajaxWithCredentials: this.ajaxWithCredentials,
<span id="line8820" class="line"></span>        });
<span id="line8821" class="line"></span>    }
<span id="line8822" class="line"></span>
<span id="line8823" class="line"></span>    // Sequence mode
<span id="line8824" class="line"></span>    if (this.sequenceMode) {
<span id="line8825" class="line"></span>        this.bindSequenceControls();
<span id="line8826" class="line"></span>    }
<span id="line8827" class="line"></span>
<span id="line8828" class="line"></span>    // Open initial tilesources
<span id="line8829" class="line"></span>    if (this.tileSources) {
<span id="line8830" class="line"></span>        this.open( this.tileSources );
<span id="line8831" class="line"></span>    }
<span id="line8832" class="line"></span>
<span id="line8833" class="line"></span>    // Add custom controls
<span id="line8834" class="line"></span>    for ( i = 0; i &lt; this.customControls.length; i++ ) {
<span id="line8835" class="line"></span>        this.addControl(
<span id="line8836" class="line"></span>            this.customControls[ i ].id,
<span id="line8837" class="line"></span>            {anchor: this.customControls[ i ].anchor}
<span id="line8838" class="line"></span>        );
<span id="line8839" class="line"></span>    }
<span id="line8840" class="line"></span>
<span id="line8841" class="line"></span>    // Initial fade out
<span id="line8842" class="line"></span>    $.requestAnimationFrame( function(){
<span id="line8843" class="line"></span>        beginControlsAutoHide( _this );
<span id="line8844" class="line"></span>    } );
<span id="line8845" class="line"></span>
<span id="line8846" class="line"></span>    // Register the viewer
<span id="line8847" class="line"></span>    $._viewers.set(this.element, this);
<span id="line8848" class="line"></span>};
<span id="line8849" class="line"></span>
<span id="line8850" class="line"></span>$.extend( $.Viewer.prototype, $.EventSource.prototype, $.ControlDock.prototype, /** @lends OpenSeadragon.Viewer.prototype */{
<span id="line8851" class="line"></span>
<span id="line8852" class="line"></span>
<span id="line8853" class="line"></span>    /**
<span id="line8854" class="line"></span>     * @function
<span id="line8855" class="line"></span>     * @returns {Boolean}
<span id="line8856" class="line"></span>     */
<span id="line8857" class="line"></span>    isOpen: function () {
<span id="line8858" class="line"></span>        return !!this.world.getItemCount();
<span id="line8859" class="line"></span>    },
<span id="line8860" class="line"></span>
<span id="line8861" class="line"></span>    /**
<span id="line8862" class="line"></span>     * Checks whether all TiledImage instances in the viewer's world are fully loaded.
<span id="line8863" class="line"></span>     * This determines if the entire viewer content is ready for optimal display without partial tile loading.
<span id="line8864" class="line"></span>     * @private
<span id="line8865" class="line"></span>     * @returns {Boolean} True if all TiledImages report being fully loaded,
<span id="line8866" class="line"></span>     *                    false if any image still has pending tiles
<span id="line8867" class="line"></span>     */
<span id="line8868" class="line"></span>    _areAllFullyLoaded: function() {
<span id="line8869" class="line"></span>        const count = this.world.getItemCount();
<span id="line8870" class="line"></span>
<span id="line8871" class="line"></span>        // Iterate through all TiledImages in the viewer's world
<span id="line8872" class="line"></span>        for (let i = 0; i &lt; count; i++) {
<span id="line8873" class="line"></span>            let tiledImage = this.world.getItemAt(i);
<span id="line8874" class="line"></span>
<span id="line8875" class="line"></span>            // Return immediately if any image isn't fully loaded
<span id="line8876" class="line"></span>            if (!tiledImage.getFullyLoaded()) {
<span id="line8877" class="line"></span>                return false;
<span id="line8878" class="line"></span>            }
<span id="line8879" class="line"></span>        }
<span id="line8880" class="line"></span>        // All images passed the check
<span id="line8881" class="line"></span>        return true;
<span id="line8882" class="line"></span>    },
<span id="line8883" class="line"></span>
<span id="line8884" class="line"></span>    /**
<span id="line8885" class="line"></span>     * @function
<span id="line8886" class="line"></span>     * @returns {Boolean} True if all required tiles are loaded, false otherwise
<span id="line8887" class="line"></span>     */
<span id="line8888" class="line"></span>    getFullyLoaded: function() {
<span id="line8889" class="line"></span>        return this._fullyLoaded;
<span id="line8890" class="line"></span>    },
<span id="line8891" class="line"></span>
<span id="line8892" class="line"></span>    /**
<span id="line8893" class="line"></span>     * Executes the provided callback when the TiledImage is fully loaded. If already loaded,
<span id="line8894" class="line"></span>     * schedules the callback asynchronously. Otherwise, attaches a one-time event listener
<span id="line8895" class="line"></span>     * for the 'fully-loaded-change' event.
<span id="line8896" class="line"></span>     * @param {Function} callback - Function to execute when loading completes
<span id="line8897" class="line"></span>     * @memberof OpenSeadragon.Viewer.prototype
<span id="line8898" class="line"></span>     */
<span id="line8899" class="line"></span>    whenFullyLoaded: function(callback) {
<span id="line8900" class="line"></span>        if (this.getFullyLoaded()) {
<span id="line8901" class="line"></span>            setTimeout(callback, 1); // Asynchronous execution
<span id="line8902" class="line"></span>        } else {
<span id="line8903" class="line"></span>            this.addOnceHandler('fully-loaded-change', function() {
<span id="line8904" class="line"></span>                callback(); // Maintain context
<span id="line8905" class="line"></span>            });
<span id="line8906" class="line"></span>        }
<span id="line8907" class="line"></span>    },
<span id="line8908" class="line"></span>
<span id="line8909" class="line"></span>    // deprecated
<span id="line8910" class="line"></span>    openDzi: function ( dzi ) {
<span id="line8911" class="line"></span>        $.console.error( "[Viewer.openDzi] this function is deprecated; use Viewer.open() instead." );
<span id="line8912" class="line"></span>        return this.open( dzi );
<span id="line8913" class="line"></span>    },
<span id="line8914" class="line"></span>
<span id="line8915" class="line"></span>    // deprecated
<span id="line8916" class="line"></span>    openTileSource: function ( tileSource ) {
<span id="line8917" class="line"></span>        $.console.error( "[Viewer.openTileSource] this function is deprecated; use Viewer.open() instead." );
<span id="line8918" class="line"></span>        return this.open( tileSource );
<span id="line8919" class="line"></span>    },
<span id="line8920" class="line"></span>
<span id="line8921" class="line"></span>    //deprecated
<span id="line8922" class="line"></span>    get buttons () {
<span id="line8923" class="line"></span>        $.console.warn('Viewer.buttons is deprecated; Please use Viewer.buttonGroup');
<span id="line8924" class="line"></span>        return this.buttonGroup;
<span id="line8925" class="line"></span>    },
<span id="line8926" class="line"></span>
<span id="line8927" class="line"></span>    /**
<span id="line8928" class="line"></span>     * Open tiled images into the viewer, closing any others.
<span id="line8929" class="line"></span>     * To get the TiledImage instance created by open, add an event listener for
<span id="line8930" class="line"></span>     * {@link OpenSeadragon.Viewer.html#.event:open}, which when fired can be used to get access
<span id="line8931" class="line"></span>     * to the instance, i.e., viewer.world.getItemAt(0).
<span id="line8932" class="line"></span>     * @function
<span id="line8933" class="line"></span>     * @param {OpenSeadragon.TileSourceSpecifier|OpenSeadragon.TileSourceSpecifier[]} tileSources - This can be a TiledImage
<span id="line8934" class="line"></span>     * specifier, a TileSource specifier, or an array of either. A TiledImage specifier
<span id="line8935" class="line"></span>     * is the same as the options parameter for {@link OpenSeadragon.Viewer#addTiledImage},
<span id="line8936" class="line"></span>     * except for the index property; images are added in sequence.
<span id="line8937" class="line"></span>     * A TileSource specifier is anything you could pass as the tileSource property
<span id="line8938" class="line"></span>     * of the options parameter for {@link OpenSeadragon.Viewer#addTiledImage}.
<span id="line8939" class="line"></span>     * @param {Number} [initialPage = undefined] - If sequenceMode is true, display this page initially
<span id="line8940" class="line"></span>     * for the given tileSources. If specified, will overwrite the Viewer's existing initialPage property.
<span id="line8941" class="line"></span>     * @returns {OpenSeadragon.Viewer} Chainable.
<span id="line8942" class="line"></span>     * @fires OpenSeadragon.Viewer.event:open
<span id="line8943" class="line"></span>     * @fires OpenSeadragon.Viewer.event:open-failed
<span id="line8944" class="line"></span>     */
<span id="line8945" class="line"></span>    open: function (tileSources, initialPage = undefined) {
<span id="line8946" class="line"></span>        const _this = this;
<span id="line8947" class="line"></span>
<span id="line8948" class="line"></span>        this.close();
<span id="line8949" class="line"></span>
<span id="line8950" class="line"></span>        if (!tileSources) {
<span id="line8951" class="line"></span>            return this;
<span id="line8952" class="line"></span>        }
<span id="line8953" class="line"></span>
<span id="line8954" class="line"></span>        if (this.sequenceMode &amp;&amp; $.isArray(tileSources)) {
<span id="line8955" class="line"></span>            if (this.referenceStrip) {
<span id="line8956" class="line"></span>                this.referenceStrip.destroy();
<span id="line8957" class="line"></span>                this.referenceStrip = null;
<span id="line8958" class="line"></span>            }
<span id="line8959" class="line"></span>
<span id="line8960" class="line"></span>            if (typeof initialPage !== 'undefined' &amp;&amp; !isNaN(initialPage)) {
<span id="line8961" class="line"></span>              this.initialPage = initialPage;
<span id="line8962" class="line"></span>            }
<span id="line8963" class="line"></span>
<span id="line8964" class="line"></span>            this.tileSources = tileSources;
<span id="line8965" class="line"></span>            this._sequenceIndex = Math.max(0, Math.min(this.tileSources.length - 1, this.initialPage));
<span id="line8966" class="line"></span>            if (this.tileSources.length) {
<span id="line8967" class="line"></span>                this.open(this.tileSources[this._sequenceIndex]);
<span id="line8968" class="line"></span>
<span id="line8969" class="line"></span>                if ( this.showReferenceStrip ){
<span id="line8970" class="line"></span>                    this.addReferenceStrip();
<span id="line8971" class="line"></span>                }
<span id="line8972" class="line"></span>            }
<span id="line8973" class="line"></span>
<span id="line8974" class="line"></span>            this._updateSequenceButtons( this._sequenceIndex );
<span id="line8975" class="line"></span>            return this;
<span id="line8976" class="line"></span>        }
<span id="line8977" class="line"></span>
<span id="line8978" class="line"></span>        if (!$.isArray(tileSources)) {
<span id="line8979" class="line"></span>            tileSources = [tileSources];
<span id="line8980" class="line"></span>        }
<span id="line8981" class="line"></span>
<span id="line8982" class="line"></span>        if (!tileSources.length) {
<span id="line8983" class="line"></span>            return this;
<span id="line8984" class="line"></span>        }
<span id="line8985" class="line"></span>
<span id="line8986" class="line"></span>        this._opening = true;
<span id="line8987" class="line"></span>
<span id="line8988" class="line"></span>        const expected = tileSources.length;
<span id="line8989" class="line"></span>        let successes = 0;
<span id="line8990" class="line"></span>        let failures = 0;
<span id="line8991" class="line"></span>        let failEvent;
<span id="line8992" class="line"></span>
<span id="line8993" class="line"></span>        const checkCompletion = function() {
<span id="line8994" class="line"></span>            if (successes + failures === expected) {
<span id="line8995" class="line"></span>                if (successes) {
<span id="line8996" class="line"></span>                    if (_this._firstOpen || !_this.preserveViewport) {
<span id="line8997" class="line"></span>                        _this.viewport.goHome( true );
<span id="line8998" class="line"></span>                        _this.viewport.update();
<span id="line8999" class="line"></span>                    }
<span id="line9000" class="line"></span>
<span id="line9001" class="line"></span>                    _this._firstOpen = false;
<span id="line9002" class="line"></span>
<span id="line9003" class="line"></span>                    let source = tileSources[0];
<span id="line9004" class="line"></span>                    if (source.tileSource) {
<span id="line9005" class="line"></span>                        source = source.tileSource;
<span id="line9006" class="line"></span>                    }
<span id="line9007" class="line"></span>
<span id="line9008" class="line"></span>                    // Global overlays
<span id="line9009" class="line"></span>                    if( _this.overlays &amp;&amp; !_this.preserveOverlays ){
<span id="line9010" class="line"></span>                        for ( let i = 0; i &lt; _this.overlays.length; i++ ) {
<span id="line9011" class="line"></span>                            _this.currentOverlays[ i ] = getOverlayObject( _this, _this.overlays[ i ] );
<span id="line9012" class="line"></span>                        }
<span id="line9013" class="line"></span>                    }
<span id="line9014" class="line"></span>
<span id="line9015" class="line"></span>                    _this._drawOverlays();
<span id="line9016" class="line"></span>                    _this._opening = false;
<span id="line9017" class="line"></span>
<span id="line9018" class="line"></span>                    /**
<span id="line9019" class="line"></span>                     * Raised when the viewer has opened and loaded one or more TileSources.
<span id="line9020" class="line"></span>                     *
<span id="line9021" class="line"></span>                     * @event open
<span id="line9022" class="line"></span>                     * @memberof OpenSeadragon.Viewer
<span id="line9023" class="line"></span>                     * @type {object}
<span id="line9024" class="line"></span>                     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line9025" class="line"></span>                     * @property {OpenSeadragon.TileSource} source - The tile source that was opened.
<span id="line9026" class="line"></span>                     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line9027" class="line"></span>                     */
<span id="line9028" class="line"></span>                    // TODO: what if there are multiple sources?
<span id="line9029" class="line"></span>                    _this.raiseEvent( 'open', { source: source } );
<span id="line9030" class="line"></span>                } else {
<span id="line9031" class="line"></span>                    _this._opening = false;
<span id="line9032" class="line"></span>
<span id="line9033" class="line"></span>                    /**
<span id="line9034" class="line"></span>                     * Raised when an error occurs loading a TileSource.
<span id="line9035" class="line"></span>                     *
<span id="line9036" class="line"></span>                     * @event open-failed
<span id="line9037" class="line"></span>                     * @memberof OpenSeadragon.Viewer
<span id="line9038" class="line"></span>                     * @type {object}
<span id="line9039" class="line"></span>                     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line9040" class="line"></span>                     * @property {String} message - Information about what failed.
<span id="line9041" class="line"></span>                     * @property {String} source - The tile source that failed.
<span id="line9042" class="line"></span>                     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line9043" class="line"></span>                     */
<span id="line9044" class="line"></span>                    _this.raiseEvent( 'open-failed', failEvent );
<span id="line9045" class="line"></span>                }
<span id="line9046" class="line"></span>            }
<span id="line9047" class="line"></span>        };
<span id="line9048" class="line"></span>
<span id="line9049" class="line"></span>        const doOne = function(index, options) {
<span id="line9050" class="line"></span>            if (!$.isPlainObject(options) || !options.tileSource) {
<span id="line9051" class="line"></span>                options = {
<span id="line9052" class="line"></span>                    tileSource: options
<span id="line9053" class="line"></span>                };
<span id="line9054" class="line"></span>            }
<span id="line9055" class="line"></span>
<span id="line9056" class="line"></span>            if (options.index !== undefined) {
<span id="line9057" class="line"></span>                $.console.warn('[Viewer.open] Ignoring user-supplied index; preserving order by setting index to ' + index + '. If you need to set indexes, use addTiledImage instead.');
<span id="line9058" class="line"></span>                delete options.index;
<span id="line9059" class="line"></span>                // ensure we keep the order we received
<span id="line9060" class="line"></span>                options.index = index;
<span id="line9061" class="line"></span>            }
<span id="line9062" class="line"></span>
<span id="line9063" class="line"></span>            if (options.collectionImmediately === undefined) {
<span id="line9064" class="line"></span>                options.collectionImmediately = true;
<span id="line9065" class="line"></span>            }
<span id="line9066" class="line"></span>
<span id="line9067" class="line"></span>            const originalSuccess = options.success;
<span id="line9068" class="line"></span>            options.success = function(event) {
<span id="line9069" class="line"></span>                successes++;
<span id="line9070" class="line"></span>
<span id="line9071" class="line"></span>                // TODO: now that options has other things besides tileSource, the overlays
<span id="line9072" class="line"></span>                // should probably be at the options level, not the tileSource level.
<span id="line9073" class="line"></span>                if (options.tileSource.overlays) {
<span id="line9074" class="line"></span>                    for (let i = 0; i &lt; options.tileSource.overlays.length; i++) {
<span id="line9075" class="line"></span>                        _this.addOverlay(options.tileSource.overlays[i]);
<span id="line9076" class="line"></span>                    }
<span id="line9077" class="line"></span>                }
<span id="line9078" class="line"></span>
<span id="line9079" class="line"></span>                if (originalSuccess) {
<span id="line9080" class="line"></span>                    originalSuccess(event);
<span id="line9081" class="line"></span>                }
<span id="line9082" class="line"></span>
<span id="line9083" class="line"></span>                checkCompletion();
<span id="line9084" class="line"></span>            };
<span id="line9085" class="line"></span>
<span id="line9086" class="line"></span>            const originalError = options.error;
<span id="line9087" class="line"></span>            options.error = function(event) {
<span id="line9088" class="line"></span>                failures++;
<span id="line9089" class="line"></span>
<span id="line9090" class="line"></span>                if (!failEvent) {
<span id="line9091" class="line"></span>                    failEvent = event;
<span id="line9092" class="line"></span>                }
<span id="line9093" class="line"></span>
<span id="line9094" class="line"></span>                if (originalError) {
<span id="line9095" class="line"></span>                    originalError(event);
<span id="line9096" class="line"></span>                }
<span id="line9097" class="line"></span>
<span id="line9098" class="line"></span>                checkCompletion();
<span id="line9099" class="line"></span>            };
<span id="line9100" class="line"></span>
<span id="line9101" class="line"></span>            _this.addTiledImage(options);
<span id="line9102" class="line"></span>        };
<span id="line9103" class="line"></span>
<span id="line9104" class="line"></span>        // TileSources
<span id="line9105" class="line"></span>        for (let i = 0; i &lt; tileSources.length; i++) {
<span id="line9106" class="line"></span>            doOne(i, tileSources[i]);
<span id="line9107" class="line"></span>        }
<span id="line9108" class="line"></span>
<span id="line9109" class="line"></span>        return this;
<span id="line9110" class="line"></span>    },
<span id="line9111" class="line"></span>
<span id="line9112" class="line"></span>    /**
<span id="line9113" class="line"></span>     * Updates data within every tile in the viewer. Should be called
<span id="line9114" class="line"></span>     * when tiles are outdated and should be re-processed. Useful mainly
<span id="line9115" class="line"></span>     * for plugins that change tile data.
<span id="line9116" class="line"></span>     * @function
<span id="line9117" class="line"></span>     * @param {Boolean} [restoreTiles=true] if true, tile processing starts from the tile original data
<span id="line9118" class="line"></span>     * @fires OpenSeadragon.Viewer.event:tile-invalidated
<span id="line9119" class="line"></span>     * @return {OpenSeadragon.Promise&lt;?&gt;}
<span id="line9120" class="line"></span>     */
<span id="line9121" class="line"></span>    requestInvalidate: function (restoreTiles = true) {
<span id="line9122" class="line"></span>        if ( !THIS[ this.hash ] || !this._drawerList ) {
<span id="line9123" class="line"></span>            //this viewer has already been destroyed or is a child in connected mode: returning immediately
<span id="line9124" class="line"></span>            return $.Promise.resolve();
<span id="line9125" class="line"></span>        }
<span id="line9126" class="line"></span>
<span id="line9127" class="line"></span>        const tStamp = $.now();
<span id="line9128" class="line"></span>        // if drawer option broadCastTileInvalidation is enabled, this is NOOP for any but the base drawer, that runs update on all
<span id="line9129" class="line"></span>        return $.Promise.all(this._drawerList.map(drawer =&gt; drawer.viewer.world.requestInvalidate(restoreTiles, tStamp)));
<span id="line9130" class="line"></span>    },
<span id="line9131" class="line"></span>
<span id="line9132" class="line"></span>
<span id="line9133" class="line"></span>    /**
<span id="line9134" class="line"></span>     * @function
<span id="line9135" class="line"></span>     * @returns {OpenSeadragon.Viewer} Chainable.
<span id="line9136" class="line"></span>     * @fires OpenSeadragon.Viewer.event:close
<span id="line9137" class="line"></span>     */
<span id="line9138" class="line"></span>    close: function ( ) {
<span id="line9139" class="line"></span>        if ( !THIS[ this.hash ] ) {
<span id="line9140" class="line"></span>            //this viewer has already been destroyed: returning immediately
<span id="line9141" class="line"></span>            return this;
<span id="line9142" class="line"></span>        }
<span id="line9143" class="line"></span>
<span id="line9144" class="line"></span>        this._opening = false;
<span id="line9145" class="line"></span>
<span id="line9146" class="line"></span>        if ( this.navigator ) {
<span id="line9147" class="line"></span>            this.navigator.close();
<span id="line9148" class="line"></span>        }
<span id="line9149" class="line"></span>
<span id="line9150" class="line"></span>        if (!this.preserveOverlays) {
<span id="line9151" class="line"></span>            this.clearOverlays();
<span id="line9152" class="line"></span>            this.overlaysContainer.innerHTML = "";
<span id="line9153" class="line"></span>        }
<span id="line9154" class="line"></span>
<span id="line9155" class="line"></span>        THIS[ this.hash ].animating = false;
<span id="line9156" class="line"></span>
<span id="line9157" class="line"></span>        this.world.removeAll();
<span id="line9158" class="line"></span>        this.tileCache.clear();
<span id="line9159" class="line"></span>        this.imageLoader.clear();
<span id="line9160" class="line"></span>        /**
<span id="line9161" class="line"></span>         * Raised when the viewer is closed (see {@link OpenSeadragon.Viewer#close}).
<span id="line9162" class="line"></span>         *
<span id="line9163" class="line"></span>         * @event close
<span id="line9164" class="line"></span>         * @memberof OpenSeadragon.Viewer
<span id="line9165" class="line"></span>         * @type {object}
<span id="line9166" class="line"></span>         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line9167" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line9168" class="line"></span>         */
<span id="line9169" class="line"></span>        this.raiseEvent( 'close' );
<span id="line9170" class="line"></span>
<span id="line9171" class="line"></span>        return this;
<span id="line9172" class="line"></span>    },
<span id="line9173" class="line"></span>
<span id="line9174" class="line"></span>
<span id="line9175" class="line"></span>    /**
<span id="line9176" class="line"></span>     * Function to destroy the viewer and clean up everything created by OpenSeadragon.
<span id="line9177" class="line"></span>     *
<span id="line9178" class="line"></span>     * Example:
<span id="line9179" class="line"></span>     * var viewer = OpenSeadragon({
<span id="line9180" class="line"></span>     *   [...]
<span id="line9181" class="line"></span>     * });
<span id="line9182" class="line"></span>     *
<span id="line9183" class="line"></span>     * //when you are done with the viewer:
<span id="line9184" class="line"></span>     * viewer.destroy();
<span id="line9185" class="line"></span>     * viewer = null; //important
<span id="line9186" class="line"></span>     *
<span id="line9187" class="line"></span>     * @function
<span id="line9188" class="line"></span>     * @fires OpenSeadragon.Viewer.event:before-destroy
<span id="line9189" class="line"></span>     * @fires OpenSeadragon.Viewer.event:destroy
<span id="line9190" class="line"></span>     */
<span id="line9191" class="line"></span>    destroy: function( ) {
<span id="line9192" class="line"></span>        if ( !THIS[ this.hash ] ) {
<span id="line9193" class="line"></span>            //this viewer has already been destroyed: returning immediately
<span id="line9194" class="line"></span>            return;
<span id="line9195" class="line"></span>        }
<span id="line9196" class="line"></span>
<span id="line9197" class="line"></span>        /**
<span id="line9198" class="line"></span>         * Raised when the viewer is about to be destroyed (see {@link OpenSeadragon.Viewer#before-destroy}).
<span id="line9199" class="line"></span>         *
<span id="line9200" class="line"></span>         * @event before-destroy
<span id="line9201" class="line"></span>         * @memberof OpenSeadragon.Viewer
<span id="line9202" class="line"></span>         * @type {object}
<span id="line9203" class="line"></span>         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line9204" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line9205" class="line"></span>         */
<span id="line9206" class="line"></span>        this.raiseEvent( 'before-destroy' );
<span id="line9207" class="line"></span>
<span id="line9208" class="line"></span>        this._removeUpdatePixelDensityRatioEvent();
<span id="line9209" class="line"></span>
<span id="line9210" class="line"></span>        this.close();
<span id="line9211" class="line"></span>
<span id="line9212" class="line"></span>        this.clearOverlays();
<span id="line9213" class="line"></span>        this.overlaysContainer.innerHTML = "";
<span id="line9214" class="line"></span>
<span id="line9215" class="line"></span>        //TODO: implement this...
<span id="line9216" class="line"></span>        //this.unbindSequenceControls()
<span id="line9217" class="line"></span>        //this.unbindStandardControls()
<span id="line9218" class="line"></span>        if (this._resizeObserver){
<span id="line9219" class="line"></span>            this._resizeObserver.disconnect();
<span id="line9220" class="line"></span>        }
<span id="line9221" class="line"></span>
<span id="line9222" class="line"></span>        if (this.referenceStrip) {
<span id="line9223" class="line"></span>            this.referenceStrip.destroy();
<span id="line9224" class="line"></span>            this.referenceStrip = null;
<span id="line9225" class="line"></span>        }
<span id="line9226" class="line"></span>
<span id="line9227" class="line"></span>        if ( this._updateRequestId !== null ) {
<span id="line9228" class="line"></span>            $.cancelAnimationFrame( this._updateRequestId );
<span id="line9229" class="line"></span>            this._updateRequestId = null;
<span id="line9230" class="line"></span>        }
<span id="line9231" class="line"></span>
<span id="line9232" class="line"></span>        if ( this.drawer ) {
<span id="line9233" class="line"></span>            this.drawer.destroy();
<span id="line9234" class="line"></span>        }
<span id="line9235" class="line"></span>
<span id="line9236" class="line"></span>        if ( this.navigator ) {
<span id="line9237" class="line"></span>            this.navigator.destroy();
<span id="line9238" class="line"></span>            THIS[ this.navigator.hash ] = null;
<span id="line9239" class="line"></span>            delete THIS[ this.navigator.hash ];
<span id="line9240" class="line"></span>            this.navigator = null;
<span id="line9241" class="line"></span>        }
<span id="line9242" class="line"></span>
<span id="line9243" class="line"></span>
<span id="line9244" class="line"></span>        if (this.buttonGroup) {
<span id="line9245" class="line"></span>            this.buttonGroup.destroy();
<span id="line9246" class="line"></span>        } else if (this.customButtons) {
<span id="line9247" class="line"></span>            while (this.customButtons.length) {
<span id="line9248" class="line"></span>                this.customButtons.pop().destroy();
<span id="line9249" class="line"></span>            }
<span id="line9250" class="line"></span>        }
<span id="line9251" class="line"></span>
<span id="line9252" class="line"></span>        if (this.paging) {
<span id="line9253" class="line"></span>            this.paging.destroy();
<span id="line9254" class="line"></span>        }
<span id="line9255" class="line"></span>
<span id="line9256" class="line"></span>        // Remove both the canvas and container elements added by OpenSeadragon
<span id="line9257" class="line"></span>        // This will also remove its children (like the canvas)
<span id="line9258" class="line"></span>        if (this.container &amp;&amp; this.container.parentNode === this.element) {
<span id="line9259" class="line"></span>            this.element.removeChild(this.container);
<span id="line9260" class="line"></span>        }
<span id="line9261" class="line"></span>        this.container.onsubmit = null;
<span id="line9262" class="line"></span>        this.clearControls();
<span id="line9263" class="line"></span>
<span id="line9264" class="line"></span>        // destroy the mouse trackers
<span id="line9265" class="line"></span>        if (this.innerTracker){
<span id="line9266" class="line"></span>            this.innerTracker.destroy();
<span id="line9267" class="line"></span>        }
<span id="line9268" class="line"></span>        if (this.outerTracker){
<span id="line9269" class="line"></span>            this.outerTracker.destroy();
<span id="line9270" class="line"></span>        }
<span id="line9271" class="line"></span>
<span id="line9272" class="line"></span>        THIS[ this.hash ] = null;
<span id="line9273" class="line"></span>        delete THIS[ this.hash ];
<span id="line9274" class="line"></span>
<span id="line9275" class="line"></span>        // clear all our references to dom objects
<span id="line9276" class="line"></span>        this.canvas = null;
<span id="line9277" class="line"></span>        this.container = null;
<span id="line9278" class="line"></span>
<span id="line9279" class="line"></span>        // Unregister the viewer
<span id="line9280" class="line"></span>        $._viewers.delete(this.element);
<span id="line9281" class="line"></span>
<span id="line9282" class="line"></span>        // clear our reference to the main element - they will need to pass it in again, creating a new viewer
<span id="line9283" class="line"></span>        this.element = null;
<span id="line9284" class="line"></span>
<span id="line9285" class="line"></span>
<span id="line9286" class="line"></span>
<span id="line9287" class="line"></span>        /**
<span id="line9288" class="line"></span>         * Raised when the viewer is destroyed (see {@link OpenSeadragon.Viewer#destroy}).
<span id="line9289" class="line"></span>         *
<span id="line9290" class="line"></span>         * @event destroy
<span id="line9291" class="line"></span>         * @memberof OpenSeadragon.Viewer
<span id="line9292" class="line"></span>         * @type {object}
<span id="line9293" class="line"></span>         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line9294" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line9295" class="line"></span>         */
<span id="line9296" class="line"></span>        this.raiseEvent( 'destroy' );
<span id="line9297" class="line"></span>
<span id="line9298" class="line"></span>        this.removeAllHandlers();
<span id="line9299" class="line"></span>    },
<span id="line9300" class="line"></span>
<span id="line9301" class="line"></span>    /**
<span id="line9302" class="line"></span>     * Check if the viewer has been destroyed or not yet initialized.
<span id="line9303" class="line"></span>     * @return {boolean}
<span id="line9304" class="line"></span>     */
<span id="line9305" class="line"></span>    isDestroyed() {
<span id="line9306" class="line"></span>        return !THIS[ this.hash ];
<span id="line9307" class="line"></span>    },
<span id="line9308" class="line"></span>
<span id="line9309" class="line"></span>    /**
<span id="line9310" class="line"></span>     * Request a drawer for this viewer, as a supported string or drawer constructor.
<span id="line9311" class="line"></span>     * @param {String | OpenSeadragon.DrawerBase} drawerCandidate The type of drawer to try to construct.
<span id="line9312" class="line"></span>     * @param { Object } options
<span id="line9313" class="line"></span>     * @param { Boolean } [options.mainDrawer] Whether to use this as the viewer's main drawer. Default = true.
<span id="line9314" class="line"></span>     * @param { Boolean } [options.redrawImmediately] Whether to immediately draw a new frame. Only used if options.mainDrawer = true. Default = true.
<span id="line9315" class="line"></span>     * @param { Object } [options.drawerOptions] Options for this drawer. Defaults to viewer.drawerOptions.
<span id="line9316" class="line"></span>     * for this viewer type. See {@link OpenSeadragon.Options}.
<span id="line9317" class="line"></span>     * @returns {Object | Boolean} The drawer that was created, or false if the requested drawer is not supported
<span id="line9318" class="line"></span>     */
<span id="line9319" class="line"></span>    requestDrawer(drawerCandidate, options){
<span id="line9320" class="line"></span>        const defaultOpts = {
<span id="line9321" class="line"></span>            mainDrawer: true,
<span id="line9322" class="line"></span>            redrawImmediately: true,
<span id="line9323" class="line"></span>            drawerOptions: null
<span id="line9324" class="line"></span>        };
<span id="line9325" class="line"></span>        options = $.extend(true, defaultOpts, options);
<span id="line9326" class="line"></span>        const mainDrawer = options.mainDrawer;
<span id="line9327" class="line"></span>        const redrawImmediately = options.redrawImmediately;
<span id="line9328" class="line"></span>        const drawerOptions = options.drawerOptions;
<span id="line9329" class="line"></span>
<span id="line9330" class="line"></span>        const oldDrawer = this.drawer;
<span id="line9331" class="line"></span>
<span id="line9332" class="line"></span>        let Drawer = null;
<span id="line9333" class="line"></span>
<span id="line9334" class="line"></span>        //if the candidate inherits from a drawer base, use it
<span id="line9335" class="line"></span>        if (drawerCandidate &amp;&amp; drawerCandidate.prototype instanceof $.DrawerBase) {
<span id="line9336" class="line"></span>            Drawer = drawerCandidate;
<span id="line9337" class="line"></span>            drawerCandidate = 'custom';
<span id="line9338" class="line"></span>        } else if (typeof drawerCandidate === "string") {
<span id="line9339" class="line"></span>            Drawer = $.determineDrawer(drawerCandidate);
<span id="line9340" class="line"></span>        }
<span id="line9341" class="line"></span>
<span id="line9342" class="line"></span>        if (!Drawer) {
<span id="line9343" class="line"></span>            $.console.warn('Unsupported drawer %s! Drawer must be an existing string type, or a class that extends OpenSeadragon.DrawerBase.', drawerCandidate);
<span id="line9344" class="line"></span>        }
<span id="line9345" class="line"></span>
<span id="line9346" class="line"></span>        // Guard isSupported() in try/catch so a buggy or throwing plugin drawer cannot crash the whole viewer
<span id="line9347" class="line"></span>        let supported = false;
<span id="line9348" class="line"></span>        if (Drawer) {
<span id="line9349" class="line"></span>            try {
<span id="line9350" class="line"></span>                supported = Drawer.isSupported();
<span id="line9351" class="line"></span>            } catch (e) {
<span id="line9352" class="line"></span>                $.console.warn('Error in %s isSupported(); treating this drawer as unsupported:', drawerCandidate, e &amp;&amp; e.message ? e.message : e);
<span id="line9353" class="line"></span>            }
<span id="line9354" class="line"></span>        }
<span id="line9355" class="line"></span>        if (supported) {
<span id="line9356" class="line"></span>            // if the drawer is supported, create it and return it.
<span id="line9357" class="line"></span>            // first destroy the previous drawer
<span id="line9358" class="line"></span>            if(oldDrawer &amp;&amp; mainDrawer){
<span id="line9359" class="line"></span>                oldDrawer.destroy();
<span id="line9360" class="line"></span>            }
<span id="line9361" class="line"></span>
<span id="line9362" class="line"></span>            // create the new drawer
<span id="line9363" class="line"></span>            const newDrawer = new Drawer({
<span id="line9364" class="line"></span>                viewer:             this,
<span id="line9365" class="line"></span>                viewport:           this.viewport,
<span id="line9366" class="line"></span>                element:            this.canvas,
<span id="line9367" class="line"></span>                debugGridColor:     this.debugGridColor,
<span id="line9368" class="line"></span>                options:            drawerOptions || this.drawerOptions[drawerCandidate],
<span id="line9369" class="line"></span>            });
<span id="line9370" class="line"></span>
<span id="line9371" class="line"></span>            if(mainDrawer){
<span id="line9372" class="line"></span>                this.drawer = newDrawer;
<span id="line9373" class="line"></span>                if(redrawImmediately){
<span id="line9374" class="line"></span>                    this.forceRedraw();
<span id="line9375" class="line"></span>                }
<span id="line9376" class="line"></span>            }
<span id="line9377" class="line"></span>
<span id="line9378" class="line"></span>            return newDrawer;
<span id="line9379" class="line"></span>        }
<span id="line9380" class="line"></span>
<span id="line9381" class="line"></span>        return false;
<span id="line9382" class="line"></span>    },
<span id="line9383" class="line"></span>
<span id="line9384" class="line"></span>    /**
<span id="line9385" class="line"></span>     * @function
<span id="line9386" class="line"></span>     * @returns {Boolean}
<span id="line9387" class="line"></span>     */
<span id="line9388" class="line"></span>    isMouseNavEnabled: function () {
<span id="line9389" class="line"></span>        return this.innerTracker.tracking;
<span id="line9390" class="line"></span>    },
<span id="line9391" class="line"></span>
<span id="line9392" class="line"></span>    /**
<span id="line9393" class="line"></span>     * @function
<span id="line9394" class="line"></span>     * @param {Boolean} enabled - true to enable, false to disable
<span id="line9395" class="line"></span>     * @returns {OpenSeadragon.Viewer} Chainable.
<span id="line9396" class="line"></span>     * @fires OpenSeadragon.Viewer.event:mouse-enabled
<span id="line9397" class="line"></span>     */
<span id="line9398" class="line"></span>    setMouseNavEnabled: function( enabled ){
<span id="line9399" class="line"></span>        this.innerTracker.setTracking( enabled );
<span id="line9400" class="line"></span>        this.outerTracker.setTracking( enabled );
<span id="line9401" class="line"></span>        /**
<span id="line9402" class="line"></span>         * Raised when mouse/touch navigation is enabled or disabled (see {@link OpenSeadragon.Viewer#setMouseNavEnabled}).
<span id="line9403" class="line"></span>         *
<span id="line9404" class="line"></span>         * @event mouse-enabled
<span id="line9405" class="line"></span>         * @memberof OpenSeadragon.Viewer
<span id="line9406" class="line"></span>         * @type {object}
<span id="line9407" class="line"></span>         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line9408" class="line"></span>         * @property {Boolean} enabled
<span id="line9409" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line9410" class="line"></span>         */
<span id="line9411" class="line"></span>        this.raiseEvent( 'mouse-enabled', { enabled: enabled } );
<span id="line9412" class="line"></span>        return this;
<span id="line9413" class="line"></span>    },
<span id="line9414" class="line"></span>
<span id="line9415" class="line"></span>
<span id="line9416" class="line"></span>    /**
<span id="line9417" class="line"></span>     * @function
<span id="line9418" class="line"></span>     * @returns {Boolean}
<span id="line9419" class="line"></span>     */
<span id="line9420" class="line"></span>    isKeyboardNavEnabled: function () {
<span id="line9421" class="line"></span>        return this.keyboardNavEnabled;
<span id="line9422" class="line"></span>    },
<span id="line9423" class="line"></span>
<span id="line9424" class="line"></span>    /**
<span id="line9425" class="line"></span>     * @function
<span id="line9426" class="line"></span>     * @param {Boolean} enabled - true to enable, false to disable
<span id="line9427" class="line"></span>     * @returns {OpenSeadragon.Viewer} Chainable.
<span id="line9428" class="line"></span>     * @fires OpenSeadragon.Viewer.event:keyboard-enabled
<span id="line9429" class="line"></span>     */
<span id="line9430" class="line"></span>    setKeyboardNavEnabled: function( enabled ){
<span id="line9431" class="line"></span>        this.keyboardNavEnabled = enabled;
<span id="line9432" class="line"></span>
<span id="line9433" class="line"></span>        /**
<span id="line9434" class="line"></span>         * Raised when keyboard navigation is enabled or disabled (see {@link OpenSeadragon.Viewer#setKeyboardNavEnabled}).
<span id="line9435" class="line"></span>         *
<span id="line9436" class="line"></span>         * @event keyboard-enabled
<span id="line9437" class="line"></span>         * @memberof OpenSeadragon.Viewer
<span id="line9438" class="line"></span>         * @type {object}
<span id="line9439" class="line"></span>         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line9440" class="line"></span>         * @property {Boolean} enabled
<span id="line9441" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line9442" class="line"></span>         */
<span id="line9443" class="line"></span>        this.raiseEvent( 'keyboard-enabled', { enabled: enabled } );
<span id="line9444" class="line"></span>        return this;
<span id="line9445" class="line"></span>    },
<span id="line9446" class="line"></span>
<span id="line9447" class="line"></span>
<span id="line9448" class="line"></span>    /**
<span id="line9449" class="line"></span>     * @function
<span id="line9450" class="line"></span>     * @returns {Boolean}
<span id="line9451" class="line"></span>     */
<span id="line9452" class="line"></span>    areControlsEnabled: function () {
<span id="line9453" class="line"></span>        let enabled = this.controls.length;
<span id="line9454" class="line"></span>        for( let i = 0; i &lt; this.controls.length; i++ ){
<span id="line9455" class="line"></span>            enabled = enabled &amp;&amp; this.controls[ i ].isVisible();
<span id="line9456" class="line"></span>        }
<span id="line9457" class="line"></span>        return enabled;
<span id="line9458" class="line"></span>    },
<span id="line9459" class="line"></span>
<span id="line9460" class="line"></span>
<span id="line9461" class="line"></span>    /**
<span id="line9462" class="line"></span>     * Shows or hides the controls (e.g. the default navigation buttons).
<span id="line9463" class="line"></span>     *
<span id="line9464" class="line"></span>     * @function
<span id="line9465" class="line"></span>     * @param {Boolean} true to show, false to hide.
<span id="line9466" class="line"></span>     * @returns {OpenSeadragon.Viewer} Chainable.
<span id="line9467" class="line"></span>     * @fires OpenSeadragon.Viewer.event:controls-enabled
<span id="line9468" class="line"></span>     */
<span id="line9469" class="line"></span>    setControlsEnabled: function( enabled ) {
<span id="line9470" class="line"></span>        if( enabled ){
<span id="line9471" class="line"></span>            abortControlsAutoHide( this );
<span id="line9472" class="line"></span>        } else {
<span id="line9473" class="line"></span>            beginControlsAutoHide( this );
<span id="line9474" class="line"></span>        }
<span id="line9475" class="line"></span>        /**
<span id="line9476" class="line"></span>         * Raised when the navigation controls are shown or hidden (see {@link OpenSeadragon.Viewer#setControlsEnabled}).
<span id="line9477" class="line"></span>         *
<span id="line9478" class="line"></span>         * @event controls-enabled
<span id="line9479" class="line"></span>         * @memberof OpenSeadragon.Viewer
<span id="line9480" class="line"></span>         * @type {object}
<span id="line9481" class="line"></span>         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line9482" class="line"></span>         * @property {Boolean} enabled
<span id="line9483" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line9484" class="line"></span>         */
<span id="line9485" class="line"></span>        this.raiseEvent( 'controls-enabled', { enabled: enabled } );
<span id="line9486" class="line"></span>        return this;
<span id="line9487" class="line"></span>    },
<span id="line9488" class="line"></span>
<span id="line9489" class="line"></span>    /**
<span id="line9490" class="line"></span>     * Turns debugging mode on or off for this viewer.
<span id="line9491" class="line"></span>     *
<span id="line9492" class="line"></span>     * @function
<span id="line9493" class="line"></span>     * @param {Boolean} debugMode true to turn debug on, false to turn debug off.
<span id="line9494" class="line"></span>     */
<span id="line9495" class="line"></span>    setDebugMode: function(debugMode){
<span id="line9496" class="line"></span>
<span id="line9497" class="line"></span>        for (let i = 0; i &lt; this.world.getItemCount(); i++) {
<span id="line9498" class="line"></span>            this.world.getItemAt(i).debugMode = debugMode;
<span id="line9499" class="line"></span>        }
<span id="line9500" class="line"></span>
<span id="line9501" class="line"></span>        this.debugMode = debugMode;
<span id="line9502" class="line"></span>        this.forceRedraw();
<span id="line9503" class="line"></span>    },
<span id="line9504" class="line"></span>
<span id="line9505" class="line"></span>    /**
<span id="line9506" class="line"></span>     * Update headers to include when making AJAX requests.
<span id="line9507" class="line"></span>     *
<span id="line9508" class="line"></span>     * Unless `propagate` is set to false (which is likely only useful in rare circumstances),
<span id="line9509" class="line"></span>     * the updated headers are propagated to all tiled images, each of which will subsequently
<span id="line9510" class="line"></span>     * propagate the changed headers to all their tiles.
<span id="line9511" class="line"></span>     * If applicable, the headers of the viewer's navigator and reference strip will also be updated.
<span id="line9512" class="line"></span>     *
<span id="line9513" class="line"></span>     * Note that the rules for merging headers still apply, i.e. headers returned by
<span id="line9514" class="line"></span>     * {@link OpenSeadragon.TileSource#getTileAjaxHeaders} take precedence over
<span id="line9515" class="line"></span>     * `TiledImage.ajaxHeaders`, which take precedence over the headers here in the viewer.
<span id="line9516" class="line"></span>     *
<span id="line9517" class="line"></span>     * @function
<span id="line9518" class="line"></span>     * @param {Object} ajaxHeaders Updated AJAX headers.
<span id="line9519" class="line"></span>     * @param {Boolean} [propagate=true] Whether to propagate updated headers to tiled images, etc.
<span id="line9520" class="line"></span>     */
<span id="line9521" class="line"></span>    setAjaxHeaders: function(ajaxHeaders, propagate) {
<span id="line9522" class="line"></span>        if (ajaxHeaders === null) {
<span id="line9523" class="line"></span>            ajaxHeaders = {};
<span id="line9524" class="line"></span>        }
<span id="line9525" class="line"></span>        if (!$.isPlainObject(ajaxHeaders)) {
<span id="line9526" class="line"></span>            $.console.error('[Viewer.setAjaxHeaders] Ignoring invalid headers, must be a plain object');
<span id="line9527" class="line"></span>            return;
<span id="line9528" class="line"></span>        }
<span id="line9529" class="line"></span>        if (propagate === undefined) {
<span id="line9530" class="line"></span>            propagate = true;
<span id="line9531" class="line"></span>        }
<span id="line9532" class="line"></span>
<span id="line9533" class="line"></span>        this.ajaxHeaders = ajaxHeaders;
<span id="line9534" class="line"></span>
<span id="line9535" class="line"></span>        if (propagate) {
<span id="line9536" class="line"></span>            for (let i = 0; i &lt; this.world.getItemCount(); i++) {
<span id="line9537" class="line"></span>                this.world.getItemAt(i)._updateAjaxHeaders(true);
<span id="line9538" class="line"></span>            }
<span id="line9539" class="line"></span>
<span id="line9540" class="line"></span>            if (this.navigator) {
<span id="line9541" class="line"></span>                this.navigator.setAjaxHeaders(this.ajaxHeaders, true);
<span id="line9542" class="line"></span>            }
<span id="line9543" class="line"></span>
<span id="line9544" class="line"></span>            if (this.referenceStrip &amp;&amp; this.referenceStrip.miniViewers) {
<span id="line9545" class="line"></span>                for (const key in this.referenceStrip.miniViewers) {
<span id="line9546" class="line"></span>                    this.referenceStrip.miniViewers[key].setAjaxHeaders(this.ajaxHeaders, true);
<span id="line9547" class="line"></span>                }
<span id="line9548" class="line"></span>            }
<span id="line9549" class="line"></span>        }
<span id="line9550" class="line"></span>    },
<span id="line9551" class="line"></span>
<span id="line9552" class="line"></span>    /**
<span id="line9553" class="line"></span>     * Adds the given button to this viewer.
<span id="line9554" class="line"></span>     *
<span id="line9555" class="line"></span>     * @function
<span id="line9556" class="line"></span>     * @param {OpenSeadragon.Button} button
<span id="line9557" class="line"></span>     */
<span id="line9558" class="line"></span>    addButton: function( button ){
<span id="line9559" class="line"></span>        this.buttonGroup.addButton(button);
<span id="line9560" class="line"></span>    },
<span id="line9561" class="line"></span>
<span id="line9562" class="line"></span>    /**
<span id="line9563" class="line"></span>     * @function
<span id="line9564" class="line"></span>     * @returns {Boolean}
<span id="line9565" class="line"></span>     */
<span id="line9566" class="line"></span>    isFullPage: function () {
<span id="line9567" class="line"></span>        return THIS[this.hash] &amp;&amp; THIS[ this.hash ].fullPage;
<span id="line9568" class="line"></span>    },
<span id="line9569" class="line"></span>
<span id="line9570" class="line"></span>
<span id="line9571" class="line"></span>    /**
<span id="line9572" class="line"></span>     * Toggle full page mode.
<span id="line9573" class="line"></span>     * @function
<span id="line9574" class="line"></span>     * @param {Boolean} fullPage
<span id="line9575" class="line"></span>     *      If true, enter full page mode.  If false, exit full page mode.
<span id="line9576" class="line"></span>     * @returns {OpenSeadragon.Viewer} Chainable.
<span id="line9577" class="line"></span>     * @fires OpenSeadragon.Viewer.event:pre-full-page
<span id="line9578" class="line"></span>     * @fires OpenSeadragon.Viewer.event:full-page
<span id="line9579" class="line"></span>     */
<span id="line9580" class="line"></span>    setFullPage: function( fullPage ) {
<span id="line9581" class="line"></span>
<span id="line9582" class="line"></span>        const body = document.body;
<span id="line9583" class="line"></span>        const bodyStyle = body.style;
<span id="line9584" class="line"></span>        const docStyle = document.documentElement.style;
<span id="line9585" class="line"></span>        const _this = this;
<span id="line9586" class="line"></span>        let nodes;
<span id="line9587" class="line"></span>
<span id="line9588" class="line"></span>        //don't bother modifying the DOM if we are already in full page mode.
<span id="line9589" class="line"></span>        if ( fullPage === this.isFullPage() ) {
<span id="line9590" class="line"></span>            return this;
<span id="line9591" class="line"></span>        }
<span id="line9592" class="line"></span>
<span id="line9593" class="line"></span>        const fullPageEventArgs = {
<span id="line9594" class="line"></span>            fullPage: fullPage,
<span id="line9595" class="line"></span>            preventDefaultAction: false
<span id="line9596" class="line"></span>        };
<span id="line9597" class="line"></span>        /**
<span id="line9598" class="line"></span>         * Raised when the viewer is about to change to/from full-page mode (see {@link OpenSeadragon.Viewer#setFullPage}).
<span id="line9599" class="line"></span>         *
<span id="line9600" class="line"></span>         * @event pre-full-page
<span id="line9601" class="line"></span>         * @memberof OpenSeadragon.Viewer
<span id="line9602" class="line"></span>         * @type {object}
<span id="line9603" class="line"></span>         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line9604" class="line"></span>         * @property {Boolean} fullPage - True if entering full-page mode, false if exiting full-page mode.
<span id="line9605" class="line"></span>         * @property {Boolean} preventDefaultAction - Set to true to prevent full-page mode change. Default: false.
<span id="line9606" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line9607" class="line"></span>         */
<span id="line9608" class="line"></span>        this.raiseEvent( 'pre-full-page', fullPageEventArgs );
<span id="line9609" class="line"></span>        if ( fullPageEventArgs.preventDefaultAction ) {
<span id="line9610" class="line"></span>            return this;
<span id="line9611" class="line"></span>        }
<span id="line9612" class="line"></span>
<span id="line9613" class="line"></span>        if ( fullPage &amp;&amp; this.element ) {
<span id="line9614" class="line"></span>
<span id="line9615" class="line"></span>            this.elementSize = $.getElementSize( this.element );
<span id="line9616" class="line"></span>            this.pageScroll = $.getPageScroll();
<span id="line9617" class="line"></span>
<span id="line9618" class="line"></span>            this.elementMargin = this.element.style.margin;
<span id="line9619" class="line"></span>            this.element.style.margin = "0";
<span id="line9620" class="line"></span>            this.elementPadding = this.element.style.padding;
<span id="line9621" class="line"></span>            this.element.style.padding = "0";
<span id="line9622" class="line"></span>
<span id="line9623" class="line"></span>            this.bodyMargin = bodyStyle.margin;
<span id="line9624" class="line"></span>            this.docMargin = docStyle.margin;
<span id="line9625" class="line"></span>            bodyStyle.margin = "0";
<span id="line9626" class="line"></span>            docStyle.margin = "0";
<span id="line9627" class="line"></span>
<span id="line9628" class="line"></span>            this.bodyPadding = bodyStyle.padding;
<span id="line9629" class="line"></span>            this.docPadding = docStyle.padding;
<span id="line9630" class="line"></span>            bodyStyle.padding = "0";
<span id="line9631" class="line"></span>            docStyle.padding = "0";
<span id="line9632" class="line"></span>
<span id="line9633" class="line"></span>            this.bodyWidth = bodyStyle.width;
<span id="line9634" class="line"></span>            this.docWidth = docStyle.width;
<span id="line9635" class="line"></span>            bodyStyle.width = "100%";
<span id="line9636" class="line"></span>            docStyle.width = "100%";
<span id="line9637" class="line"></span>
<span id="line9638" class="line"></span>            this.bodyHeight = bodyStyle.height;
<span id="line9639" class="line"></span>            this.docHeight = docStyle.height;
<span id="line9640" class="line"></span>            bodyStyle.height = "100%";
<span id="line9641" class="line"></span>            docStyle.height = "100%";
<span id="line9642" class="line"></span>
<span id="line9643" class="line"></span>            this.bodyDisplay = bodyStyle.display;
<span id="line9644" class="line"></span>            bodyStyle.display = "block";
<span id="line9645" class="line"></span>
<span id="line9646" class="line"></span>            //when entering full screen on the ipad it wasn't sufficient to
<span id="line9647" class="line"></span>            //leave the body intact as only only the top half of the screen
<span id="line9648" class="line"></span>            //would respond to touch events on the canvas, while the bottom half
<span id="line9649" class="line"></span>            //treated them as touch events on the document body.  Thus we make
<span id="line9650" class="line"></span>            //them invisible (display: none) and apply the older values when we
<span id="line9651" class="line"></span>            //go out of full screen.
<span id="line9652" class="line"></span>            this.previousDisplayValuesOfBodyChildren = [];
<span id="line9653" class="line"></span>            THIS[ this.hash ].prevElementParent = this.element.parentNode;
<span id="line9654" class="line"></span>            THIS[ this.hash ].prevNextSibling = this.element.nextSibling;
<span id="line9655" class="line"></span>            THIS[ this.hash ].prevElementWidth = this.element.style.width;
<span id="line9656" class="line"></span>            THIS[ this.hash ].prevElementHeight = this.element.style.height;
<span id="line9657" class="line"></span>            nodes = body.children.length;
<span id="line9658" class="line"></span>            for ( let i = 0; i &lt; nodes; i++ ) {
<span id="line9659" class="line"></span>                const element = body.children[i];
<span id="line9660" class="line"></span>                if (element === this.element) {
<span id="line9661" class="line"></span>                    // Do not hide ourselves...
<span id="line9662" class="line"></span>                    continue;
<span id="line9663" class="line"></span>                }
<span id="line9664" class="line"></span>                this.previousDisplayValuesOfBodyChildren.push({
<span id="line9665" class="line"></span>                    element,
<span id="line9666" class="line"></span>                    display: element.style.display
<span id="line9667" class="line"></span>                });
<span id="line9668" class="line"></span>                element.style.display = 'none';
<span id="line9669" class="line"></span>            }
<span id="line9670" class="line"></span>
<span id="line9671" class="line"></span>            //If we've got a toolbar, we need to enable the user to use css to
<span id="line9672" class="line"></span>            //preserve it in fullpage mode
<span id="line9673" class="line"></span>            if ( this.toolbar &amp;&amp; this.toolbar.element ) {
<span id="line9674" class="line"></span>                //save a reference to the parent so we can put it back
<span id="line9675" class="line"></span>                //in the long run we need a better strategy
<span id="line9676" class="line"></span>                this.toolbar.parentNode = this.toolbar.element.parentNode;
<span id="line9677" class="line"></span>                this.toolbar.nextSibling = this.toolbar.element.nextSibling;
<span id="line9678" class="line"></span>                body.appendChild( this.toolbar.element );
<span id="line9679" class="line"></span>
<span id="line9680" class="line"></span>                //Make sure the user has some ability to style the toolbar based
<span id="line9681" class="line"></span>                //on the mode
<span id="line9682" class="line"></span>                $.addClass( this.toolbar.element, 'fullpage' );
<span id="line9683" class="line"></span>            }
<span id="line9684" class="line"></span>
<span id="line9685" class="line"></span>            $.addClass( this.element, 'fullpage' );
<span id="line9686" class="line"></span>            body.appendChild( this.element );
<span id="line9687" class="line"></span>
<span id="line9688" class="line"></span>            this.element.style.height = '100vh';
<span id="line9689" class="line"></span>            this.element.style.width = '100vw';
<span id="line9690" class="line"></span>
<span id="line9691" class="line"></span>            if ( this.toolbar &amp;&amp; this.toolbar.element ) {
<span id="line9692" class="line"></span>                this.element.style.height = (
<span id="line9693" class="line"></span>                    $.getElementSize( this.element ).y - $.getElementSize( this.toolbar.element ).y
<span id="line9694" class="line"></span>                ) + 'px';
<span id="line9695" class="line"></span>            }
<span id="line9696" class="line"></span>
<span id="line9697" class="line"></span>            THIS[ this.hash ].fullPage = true;
<span id="line9698" class="line"></span>
<span id="line9699" class="line"></span>            // mouse will be inside container now
<span id="line9700" class="line"></span>            $.delegate( this, onContainerEnter )( {} );
<span id="line9701" class="line"></span>
<span id="line9702" class="line"></span>        } else {
<span id="line9703" class="line"></span>
<span id="line9704" class="line"></span>            this.element.style.margin = this.elementMargin;
<span id="line9705" class="line"></span>            this.element.style.padding = this.elementPadding;
<span id="line9706" class="line"></span>
<span id="line9707" class="line"></span>            bodyStyle.margin = this.bodyMargin;
<span id="line9708" class="line"></span>            docStyle.margin = this.docMargin;
<span id="line9709" class="line"></span>
<span id="line9710" class="line"></span>            bodyStyle.padding = this.bodyPadding;
<span id="line9711" class="line"></span>            docStyle.padding = this.docPadding;
<span id="line9712" class="line"></span>
<span id="line9713" class="line"></span>            bodyStyle.width = this.bodyWidth;
<span id="line9714" class="line"></span>            docStyle.width = this.docWidth;
<span id="line9715" class="line"></span>
<span id="line9716" class="line"></span>            bodyStyle.height = this.bodyHeight;
<span id="line9717" class="line"></span>            docStyle.height = this.docHeight;
<span id="line9718" class="line"></span>
<span id="line9719" class="line"></span>            bodyStyle.display = this.bodyDisplay;
<span id="line9720" class="line"></span>
<span id="line9721" class="line"></span>            body.removeChild( this.element );
<span id="line9722" class="line"></span>            nodes = this.previousDisplayValuesOfBodyChildren.length;
<span id="line9723" class="line"></span>            for ( let i = 0; i &lt; nodes; i++ ) {
<span id="line9724" class="line"></span>                const { element, display } = this.previousDisplayValuesOfBodyChildren[i];
<span id="line9725" class="line"></span>                element.style.display = display;
<span id="line9726" class="line"></span>            }
<span id="line9727" class="line"></span>
<span id="line9728" class="line"></span>            $.removeClass( this.element, 'fullpage' );
<span id="line9729" class="line"></span>            THIS[ this.hash ].prevElementParent.insertBefore(
<span id="line9730" class="line"></span>                this.element,
<span id="line9731" class="line"></span>                THIS[ this.hash ].prevNextSibling
<span id="line9732" class="line"></span>            );
<span id="line9733" class="line"></span>
<span id="line9734" class="line"></span>            //If we've got a toolbar, we need to enable the user to use css to
<span id="line9735" class="line"></span>            //reset it to its original state
<span id="line9736" class="line"></span>            if ( this.toolbar &amp;&amp; this.toolbar.element ) {
<span id="line9737" class="line"></span>                body.removeChild( this.toolbar.element );
<span id="line9738" class="line"></span>
<span id="line9739" class="line"></span>                //Make sure the user has some ability to style the toolbar based
<span id="line9740" class="line"></span>                //on the mode
<span id="line9741" class="line"></span>                $.removeClass( this.toolbar.element, 'fullpage' );
<span id="line9742" class="line"></span>
<span id="line9743" class="line"></span>                this.toolbar.parentNode.insertBefore(
<span id="line9744" class="line"></span>                    this.toolbar.element,
<span id="line9745" class="line"></span>                    this.toolbar.nextSibling
<span id="line9746" class="line"></span>                );
<span id="line9747" class="line"></span>                delete this.toolbar.parentNode;
<span id="line9748" class="line"></span>                delete this.toolbar.nextSibling;
<span id="line9749" class="line"></span>            }
<span id="line9750" class="line"></span>
<span id="line9751" class="line"></span>            this.element.style.width = THIS[ this.hash ].prevElementWidth;
<span id="line9752" class="line"></span>            this.element.style.height = THIS[ this.hash ].prevElementHeight;
<span id="line9753" class="line"></span>
<span id="line9754" class="line"></span>            // After exiting fullPage or fullScreen, it can take some time
<span id="line9755" class="line"></span>            // before the browser can actually set the scroll.
<span id="line9756" class="line"></span>            let restoreScrollCounter = 0;
<span id="line9757" class="line"></span>            const restoreScroll = function() {
<span id="line9758" class="line"></span>                $.setPageScroll( _this.pageScroll );
<span id="line9759" class="line"></span>                const pageScroll = $.getPageScroll();
<span id="line9760" class="line"></span>                restoreScrollCounter++;
<span id="line9761" class="line"></span>                if (restoreScrollCounter &lt; 10 &amp;&amp;
<span id="line9762" class="line"></span>                    (pageScroll.x !== _this.pageScroll.x ||
<span id="line9763" class="line"></span>                    pageScroll.y !== _this.pageScroll.y)) {
<span id="line9764" class="line"></span>                    $.requestAnimationFrame( restoreScroll );
<span id="line9765" class="line"></span>                }
<span id="line9766" class="line"></span>            };
<span id="line9767" class="line"></span>            $.requestAnimationFrame( restoreScroll );
<span id="line9768" class="line"></span>
<span id="line9769" class="line"></span>            THIS[ this.hash ].fullPage = false;
<span id="line9770" class="line"></span>
<span id="line9771" class="line"></span>            // mouse will likely be outside now
<span id="line9772" class="line"></span>            $.delegate( this, onContainerLeave )( { } );
<span id="line9773" class="line"></span>
<span id="line9774" class="line"></span>        }
<span id="line9775" class="line"></span>
<span id="line9776" class="line"></span>        if ( this.navigator &amp;&amp; this.viewport ) {
<span id="line9777" class="line"></span>            this.navigator.update( this.viewport );
<span id="line9778" class="line"></span>        }
<span id="line9779" class="line"></span>
<span id="line9780" class="line"></span>        /**
<span id="line9781" class="line"></span>         * Raised when the viewer has changed to/from full-page mode (see {@link OpenSeadragon.Viewer#setFullPage}).
<span id="line9782" class="line"></span>         *
<span id="line9783" class="line"></span>         * @event full-page
<span id="line9784" class="line"></span>         * @memberof OpenSeadragon.Viewer
<span id="line9785" class="line"></span>         * @type {object}
<span id="line9786" class="line"></span>         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line9787" class="line"></span>         * @property {Boolean} fullPage - True if changed to full-page mode, false if exited full-page mode.
<span id="line9788" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line9789" class="line"></span>         */
<span id="line9790" class="line"></span>        this.raiseEvent( 'full-page', { fullPage: fullPage } );
<span id="line9791" class="line"></span>
<span id="line9792" class="line"></span>        return this;
<span id="line9793" class="line"></span>    },
<span id="line9794" class="line"></span>
<span id="line9795" class="line"></span>    /**
<span id="line9796" class="line"></span>     * Toggle full screen mode if supported. Toggle full page mode otherwise.
<span id="line9797" class="line"></span>     * @function
<span id="line9798" class="line"></span>     * @param {Boolean} fullScreen
<span id="line9799" class="line"></span>     *      If true, enter full screen mode.  If false, exit full screen mode.
<span id="line9800" class="line"></span>     * @returns {OpenSeadragon.Viewer} Chainable.
<span id="line9801" class="line"></span>     * @fires OpenSeadragon.Viewer.event:pre-full-screen
<span id="line9802" class="line"></span>     * @fires OpenSeadragon.Viewer.event:full-screen
<span id="line9803" class="line"></span>     */
<span id="line9804" class="line"></span>    setFullScreen: function( fullScreen ) {
<span id="line9805" class="line"></span>        const _this = this;
<span id="line9806" class="line"></span>
<span id="line9807" class="line"></span>        if ( !$.supportsFullScreen ) {
<span id="line9808" class="line"></span>            return this.setFullPage( fullScreen );
<span id="line9809" class="line"></span>        }
<span id="line9810" class="line"></span>
<span id="line9811" class="line"></span>        if ( $.isFullScreen() === fullScreen ) {
<span id="line9812" class="line"></span>            return this;
<span id="line9813" class="line"></span>        }
<span id="line9814" class="line"></span>
<span id="line9815" class="line"></span>        const fullScreenEventArgs = {
<span id="line9816" class="line"></span>            fullScreen: fullScreen,
<span id="line9817" class="line"></span>            preventDefaultAction: false
<span id="line9818" class="line"></span>        };
<span id="line9819" class="line"></span>        /**
<span id="line9820" class="line"></span>         * Raised when the viewer is about to change to/from full-screen mode (see {@link OpenSeadragon.Viewer#setFullScreen}).
<span id="line9821" class="line"></span>         * Note: the pre-full-screen event is not raised when the user is exiting
<span id="line9822" class="line"></span>         * full-screen mode by pressing the Esc key. In that case, consider using
<span id="line9823" class="line"></span>         * the full-screen, pre-full-page or full-page events.
<span id="line9824" class="line"></span>         *
<span id="line9825" class="line"></span>         * @event pre-full-screen
<span id="line9826" class="line"></span>         * @memberof OpenSeadragon.Viewer
<span id="line9827" class="line"></span>         * @type {object}
<span id="line9828" class="line"></span>         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line9829" class="line"></span>         * @property {Boolean} fullScreen - True if entering full-screen mode, false if exiting full-screen mode.
<span id="line9830" class="line"></span>         * @property {Boolean} preventDefaultAction - Set to true to prevent full-screen mode change. Default: false.
<span id="line9831" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line9832" class="line"></span>         */
<span id="line9833" class="line"></span>        this.raiseEvent( 'pre-full-screen', fullScreenEventArgs );
<span id="line9834" class="line"></span>        if ( fullScreenEventArgs.preventDefaultAction ) {
<span id="line9835" class="line"></span>            return this;
<span id="line9836" class="line"></span>        }
<span id="line9837" class="line"></span>
<span id="line9838" class="line"></span>        if ( fullScreen ) {
<span id="line9839" class="line"></span>
<span id="line9840" class="line"></span>            this.setFullPage( true );
<span id="line9841" class="line"></span>            // If the full page mode is not actually entered, we need to prevent
<span id="line9842" class="line"></span>            // the full screen mode.
<span id="line9843" class="line"></span>            if ( !this.isFullPage() ) {
<span id="line9844" class="line"></span>                return this;
<span id="line9845" class="line"></span>            }
<span id="line9846" class="line"></span>
<span id="line9847" class="line"></span>            this.fullPageStyleWidth = this.element.style.width;
<span id="line9848" class="line"></span>            this.fullPageStyleHeight = this.element.style.height;
<span id="line9849" class="line"></span>            this.element.style.width = '100%';
<span id="line9850" class="line"></span>            this.element.style.height = '100%';
<span id="line9851" class="line"></span>
<span id="line9852" class="line"></span>            const onFullScreenChange = function() {
<span id="line9853" class="line"></span>                if (!THIS[ _this.hash ]) {
<span id="line9854" class="line"></span>                    $.removeEvent( document, $.fullScreenEventName, onFullScreenChange );
<span id="line9855" class="line"></span>                    $.removeEvent( document, $.fullScreenErrorEventName, onFullScreenChange );
<span id="line9856" class="line"></span>                    return;
<span id="line9857" class="line"></span>                }
<span id="line9858" class="line"></span>
<span id="line9859" class="line"></span>                const isFullScreen = $.isFullScreen();
<span id="line9860" class="line"></span>                if ( !isFullScreen ) {
<span id="line9861" class="line"></span>                    $.removeEvent( document, $.fullScreenEventName, onFullScreenChange );
<span id="line9862" class="line"></span>                    $.removeEvent( document, $.fullScreenErrorEventName, onFullScreenChange );
<span id="line9863" class="line"></span>
<span id="line9864" class="line"></span>                    _this.setFullPage( false );
<span id="line9865" class="line"></span>                    if ( _this.isFullPage() ) {
<span id="line9866" class="line"></span>                        _this.element.style.width = _this.fullPageStyleWidth;
<span id="line9867" class="line"></span>                        _this.element.style.height = _this.fullPageStyleHeight;
<span id="line9868" class="line"></span>                    }
<span id="line9869" class="line"></span>                }
<span id="line9870" class="line"></span>                if ( _this.navigator &amp;&amp; _this.viewport ) {
<span id="line9871" class="line"></span>                    //09/08/2018 - Fabroh : Fix issue #1504 : Ensure to get the navigator updated on fullscreen out with custom location with a timeout
<span id="line9872" class="line"></span>                    setTimeout(function(){
<span id="line9873" class="line"></span>                        _this.navigator.update( _this.viewport );
<span id="line9874" class="line"></span>                    });
<span id="line9875" class="line"></span>                }
<span id="line9876" class="line"></span>                /**
<span id="line9877" class="line"></span>                 * Raised when the viewer has changed to/from full-screen mode (see {@link OpenSeadragon.Viewer#setFullScreen}).
<span id="line9878" class="line"></span>                 *
<span id="line9879" class="line"></span>                 * @event full-screen
<span id="line9880" class="line"></span>                 * @memberof OpenSeadragon.Viewer
<span id="line9881" class="line"></span>                 * @type {object}
<span id="line9882" class="line"></span>                 * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line9883" class="line"></span>                 * @property {Boolean} fullScreen - True if changed to full-screen mode, false if exited full-screen mode.
<span id="line9884" class="line"></span>                 * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line9885" class="line"></span>                 */
<span id="line9886" class="line"></span>                _this.raiseEvent( 'full-screen', { fullScreen: isFullScreen } );
<span id="line9887" class="line"></span>            };
<span id="line9888" class="line"></span>            $.addEvent( document, $.fullScreenEventName, onFullScreenChange );
<span id="line9889" class="line"></span>            $.addEvent( document, $.fullScreenErrorEventName, onFullScreenChange );
<span id="line9890" class="line"></span>
<span id="line9891" class="line"></span>            $.requestFullScreen( document.body );
<span id="line9892" class="line"></span>
<span id="line9893" class="line"></span>        } else {
<span id="line9894" class="line"></span>            $.exitFullScreen();
<span id="line9895" class="line"></span>        }
<span id="line9896" class="line"></span>        return this;
<span id="line9897" class="line"></span>    },
<span id="line9898" class="line"></span>
<span id="line9899" class="line"></span>    /**
<span id="line9900" class="line"></span>     * @function
<span id="line9901" class="line"></span>     * @returns {Boolean}
<span id="line9902" class="line"></span>     */
<span id="line9903" class="line"></span>    isVisible: function () {
<span id="line9904" class="line"></span>        return this.container.style.visibility !== "hidden";
<span id="line9905" class="line"></span>    },
<span id="line9906" class="line"></span>
<span id="line9907" class="line"></span>
<span id="line9908" class="line"></span>    //
<span id="line9909" class="line"></span>    /**
<span id="line9910" class="line"></span>     * @function
<span id="line9911" class="line"></span>     * @returns {Boolean} returns true if the viewer is in fullscreen
<span id="line9912" class="line"></span>     */
<span id="line9913" class="line"></span>     isFullScreen: function () {
<span id="line9914" class="line"></span>        return $.isFullScreen() &amp;&amp; this.isFullPage();
<span id="line9915" class="line"></span>    },
<span id="line9916" class="line"></span>
<span id="line9917" class="line"></span>    /**
<span id="line9918" class="line"></span>     * @function
<span id="line9919" class="line"></span>     * @param {Boolean} visible
<span id="line9920" class="line"></span>     * @returns {OpenSeadragon.Viewer} Chainable.
<span id="line9921" class="line"></span>     * @fires OpenSeadragon.Viewer.event:visible
<span id="line9922" class="line"></span>     */
<span id="line9923" class="line"></span>    setVisible: function( visible ){
<span id="line9924" class="line"></span>        this.container.style.visibility = visible ? "" : "hidden";
<span id="line9925" class="line"></span>        /**
<span id="line9926" class="line"></span>         * Raised when the viewer is shown or hidden (see {@link OpenSeadragon.Viewer#setVisible}).
<span id="line9927" class="line"></span>         *
<span id="line9928" class="line"></span>         * @event visible
<span id="line9929" class="line"></span>         * @memberof OpenSeadragon.Viewer
<span id="line9930" class="line"></span>         * @type {object}
<span id="line9931" class="line"></span>         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line9932" class="line"></span>         * @property {Boolean} visible
<span id="line9933" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line9934" class="line"></span>         */
<span id="line9935" class="line"></span>        this.raiseEvent( 'visible', { visible: visible } );
<span id="line9936" class="line"></span>        return this;
<span id="line9937" class="line"></span>    },
<span id="line9938" class="line"></span>
<span id="line9939" class="line"></span>    /**
<span id="line9940" class="line"></span>     * @typedef OpenSeadragon.TileSourceSpecifier
<span id="line9941" class="line"></span>     * @property {Object} options
<span id="line9942" class="line"></span>     * @property {OpenSeadragon.TileSource|String|Object|Function} options.tileSource - The TileSource specifier.
<span id="line9943" class="line"></span>     * A String implies a url used to determine the tileSource implementation
<span id="line9944" class="line"></span>     *      based on the file extension of url. JSONP is implied by *.js,
<span id="line9945" class="line"></span>     *      otherwise the url is retrieved as text and the resulting text is
<span id="line9946" class="line"></span>     *      introspected to determine if its json, xml, or text and parsed.
<span id="line9947" class="line"></span>     * An Object implies an inline configuration which has a single
<span id="line9948" class="line"></span>     *      property sufficient for being able to determine tileSource
<span id="line9949" class="line"></span>     *      implementation. If the object has a property which is a function
<span id="line9950" class="line"></span>     *      named 'getTileUrl', it is treated as a custom TileSource.
<span id="line9951" class="line"></span>     * @property {Number} [options.index] The index of the item. Added on top of
<span id="line9952" class="line"></span>     * all other items if not specified.
<span id="line9953" class="line"></span>     * @property {Boolean} [options.replace=false] If true, the item at options.index will be
<span id="line9954" class="line"></span>     * removed and the new item is added in its place. options.tileSource will be
<span id="line9955" class="line"></span>     * interpreted and fetched if necessary before the old item is removed to avoid leaving
<span id="line9956" class="line"></span>     * a gap in the world.
<span id="line9957" class="line"></span>     * @property {Number} [options.x=0] The X position for the image in viewport coordinates.
<span id="line9958" class="line"></span>     * @property {Number} [options.y=0] The Y position for the image in viewport coordinates.
<span id="line9959" class="line"></span>     * @property {Number} [options.width=1] The width for the image in viewport coordinates.
<span id="line9960" class="line"></span>     * @property {Number} [options.height] The height for the image in viewport coordinates.
<span id="line9961" class="line"></span>     * @property {OpenSeadragon.Rect} [options.fitBounds] The bounds in viewport coordinates
<span id="line9962" class="line"></span>     * to fit the image into. If specified, x, y, width and height get ignored.
<span id="line9963" class="line"></span>     * @property {OpenSeadragon.Placement} [options.fitBoundsPlacement=OpenSeadragon.Placement.CENTER]
<span id="line9964" class="line"></span>     * How to anchor the image in the bounds if options.fitBounds is set.
<span id="line9965" class="line"></span>     * @property {OpenSeadragon.Rect} [options.clip] - An area, in image pixels, to clip to
<span id="line9966" class="line"></span>     * (portions of the image outside of this area will not be visible). Only works on
<span id="line9967" class="line"></span>     * browsers that support the HTML5 canvas.
<span id="line9968" class="line"></span>     * @property {Number} [options.opacity=1] Proportional opacity of the tiled images (1=opaque, 0=hidden)
<span id="line9969" class="line"></span>     * @property {Boolean} [options.preload=false] Default switch for loading hidden images (true loads, false blocks)
<span id="line9970" class="line"></span>     * @property {Boolean} [options.zombieCache] In the case that this method removes any TiledImage instance,
<span id="line9971" class="line"></span>     *      allow the item-referenced cache to remain in memory even without active tiles. Default false.
<span id="line9972" class="line"></span>     * @property {Number} [options.degrees=0] Initial rotation of the tiled image around
<span id="line9973" class="line"></span>     * its top left corner in degrees.
<span id="line9974" class="line"></span>     * @property {Boolean} [options.flipped=false] Whether to horizontally flip the image.
<span id="line9975" class="line"></span>     * @property {String} [options.compositeOperation] How the image is composited onto other images.
<span id="line9976" class="line"></span>     * @property {String} [options.crossOriginPolicy] The crossOriginPolicy for this specific image,
<span id="line9977" class="line"></span>     * overriding viewer.crossOriginPolicy.
<span id="line9978" class="line"></span>     * @property {Boolean} [options.ajaxWithCredentials] Whether to set withCredentials on tile AJAX
<span id="line9979" class="line"></span>     * @property {Boolean} [options.loadTilesWithAjax]
<span id="line9980" class="line"></span>     *      Whether to load tile data using AJAX requests.
<span id="line9981" class="line"></span>     *      Defaults to the setting in {@link OpenSeadragon.Options}.
<span id="line9982" class="line"></span>     * @property {Object} [options.ajaxHeaders]
<span id="line9983" class="line"></span>     *      A set of headers to include when making tile AJAX requests.
<span id="line9984" class="line"></span>     *      Note that these headers will be merged over any headers specified in {@link OpenSeadragon.Options}.
<span id="line9985" class="line"></span>     *      Specifying a falsy value for a header will clear its existing value set at the Viewer level (if any).
<span id="line9986" class="line"></span>     * @property {Function} [options.success] A function that gets called when the image is
<span id="line9987" class="line"></span>     * successfully added. It's passed the event object which contains a single property:
<span id="line9988" class="line"></span>     * "item", which is the resulting instance of TiledImage.
<span id="line9989" class="line"></span>     * @property {Function} [options.error] A function that gets called if the image is
<span id="line9990" class="line"></span>     * unable to be added. It's passed the error event object, which contains "message"
<span id="line9991" class="line"></span>     * and "source" properties.
<span id="line9992" class="line"></span>     * @property {Boolean} [options.collectionImmediately=false] If collectionMode is on,
<span id="line9993" class="line"></span>     * specifies whether to snap to the new arrangement immediately or to animate to it.
<span id="line9994" class="line"></span>     * @property {String|CanvasGradient|CanvasPattern|Function} [options.placeholderFillStyle] - See {@link OpenSeadragon.Options}.
<span id="line9995" class="line"></span>     * @param {string|string[]} [options.originalDataType=undefined]
<span id="line9996" class="line"></span>     *      A default format to convert tiles to at the beginning. The format is the base tile format,
<span id="line9997" class="line"></span>     *      and this can optimize rendering or processing logics in case for example a plugin always requires a certain
<span id="line9998" class="line"></span>     *      format to convert to.
<span id="line9999" class="line"></span>     */
<span id="line10000" class="line"></span>
<span id="line10001" class="line"></span>    /**
<span id="line10002" class="line"></span>     * Add a tiled image to the viewer.
<span id="line10003" class="line"></span>     * options.tileSource can be anything that {@link OpenSeadragon.Viewer#open}
<span id="line10004" class="line"></span>     *  supports except arrays of images.
<span id="line10005" class="line"></span>     * Note that you can specify options.width or options.height, but not both.
<span id="line10006" class="line"></span>     * The other dimension will be calculated according to the item's aspect ratio.
<span id="line10007" class="line"></span>     * If collectionMode is on (see {@link OpenSeadragon.Options}), the new image is
<span id="line10008" class="line"></span>     * automatically arranged with the others.
<span id="line10009" class="line"></span>     * @function
<span id="line10010" class="line"></span>     * @param {OpenSeadragon.TileSourceSpecifier} options
<span id="line10011" class="line"></span>     * @fires OpenSeadragon.World.event:add-item
<span id="line10012" class="line"></span>     * @fires OpenSeadragon.Viewer.event:add-item-failed
<span id="line10013" class="line"></span>     */
<span id="line10014" class="line"></span>    addTiledImage: function( options ) {
<span id="line10015" class="line"></span>        $.console.assert(options, "[Viewer.addTiledImage] options is required");
<span id="line10016" class="line"></span>        $.console.assert(options.tileSource, "[Viewer.addTiledImage] options.tileSource is required");
<span id="line10017" class="line"></span>        $.console.assert(!options.replace || (options.index &gt; -1 &amp;&amp; options.index &lt; this.world.getItemCount()),
<span id="line10018" class="line"></span>            "[Viewer.addTiledImage] if options.replace is used, options.index must be a valid index in Viewer.world");
<span id="line10019" class="line"></span>
<span id="line10020" class="line"></span>        this._hideMessage();
<span id="line10021" class="line"></span>
<span id="line10022" class="line"></span>        const originalSuccess = options.success;
<span id="line10023" class="line"></span>        const originalError = options.error;
<span id="line10024" class="line"></span>        if (options.replace) {
<span id="line10025" class="line"></span>            options.replaceItem = this.world.getItemAt(options.index);
<span id="line10026" class="line"></span>        }
<span id="line10027" class="line"></span>
<span id="line10028" class="line"></span>        const myQueueItem = {
<span id="line10029" class="line"></span>            options: options
<span id="line10030" class="line"></span>        };
<span id="line10031" class="line"></span>
<span id="line10032" class="line"></span>        this._loadQueue.push(myQueueItem);
<span id="line10033" class="line"></span>
<span id="line10034" class="line"></span>        const refreshWorld = theItem =&gt; {
<span id="line10035" class="line"></span>            if (this.collectionMode) {
<span id="line10036" class="line"></span>                this.world.arrange({
<span id="line10037" class="line"></span>                    immediately: theItem.options.collectionImmediately,
<span id="line10038" class="line"></span>                    rows: this.collectionRows,
<span id="line10039" class="line"></span>                    columns: this.collectionColumns,
<span id="line10040" class="line"></span>                    layout: this.collectionLayout,
<span id="line10041" class="line"></span>                    tileSize: this.collectionTileSize,
<span id="line10042" class="line"></span>                    tileMargin: this.collectionTileMargin
<span id="line10043" class="line"></span>                });
<span id="line10044" class="line"></span>                this.world.setAutoRefigureSizes(true);
<span id="line10045" class="line"></span>            }
<span id="line10046" class="line"></span>        };
<span id="line10047" class="line"></span>
<span id="line10048" class="line"></span>        const raiseAddItemFailed = ( event ) =&gt; {
<span id="line10049" class="line"></span>            for (let i = 0; i &lt; this._loadQueue.length; i++) {
<span id="line10050" class="line"></span>                if (this._loadQueue[i] === myQueueItem) {
<span id="line10051" class="line"></span>                    this._loadQueue.splice(i, 1);
<span id="line10052" class="line"></span>                    break;
<span id="line10053" class="line"></span>                }
<span id="line10054" class="line"></span>            }
<span id="line10055" class="line"></span>
<span id="line10056" class="line"></span>            if (this._loadQueue.length === 0) {
<span id="line10057" class="line"></span>                refreshWorld(myQueueItem);
<span id="line10058" class="line"></span>            }
<span id="line10059" class="line"></span>
<span id="line10060" class="line"></span>            /**
<span id="line10061" class="line"></span>             * Raised when an error occurs while adding a item.
<span id="line10062" class="line"></span>             * @event add-item-failed
<span id="line10063" class="line"></span>             * @memberOf OpenSeadragon.Viewer
<span id="line10064" class="line"></span>             * @type {object}
<span id="line10065" class="line"></span>             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line10066" class="line"></span>             * @property {String} message
<span id="line10067" class="line"></span>             * @property {String} source
<span id="line10068" class="line"></span>             * @property {Object} options The options passed to the addTiledImage method.
<span id="line10069" class="line"></span>             * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line10070" class="line"></span>             */
<span id="line10071" class="line"></span>            this.raiseEvent( 'add-item-failed', event );
<span id="line10072" class="line"></span>
<span id="line10073" class="line"></span>            if (originalError) {
<span id="line10074" class="line"></span>                originalError(event);
<span id="line10075" class="line"></span>            }
<span id="line10076" class="line"></span>        };
<span id="line10077" class="line"></span>
<span id="line10078" class="line"></span>        if ($.isArray(options.tileSource)) {
<span id="line10079" class="line"></span>            setTimeout(function() {
<span id="line10080" class="line"></span>                raiseAddItemFailed({
<span id="line10081" class="line"></span>                    message: "[Viewer.addTiledImage] Sequences can not be added; add them one at a time instead.",
<span id="line10082" class="line"></span>                    source: options.tileSource,
<span id="line10083" class="line"></span>                    options: options
<span id="line10084" class="line"></span>                });
<span id="line10085" class="line"></span>            });
<span id="line10086" class="line"></span>            return;
<span id="line10087" class="line"></span>        }
<span id="line10088" class="line"></span>
<span id="line10089" class="line"></span>        // ensure nobody provided such entry
<span id="line10090" class="line"></span>        delete myQueueItem.tiledImage;
<span id="line10091" class="line"></span>        options.success = event =&gt; {
<span id="line10092" class="line"></span>            myQueueItem.tiledImage = event.item;
<span id="line10093" class="line"></span>            myQueueItem.originalSuccess = originalSuccess;
<span id="line10094" class="line"></span>
<span id="line10095" class="line"></span>            let queueItem, optionsClone;
<span id="line10096" class="line"></span>            while (this._loadQueue.length) {
<span id="line10097" class="line"></span>                queueItem = this._loadQueue[0];
<span id="line10098" class="line"></span>                const tiledImage = queueItem.tiledImage;
<span id="line10099" class="line"></span>                if (!tiledImage) {
<span id="line10100" class="line"></span>                    break;
<span id="line10101" class="line"></span>                }
<span id="line10102" class="line"></span>
<span id="line10103" class="line"></span>                this._loadQueue.splice(0, 1);
<span id="line10104" class="line"></span>                const tileSource = tiledImage.source;
<span id="line10105" class="line"></span>
<span id="line10106" class="line"></span>                if (queueItem.options.replace) {
<span id="line10107" class="line"></span>                    const replaced = queueItem.options.replaceItem;
<span id="line10108" class="line"></span>                    const newIndex = this.world.getIndexOfItem(replaced);
<span id="line10109" class="line"></span>                    if (newIndex !== -1) {
<span id="line10110" class="line"></span>                        queueItem.options.index = newIndex;
<span id="line10111" class="line"></span>                    }
<span id="line10112" class="line"></span>                    if (!replaced._zombieCache &amp;&amp; replaced.source.equals(tileSource)) {
<span id="line10113" class="line"></span>                        replaced.allowZombieCache(true);
<span id="line10114" class="line"></span>                    }
<span id="line10115" class="line"></span>                    this.world.removeItem(replaced);
<span id="line10116" class="line"></span>                }
<span id="line10117" class="line"></span>
<span id="line10118" class="line"></span>                if (this.collectionMode) {
<span id="line10119" class="line"></span>                    this.world.setAutoRefigureSizes(false);
<span id="line10120" class="line"></span>                }
<span id="line10121" class="line"></span>
<span id="line10122" class="line"></span>                if (this.navigator) {
<span id="line10123" class="line"></span>                    optionsClone = $.extend({}, queueItem.options, {
<span id="line10124" class="line"></span>                        replace: false, // navigator already removed the layer, nothing to replace
<span id="line10125" class="line"></span>                        originalTiledImage: tiledImage,
<span id="line10126" class="line"></span>                        tileSource: tileSource
<span id="line10127" class="line"></span>                    });
<span id="line10128" class="line"></span>
<span id="line10129" class="line"></span>                    this.navigator.addTiledImage(optionsClone);
<span id="line10130" class="line"></span>                }
<span id="line10131" class="line"></span>
<span id="line10132" class="line"></span>                this.world.addItem( tiledImage, {
<span id="line10133" class="line"></span>                    index: queueItem.options.index
<span id="line10134" class="line"></span>                });
<span id="line10135" class="line"></span>
<span id="line10136" class="line"></span>                if (this._loadQueue.length === 0) {
<span id="line10137" class="line"></span>                    //this restores the autoRefigureSizes flag to true.
<span id="line10138" class="line"></span>                    refreshWorld(queueItem);
<span id="line10139" class="line"></span>                }
<span id="line10140" class="line"></span>
<span id="line10141" class="line"></span>                if (this.world.getItemCount() === 1 &amp;&amp; !this.preserveViewport) {
<span id="line10142" class="line"></span>                    this.viewport.goHome(true);
<span id="line10143" class="line"></span>                }
<span id="line10144" class="line"></span>
<span id="line10145" class="line"></span>                if (queueItem.originalSuccess) {
<span id="line10146" class="line"></span>                    queueItem.originalSuccess(event);
<span id="line10147" class="line"></span>                }
<span id="line10148" class="line"></span>
<span id="line10149" class="line"></span>                // It might happen processReadyItems() is called after viewer.destroy()
<span id="line10150" class="line"></span>                if (this.drawer) {
<span id="line10151" class="line"></span>                    // This is necessary since drawer might react upon finalized tiled image, after
<span id="line10152" class="line"></span>                    // all events have been processed.
<span id="line10153" class="line"></span>                    this.drawer.tiledImageCreated(tiledImage);
<span id="line10154" class="line"></span>                }
<span id="line10155" class="line"></span>            }
<span id="line10156" class="line"></span>        };
<span id="line10157" class="line"></span>        options.error = raiseAddItemFailed;
<span id="line10158" class="line"></span>        this.instantiateTiledImageClass(options);
<span id="line10159" class="line"></span>    },
<span id="line10160" class="line"></span>
<span id="line10161" class="line"></span>    /**
<span id="line10162" class="line"></span>     * Create a TiledImage Instance. This instance is not integrated into the viewer
<span id="line10163" class="line"></span>     * and can be used to for example draw custom data in offscreen fashion by instantiating
<span id="line10164" class="line"></span>     * offscreen drawer, creating detached tiled images, forcing them to load certain region
<span id="line10165" class="line"></span>     * and calling drawer.draw([my tiled images]).
<span id="line10166" class="line"></span>     * @param {OpenSeadragon.TileSourceSpecifier} options options to create the image. Some properties
<span id="line10167" class="line"></span>     *   are unused, these properties drive how the image is inserted into the world, and therefore
<span id="line10168" class="line"></span>     *   they are not used in the pure creation of the TiledImage.
<span id="line10169" class="line"></span>     * @return {OpenSeadragon.Promise&lt;OpenSeadragon.TiledImage|object&gt;} A promise that resolves to the created TiledImage.
<span id="line10170" class="line"></span>     *   Also, old options.error and options.success callbacks can be used instead to handle the output.
<span id="line10171" class="line"></span>     */
<span id="line10172" class="line"></span>    instantiateTiledImageClass: function( options) {
<span id="line10173" class="line"></span>        return this.instantiateTileSourceClass(options).then(event =&gt; {
<span id="line10174" class="line"></span>            // add everybody at the front of the queue that's ready to go
<span id="line10175" class="line"></span>            const tiledImage = new $.TiledImage({
<span id="line10176" class="line"></span>                viewer: this,
<span id="line10177" class="line"></span>                source: event.source,
<span id="line10178" class="line"></span>                viewport: this.viewport,
<span id="line10179" class="line"></span>                drawer: this.drawer,
<span id="line10180" class="line"></span>                tileCache: this.tileCache,
<span id="line10181" class="line"></span>                imageLoader: this.imageLoader,
<span id="line10182" class="line"></span>                x: options.x,
<span id="line10183" class="line"></span>                y: options.y,
<span id="line10184" class="line"></span>                width: options.width,
<span id="line10185" class="line"></span>                height: options.height,
<span id="line10186" class="line"></span>                fitBounds: options.fitBounds,
<span id="line10187" class="line"></span>                fitBoundsPlacement: options.fitBoundsPlacement,
<span id="line10188" class="line"></span>                clip: options.clip,
<span id="line10189" class="line"></span>                placeholderFillStyle: options.placeholderFillStyle,
<span id="line10190" class="line"></span>                opacity: options.opacity,
<span id="line10191" class="line"></span>                preload: options.preload,
<span id="line10192" class="line"></span>                degrees: options.degrees,
<span id="line10193" class="line"></span>                flipped: options.flipped,
<span id="line10194" class="line"></span>                compositeOperation: options.compositeOperation,
<span id="line10195" class="line"></span>                springStiffness: this.springStiffness,
<span id="line10196" class="line"></span>                animationTime: this.animationTime,
<span id="line10197" class="line"></span>                minZoomImageRatio: this.minZoomImageRatio,
<span id="line10198" class="line"></span>                wrapHorizontal: this.wrapHorizontal,
<span id="line10199" class="line"></span>                wrapVertical: this.wrapVertical,
<span id="line10200" class="line"></span>                maxTilesPerFrame: this.maxTilesPerFrame,
<span id="line10201" class="line"></span>                loadDestinationTilesOnAnimation: this.loadDestinationTilesOnAnimation,
<span id="line10202" class="line"></span>                immediateRender: this.immediateRender,
<span id="line10203" class="line"></span>                blendTime: this.blendTime,
<span id="line10204" class="line"></span>                alwaysBlend: this.alwaysBlend,
<span id="line10205" class="line"></span>                minPixelRatio: this.minPixelRatio,
<span id="line10206" class="line"></span>                smoothTileEdgesMinZoom: this.smoothTileEdgesMinZoom,
<span id="line10207" class="line"></span>                iOSDevice: this.iOSDevice,
<span id="line10208" class="line"></span>                crossOriginPolicy: options.crossOriginPolicy,
<span id="line10209" class="line"></span>                ajaxWithCredentials: options.ajaxWithCredentials,
<span id="line10210" class="line"></span>                loadTilesWithAjax: options.loadTilesWithAjax,
<span id="line10211" class="line"></span>                ajaxHeaders: options.ajaxHeaders,
<span id="line10212" class="line"></span>                debugMode: this.debugMode,
<span id="line10213" class="line"></span>                subPixelRoundingForTransparency: this.subPixelRoundingForTransparency,
<span id="line10214" class="line"></span>                callTileLoadedWithCachedData: this.callTileLoadedWithCachedData,
<span id="line10215" class="line"></span>                originalDataType: options.originalDataType
<span id="line10216" class="line"></span>            });
<span id="line10217" class="line"></span>
<span id="line10218" class="line"></span>            options.success({
<span id="line10219" class="line"></span>                item: tiledImage
<span id="line10220" class="line"></span>            });
<span id="line10221" class="line"></span>            return tiledImage;
<span id="line10222" class="line"></span>        }).catch(e =&gt; {
<span id="line10223" class="line"></span>            if (options.error) {
<span id="line10224" class="line"></span>                options.error(e);
<span id="line10225" class="line"></span>                return e;
<span id="line10226" class="line"></span>            }
<span id="line10227" class="line"></span>            throw e;
<span id="line10228" class="line"></span>        });
<span id="line10229" class="line"></span>    },
<span id="line10230" class="line"></span>
<span id="line10231" class="line"></span>    /**
<span id="line10232" class="line"></span>     * Attempts to initialize a TileSource from various input types and configuration formats.
<span id="line10233" class="line"></span>     * Handles string URLs, raw XML/JSON strings, inline configuration objects, or custom TileSource implementations.
<span id="line10234" class="line"></span>     *
<span id="line10235" class="line"></span>     * @function
<span id="line10236" class="line"></span>     * @param {OpenSeadragon.TileSourceSpecifier} options options to create the image. Some properties
<span id="line10237" class="line"></span>     * @return {OpenSeadragon.Promise&lt;object&gt;} A promise that resolves to info object carrying 'source' and 'message'.
<span id="line10238" class="line"></span>     *   Message is provided only on error, in that case the source is reference to the original source parameter that
<span id="line10239" class="line"></span>     *   was defining the TileSource. On success, the source is a TileSource instance.
<span id="line10240" class="line"></span>     */
<span id="line10241" class="line"></span>    instantiateTileSourceClass( options ) {
<span id="line10242" class="line"></span>        return new $.Promise( ( resolve, reject ) =&gt; {
<span id="line10243" class="line"></span>            if (options.placeholderFillStyle === undefined) {
<span id="line10244" class="line"></span>                options.placeholderFillStyle = this.placeholderFillStyle;
<span id="line10245" class="line"></span>            }
<span id="line10246" class="line"></span>            if (options.opacity === undefined) {
<span id="line10247" class="line"></span>                options.opacity = this.opacity;
<span id="line10248" class="line"></span>            }
<span id="line10249" class="line"></span>            if (options.preload === undefined) {
<span id="line10250" class="line"></span>                options.preload = this.preload;
<span id="line10251" class="line"></span>            }
<span id="line10252" class="line"></span>            if (options.compositeOperation === undefined) {
<span id="line10253" class="line"></span>                options.compositeOperation = this.compositeOperation;
<span id="line10254" class="line"></span>            }
<span id="line10255" class="line"></span>            if (options.crossOriginPolicy === undefined) {
<span id="line10256" class="line"></span>                options.crossOriginPolicy = options.tileSource.crossOriginPolicy !== undefined ?
<span id="line10257" class="line"></span>                    options.tileSource.crossOriginPolicy : this.crossOriginPolicy;
<span id="line10258" class="line"></span>            }
<span id="line10259" class="line"></span>            if (options.ajaxWithCredentials === undefined) {
<span id="line10260" class="line"></span>                options.ajaxWithCredentials = this.ajaxWithCredentials;
<span id="line10261" class="line"></span>            }
<span id="line10262" class="line"></span>            if (options.loadTilesWithAjax === undefined) {
<span id="line10263" class="line"></span>                options.loadTilesWithAjax = this.loadTilesWithAjax;
<span id="line10264" class="line"></span>            }
<span id="line10265" class="line"></span>            if (!$.isPlainObject(options.ajaxHeaders)) {
<span id="line10266" class="line"></span>                options.ajaxHeaders = {};
<span id="line10267" class="line"></span>            }
<span id="line10268" class="line"></span>
<span id="line10269" class="line"></span>            let tileSource = options.tileSource;
<span id="line10270" class="line"></span>
<span id="line10271" class="line"></span>            //allow plain xml strings or json strings to be parsed here
<span id="line10272" class="line"></span>            if ( $.type( tileSource ) === 'string' ) {
<span id="line10273" class="line"></span>                //xml should start with "&lt;" and end with "&gt;"
<span id="line10274" class="line"></span>                if ( tileSource.match( /^\s*&lt;.*&gt;\s*$/ ) ) {
<span id="line10275" class="line"></span>                    tileSource = $.parseXml( tileSource );
<span id="line10276" class="line"></span>                    //json should start with "{" or "[" and end with "}" or "]"
<span id="line10277" class="line"></span>                } else if ( tileSource.match(/^\s*[{[].*[}\]]\s*$/ ) ) {
<span id="line10278" class="line"></span>                    try {
<span id="line10279" class="line"></span>                        tileSource = $.parseJSON(tileSource);
<span id="line10280" class="line"></span>                    } catch (e) {
<span id="line10281" class="line"></span>                        //tileSource = tileSource;
<span id="line10282" class="line"></span>                    }
<span id="line10283" class="line"></span>                }
<span id="line10284" class="line"></span>            }
<span id="line10285" class="line"></span>
<span id="line10286" class="line"></span>            function waitUntilReady(tileSource, originalTileSource) {
<span id="line10287" class="line"></span>                if (tileSource.ready) {
<span id="line10288" class="line"></span>                    resolve({
<span id="line10289" class="line"></span>                        source: tileSource
<span id="line10290" class="line"></span>                    });
<span id="line10291" class="line"></span>                } else {
<span id="line10292" class="line"></span>                    tileSource.addHandler('ready', function (event) {
<span id="line10293" class="line"></span>                        resolve({
<span id="line10294" class="line"></span>                            source: event.tileSource
<span id="line10295" class="line"></span>                        });
<span id="line10296" class="line"></span>                    });
<span id="line10297" class="line"></span>                    tileSource.addHandler('open-failed', function (event) {
<span id="line10298" class="line"></span>                        reject({
<span id="line10299" class="line"></span>                            message: event.message,
<span id="line10300" class="line"></span>                            source: originalTileSource
<span id="line10301" class="line"></span>                        });
<span id="line10302" class="line"></span>                    });
<span id="line10303" class="line"></span>                }
<span id="line10304" class="line"></span>            }
<span id="line10305" class="line"></span>
<span id="line10306" class="line"></span>            setTimeout(() =&gt; {
<span id="line10307" class="line"></span>                if ( $.type( tileSource ) === 'string' ) {
<span id="line10308" class="line"></span>                    //If its still a string it means it must be a url at this point
<span id="line10309" class="line"></span>                    tileSource = new $.TileSource({
<span id="line10310" class="line"></span>                        url: tileSource,
<span id="line10311" class="line"></span>                        crossOriginPolicy: options.crossOriginPolicy !== undefined ?
<span id="line10312" class="line"></span>                            options.crossOriginPolicy : this.crossOriginPolicy,
<span id="line10313" class="line"></span>                        ajaxWithCredentials: this.ajaxWithCredentials,
<span id="line10314" class="line"></span>                        ajaxHeaders: $.extend({}, this.ajaxHeaders, options.ajaxHeaders),
<span id="line10315" class="line"></span>                        splitHashDataForPost: this.splitHashDataForPost,
<span id="line10316" class="line"></span>                    });
<span id="line10317" class="line"></span>                    waitUntilReady(tileSource, tileSource);
<span id="line10318" class="line"></span>                } else if ($.isPlainObject(tileSource) || tileSource.nodeType) {
<span id="line10319" class="line"></span>                    if (tileSource.crossOriginPolicy === undefined &amp;&amp;
<span id="line10320" class="line"></span>                        (options.crossOriginPolicy !== undefined || this.crossOriginPolicy !== undefined)) {
<span id="line10321" class="line"></span>                        tileSource.crossOriginPolicy = options.crossOriginPolicy !== undefined ?
<span id="line10322" class="line"></span>                            options.crossOriginPolicy : this.crossOriginPolicy;
<span id="line10323" class="line"></span>                    }
<span id="line10324" class="line"></span>                    if (tileSource.ajaxWithCredentials === undefined) {
<span id="line10325" class="line"></span>                        tileSource.ajaxWithCredentials = this.ajaxWithCredentials;
<span id="line10326" class="line"></span>                    }
<span id="line10327" class="line"></span>
<span id="line10328" class="line"></span>                    if ( $.isFunction( tileSource.getTileUrl ) ) {
<span id="line10329" class="line"></span>                        //Custom tile source
<span id="line10330" class="line"></span>                        const customTileSource = new $.TileSource( tileSource );
<span id="line10331" class="line"></span>                        customTileSource.getTileUrl = tileSource.getTileUrl;
<span id="line10332" class="line"></span>                        tileSource.ready = false;
<span id="line10333" class="line"></span>                        waitUntilReady(customTileSource, tileSource);
<span id="line10334" class="line"></span>                    } else {
<span id="line10335" class="line"></span>                        //inline configuration
<span id="line10336" class="line"></span>                        const $TileSource = $.TileSource.determineType( this, tileSource, null );
<span id="line10337" class="line"></span>                        if ( !$TileSource ) {
<span id="line10338" class="line"></span>                            reject({
<span id="line10339" class="line"></span>                                message: "Unable to load TileSource",
<span id="line10340" class="line"></span>                                source: tileSource,
<span id="line10341" class="line"></span>                                error: true
<span id="line10342" class="line"></span>                            });
<span id="line10343" class="line"></span>                            return;
<span id="line10344" class="line"></span>                        }
<span id="line10345" class="line"></span>                        const tileOptions = $TileSource.prototype.configure.apply( this, [ tileSource ] );
<span id="line10346" class="line"></span>                        tileOptions.ready = false;
<span id="line10347" class="line"></span>                        waitUntilReady(new $TileSource(tileOptions), tileSource);
<span id="line10348" class="line"></span>                    }
<span id="line10349" class="line"></span>                } else {
<span id="line10350" class="line"></span>                    //can assume it's already a tile source implementation, force inheritance
<span id="line10351" class="line"></span>                    waitUntilReady(tileSource, tileSource);
<span id="line10352" class="line"></span>                }
<span id="line10353" class="line"></span>            });
<span id="line10354" class="line"></span>        });
<span id="line10355" class="line"></span>    },
<span id="line10356" class="line"></span>
<span id="line10357" class="line"></span>    /**
<span id="line10358" class="line"></span>     * Add a simple image to the viewer.
<span id="line10359" class="line"></span>     * The options are the same as the ones in {@link OpenSeadragon.Viewer#addTiledImage}
<span id="line10360" class="line"></span>     * except for options.tileSource which is replaced by options.url.
<span id="line10361" class="line"></span>     * @function
<span id="line10362" class="line"></span>     * @param {Object} options - See {@link OpenSeadragon.Viewer#addTiledImage}
<span id="line10363" class="line"></span>     * for all the options
<span id="line10364" class="line"></span>     * @param {String} options.url - The URL of the image to add.
<span id="line10365" class="line"></span>     * @fires OpenSeadragon.World.event:add-item
<span id="line10366" class="line"></span>     * @fires OpenSeadragon.Viewer.event:add-item-failed
<span id="line10367" class="line"></span>     */
<span id="line10368" class="line"></span>    addSimpleImage: function(options) {
<span id="line10369" class="line"></span>        $.console.assert(options, "[Viewer.addSimpleImage] options is required");
<span id="line10370" class="line"></span>        $.console.assert(options.url, "[Viewer.addSimpleImage] options.url is required");
<span id="line10371" class="line"></span>
<span id="line10372" class="line"></span>        const opts = $.extend({}, options, {
<span id="line10373" class="line"></span>            tileSource: {
<span id="line10374" class="line"></span>                type: 'image',
<span id="line10375" class="line"></span>                url:  options.url
<span id="line10376" class="line"></span>            }
<span id="line10377" class="line"></span>        });
<span id="line10378" class="line"></span>        delete opts.url;
<span id="line10379" class="line"></span>        this.addTiledImage(opts);
<span id="line10380" class="line"></span>    },
<span id="line10381" class="line"></span>
<span id="line10382" class="line"></span>    // deprecated
<span id="line10383" class="line"></span>    addLayer: function( options ) {
<span id="line10384" class="line"></span>        const _this = this;
<span id="line10385" class="line"></span>
<span id="line10386" class="line"></span>        $.console.error( "[Viewer.addLayer] this function is deprecated; use Viewer.addTiledImage() instead." );
<span id="line10387" class="line"></span>
<span id="line10388" class="line"></span>        const optionsClone = $.extend({}, options, {
<span id="line10389" class="line"></span>            success: function(event) {
<span id="line10390" class="line"></span>                _this.raiseEvent("add-layer", {
<span id="line10391" class="line"></span>                    options: options,
<span id="line10392" class="line"></span>                    drawer: event.item
<span id="line10393" class="line"></span>                });
<span id="line10394" class="line"></span>            },
<span id="line10395" class="line"></span>            error: function(event) {
<span id="line10396" class="line"></span>                _this.raiseEvent("add-layer-failed", event);
<span id="line10397" class="line"></span>            }
<span id="line10398" class="line"></span>        });
<span id="line10399" class="line"></span>
<span id="line10400" class="line"></span>        this.addTiledImage(optionsClone);
<span id="line10401" class="line"></span>        return this;
<span id="line10402" class="line"></span>    },
<span id="line10403" class="line"></span>
<span id="line10404" class="line"></span>    // deprecated
<span id="line10405" class="line"></span>    getLayerAtLevel: function( level ) {
<span id="line10406" class="line"></span>        $.console.error( "[Viewer.getLayerAtLevel] this function is deprecated; use World.getItemAt() instead." );
<span id="line10407" class="line"></span>        return this.world.getItemAt(level);
<span id="line10408" class="line"></span>    },
<span id="line10409" class="line"></span>
<span id="line10410" class="line"></span>    // deprecated
<span id="line10411" class="line"></span>    getLevelOfLayer: function( drawer ) {
<span id="line10412" class="line"></span>        $.console.error( "[Viewer.getLevelOfLayer] this function is deprecated; use World.getIndexOfItem() instead." );
<span id="line10413" class="line"></span>        return this.world.getIndexOfItem(drawer);
<span id="line10414" class="line"></span>    },
<span id="line10415" class="line"></span>
<span id="line10416" class="line"></span>    // deprecated
<span id="line10417" class="line"></span>    getLayersCount: function() {
<span id="line10418" class="line"></span>        $.console.error( "[Viewer.getLayersCount] this function is deprecated; use World.getItemCount() instead." );
<span id="line10419" class="line"></span>        return this.world.getItemCount();
<span id="line10420" class="line"></span>    },
<span id="line10421" class="line"></span>
<span id="line10422" class="line"></span>    // deprecated
<span id="line10423" class="line"></span>    setLayerLevel: function( drawer, level ) {
<span id="line10424" class="line"></span>        $.console.error( "[Viewer.setLayerLevel] this function is deprecated; use World.setItemIndex() instead." );
<span id="line10425" class="line"></span>        return this.world.setItemIndex(drawer, level);
<span id="line10426" class="line"></span>    },
<span id="line10427" class="line"></span>
<span id="line10428" class="line"></span>    // deprecated
<span id="line10429" class="line"></span>    removeLayer: function( drawer ) {
<span id="line10430" class="line"></span>        $.console.error( "[Viewer.removeLayer] this function is deprecated; use World.removeItem() instead." );
<span id="line10431" class="line"></span>        return this.world.removeItem(drawer);
<span id="line10432" class="line"></span>    },
<span id="line10433" class="line"></span>
<span id="line10434" class="line"></span>    /**
<span id="line10435" class="line"></span>     * Force the viewer to redraw its contents.
<span id="line10436" class="line"></span>     * @returns {OpenSeadragon.Viewer} Chainable.
<span id="line10437" class="line"></span>     */
<span id="line10438" class="line"></span>    forceRedraw: function() {
<span id="line10439" class="line"></span>        THIS[ this.hash ].forceRedraw = true;
<span id="line10440" class="line"></span>        return this;
<span id="line10441" class="line"></span>    },
<span id="line10442" class="line"></span>
<span id="line10443" class="line"></span>    /**
<span id="line10444" class="line"></span>     * Force the viewer to reset its size to match its container.
<span id="line10445" class="line"></span>     */
<span id="line10446" class="line"></span>    forceResize: function() {
<span id="line10447" class="line"></span>        THIS[this.hash].needsResize = true;
<span id="line10448" class="line"></span>        THIS[this.hash].forceResize = true;
<span id="line10449" class="line"></span>    },
<span id="line10450" class="line"></span>
<span id="line10451" class="line"></span>    /**
<span id="line10452" class="line"></span>     * @function
<span id="line10453" class="line"></span>     * @returns {OpenSeadragon.Viewer} Chainable.
<span id="line10454" class="line"></span>     */
<span id="line10455" class="line"></span>    bindSequenceControls: function(){
<span id="line10456" class="line"></span>
<span id="line10457" class="line"></span>        //////////////////////////////////////////////////////////////////////////
<span id="line10458" class="line"></span>        // Image Sequence Controls
<span id="line10459" class="line"></span>        //////////////////////////////////////////////////////////////////////////
<span id="line10460" class="line"></span>        const onFocusHandler          = $.delegate( this, onFocus );
<span id="line10461" class="line"></span>        const onBlurHandler           = $.delegate( this, onBlur );
<span id="line10462" class="line"></span>        const onNextHandler           = $.delegate( this, this.goToNextPage );
<span id="line10463" class="line"></span>        const onPreviousHandler       = $.delegate( this, this.goToPreviousPage );
<span id="line10464" class="line"></span>        const navImages               = this.navImages;
<span id="line10465" class="line"></span>        let useGroup                  = true;
<span id="line10466" class="line"></span>
<span id="line10467" class="line"></span>        if( this.showSequenceControl ){
<span id="line10468" class="line"></span>
<span id="line10469" class="line"></span>            if( this.previousButton || this.nextButton ){
<span id="line10470" class="line"></span>                //if we are binding to custom buttons then layout and
<span id="line10471" class="line"></span>                //grouping is the responsibility of the page author
<span id="line10472" class="line"></span>                useGroup = false;
<span id="line10473" class="line"></span>            }
<span id="line10474" class="line"></span>
<span id="line10475" class="line"></span>            this.previousButton = new $.Button({
<span id="line10476" class="line"></span>                element:    this.previousButton ? $.getElement( this.previousButton ) : null,
<span id="line10477" class="line"></span>                clickTimeThreshold: this.clickTimeThreshold,
<span id="line10478" class="line"></span>                clickDistThreshold: this.clickDistThreshold,
<span id="line10479" class="line"></span>                tooltip:    $.getString( "Tooltips.PreviousPage" ),
<span id="line10480" class="line"></span>                srcRest:    resolveUrl( this.prefixUrl, navImages.previous.REST ),
<span id="line10481" class="line"></span>                srcGroup:   resolveUrl( this.prefixUrl, navImages.previous.GROUP ),
<span id="line10482" class="line"></span>                srcHover:   resolveUrl( this.prefixUrl, navImages.previous.HOVER ),
<span id="line10483" class="line"></span>                srcDown:    resolveUrl( this.prefixUrl, navImages.previous.DOWN ),
<span id="line10484" class="line"></span>                onRelease:  onPreviousHandler,
<span id="line10485" class="line"></span>                onFocus:    onFocusHandler,
<span id="line10486" class="line"></span>                onBlur:     onBlurHandler
<span id="line10487" class="line"></span>            });
<span id="line10488" class="line"></span>
<span id="line10489" class="line"></span>            this.nextButton = new $.Button({
<span id="line10490" class="line"></span>                element:    this.nextButton ? $.getElement( this.nextButton ) : null,
<span id="line10491" class="line"></span>                clickTimeThreshold: this.clickTimeThreshold,
<span id="line10492" class="line"></span>                clickDistThreshold: this.clickDistThreshold,
<span id="line10493" class="line"></span>                tooltip:    $.getString( "Tooltips.NextPage" ),
<span id="line10494" class="line"></span>                srcRest:    resolveUrl( this.prefixUrl, navImages.next.REST ),
<span id="line10495" class="line"></span>                srcGroup:   resolveUrl( this.prefixUrl, navImages.next.GROUP ),
<span id="line10496" class="line"></span>                srcHover:   resolveUrl( this.prefixUrl, navImages.next.HOVER ),
<span id="line10497" class="line"></span>                srcDown:    resolveUrl( this.prefixUrl, navImages.next.DOWN ),
<span id="line10498" class="line"></span>                onRelease:  onNextHandler,
<span id="line10499" class="line"></span>                onFocus:    onFocusHandler,
<span id="line10500" class="line"></span>                onBlur:     onBlurHandler
<span id="line10501" class="line"></span>            });
<span id="line10502" class="line"></span>
<span id="line10503" class="line"></span>            if( !this.navPrevNextWrap ){
<span id="line10504" class="line"></span>                this.previousButton.disable();
<span id="line10505" class="line"></span>            }
<span id="line10506" class="line"></span>
<span id="line10507" class="line"></span>            if (!this.tileSources || !this.tileSources.length) {
<span id="line10508" class="line"></span>                this.nextButton.disable();
<span id="line10509" class="line"></span>            }
<span id="line10510" class="line"></span>
<span id="line10511" class="line"></span>            if( useGroup ){
<span id="line10512" class="line"></span>                this.paging = new $.ButtonGroup({
<span id="line10513" class="line"></span>                    buttons: [
<span id="line10514" class="line"></span>                        this.previousButton,
<span id="line10515" class="line"></span>                        this.nextButton
<span id="line10516" class="line"></span>                    ],
<span id="line10517" class="line"></span>                    clickTimeThreshold: this.clickTimeThreshold,
<span id="line10518" class="line"></span>                    clickDistThreshold: this.clickDistThreshold
<span id="line10519" class="line"></span>                });
<span id="line10520" class="line"></span>
<span id="line10521" class="line"></span>                this.pagingControl = this.paging.element;
<span id="line10522" class="line"></span>
<span id="line10523" class="line"></span>                if( this.toolbar ){
<span id="line10524" class="line"></span>                    this.toolbar.addControl(
<span id="line10525" class="line"></span>                        this.pagingControl,
<span id="line10526" class="line"></span>                        {anchor: $.ControlAnchor.BOTTOM_RIGHT}
<span id="line10527" class="line"></span>                    );
<span id="line10528" class="line"></span>                }else{
<span id="line10529" class="line"></span>                    this.addControl(
<span id="line10530" class="line"></span>                        this.pagingControl,
<span id="line10531" class="line"></span>                        {anchor: this.sequenceControlAnchor || $.ControlAnchor.TOP_LEFT}
<span id="line10532" class="line"></span>                    );
<span id="line10533" class="line"></span>                }
<span id="line10534" class="line"></span>            }
<span id="line10535" class="line"></span>        }
<span id="line10536" class="line"></span>        return this;
<span id="line10537" class="line"></span>    },
<span id="line10538" class="line"></span>
<span id="line10539" class="line"></span>
<span id="line10540" class="line"></span>    /**
<span id="line10541" class="line"></span>     * @function
<span id="line10542" class="line"></span>     * @returns {OpenSeadragon.Viewer} Chainable.
<span id="line10543" class="line"></span>     */
<span id="line10544" class="line"></span>    bindStandardControls: function(){
<span id="line10545" class="line"></span>        //////////////////////////////////////////////////////////////////////////
<span id="line10546" class="line"></span>        // Navigation Controls
<span id="line10547" class="line"></span>        //////////////////////////////////////////////////////////////////////////
<span id="line10548" class="line"></span>        const beginZoomingInHandler   = $.delegate( this, this.startZoomInAction );
<span id="line10549" class="line"></span>        const endZoomingHandler       = $.delegate( this, this.endZoomAction );
<span id="line10550" class="line"></span>        const doSingleZoomInHandler   = $.delegate( this, this.singleZoomInAction );
<span id="line10551" class="line"></span>        const beginZoomingOutHandler  = $.delegate( this, this.startZoomOutAction );
<span id="line10552" class="line"></span>        const doSingleZoomOutHandler  = $.delegate( this, this.singleZoomOutAction );
<span id="line10553" class="line"></span>        const onHomeHandler           = $.delegate( this, onHome );
<span id="line10554" class="line"></span>        const onFullScreenHandler     = $.delegate( this, onFullScreen );
<span id="line10555" class="line"></span>        const onRotateLeftHandler     = $.delegate( this, onRotateLeft );
<span id="line10556" class="line"></span>        const onRotateRightHandler    = $.delegate( this, onRotateRight );
<span id="line10557" class="line"></span>        const onFlipHandler           = $.delegate( this, onFlip);
<span id="line10558" class="line"></span>        const onFocusHandler          = $.delegate( this, onFocus );
<span id="line10559" class="line"></span>        const onBlurHandler           = $.delegate( this, onBlur );
<span id="line10560" class="line"></span>        const navImages               = this.navImages;
<span id="line10561" class="line"></span>        const buttons                 = [];
<span id="line10562" class="line"></span>        let useGroup                = true;
<span id="line10563" class="line"></span>
<span id="line10564" class="line"></span>
<span id="line10565" class="line"></span>        if ( this.showNavigationControl ) {
<span id="line10566" class="line"></span>
<span id="line10567" class="line"></span>            if( this.zoomInButton || this.zoomOutButton ||
<span id="line10568" class="line"></span>                this.homeButton || this.fullPageButton ||
<span id="line10569" class="line"></span>                this.rotateLeftButton || this.rotateRightButton ||
<span id="line10570" class="line"></span>                this.flipButton ) {
<span id="line10571" class="line"></span>                //if we are binding to custom buttons then layout and
<span id="line10572" class="line"></span>                //grouping is the responsibility of the page author
<span id="line10573" class="line"></span>                useGroup = false;
<span id="line10574" class="line"></span>            }
<span id="line10575" class="line"></span>
<span id="line10576" class="line"></span>            if ( this.showZoomControl ) {
<span id="line10577" class="line"></span>                buttons.push( this.zoomInButton = new $.Button({
<span id="line10578" class="line"></span>                    element:    this.zoomInButton ? $.getElement( this.zoomInButton ) : null,
<span id="line10579" class="line"></span>                    clickTimeThreshold: this.clickTimeThreshold,
<span id="line10580" class="line"></span>                    clickDistThreshold: this.clickDistThreshold,
<span id="line10581" class="line"></span>                    tooltip:    $.getString( "Tooltips.ZoomIn" ),
<span id="line10582" class="line"></span>                    srcRest:    resolveUrl( this.prefixUrl, navImages.zoomIn.REST ),
<span id="line10583" class="line"></span>                    srcGroup:   resolveUrl( this.prefixUrl, navImages.zoomIn.GROUP ),
<span id="line10584" class="line"></span>                    srcHover:   resolveUrl( this.prefixUrl, navImages.zoomIn.HOVER ),
<span id="line10585" class="line"></span>                    srcDown:    resolveUrl( this.prefixUrl, navImages.zoomIn.DOWN ),
<span id="line10586" class="line"></span>                    onPress:    beginZoomingInHandler,
<span id="line10587" class="line"></span>                    onRelease:  endZoomingHandler,
<span id="line10588" class="line"></span>                    onClick:    doSingleZoomInHandler,
<span id="line10589" class="line"></span>                    onEnter:    beginZoomingInHandler,
<span id="line10590" class="line"></span>                    onExit:     endZoomingHandler,
<span id="line10591" class="line"></span>                    onFocus:    onFocusHandler,
<span id="line10592" class="line"></span>                    onBlur:     onBlurHandler
<span id="line10593" class="line"></span>                }));
<span id="line10594" class="line"></span>
<span id="line10595" class="line"></span>                buttons.push( this.zoomOutButton = new $.Button({
<span id="line10596" class="line"></span>                    element:    this.zoomOutButton ? $.getElement( this.zoomOutButton ) : null,
<span id="line10597" class="line"></span>                    clickTimeThreshold: this.clickTimeThreshold,
<span id="line10598" class="line"></span>                    clickDistThreshold: this.clickDistThreshold,
<span id="line10599" class="line"></span>                    tooltip:    $.getString( "Tooltips.ZoomOut" ),
<span id="line10600" class="line"></span>                    srcRest:    resolveUrl( this.prefixUrl, navImages.zoomOut.REST ),
<span id="line10601" class="line"></span>                    srcGroup:   resolveUrl( this.prefixUrl, navImages.zoomOut.GROUP ),
<span id="line10602" class="line"></span>                    srcHover:   resolveUrl( this.prefixUrl, navImages.zoomOut.HOVER ),
<span id="line10603" class="line"></span>                    srcDown:    resolveUrl( this.prefixUrl, navImages.zoomOut.DOWN ),
<span id="line10604" class="line"></span>                    onPress:    beginZoomingOutHandler,
<span id="line10605" class="line"></span>                    onRelease:  endZoomingHandler,
<span id="line10606" class="line"></span>                    onClick:    doSingleZoomOutHandler,
<span id="line10607" class="line"></span>                    onEnter:    beginZoomingOutHandler,
<span id="line10608" class="line"></span>                    onExit:     endZoomingHandler,
<span id="line10609" class="line"></span>                    onFocus:    onFocusHandler,
<span id="line10610" class="line"></span>                    onBlur:     onBlurHandler
<span id="line10611" class="line"></span>                }));
<span id="line10612" class="line"></span>            }
<span id="line10613" class="line"></span>
<span id="line10614" class="line"></span>            if ( this.showHomeControl ) {
<span id="line10615" class="line"></span>                buttons.push( this.homeButton = new $.Button({
<span id="line10616" class="line"></span>                    element:    this.homeButton ? $.getElement( this.homeButton ) : null,
<span id="line10617" class="line"></span>                    clickTimeThreshold: this.clickTimeThreshold,
<span id="line10618" class="line"></span>                    clickDistThreshold: this.clickDistThreshold,
<span id="line10619" class="line"></span>                    tooltip:    $.getString( "Tooltips.Home" ),
<span id="line10620" class="line"></span>                    srcRest:    resolveUrl( this.prefixUrl, navImages.home.REST ),
<span id="line10621" class="line"></span>                    srcGroup:   resolveUrl( this.prefixUrl, navImages.home.GROUP ),
<span id="line10622" class="line"></span>                    srcHover:   resolveUrl( this.prefixUrl, navImages.home.HOVER ),
<span id="line10623" class="line"></span>                    srcDown:    resolveUrl( this.prefixUrl, navImages.home.DOWN ),
<span id="line10624" class="line"></span>                    onRelease:  onHomeHandler,
<span id="line10625" class="line"></span>                    onFocus:    onFocusHandler,
<span id="line10626" class="line"></span>                    onBlur:     onBlurHandler
<span id="line10627" class="line"></span>                }));
<span id="line10628" class="line"></span>            }
<span id="line10629" class="line"></span>
<span id="line10630" class="line"></span>            if ( this.showFullPageControl ) {
<span id="line10631" class="line"></span>                buttons.push( this.fullPageButton = new $.Button({
<span id="line10632" class="line"></span>                    element:    this.fullPageButton ? $.getElement( this.fullPageButton ) : null,
<span id="line10633" class="line"></span>                    clickTimeThreshold: this.clickTimeThreshold,
<span id="line10634" class="line"></span>                    clickDistThreshold: this.clickDistThreshold,
<span id="line10635" class="line"></span>                    tooltip:    $.getString( "Tooltips.FullPage" ),
<span id="line10636" class="line"></span>                    srcRest:    resolveUrl( this.prefixUrl, navImages.fullpage.REST ),
<span id="line10637" class="line"></span>                    srcGroup:   resolveUrl( this.prefixUrl, navImages.fullpage.GROUP ),
<span id="line10638" class="line"></span>                    srcHover:   resolveUrl( this.prefixUrl, navImages.fullpage.HOVER ),
<span id="line10639" class="line"></span>                    srcDown:    resolveUrl( this.prefixUrl, navImages.fullpage.DOWN ),
<span id="line10640" class="line"></span>                    onRelease:  onFullScreenHandler,
<span id="line10641" class="line"></span>                    onFocus:    onFocusHandler,
<span id="line10642" class="line"></span>                    onBlur:     onBlurHandler
<span id="line10643" class="line"></span>                }));
<span id="line10644" class="line"></span>            }
<span id="line10645" class="line"></span>
<span id="line10646" class="line"></span>            if ( this.showRotationControl ) {
<span id="line10647" class="line"></span>                buttons.push( this.rotateLeftButton = new $.Button({
<span id="line10648" class="line"></span>                    element:    this.rotateLeftButton ? $.getElement( this.rotateLeftButton ) : null,
<span id="line10649" class="line"></span>                    clickTimeThreshold: this.clickTimeThreshold,
<span id="line10650" class="line"></span>                    clickDistThreshold: this.clickDistThreshold,
<span id="line10651" class="line"></span>                    tooltip:    $.getString( "Tooltips.RotateLeft" ),
<span id="line10652" class="line"></span>                    srcRest:    resolveUrl( this.prefixUrl, navImages.rotateleft.REST ),
<span id="line10653" class="line"></span>                    srcGroup:   resolveUrl( this.prefixUrl, navImages.rotateleft.GROUP ),
<span id="line10654" class="line"></span>                    srcHover:   resolveUrl( this.prefixUrl, navImages.rotateleft.HOVER ),
<span id="line10655" class="line"></span>                    srcDown:    resolveUrl( this.prefixUrl, navImages.rotateleft.DOWN ),
<span id="line10656" class="line"></span>                    onRelease:  onRotateLeftHandler,
<span id="line10657" class="line"></span>                    onFocus:    onFocusHandler,
<span id="line10658" class="line"></span>                    onBlur:     onBlurHandler
<span id="line10659" class="line"></span>                }));
<span id="line10660" class="line"></span>
<span id="line10661" class="line"></span>                buttons.push( this.rotateRightButton = new $.Button({
<span id="line10662" class="line"></span>                    element:    this.rotateRightButton ? $.getElement( this.rotateRightButton ) : null,
<span id="line10663" class="line"></span>                    clickTimeThreshold: this.clickTimeThreshold,
<span id="line10664" class="line"></span>                    clickDistThreshold: this.clickDistThreshold,
<span id="line10665" class="line"></span>                    tooltip:    $.getString( "Tooltips.RotateRight" ),
<span id="line10666" class="line"></span>                    srcRest:    resolveUrl( this.prefixUrl, navImages.rotateright.REST ),
<span id="line10667" class="line"></span>                    srcGroup:   resolveUrl( this.prefixUrl, navImages.rotateright.GROUP ),
<span id="line10668" class="line"></span>                    srcHover:   resolveUrl( this.prefixUrl, navImages.rotateright.HOVER ),
<span id="line10669" class="line"></span>                    srcDown:    resolveUrl( this.prefixUrl, navImages.rotateright.DOWN ),
<span id="line10670" class="line"></span>                    onRelease:  onRotateRightHandler,
<span id="line10671" class="line"></span>                    onFocus:    onFocusHandler,
<span id="line10672" class="line"></span>                    onBlur:     onBlurHandler
<span id="line10673" class="line"></span>                }));
<span id="line10674" class="line"></span>            }
<span id="line10675" class="line"></span>
<span id="line10676" class="line"></span>            if ( this.showFlipControl ) {
<span id="line10677" class="line"></span>                buttons.push( this.flipButton = new $.Button({
<span id="line10678" class="line"></span>                    element:    this.flipButton ? $.getElement( this.flipButton ) : null,
<span id="line10679" class="line"></span>                    clickTimeThreshold: this.clickTimeThreshold,
<span id="line10680" class="line"></span>                    clickDistThreshold: this.clickDistThreshold,
<span id="line10681" class="line"></span>                    tooltip:    $.getString( "Tooltips.Flip" ),
<span id="line10682" class="line"></span>                    srcRest:    resolveUrl( this.prefixUrl, navImages.flip.REST ),
<span id="line10683" class="line"></span>                    srcGroup:   resolveUrl( this.prefixUrl, navImages.flip.GROUP ),
<span id="line10684" class="line"></span>                    srcHover:   resolveUrl( this.prefixUrl, navImages.flip.HOVER ),
<span id="line10685" class="line"></span>                    srcDown:    resolveUrl( this.prefixUrl, navImages.flip.DOWN ),
<span id="line10686" class="line"></span>                    onRelease:  onFlipHandler,
<span id="line10687" class="line"></span>                    onFocus:    onFocusHandler,
<span id="line10688" class="line"></span>                    onBlur:     onBlurHandler
<span id="line10689" class="line"></span>                }));
<span id="line10690" class="line"></span>            }
<span id="line10691" class="line"></span>
<span id="line10692" class="line"></span>            if ( useGroup ) {
<span id="line10693" class="line"></span>                this.buttonGroup = new $.ButtonGroup({
<span id="line10694" class="line"></span>                    buttons:            buttons,
<span id="line10695" class="line"></span>                    clickTimeThreshold: this.clickTimeThreshold,
<span id="line10696" class="line"></span>                    clickDistThreshold: this.clickDistThreshold
<span id="line10697" class="line"></span>                });
<span id="line10698" class="line"></span>
<span id="line10699" class="line"></span>                this.navControl  = this.buttonGroup.element;
<span id="line10700" class="line"></span>                this.addHandler( 'open', $.delegate( this, lightUp ) );
<span id="line10701" class="line"></span>
<span id="line10702" class="line"></span>                if( this.toolbar ){
<span id="line10703" class="line"></span>                    this.toolbar.addControl(
<span id="line10704" class="line"></span>                        this.navControl,
<span id="line10705" class="line"></span>                        {anchor: this.navigationControlAnchor || $.ControlAnchor.TOP_LEFT}
<span id="line10706" class="line"></span>                    );
<span id="line10707" class="line"></span>                } else {
<span id="line10708" class="line"></span>                    this.addControl(
<span id="line10709" class="line"></span>                        this.navControl,
<span id="line10710" class="line"></span>                        {anchor: this.navigationControlAnchor || $.ControlAnchor.TOP_LEFT}
<span id="line10711" class="line"></span>                    );
<span id="line10712" class="line"></span>                }
<span id="line10713" class="line"></span>            } else {
<span id="line10714" class="line"></span>                this.customButtons = buttons;
<span id="line10715" class="line"></span>            }
<span id="line10716" class="line"></span>
<span id="line10717" class="line"></span>        }
<span id="line10718" class="line"></span>        return this;
<span id="line10719" class="line"></span>    },
<span id="line10720" class="line"></span>
<span id="line10721" class="line"></span>    /**
<span id="line10722" class="line"></span>     * Gets the active page of a sequence
<span id="line10723" class="line"></span>     * @function
<span id="line10724" class="line"></span>     * @returns {Number}
<span id="line10725" class="line"></span>     */
<span id="line10726" class="line"></span>    currentPage: function() {
<span id="line10727" class="line"></span>        return this._sequenceIndex;
<span id="line10728" class="line"></span>    },
<span id="line10729" class="line"></span>
<span id="line10730" class="line"></span>    /**
<span id="line10731" class="line"></span>     * @function
<span id="line10732" class="line"></span>     * @returns {OpenSeadragon.Viewer} Chainable.
<span id="line10733" class="line"></span>     * @fires OpenSeadragon.Viewer.event:page
<span id="line10734" class="line"></span>     */
<span id="line10735" class="line"></span>    goToPage: function( page ){
<span id="line10736" class="line"></span>        if( this.tileSources &amp;&amp; page &gt;= 0 &amp;&amp; page &lt; this.tileSources.length ){
<span id="line10737" class="line"></span>            this._sequenceIndex = page;
<span id="line10738" class="line"></span>
<span id="line10739" class="line"></span>            this._updateSequenceButtons( page );
<span id="line10740" class="line"></span>
<span id="line10741" class="line"></span>            this.open( this.tileSources[ page ] );
<span id="line10742" class="line"></span>
<span id="line10743" class="line"></span>            if( this.referenceStrip ){
<span id="line10744" class="line"></span>                this.referenceStrip.setFocus( page );
<span id="line10745" class="line"></span>            }
<span id="line10746" class="line"></span>
<span id="line10747" class="line"></span>            /**
<span id="line10748" class="line"></span>             * Raised when the page is changed on a viewer configured with multiple image sources (see {@link OpenSeadragon.Viewer#goToPage}).
<span id="line10749" class="line"></span>             *
<span id="line10750" class="line"></span>             * @event page
<span id="line10751" class="line"></span>             * @memberof OpenSeadragon.Viewer
<span id="line10752" class="line"></span>             * @type {Object}
<span id="line10753" class="line"></span>             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line10754" class="line"></span>             * @property {Number} page - The page index.
<span id="line10755" class="line"></span>             * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line10756" class="line"></span>             */
<span id="line10757" class="line"></span>            this.raiseEvent( 'page', { page: page } );
<span id="line10758" class="line"></span>        }
<span id="line10759" class="line"></span>
<span id="line10760" class="line"></span>        return this;
<span id="line10761" class="line"></span>    },
<span id="line10762" class="line"></span>
<span id="line10763" class="line"></span>   /**
<span id="line10764" class="line"></span>     * Adds an html element as an overlay to the current viewport.  Useful for
<span id="line10765" class="line"></span>     * highlighting words or areas of interest on an image or other zoomable
<span id="line10766" class="line"></span>     * interface. Unless the viewer has been configured with the preserveOverlays
<span id="line10767" class="line"></span>     * option, overlays added via this method are removed when the viewport
<span id="line10768" class="line"></span>     * is closed (including in sequence mode when changing page).
<span id="line10769" class="line"></span>     * @method
<span id="line10770" class="line"></span>     * @param {Element|String|Object} element - A reference to an element or an id for
<span id="line10771" class="line"></span>     *      the element which will be overlaid. Or an Object specifying the configuration for the overlay.
<span id="line10772" class="line"></span>     *      If using an object, see {@link OpenSeadragon.Overlay} for a list of
<span id="line10773" class="line"></span>     *      all available options.
<span id="line10774" class="line"></span>     * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or
<span id="line10775" class="line"></span>     *      rectangle which will be overlaid. This is a viewport relative location.
<span id="line10776" class="line"></span>     * @param {OpenSeadragon.Placement} [placement=OpenSeadragon.Placement.TOP_LEFT] - The position of the
<span id="line10777" class="line"></span>     *      viewport which the location coordinates will be treated as relative
<span id="line10778" class="line"></span>     *      to.
<span id="line10779" class="line"></span>     * @param {function} [onDraw] - If supplied the callback is called when the overlay
<span id="line10780" class="line"></span>     *      needs to be drawn. It is the responsibility of the callback to do any drawing/positioning.
<span id="line10781" class="line"></span>     *      It is passed position, size and element.
<span id="line10782" class="line"></span>     * @returns {OpenSeadragon.Viewer} Chainable.
<span id="line10783" class="line"></span>     * @fires OpenSeadragon.Viewer.event:add-overlay
<span id="line10784" class="line"></span>     */
<span id="line10785" class="line"></span>    addOverlay: function( element, location, placement, onDraw ) {
<span id="line10786" class="line"></span>        let options;
<span id="line10787" class="line"></span>        if( $.isPlainObject( element ) ){
<span id="line10788" class="line"></span>            options = element;
<span id="line10789" class="line"></span>        } else {
<span id="line10790" class="line"></span>            options = {
<span id="line10791" class="line"></span>                element: element,
<span id="line10792" class="line"></span>                location: location,
<span id="line10793" class="line"></span>                placement: placement,
<span id="line10794" class="line"></span>                onDraw: onDraw
<span id="line10795" class="line"></span>            };
<span id="line10796" class="line"></span>        }
<span id="line10797" class="line"></span>
<span id="line10798" class="line"></span>        element = $.getElement( options.element );
<span id="line10799" class="line"></span>
<span id="line10800" class="line"></span>        if ( getOverlayIndex( this.currentOverlays, element ) &gt;= 0 ) {
<span id="line10801" class="line"></span>            // they're trying to add a duplicate overlay
<span id="line10802" class="line"></span>            return this;
<span id="line10803" class="line"></span>        }
<span id="line10804" class="line"></span>
<span id="line10805" class="line"></span>        const overlay = getOverlayObject( this, options);
<span id="line10806" class="line"></span>        this.currentOverlays.push(overlay);
<span id="line10807" class="line"></span>        overlay.drawHTML( this.overlaysContainer, this.viewport );
<span id="line10808" class="line"></span>
<span id="line10809" class="line"></span>        /**
<span id="line10810" class="line"></span>         * Raised when an overlay is added to the viewer (see {@link OpenSeadragon.Viewer#addOverlay}).
<span id="line10811" class="line"></span>         *
<span id="line10812" class="line"></span>         * @event add-overlay
<span id="line10813" class="line"></span>         * @memberof OpenSeadragon.Viewer
<span id="line10814" class="line"></span>         * @type {object}
<span id="line10815" class="line"></span>         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line10816" class="line"></span>         * @property {Element} element - The overlay element.
<span id="line10817" class="line"></span>         * @property {OpenSeadragon.Point|OpenSeadragon.Rect} location
<span id="line10818" class="line"></span>         * @property {OpenSeadragon.Placement} placement
<span id="line10819" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line10820" class="line"></span>         */
<span id="line10821" class="line"></span>        this.raiseEvent( 'add-overlay', {
<span id="line10822" class="line"></span>            element: element,
<span id="line10823" class="line"></span>            location: options.location,
<span id="line10824" class="line"></span>            placement: options.placement
<span id="line10825" class="line"></span>        });
<span id="line10826" class="line"></span>        return this;
<span id="line10827" class="line"></span>    },
<span id="line10828" class="line"></span>
<span id="line10829" class="line"></span>    /**
<span id="line10830" class="line"></span>     * Updates the overlay represented by the reference to the element or
<span id="line10831" class="line"></span>     * element id moving it to the new location, relative to the new placement.
<span id="line10832" class="line"></span>     * @method
<span id="line10833" class="line"></span>     * @param {Element|String} element - A reference to an element or an id for
<span id="line10834" class="line"></span>     *      the element which is overlaid.
<span id="line10835" class="line"></span>     * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or
<span id="line10836" class="line"></span>     *      rectangle which will be overlaid. This is a viewport relative location.
<span id="line10837" class="line"></span>     * @param {OpenSeadragon.Placement} [placement=OpenSeadragon.Placement.TOP_LEFT] - The position of the
<span id="line10838" class="line"></span>     *      viewport which the location coordinates will be treated as relative
<span id="line10839" class="line"></span>     *      to.
<span id="line10840" class="line"></span>     * @returns {OpenSeadragon.Viewer} Chainable.
<span id="line10841" class="line"></span>     * @fires OpenSeadragon.Viewer.event:update-overlay
<span id="line10842" class="line"></span>     */
<span id="line10843" class="line"></span>    updateOverlay: function( element, location, placement ) {
<span id="line10844" class="line"></span>        element = $.getElement( element );
<span id="line10845" class="line"></span>        const i = getOverlayIndex( this.currentOverlays, element );
<span id="line10846" class="line"></span>
<span id="line10847" class="line"></span>        if ( i &gt;= 0 ) {
<span id="line10848" class="line"></span>            this.currentOverlays[ i ].update( location, placement );
<span id="line10849" class="line"></span>            THIS[ this.hash ].forceRedraw = true;
<span id="line10850" class="line"></span>            /**
<span id="line10851" class="line"></span>             * Raised when an overlay's location or placement changes
<span id="line10852" class="line"></span>             * (see {@link OpenSeadragon.Viewer#updateOverlay}).
<span id="line10853" class="line"></span>             *
<span id="line10854" class="line"></span>             * @event update-overlay
<span id="line10855" class="line"></span>             * @memberof OpenSeadragon.Viewer
<span id="line10856" class="line"></span>             * @type {object}
<span id="line10857" class="line"></span>             * @property {OpenSeadragon.Viewer} eventSource - A reference to the
<span id="line10858" class="line"></span>             * Viewer which raised the event.
<span id="line10859" class="line"></span>             * @property {Element} element
<span id="line10860" class="line"></span>             * @property {OpenSeadragon.Point|OpenSeadragon.Rect} location
<span id="line10861" class="line"></span>             * @property {OpenSeadragon.Placement} placement
<span id="line10862" class="line"></span>             * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line10863" class="line"></span>             */
<span id="line10864" class="line"></span>            this.raiseEvent( 'update-overlay', {
<span id="line10865" class="line"></span>                element: element,
<span id="line10866" class="line"></span>                location: location,
<span id="line10867" class="line"></span>                placement: placement
<span id="line10868" class="line"></span>            });
<span id="line10869" class="line"></span>        }
<span id="line10870" class="line"></span>        return this;
<span id="line10871" class="line"></span>    },
<span id="line10872" class="line"></span>
<span id="line10873" class="line"></span>    /**
<span id="line10874" class="line"></span>     * Removes an overlay identified by the reference element or element id
<span id="line10875" class="line"></span>     * and schedules an update.
<span id="line10876" class="line"></span>     * @method
<span id="line10877" class="line"></span>     * @param {Element|String} element - A reference to the element or an
<span id="line10878" class="line"></span>     *      element id which represent the ovelay content to be removed.
<span id="line10879" class="line"></span>     * @returns {OpenSeadragon.Viewer} Chainable.
<span id="line10880" class="line"></span>     * @fires OpenSeadragon.Viewer.event:remove-overlay
<span id="line10881" class="line"></span>     */
<span id="line10882" class="line"></span>    removeOverlay: function( element ) {
<span id="line10883" class="line"></span>        element = $.getElement( element );
<span id="line10884" class="line"></span>        const i = getOverlayIndex( this.currentOverlays, element );
<span id="line10885" class="line"></span>
<span id="line10886" class="line"></span>        if ( i &gt;= 0 ) {
<span id="line10887" class="line"></span>            this.currentOverlays[ i ].destroy();
<span id="line10888" class="line"></span>            this.currentOverlays.splice( i, 1 );
<span id="line10889" class="line"></span>            THIS[ this.hash ].forceRedraw = true;
<span id="line10890" class="line"></span>            /**
<span id="line10891" class="line"></span>             * Raised when an overlay is removed from the viewer
<span id="line10892" class="line"></span>             * (see {@link OpenSeadragon.Viewer#removeOverlay}).
<span id="line10893" class="line"></span>             *
<span id="line10894" class="line"></span>             * @event remove-overlay
<span id="line10895" class="line"></span>             * @memberof OpenSeadragon.Viewer
<span id="line10896" class="line"></span>             * @type {object}
<span id="line10897" class="line"></span>             * @property {OpenSeadragon.Viewer} eventSource - A reference to the
<span id="line10898" class="line"></span>             * Viewer which raised the event.
<span id="line10899" class="line"></span>             * @property {Element} element - The overlay element.
<span id="line10900" class="line"></span>             * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line10901" class="line"></span>             */
<span id="line10902" class="line"></span>            this.raiseEvent( 'remove-overlay', {
<span id="line10903" class="line"></span>                element: element
<span id="line10904" class="line"></span>            });
<span id="line10905" class="line"></span>        }
<span id="line10906" class="line"></span>        return this;
<span id="line10907" class="line"></span>    },
<span id="line10908" class="line"></span>
<span id="line10909" class="line"></span>    /**
<span id="line10910" class="line"></span>     * Removes all currently configured Overlays from this Viewer and schedules
<span id="line10911" class="line"></span>     * an update.
<span id="line10912" class="line"></span>     * @method
<span id="line10913" class="line"></span>     * @returns {OpenSeadragon.Viewer} Chainable.
<span id="line10914" class="line"></span>     * @fires OpenSeadragon.Viewer.event:clear-overlay
<span id="line10915" class="line"></span>     */
<span id="line10916" class="line"></span>    clearOverlays: function() {
<span id="line10917" class="line"></span>        while ( this.currentOverlays.length &gt; 0 ) {
<span id="line10918" class="line"></span>            this.currentOverlays.pop().destroy();
<span id="line10919" class="line"></span>        }
<span id="line10920" class="line"></span>        THIS[ this.hash ].forceRedraw = true;
<span id="line10921" class="line"></span>        /**
<span id="line10922" class="line"></span>         * Raised when all overlays are removed from the viewer (see {@link OpenSeadragon.Drawer#clearOverlays}).
<span id="line10923" class="line"></span>         *
<span id="line10924" class="line"></span>         * @event clear-overlay
<span id="line10925" class="line"></span>         * @memberof OpenSeadragon.Viewer
<span id="line10926" class="line"></span>         * @type {object}
<span id="line10927" class="line"></span>         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line10928" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line10929" class="line"></span>         */
<span id="line10930" class="line"></span>        this.raiseEvent( 'clear-overlay', {} );
<span id="line10931" class="line"></span>        return this;
<span id="line10932" class="line"></span>    },
<span id="line10933" class="line"></span>
<span id="line10934" class="line"></span>     /**
<span id="line10935" class="line"></span>     * Finds an overlay identified by the reference element or element id
<span id="line10936" class="line"></span>     * and returns it as an object, return null if not found.
<span id="line10937" class="line"></span>     * @method
<span id="line10938" class="line"></span>     * @param {Element|String} element - A reference to the element or an
<span id="line10939" class="line"></span>     *      element id which represents the overlay content.
<span id="line10940" class="line"></span>     * @returns {OpenSeadragon.Overlay} the matching overlay or null if none found.
<span id="line10941" class="line"></span>     */
<span id="line10942" class="line"></span>    getOverlayById: function( element ) {
<span id="line10943" class="line"></span>        element = $.getElement( element );
<span id="line10944" class="line"></span>        const i = getOverlayIndex( this.currentOverlays, element );
<span id="line10945" class="line"></span>
<span id="line10946" class="line"></span>        if (i &gt;= 0) {
<span id="line10947" class="line"></span>            return this.currentOverlays[i];
<span id="line10948" class="line"></span>        } else {
<span id="line10949" class="line"></span>            return null;
<span id="line10950" class="line"></span>        }
<span id="line10951" class="line"></span>    },
<span id="line10952" class="line"></span>
<span id="line10953" class="line"></span>    /**
<span id="line10954" class="line"></span>     * Register drawer for shared updates
<span id="line10955" class="line"></span>     * @param drawer
<span id="line10956" class="line"></span>     * @private
<span id="line10957" class="line"></span>     */
<span id="line10958" class="line"></span>    _registerDrawer: function (drawer) {
<span id="line10959" class="line"></span>        if (!this._drawerList) {
<span id="line10960" class="line"></span>            this._drawerList = [];
<span id="line10961" class="line"></span>        }
<span id="line10962" class="line"></span>        this._drawerList.push(drawer);
<span id="line10963" class="line"></span>    },
<span id="line10964" class="line"></span>    /**
<span id="line10965" class="line"></span>     * Unregister drawer from shared updates
<span id="line10966" class="line"></span>     * @param drawer
<span id="line10967" class="line"></span>     * @private
<span id="line10968" class="line"></span>     */
<span id="line10969" class="line"></span>    _unregisterDrawer: function (drawer) {
<span id="line10970" class="line"></span>        if (!this._drawerList) {
<span id="line10971" class="line"></span>            $.console.warn('Viewer._unregisterDrawer: cannot unregister on viewer that is not meant to share updates.');
<span id="line10972" class="line"></span>            return;
<span id="line10973" class="line"></span>        }
<span id="line10974" class="line"></span>        this._drawerList.splice(this._drawerList.indexOf(drawer), 1);
<span id="line10975" class="line"></span>    },
<span id="line10976" class="line"></span>
<span id="line10977" class="line"></span>    /**
<span id="line10978" class="line"></span>     * Updates the sequence buttons.
<span id="line10979" class="line"></span>     * @function OpenSeadragon.Viewer.prototype._updateSequenceButtons
<span id="line10980" class="line"></span>     * @private
<span id="line10981" class="line"></span>     * @param {Number} Sequence Value
<span id="line10982" class="line"></span>     */
<span id="line10983" class="line"></span>    _updateSequenceButtons: function( page ) {
<span id="line10984" class="line"></span>
<span id="line10985" class="line"></span>            if ( this.nextButton ) {
<span id="line10986" class="line"></span>                if(!this.tileSources || this.tileSources.length - 1 === page) {
<span id="line10987" class="line"></span>                    //Disable next button
<span id="line10988" class="line"></span>                    if ( !this.navPrevNextWrap ) {
<span id="line10989" class="line"></span>                        this.nextButton.disable();
<span id="line10990" class="line"></span>                    }
<span id="line10991" class="line"></span>                } else {
<span id="line10992" class="line"></span>                    this.nextButton.enable();
<span id="line10993" class="line"></span>                }
<span id="line10994" class="line"></span>            }
<span id="line10995" class="line"></span>            if ( this.previousButton ) {
<span id="line10996" class="line"></span>                if ( page &gt; 0 ) {
<span id="line10997" class="line"></span>                    //Enable previous button
<span id="line10998" class="line"></span>                    this.previousButton.enable();
<span id="line10999" class="line"></span>                } else {
<span id="line11000" class="line"></span>                    if ( !this.navPrevNextWrap ) {
<span id="line11001" class="line"></span>                        this.previousButton.disable();
<span id="line11002" class="line"></span>                    }
<span id="line11003" class="line"></span>                }
<span id="line11004" class="line"></span>            }
<span id="line11005" class="line"></span>      },
<span id="line11006" class="line"></span>
<span id="line11007" class="line"></span>    /**
<span id="line11008" class="line"></span>     * Display a message in the viewport
<span id="line11009" class="line"></span>     * @function OpenSeadragon.Viewer.prototype._showMessage
<span id="line11010" class="line"></span>     * @private
<span id="line11011" class="line"></span>     * @param {String} text message
<span id="line11012" class="line"></span>     */
<span id="line11013" class="line"></span>    _showMessage: function ( message ) {
<span id="line11014" class="line"></span>        this._hideMessage();
<span id="line11015" class="line"></span>
<span id="line11016" class="line"></span>        const div = $.makeNeutralElement( "div" );
<span id="line11017" class="line"></span>        div.appendChild( document.createTextNode( message ) );
<span id="line11018" class="line"></span>
<span id="line11019" class="line"></span>        this.messageDiv = $.makeCenteredNode( div );
<span id="line11020" class="line"></span>
<span id="line11021" class="line"></span>        $.addClass(this.messageDiv, "openseadragon-message");
<span id="line11022" class="line"></span>
<span id="line11023" class="line"></span>        this.container.appendChild( this.messageDiv );
<span id="line11024" class="line"></span>    },
<span id="line11025" class="line"></span>
<span id="line11026" class="line"></span>    /**
<span id="line11027" class="line"></span>     * Hide any currently displayed viewport message
<span id="line11028" class="line"></span>     * @function OpenSeadragon.Viewer.prototype._hideMessage
<span id="line11029" class="line"></span>     * @private
<span id="line11030" class="line"></span>     */
<span id="line11031" class="line"></span>    _hideMessage: function () {
<span id="line11032" class="line"></span>        const div = this.messageDiv;
<span id="line11033" class="line"></span>        if (div) {
<span id="line11034" class="line"></span>            div.parentNode.removeChild(div);
<span id="line11035" class="line"></span>            delete this.messageDiv;
<span id="line11036" class="line"></span>        }
<span id="line11037" class="line"></span>    },
<span id="line11038" class="line"></span>
<span id="line11039" class="line"></span>    /**
<span id="line11040" class="line"></span>     * Gets this viewer's gesture settings for the given pointer device type.
<span id="line11041" class="line"></span>     * @method
<span id="line11042" class="line"></span>     * @param {String} type - The pointer device type to get the gesture settings for ("mouse", "touch", "pen", etc.).
<span id="line11043" class="line"></span>     * @returns {OpenSeadragon.GestureSettings}
<span id="line11044" class="line"></span>     */
<span id="line11045" class="line"></span>    gestureSettingsByDeviceType: function ( type ) {
<span id="line11046" class="line"></span>        switch ( type ) {
<span id="line11047" class="line"></span>            case 'mouse':
<span id="line11048" class="line"></span>                return this.gestureSettingsMouse;
<span id="line11049" class="line"></span>            case 'touch':
<span id="line11050" class="line"></span>                return this.gestureSettingsTouch;
<span id="line11051" class="line"></span>            case 'pen':
<span id="line11052" class="line"></span>                return this.gestureSettingsPen;
<span id="line11053" class="line"></span>            default:
<span id="line11054" class="line"></span>                return this.gestureSettingsUnknown;
<span id="line11055" class="line"></span>        }
<span id="line11056" class="line"></span>    },
<span id="line11057" class="line"></span>
<span id="line11058" class="line"></span>    // private
<span id="line11059" class="line"></span>    _drawOverlays: function() {
<span id="line11060" class="line"></span>        const length = this.currentOverlays.length;
<span id="line11061" class="line"></span>        for ( let i = 0; i &lt; length; i++ ) {
<span id="line11062" class="line"></span>            this.currentOverlays[ i ].drawHTML( this.overlaysContainer, this.viewport );
<span id="line11063" class="line"></span>        }
<span id="line11064" class="line"></span>    },
<span id="line11065" class="line"></span>
<span id="line11066" class="line"></span>    /**
<span id="line11067" class="line"></span>     * Cancel the "in flight" images.
<span id="line11068" class="line"></span>     */
<span id="line11069" class="line"></span>    _cancelPendingImages: function() {
<span id="line11070" class="line"></span>        this._loadQueue = [];
<span id="line11071" class="line"></span>    },
<span id="line11072" class="line"></span>
<span id="line11073" class="line"></span>    /**
<span id="line11074" class="line"></span>     * Removes the reference strip and disables displaying it.
<span id="line11075" class="line"></span>     * @function
<span id="line11076" class="line"></span>     */
<span id="line11077" class="line"></span>    removeReferenceStrip: function() {
<span id="line11078" class="line"></span>        this.showReferenceStrip = false;
<span id="line11079" class="line"></span>
<span id="line11080" class="line"></span>        if (this.referenceStrip) {
<span id="line11081" class="line"></span>            this.referenceStrip.destroy();
<span id="line11082" class="line"></span>            this.referenceStrip = null;
<span id="line11083" class="line"></span>        }
<span id="line11084" class="line"></span>    },
<span id="line11085" class="line"></span>
<span id="line11086" class="line"></span>    /**
<span id="line11087" class="line"></span>     * Enables and displays the reference strip based on the currently set tileSources.
<span id="line11088" class="line"></span>     * Works only when the Viewer has sequenceMode set to true.
<span id="line11089" class="line"></span>     * @function
<span id="line11090" class="line"></span>     */
<span id="line11091" class="line"></span>    addReferenceStrip: function() {
<span id="line11092" class="line"></span>        this.showReferenceStrip = true;
<span id="line11093" class="line"></span>
<span id="line11094" class="line"></span>        if (this.sequenceMode) {
<span id="line11095" class="line"></span>            if (this.referenceStrip) {
<span id="line11096" class="line"></span>                return;
<span id="line11097" class="line"></span>            }
<span id="line11098" class="line"></span>
<span id="line11099" class="line"></span>            if (this.tileSources.length &amp;&amp; this.tileSources.length &gt; 1) {
<span id="line11100" class="line"></span>                this.referenceStrip = new $.ReferenceStrip({
<span id="line11101" class="line"></span>                    id:          this.referenceStripElement,
<span id="line11102" class="line"></span>                    position:    this.referenceStripPosition,
<span id="line11103" class="line"></span>                    sizeRatio:   this.referenceStripSizeRatio,
<span id="line11104" class="line"></span>                    scroll:      this.referenceStripScroll,
<span id="line11105" class="line"></span>                    height:      this.referenceStripHeight,
<span id="line11106" class="line"></span>                    width:       this.referenceStripWidth,
<span id="line11107" class="line"></span>                    tileSources: this.tileSources,
<span id="line11108" class="line"></span>                    prefixUrl:   this.prefixUrl,
<span id="line11109" class="line"></span>                    viewer:      this
<span id="line11110" class="line"></span>                });
<span id="line11111" class="line"></span>
<span id="line11112" class="line"></span>                this.referenceStrip.setFocus( this._sequenceIndex );
<span id="line11113" class="line"></span>            }
<span id="line11114" class="line"></span>        } else {
<span id="line11115" class="line"></span>            $.console.warn('Attempting to display a reference strip while "sequenceMode" is off.');
<span id="line11116" class="line"></span>        }
<span id="line11117" class="line"></span>    },
<span id="line11118" class="line"></span>
<span id="line11119" class="line"></span>    /**
<span id="line11120" class="line"></span>     * Adds _updatePixelDensityRatio to the window resize event.
<span id="line11121" class="line"></span>     * @private
<span id="line11122" class="line"></span>     */
<span id="line11123" class="line"></span>    _addUpdatePixelDensityRatioEvent: function() {
<span id="line11124" class="line"></span>        this._updatePixelDensityRatioBind = this._updatePixelDensityRatio.bind(this);
<span id="line11125" class="line"></span>        $.addEvent( window, 'resize', this._updatePixelDensityRatioBind );
<span id="line11126" class="line"></span>    },
<span id="line11127" class="line"></span>
<span id="line11128" class="line"></span>    /**
<span id="line11129" class="line"></span>     * Removes _updatePixelDensityRatio from the window resize event.
<span id="line11130" class="line"></span>     * @private
<span id="line11131" class="line"></span>     */
<span id="line11132" class="line"></span>    _removeUpdatePixelDensityRatioEvent: function() {
<span id="line11133" class="line"></span>        $.removeEvent( window, 'resize', this._updatePixelDensityRatioBind );
<span id="line11134" class="line"></span>    },
<span id="line11135" class="line"></span>
<span id="line11136" class="line"></span>    /**
<span id="line11137" class="line"></span>     * Update pixel density ratio and forces a resize operation.
<span id="line11138" class="line"></span>     * @private
<span id="line11139" class="line"></span>     */
<span id="line11140" class="line"></span>     _updatePixelDensityRatio: function() {
<span id="line11141" class="line"></span>        const previusPixelDensityRatio = $.pixelDensityRatio;
<span id="line11142" class="line"></span>        const currentPixelDensityRatio = $.getCurrentPixelDensityRatio();
<span id="line11143" class="line"></span>        if (previusPixelDensityRatio !== currentPixelDensityRatio) {
<span id="line11144" class="line"></span>            $.pixelDensityRatio = currentPixelDensityRatio;
<span id="line11145" class="line"></span>            this.forceResize();
<span id="line11146" class="line"></span>        }
<span id="line11147" class="line"></span>    },
<span id="line11148" class="line"></span>
<span id="line11149" class="line"></span>    /**
<span id="line11150" class="line"></span>     * Sets the image source to the source with index equal to
<span id="line11151" class="line"></span>     * currentIndex - 1. Changes current image in sequence mode.
<span id="line11152" class="line"></span>     * If specified, wraps around (see navPrevNextWrap in
<span id="line11153" class="line"></span>     * {@link OpenSeadragon.Options})
<span id="line11154" class="line"></span>     *
<span id="line11155" class="line"></span>     * @method
<span id="line11156" class="line"></span>     */
<span id="line11157" class="line"></span>
<span id="line11158" class="line"></span>    goToPreviousPage: function () {
<span id="line11159" class="line"></span>        let previous = this._sequenceIndex - 1;
<span id="line11160" class="line"></span>        if(this.navPrevNextWrap &amp;&amp; previous &lt; 0){
<span id="line11161" class="line"></span>            previous += this.tileSources.length;
<span id="line11162" class="line"></span>        }
<span id="line11163" class="line"></span>        this.goToPage( previous );
<span id="line11164" class="line"></span>    },
<span id="line11165" class="line"></span>
<span id="line11166" class="line"></span>    /**
<span id="line11167" class="line"></span>     * Sets the image source to the source with index equal to
<span id="line11168" class="line"></span>     * currentIndex + 1. Changes current image in sequence mode.
<span id="line11169" class="line"></span>     * If specified, wraps around (see navPrevNextWrap in
<span id="line11170" class="line"></span>     * {@link OpenSeadragon.Options})
<span id="line11171" class="line"></span>     *
<span id="line11172" class="line"></span>     * @method
<span id="line11173" class="line"></span>     */
<span id="line11174" class="line"></span>    goToNextPage: function () {
<span id="line11175" class="line"></span>        let next = this._sequenceIndex + 1;
<span id="line11176" class="line"></span>        if(this.navPrevNextWrap &amp;&amp; next &gt;= this.tileSources.length){
<span id="line11177" class="line"></span>            next = 0;
<span id="line11178" class="line"></span>        }
<span id="line11179" class="line"></span>        this.goToPage( next );
<span id="line11180" class="line"></span>    },
<span id="line11181" class="line"></span>
<span id="line11182" class="line"></span>    isAnimating: function () {
<span id="line11183" class="line"></span>        return THIS[ this.hash ].animating;
<span id="line11184" class="line"></span>    },
<span id="line11185" class="line"></span>
<span id="line11186" class="line"></span>    /**
<span id="line11187" class="line"></span>     * Starts continuous zoom-in animation (typically bound to mouse-down on the zoom-in button).
<span id="line11188" class="line"></span>     * @function
<span id="line11189" class="line"></span>     * @memberof OpenSeadragon.Viewer.prototype
<span id="line11190" class="line"></span>     */
<span id="line11191" class="line"></span>    startZoomInAction: function () {
<span id="line11192" class="line"></span>        THIS[ this.hash ].lastZoomTime = $.now();
<span id="line11193" class="line"></span>        THIS[ this.hash ].zoomFactor = this.zoomPerSecond;
<span id="line11194" class="line"></span>        THIS[ this.hash ].zooming = true;
<span id="line11195" class="line"></span>        scheduleZoom( this );
<span id="line11196" class="line"></span>    },
<span id="line11197" class="line"></span>
<span id="line11198" class="line"></span>    /**
<span id="line11199" class="line"></span>     * Starts continuous zoom-out animation (typically bound to mouse-down on the zoom-out button).
<span id="line11200" class="line"></span>     * @function
<span id="line11201" class="line"></span>     * @memberof OpenSeadragon.Viewer.prototype
<span id="line11202" class="line"></span>     */
<span id="line11203" class="line"></span>    startZoomOutAction: function () {
<span id="line11204" class="line"></span>        THIS[ this.hash ].lastZoomTime = $.now();
<span id="line11205" class="line"></span>        THIS[ this.hash ].zoomFactor = 1.0 / this.zoomPerSecond;
<span id="line11206" class="line"></span>        THIS[ this.hash ].zooming = true;
<span id="line11207" class="line"></span>        scheduleZoom( this );
<span id="line11208" class="line"></span>    },
<span id="line11209" class="line"></span>
<span id="line11210" class="line"></span>    /**
<span id="line11211" class="line"></span>     * Stops any continuous zoom animation (typically bound to mouse-up/leave events on a button).
<span id="line11212" class="line"></span>     * @function
<span id="line11213" class="line"></span>     * @memberof OpenSeadragon.Viewer.prototype
<span id="line11214" class="line"></span>     */
<span id="line11215" class="line"></span>    endZoomAction: function () {
<span id="line11216" class="line"></span>        THIS[ this.hash ].zooming = false;
<span id="line11217" class="line"></span>    },
<span id="line11218" class="line"></span>
<span id="line11219" class="line"></span>    /**
<span id="line11220" class="line"></span>     * Performs single-step zoom-in operation (typically bound to click/enter on the zoom-in button).
<span id="line11221" class="line"></span>     * @function
<span id="line11222" class="line"></span>     * @memberof OpenSeadragon.Viewer.prototype
<span id="line11223" class="line"></span>     */
<span id="line11224" class="line"></span>    singleZoomInAction: function () {
<span id="line11225" class="line"></span>        if ( this.viewport ) {
<span id="line11226" class="line"></span>            THIS[ this.hash ].zooming = false;
<span id="line11227" class="line"></span>            this.viewport.zoomBy(
<span id="line11228" class="line"></span>                this.zoomPerClick / 1.0
<span id="line11229" class="line"></span>            );
<span id="line11230" class="line"></span>            this.viewport.applyConstraints();
<span id="line11231" class="line"></span>        }
<span id="line11232" class="line"></span>    },
<span id="line11233" class="line"></span>
<span id="line11234" class="line"></span>    /**
<span id="line11235" class="line"></span>     * Performs single-step zoom-out operation (typically bound to click/enter on the zoom-out button).
<span id="line11236" class="line"></span>     * @function
<span id="line11237" class="line"></span>     * @memberof OpenSeadragon.Viewer.prototype
<span id="line11238" class="line"></span>     */
<span id="line11239" class="line"></span>    singleZoomOutAction: function () {
<span id="line11240" class="line"></span>        if ( this.viewport ) {
<span id="line11241" class="line"></span>            THIS[ this.hash ].zooming = false;
<span id="line11242" class="line"></span>            this.viewport.zoomBy(
<span id="line11243" class="line"></span>                1.0 / this.zoomPerClick
<span id="line11244" class="line"></span>            );
<span id="line11245" class="line"></span>            this.viewport.applyConstraints();
<span id="line11246" class="line"></span>        }
<span id="line11247" class="line"></span>    },
<span id="line11248" class="line"></span>});
<span id="line11249" class="line"></span>
<span id="line11250" class="line"></span>
<span id="line11251" class="line"></span>/**
<span id="line11252" class="line"></span> * _getSafeElemSize is like getElementSize(), but refuses to return 0 for x or y,
<span id="line11253" class="line"></span> * which was causing some calling operations to return NaN.
<span id="line11254" class="line"></span> * @returns {Point}
<span id="line11255" class="line"></span> * @private
<span id="line11256" class="line"></span> */
<span id="line11257" class="line"></span>function _getSafeElemSize (oElement) {
<span id="line11258" class="line"></span>    oElement = $.getElement( oElement );
<span id="line11259" class="line"></span>
<span id="line11260" class="line"></span>    return new $.Point(
<span id="line11261" class="line"></span>        (oElement.clientWidth === 0 ? 1 : oElement.clientWidth),
<span id="line11262" class="line"></span>        (oElement.clientHeight === 0 ? 1 : oElement.clientHeight)
<span id="line11263" class="line"></span>    );
<span id="line11264" class="line"></span>}
<span id="line11265" class="line"></span>
<span id="line11266" class="line"></span>function getOverlayObject( viewer, overlay ) {
<span id="line11267" class="line"></span>    if ( overlay instanceof $.Overlay ) {
<span id="line11268" class="line"></span>        return overlay;
<span id="line11269" class="line"></span>    }
<span id="line11270" class="line"></span>
<span id="line11271" class="line"></span>    let element = null;
<span id="line11272" class="line"></span>    if ( overlay.element ) {
<span id="line11273" class="line"></span>        element = $.getElement( overlay.element );
<span id="line11274" class="line"></span>    } else {
<span id="line11275" class="line"></span>        const id = overlay.id ?
<span id="line11276" class="line"></span>            overlay.id :
<span id="line11277" class="line"></span>            "openseadragon-overlay-" + Math.floor( Math.random() * 10000000 );
<span id="line11278" class="line"></span>
<span id="line11279" class="line"></span>        element = $.getElement( overlay.id );
<span id="line11280" class="line"></span>        if ( !element ) {
<span id="line11281" class="line"></span>            element         = document.createElement( "a" );
<span id="line11282" class="line"></span>            element.href    = "#/overlay/" + id;
<span id="line11283" class="line"></span>        }
<span id="line11284" class="line"></span>        element.id = id;
<span id="line11285" class="line"></span>        $.addClass( element, overlay.className ?
<span id="line11286" class="line"></span>            overlay.className :
<span id="line11287" class="line"></span>            "openseadragon-overlay"
<span id="line11288" class="line"></span>        );
<span id="line11289" class="line"></span>    }
<span id="line11290" class="line"></span>
<span id="line11291" class="line"></span>    let location = overlay.location;
<span id="line11292" class="line"></span>    let width = overlay.width;
<span id="line11293" class="line"></span>    let height = overlay.height;
<span id="line11294" class="line"></span>    if (!location) {
<span id="line11295" class="line"></span>        let x = overlay.x;
<span id="line11296" class="line"></span>        let y = overlay.y;
<span id="line11297" class="line"></span>        if (overlay.px !== undefined) {
<span id="line11298" class="line"></span>            const rect = viewer.viewport.imageToViewportRectangle(new $.Rect(
<span id="line11299" class="line"></span>                overlay.px,
<span id="line11300" class="line"></span>                overlay.py,
<span id="line11301" class="line"></span>                width || 0,
<span id="line11302" class="line"></span>                height || 0));
<span id="line11303" class="line"></span>            x = rect.x;
<span id="line11304" class="line"></span>            y = rect.y;
<span id="line11305" class="line"></span>            width = width !== undefined ? rect.width : undefined;
<span id="line11306" class="line"></span>            height = height !== undefined ? rect.height : undefined;
<span id="line11307" class="line"></span>        }
<span id="line11308" class="line"></span>        location = new $.Point(x, y);
<span id="line11309" class="line"></span>    }
<span id="line11310" class="line"></span>
<span id="line11311" class="line"></span>    let placement = overlay.placement;
<span id="line11312" class="line"></span>    if (placement &amp;&amp; $.type(placement) === "string") {
<span id="line11313" class="line"></span>        placement = $.Placement[overlay.placement.toUpperCase()];
<span id="line11314" class="line"></span>    }
<span id="line11315" class="line"></span>
<span id="line11316" class="line"></span>    return new $.Overlay({
<span id="line11317" class="line"></span>        element: element,
<span id="line11318" class="line"></span>        location: location,
<span id="line11319" class="line"></span>        placement: placement,
<span id="line11320" class="line"></span>        onDraw: overlay.onDraw,
<span id="line11321" class="line"></span>        checkResize: overlay.checkResize,
<span id="line11322" class="line"></span>        width: width,
<span id="line11323" class="line"></span>        height: height,
<span id="line11324" class="line"></span>        rotationMode: overlay.rotationMode
<span id="line11325" class="line"></span>    });
<span id="line11326" class="line"></span>}
<span id="line11327" class="line"></span>
<span id="line11328" class="line"></span>/**
<span id="line11329" class="line"></span> * Determines the index of a specific overlay element within an array of overlays.
<span id="line11330" class="line"></span> *
<span id="line11331" class="line"></span> * @private
<span id="line11332" class="line"></span> * @inner
<span id="line11333" class="line"></span> * @param {Array&lt;Object&gt;} overlays - The array of overlay objects, each containing an `element` property.
<span id="line11334" class="line"></span> * @param {Element} element - The DOM element of the overlay to find.
<span id="line11335" class="line"></span> * @returns {number} The index of the matching overlay in the array, or -1 if not found.
<span id="line11336" class="line"></span> */
<span id="line11337" class="line"></span>function getOverlayIndex( overlays, element ) {
<span id="line11338" class="line"></span>    for ( let i = overlays.length - 1; i &gt;= 0; i-- ) {
<span id="line11339" class="line"></span>        if ( overlays[ i ].element === element ) {
<span id="line11340" class="line"></span>            return i;
<span id="line11341" class="line"></span>        }
<span id="line11342" class="line"></span>    }
<span id="line11343" class="line"></span>
<span id="line11344" class="line"></span>    return -1;
<span id="line11345" class="line"></span>}
<span id="line11346" class="line"></span>
<span id="line11347" class="line"></span>///////////////////////////////////////////////////////////////////////////////
<span id="line11348" class="line"></span>// Schedulers provide the general engine for animation
<span id="line11349" class="line"></span>///////////////////////////////////////////////////////////////////////////////
<span id="line11350" class="line"></span>function scheduleUpdate( viewer, updateFunc ){
<span id="line11351" class="line"></span>    return $.requestAnimationFrame( function(){
<span id="line11352" class="line"></span>        updateFunc( viewer );
<span id="line11353" class="line"></span>    } );
<span id="line11354" class="line"></span>}
<span id="line11355" class="line"></span>
<span id="line11356" class="line"></span>
<span id="line11357" class="line"></span>//provides a sequence in the fade animation
<span id="line11358" class="line"></span>function scheduleControlsFade( viewer ) {
<span id="line11359" class="line"></span>    $.requestAnimationFrame( function(){
<span id="line11360" class="line"></span>        updateControlsFade( viewer );
<span id="line11361" class="line"></span>    });
<span id="line11362" class="line"></span>}
<span id="line11363" class="line"></span>
<span id="line11364" class="line"></span>
<span id="line11365" class="line"></span>//initiates an animation to hide the controls
<span id="line11366" class="line"></span>function beginControlsAutoHide( viewer ) {
<span id="line11367" class="line"></span>    if ( !viewer.autoHideControls ) {
<span id="line11368" class="line"></span>        return;
<span id="line11369" class="line"></span>    }
<span id="line11370" class="line"></span>    viewer.controlsShouldFade = true;
<span id="line11371" class="line"></span>    viewer.controlsFadeBeginTime =
<span id="line11372" class="line"></span>        $.now() +
<span id="line11373" class="line"></span>        viewer.controlsFadeDelay;
<span id="line11374" class="line"></span>
<span id="line11375" class="line"></span>    window.setTimeout( function(){
<span id="line11376" class="line"></span>        scheduleControlsFade( viewer );
<span id="line11377" class="line"></span>    }, viewer.controlsFadeDelay );
<span id="line11378" class="line"></span>}
<span id="line11379" class="line"></span>
<span id="line11380" class="line"></span>
<span id="line11381" class="line"></span>//determines if fade animation is done or continues the animation
<span id="line11382" class="line"></span>function updateControlsFade( viewer ) {
<span id="line11383" class="line"></span>    if ( viewer.controlsShouldFade ) {
<span id="line11384" class="line"></span>        let currentTime = $.now();
<span id="line11385" class="line"></span>        let deltaTime = currentTime - viewer.controlsFadeBeginTime;
<span id="line11386" class="line"></span>        let opacity = 1.0 - deltaTime / viewer.controlsFadeLength;
<span id="line11387" class="line"></span>
<span id="line11388" class="line"></span>        opacity = Math.min( 1.0, opacity );
<span id="line11389" class="line"></span>        opacity = Math.max( 0.0, opacity );
<span id="line11390" class="line"></span>
<span id="line11391" class="line"></span>        for ( let i = viewer.controls.length - 1; i &gt;= 0; i--) {
<span id="line11392" class="line"></span>            if (viewer.controls[ i ].autoFade) {
<span id="line11393" class="line"></span>                viewer.controls[ i ].setOpacity( opacity );
<span id="line11394" class="line"></span>            }
<span id="line11395" class="line"></span>        }
<span id="line11396" class="line"></span>
<span id="line11397" class="line"></span>        if ( opacity &gt; 0 ) {
<span id="line11398" class="line"></span>            // fade again
<span id="line11399" class="line"></span>            scheduleControlsFade( viewer );
<span id="line11400" class="line"></span>        }
<span id="line11401" class="line"></span>    }
<span id="line11402" class="line"></span>}
<span id="line11403" class="line"></span>
<span id="line11404" class="line"></span>
<span id="line11405" class="line"></span>//stop the fade animation on the controls and show them
<span id="line11406" class="line"></span>function abortControlsAutoHide( viewer ) {
<span id="line11407" class="line"></span>    viewer.controlsShouldFade = false;
<span id="line11408" class="line"></span>    for ( let i = viewer.controls.length - 1; i &gt;= 0; i-- ) {
<span id="line11409" class="line"></span>        viewer.controls[ i ].setOpacity( 1.0 );
<span id="line11410" class="line"></span>    }
<span id="line11411" class="line"></span>}
<span id="line11412" class="line"></span>
<span id="line11413" class="line"></span>
<span id="line11414" class="line"></span>
<span id="line11415" class="line"></span>///////////////////////////////////////////////////////////////////////////////
<span id="line11416" class="line"></span>// Default view event handlers.
<span id="line11417" class="line"></span>///////////////////////////////////////////////////////////////////////////////
<span id="line11418" class="line"></span>function onFocus(){
<span id="line11419" class="line"></span>    abortControlsAutoHide( this );
<span id="line11420" class="line"></span>}
<span id="line11421" class="line"></span>
<span id="line11422" class="line"></span>function onBlur(){
<span id="line11423" class="line"></span>    beginControlsAutoHide( this );
<span id="line11424" class="line"></span>
<span id="line11425" class="line"></span>}
<span id="line11426" class="line"></span>
<span id="line11427" class="line"></span>function onCanvasContextMenu( event ) {
<span id="line11428" class="line"></span>    const eventArgs = {
<span id="line11429" class="line"></span>        tracker: event.eventSource,
<span id="line11430" class="line"></span>        position: event.position,
<span id="line11431" class="line"></span>        originalEvent: event.originalEvent,
<span id="line11432" class="line"></span>        preventDefault: event.preventDefault
<span id="line11433" class="line"></span>    };
<span id="line11434" class="line"></span>
<span id="line11435" class="line"></span>    /**
<span id="line11436" class="line"></span>     * Raised when a contextmenu event occurs in the {@link OpenSeadragon.Viewer#canvas} element.
<span id="line11437" class="line"></span>     *
<span id="line11438" class="line"></span>     * @event canvas-contextmenu
<span id="line11439" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line11440" class="line"></span>     * @type {object}
<span id="line11441" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line11442" class="line"></span>     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
<span id="line11443" class="line"></span>     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
<span id="line11444" class="line"></span>     * @property {Object} originalEvent - The original DOM event.
<span id="line11445" class="line"></span>     * @property {Boolean} preventDefault - Set to true to prevent the default user-agent's handling of the contextmenu event.
<span id="line11446" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line11447" class="line"></span>     */
<span id="line11448" class="line"></span>    this.raiseEvent( 'canvas-contextmenu', eventArgs );
<span id="line11449" class="line"></span>
<span id="line11450" class="line"></span>    event.preventDefault = eventArgs.preventDefault;
<span id="line11451" class="line"></span>}
<span id="line11452" class="line"></span>
<span id="line11453" class="line"></span>/**
<span id="line11454" class="line"></span> * Maps keyboard events to corresponding navigation actions,
<span id="line11455" class="line"></span> * accounting for Shift modifier state.
<span id="line11456" class="line"></span> *
<span id="line11457" class="line"></span> * @private
<span id="line11458" class="line"></span> * @param {Object} event - Keyboard event object
<span id="line11459" class="line"></span> * Returns string Navigation action name (e.g. 'panUp') or null if unmapped
<span id="line11460" class="line"></span> *
<span id="line11461" class="line"></span> * Handles:
<span id="line11462" class="line"></span> * - Arrow/WASD keys with Shift for zoom
<span id="line11463" class="line"></span> * - Arrow/WASD keys without Shift for panning
<span id="line11464" class="line"></span> * - Equal(=)/Minus(-) keys for zoom
<span id="line11465" class="line"></span> */
<span id="line11466" class="line"></span>function getActiveActionFromKey(code, shift) {
<span id="line11467" class="line"></span>    switch (code) {
<span id="line11468" class="line"></span>        case 'ArrowUp':
<span id="line11469" class="line"></span>        case 'KeyW':
<span id="line11470" class="line"></span>            return shift ? 'zoomIn' : 'panUp';
<span id="line11471" class="line"></span>        case 'ArrowDown':
<span id="line11472" class="line"></span>        case 'KeyS':
<span id="line11473" class="line"></span>            return shift ? 'zoomOut' : 'panDown';
<span id="line11474" class="line"></span>        case 'ArrowLeft':
<span id="line11475" class="line"></span>        case 'KeyA':
<span id="line11476" class="line"></span>            return 'panLeft';
<span id="line11477" class="line"></span>        case 'ArrowRight':
<span id="line11478" class="line"></span>        case 'KeyD':
<span id="line11479" class="line"></span>            return 'panRight';
<span id="line11480" class="line"></span>        case 'Equal':
<span id="line11481" class="line"></span>            return 'zoomIn';
<span id="line11482" class="line"></span>        case 'Minus':
<span id="line11483" class="line"></span>            return 'zoomOut';
<span id="line11484" class="line"></span>        default:
<span id="line11485" class="line"></span>            return null;
<span id="line11486" class="line"></span>    }
<span id="line11487" class="line"></span>}
<span id="line11488" class="line"></span>
<span id="line11489" class="line"></span>/**
<span id="line11490" class="line"></span> * Handles the keyup event on the viewer's canvas element.
<span id="line11491" class="line"></span> *
<span id="line11492" class="line"></span> * @private
<span id="line11493" class="line"></span> * For the released key, marks both the shifted and non-shifted navigation actions as inactive in the _activeActions object.
<span id="line11494" class="line"></span> * If either action is released before reaching the minimum frame threshold, sets that action as "virtually held" in _navActionVirtuallyHeld,
<span id="line11495" class="line"></span> * ensuring smooth completion of the minimum pan or zoom distance regardless of modifier key release order.
<span id="line11496" class="line"></span> */
<span id="line11497" class="line"></span>function onCanvasKeyUp(event) {
<span id="line11498" class="line"></span>
<span id="line11499" class="line"></span>    // Using arrow function to inherit 'this' from parent scope
<span id="line11500" class="line"></span>    const processCombo = (code, shift) =&gt; {
<span id="line11501" class="line"></span>        const action = getActiveActionFromKey(code, shift);
<span id="line11502" class="line"></span>
<span id="line11503" class="line"></span>        if (action &amp;&amp; this._activeActions[action]) {
<span id="line11504" class="line"></span>            this._activeActions[action] = false;
<span id="line11505" class="line"></span>            // If the action was released before the minimum frame threshold,
<span id="line11506" class="line"></span>            // keep it "virtually held" for smoothness
<span id="line11507" class="line"></span>            if (this._navActionFrames[action] &lt; this._minNavActionFrames) {
<span id="line11508" class="line"></span>                this._navActionVirtuallyHeld[action] = true;
<span id="line11509" class="line"></span>            }
<span id="line11510" class="line"></span>        }
<span id="line11511" class="line"></span>    };
<span id="line11512" class="line"></span>
<span id="line11513" class="line"></span>    // We don't know if the shift key was held down originally, so we check them both.
<span id="line11514" class="line"></span>    // Clear both possible actions for this key
<span id="line11515" class="line"></span>    const code = event.originalEvent.code;
<span id="line11516" class="line"></span>    processCombo(code, true);
<span id="line11517" class="line"></span>    processCombo(code, false);
<span id="line11518" class="line"></span>}
<span id="line11519" class="line"></span>
<span id="line11520" class="line"></span>
<span id="line11521" class="line"></span>function onCanvasKeyDown( event ) {
<span id="line11522" class="line"></span>
<span id="line11523" class="line"></span>    const canvasKeyDownEventArgs = {
<span id="line11524" class="line"></span>      originalEvent: event.originalEvent,
<span id="line11525" class="line"></span>      preventDefaultAction: !this.keyboardNavEnabled,
<span id="line11526" class="line"></span>      preventVerticalPan: event.preventVerticalPan || !this.panVertical,
<span id="line11527" class="line"></span>      preventHorizontalPan: event.preventHorizontalPan || !this.panHorizontal
<span id="line11528" class="line"></span>    };
<span id="line11529" class="line"></span>
<span id="line11530" class="line"></span>    /**
<span id="line11531" class="line"></span>     * Raised when a keyboard key is pressed and the focus is on the {@link OpenSeadragon.Viewer#canvas} element.
<span id="line11532" class="line"></span>     *
<span id="line11533" class="line"></span>     * @event canvas-key
<span id="line11534" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line11535" class="line"></span>     * @type {object}
<span id="line11536" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line11537" class="line"></span>     * @property {Object} originalEvent - The original DOM event.
<span id="line11538" class="line"></span>     * @property {Boolean} preventDefaultAction - Set to true to prevent default keyboard behaviour. Default: false.
<span id="line11539" class="line"></span>     * @property {Boolean} preventVerticalPan - Set to true to prevent keyboard vertical panning. Default: false.
<span id="line11540" class="line"></span>     * @property {Boolean} preventHorizontalPan - Set to true to prevent keyboard horizontal panning. Default: false.
<span id="line11541" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line11542" class="line"></span>     */
<span id="line11543" class="line"></span>
<span id="line11544" class="line"></span>    this.raiseEvent('canvas-key', canvasKeyDownEventArgs);
<span id="line11545" class="line"></span>
<span id="line11546" class="line"></span>    if ( !canvasKeyDownEventArgs.preventDefaultAction &amp;&amp; !event.ctrl &amp;&amp; !event.alt &amp;&amp; !event.meta ) {
<span id="line11547" class="line"></span>
<span id="line11548" class="line"></span>        const code = event.originalEvent.code;
<span id="line11549" class="line"></span>        const shift = event.shift;
<span id="line11550" class="line"></span>        const action = getActiveActionFromKey(code, shift);
<span id="line11551" class="line"></span>
<span id="line11552" class="line"></span>        if (action &amp;&amp; !this._activeActions[action]) {
<span id="line11553" class="line"></span>            this._activeActions[action] = true; // Mark this action as held down in the viewer's internal tracking object
<span id="line11554" class="line"></span>            this._navActionFrames[action] = 0; // Reset action frames
<span id="line11555" class="line"></span>            event.preventDefault = true; // prevent browser scroll/zoom, etc
<span id="line11556" class="line"></span>            return;
<span id="line11557" class="line"></span>        }
<span id="line11558" class="line"></span>
<span id="line11559" class="line"></span>        switch( event.keyCode ){
<span id="line11560" class="line"></span>            case 48://0|)
<span id="line11561" class="line"></span>                this.viewport.goHome();
<span id="line11562" class="line"></span>                this.viewport.applyConstraints();
<span id="line11563" class="line"></span>                event.preventDefault = true;
<span id="line11564" class="line"></span>                break;
<span id="line11565" class="line"></span>            case 82: //r - clockwise rotation/R - counterclockwise rotation
<span id="line11566" class="line"></span>                if(event.shift){
<span id="line11567" class="line"></span>                    if(this.viewport.flipped){
<span id="line11568" class="line"></span>                        this.viewport.setRotation(this.viewport.getRotation() + this.rotationIncrement);
<span id="line11569" class="line"></span>                    } else{
<span id="line11570" class="line"></span>                        this.viewport.setRotation(this.viewport.getRotation() - this.rotationIncrement);
<span id="line11571" class="line"></span>                    }
<span id="line11572" class="line"></span>                }else{
<span id="line11573" class="line"></span>                    if(this.viewport.flipped){
<span id="line11574" class="line"></span>                        this.viewport.setRotation(this.viewport.getRotation() - this.rotationIncrement);
<span id="line11575" class="line"></span>                    } else{
<span id="line11576" class="line"></span>                        this.viewport.setRotation(this.viewport.getRotation() + this.rotationIncrement);
<span id="line11577" class="line"></span>                    }
<span id="line11578" class="line"></span>                }
<span id="line11579" class="line"></span>                this.viewport.applyConstraints();
<span id="line11580" class="line"></span>                event.preventDefault = true;
<span id="line11581" class="line"></span>                break;
<span id="line11582" class="line"></span>            case 70: //f/F
<span id="line11583" class="line"></span>                this.viewport.toggleFlip();
<span id="line11584" class="line"></span>                event.preventDefault = true;
<span id="line11585" class="line"></span>                break;
<span id="line11586" class="line"></span>            case 74: //j - previous image source
<span id="line11587" class="line"></span>                this.goToPreviousPage();
<span id="line11588" class="line"></span>                break;
<span id="line11589" class="line"></span>            case 75: //k - next image source
<span id="line11590" class="line"></span>                this.goToNextPage();
<span id="line11591" class="line"></span>                break;
<span id="line11592" class="line"></span>            default:
<span id="line11593" class="line"></span>                //console.log( 'navigator keycode %s', event.keyCode );
<span id="line11594" class="line"></span>                event.preventDefault = false;
<span id="line11595" class="line"></span>                break;
<span id="line11596" class="line"></span>        }
<span id="line11597" class="line"></span>    } else {
<span id="line11598" class="line"></span>        event.preventDefault = false;
<span id="line11599" class="line"></span>    }
<span id="line11600" class="line"></span>}
<span id="line11601" class="line"></span>
<span id="line11602" class="line"></span>function onCanvasKeyPress( event ) {
<span id="line11603" class="line"></span>    const canvasKeyPressEventArgs = {
<span id="line11604" class="line"></span>      originalEvent: event.originalEvent,
<span id="line11605" class="line"></span>    };
<span id="line11606" class="line"></span>
<span id="line11607" class="line"></span>    /**
<span id="line11608" class="line"></span>     * Raised when a keyboard key is pressed and the focus is on the {@link OpenSeadragon.Viewer#canvas} element.
<span id="line11609" class="line"></span>     *
<span id="line11610" class="line"></span>     * @event canvas-key-press
<span id="line11611" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line11612" class="line"></span>     * @type {object}
<span id="line11613" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line11614" class="line"></span>     * @property {Object} originalEvent - The original DOM event.
<span id="line11615" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line11616" class="line"></span>     */
<span id="line11617" class="line"></span>
<span id="line11618" class="line"></span>    this.raiseEvent('canvas-key-press', canvasKeyPressEventArgs);
<span id="line11619" class="line"></span>}
<span id="line11620" class="line"></span>
<span id="line11621" class="line"></span>function onCanvasClick( event ) {
<span id="line11622" class="line"></span>    let gestureSettings;
<span id="line11623" class="line"></span>
<span id="line11624" class="line"></span>    const haveKeyboardFocus = document.activeElement === this.canvas;
<span id="line11625" class="line"></span>
<span id="line11626" class="line"></span>    // If we don't have keyboard focus, request it.
<span id="line11627" class="line"></span>    if ( !haveKeyboardFocus ) {
<span id="line11628" class="line"></span>        this.canvas.focus();
<span id="line11629" class="line"></span>    }
<span id="line11630" class="line"></span>    if(this.viewport.flipped){
<span id="line11631" class="line"></span>        event.position.x = this.viewport.getContainerSize().x - event.position.x;
<span id="line11632" class="line"></span>    }
<span id="line11633" class="line"></span>
<span id="line11634" class="line"></span>    const canvasClickEventArgs = {
<span id="line11635" class="line"></span>        tracker: event.eventSource,
<span id="line11636" class="line"></span>        position: event.position,
<span id="line11637" class="line"></span>        quick: event.quick,
<span id="line11638" class="line"></span>        shift: event.shift,
<span id="line11639" class="line"></span>        originalEvent: event.originalEvent,
<span id="line11640" class="line"></span>        originalTarget: event.originalTarget,
<span id="line11641" class="line"></span>        preventDefaultAction: false
<span id="line11642" class="line"></span>    };
<span id="line11643" class="line"></span>
<span id="line11644" class="line"></span>    /**
<span id="line11645" class="line"></span>     * Raised when a mouse press/release or touch/remove occurs on the {@link OpenSeadragon.Viewer#canvas} element.
<span id="line11646" class="line"></span>     *
<span id="line11647" class="line"></span>     * @event canvas-click
<span id="line11648" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line11649" class="line"></span>     * @type {object}
<span id="line11650" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line11651" class="line"></span>     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
<span id="line11652" class="line"></span>     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
<span id="line11653" class="line"></span>     * @property {Boolean} quick - True only if the clickDistThreshold and clickTimeThreshold are both passed. Useful for differentiating between clicks and drags.
<span id="line11654" class="line"></span>     * @property {Boolean} shift - True if the shift key was pressed during this event.
<span id="line11655" class="line"></span>     * @property {Object} originalEvent - The original DOM event.
<span id="line11656" class="line"></span>     * @property {Element} originalTarget - The DOM element clicked on.
<span id="line11657" class="line"></span>     * @property {Boolean} preventDefaultAction - Set to true to prevent default click to zoom behaviour. Default: false.
<span id="line11658" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line11659" class="line"></span>     */
<span id="line11660" class="line"></span>
<span id="line11661" class="line"></span>    this.raiseEvent( 'canvas-click', canvasClickEventArgs);
<span id="line11662" class="line"></span>
<span id="line11663" class="line"></span>
<span id="line11664" class="line"></span>    if ( !canvasClickEventArgs.preventDefaultAction &amp;&amp; this.viewport &amp;&amp; event.quick ) {
<span id="line11665" class="line"></span>        gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );
<span id="line11666" class="line"></span>
<span id="line11667" class="line"></span>        if (gestureSettings.clickToZoom === true){
<span id="line11668" class="line"></span>            this.viewport.zoomBy(
<span id="line11669" class="line"></span>                event.shift ? 1.0 / this.zoomPerClick : this.zoomPerClick,
<span id="line11670" class="line"></span>                gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel( event.position, true ) : null
<span id="line11671" class="line"></span>            );
<span id="line11672" class="line"></span>            this.viewport.applyConstraints();
<span id="line11673" class="line"></span>        }
<span id="line11674" class="line"></span>
<span id="line11675" class="line"></span>        if( gestureSettings.dblClickDragToZoom){
<span id="line11676" class="line"></span>            if(THIS[ this.hash ].draggingToZoom === true){
<span id="line11677" class="line"></span>                THIS[ this.hash ].lastClickTime = null;
<span id="line11678" class="line"></span>                THIS[ this.hash ].draggingToZoom = false;
<span id="line11679" class="line"></span>            }
<span id="line11680" class="line"></span>            else{
<span id="line11681" class="line"></span>                THIS[ this.hash ].lastClickTime = $.now();
<span id="line11682" class="line"></span>            }
<span id="line11683" class="line"></span>        }
<span id="line11684" class="line"></span>
<span id="line11685" class="line"></span>    }
<span id="line11686" class="line"></span>}
<span id="line11687" class="line"></span>
<span id="line11688" class="line"></span>function onCanvasDblClick( event ) {
<span id="line11689" class="line"></span>    let gestureSettings;
<span id="line11690" class="line"></span>
<span id="line11691" class="line"></span>    const canvasDblClickEventArgs = {
<span id="line11692" class="line"></span>        tracker: event.eventSource,
<span id="line11693" class="line"></span>        position: event.position,
<span id="line11694" class="line"></span>        shift: event.shift,
<span id="line11695" class="line"></span>        originalEvent: event.originalEvent,
<span id="line11696" class="line"></span>        preventDefaultAction: false
<span id="line11697" class="line"></span>    };
<span id="line11698" class="line"></span>
<span id="line11699" class="line"></span>    /**
<span id="line11700" class="line"></span>     * Raised when a double mouse press/release or touch/remove occurs on the {@link OpenSeadragon.Viewer#canvas} element.
<span id="line11701" class="line"></span>     *
<span id="line11702" class="line"></span>     * @event canvas-double-click
<span id="line11703" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line11704" class="line"></span>     * @type {object}
<span id="line11705" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line11706" class="line"></span>     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
<span id="line11707" class="line"></span>     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
<span id="line11708" class="line"></span>     * @property {Boolean} shift - True if the shift key was pressed during this event.
<span id="line11709" class="line"></span>     * @property {Object} originalEvent - The original DOM event.
<span id="line11710" class="line"></span>     * @property {Boolean} preventDefaultAction - Set to true to prevent default double tap to zoom behaviour. Default: false.
<span id="line11711" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line11712" class="line"></span>     */
<span id="line11713" class="line"></span>    this.raiseEvent( 'canvas-double-click', canvasDblClickEventArgs);
<span id="line11714" class="line"></span>
<span id="line11715" class="line"></span>    if ( !canvasDblClickEventArgs.preventDefaultAction &amp;&amp; this.viewport ) {
<span id="line11716" class="line"></span>        gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );
<span id="line11717" class="line"></span>        if ( gestureSettings.dblClickToZoom ) {
<span id="line11718" class="line"></span>            this.viewport.zoomBy(
<span id="line11719" class="line"></span>                event.shift ? 1.0 / this.zoomPerClick : this.zoomPerClick,
<span id="line11720" class="line"></span>                gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel( event.position, true ) : null
<span id="line11721" class="line"></span>            );
<span id="line11722" class="line"></span>            this.viewport.applyConstraints();
<span id="line11723" class="line"></span>        }
<span id="line11724" class="line"></span>    }
<span id="line11725" class="line"></span>}
<span id="line11726" class="line"></span>
<span id="line11727" class="line"></span>function onCanvasDrag( event ) {
<span id="line11728" class="line"></span>    let gestureSettings;
<span id="line11729" class="line"></span>
<span id="line11730" class="line"></span>    const canvasDragEventArgs = {
<span id="line11731" class="line"></span>        tracker: event.eventSource,
<span id="line11732" class="line"></span>        pointerType: event.pointerType,
<span id="line11733" class="line"></span>        position: event.position,
<span id="line11734" class="line"></span>        delta: event.delta,
<span id="line11735" class="line"></span>        speed: event.speed,
<span id="line11736" class="line"></span>        direction: event.direction,
<span id="line11737" class="line"></span>        shift: event.shift,
<span id="line11738" class="line"></span>        originalEvent: event.originalEvent,
<span id="line11739" class="line"></span>        preventDefaultAction: false
<span id="line11740" class="line"></span>    };
<span id="line11741" class="line"></span>
<span id="line11742" class="line"></span>    /**
<span id="line11743" class="line"></span>     * Raised when a mouse or touch drag operation occurs on the {@link OpenSeadragon.Viewer#canvas} element.
<span id="line11744" class="line"></span>     *
<span id="line11745" class="line"></span>     * @event canvas-drag
<span id="line11746" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line11747" class="line"></span>     * @type {object}
<span id="line11748" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line11749" class="line"></span>     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
<span id="line11750" class="line"></span>     * @property {String} pointerType - "mouse", "touch", "pen", etc.
<span id="line11751" class="line"></span>     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
<span id="line11752" class="line"></span>     * @property {OpenSeadragon.Point} delta - The x,y components of the difference between start drag and end drag.
<span id="line11753" class="line"></span>     * @property {Number} speed - Current computed speed, in pixels per second.
<span id="line11754" class="line"></span>     * @property {Number} direction - Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed &gt; 0.
<span id="line11755" class="line"></span>     * @property {Boolean} shift - True if the shift key was pressed during this event.
<span id="line11756" class="line"></span>     * @property {Object} originalEvent - The original DOM event.
<span id="line11757" class="line"></span>     * @property {Boolean} preventDefaultAction - Set to true to prevent default drag to pan behaviour. Default: false.
<span id="line11758" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line11759" class="line"></span>     */
<span id="line11760" class="line"></span>    this.raiseEvent( 'canvas-drag', canvasDragEventArgs);
<span id="line11761" class="line"></span>
<span id="line11762" class="line"></span>    gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );
<span id="line11763" class="line"></span>
<span id="line11764" class="line"></span>    if(!canvasDragEventArgs.preventDefaultAction &amp;&amp; this.viewport){
<span id="line11765" class="line"></span>
<span id="line11766" class="line"></span>        if (gestureSettings.dblClickDragToZoom &amp;&amp; THIS[ this.hash ].draggingToZoom){
<span id="line11767" class="line"></span>            const factor = Math.pow( this.zoomPerDblClickDrag, event.delta.y / 50);
<span id="line11768" class="line"></span>            this.viewport.zoomBy(factor);
<span id="line11769" class="line"></span>        }
<span id="line11770" class="line"></span>        else if (gestureSettings.dragToPan &amp;&amp; !THIS[ this.hash ].draggingToZoom) {
<span id="line11771" class="line"></span>            if( !this.panHorizontal ){
<span id="line11772" class="line"></span>                event.delta.x = 0;
<span id="line11773" class="line"></span>            }
<span id="line11774" class="line"></span>            if( !this.panVertical ){
<span id="line11775" class="line"></span>                event.delta.y = 0;
<span id="line11776" class="line"></span>            }
<span id="line11777" class="line"></span>            if(this.viewport.flipped){
<span id="line11778" class="line"></span>                event.delta.x = -event.delta.x;
<span id="line11779" class="line"></span>            }
<span id="line11780" class="line"></span>
<span id="line11781" class="line"></span>            if( this.constrainDuringPan ){
<span id="line11782" class="line"></span>                const delta = this.viewport.deltaPointsFromPixels( event.delta.negate() );
<span id="line11783" class="line"></span>
<span id="line11784" class="line"></span>                this.viewport.centerSpringX.target.value += delta.x;
<span id="line11785" class="line"></span>                this.viewport.centerSpringY.target.value += delta.y;
<span id="line11786" class="line"></span>
<span id="line11787" class="line"></span>                const constrainedBounds = this.viewport.getConstrainedBounds();
<span id="line11788" class="line"></span>
<span id="line11789" class="line"></span>                this.viewport.centerSpringX.target.value -= delta.x;
<span id="line11790" class="line"></span>                this.viewport.centerSpringY.target.value -= delta.y;
<span id="line11791" class="line"></span>
<span id="line11792" class="line"></span>                if (constrainedBounds.xConstrained) {
<span id="line11793" class="line"></span>                    event.delta.x = 0;
<span id="line11794" class="line"></span>                }
<span id="line11795" class="line"></span>
<span id="line11796" class="line"></span>                if (constrainedBounds.yConstrained) {
<span id="line11797" class="line"></span>                    event.delta.y = 0;
<span id="line11798" class="line"></span>                }
<span id="line11799" class="line"></span>            }
<span id="line11800" class="line"></span>            this.viewport.panBy( this.viewport.deltaPointsFromPixels( event.delta.negate() ), gestureSettings.flickEnabled &amp;&amp; !this.constrainDuringPan);
<span id="line11801" class="line"></span>        }
<span id="line11802" class="line"></span>
<span id="line11803" class="line"></span>    }
<span id="line11804" class="line"></span>
<span id="line11805" class="line"></span>}
<span id="line11806" class="line"></span>
<span id="line11807" class="line"></span>function onCanvasDragEnd( event ) {
<span id="line11808" class="line"></span>    let gestureSettings;
<span id="line11809" class="line"></span>    const canvasDragEndEventArgs = {
<span id="line11810" class="line"></span>        tracker: event.eventSource,
<span id="line11811" class="line"></span>        pointerType: event.pointerType,
<span id="line11812" class="line"></span>        position: event.position,
<span id="line11813" class="line"></span>        speed: event.speed,
<span id="line11814" class="line"></span>        direction: event.direction,
<span id="line11815" class="line"></span>        shift: event.shift,
<span id="line11816" class="line"></span>        originalEvent: event.originalEvent,
<span id="line11817" class="line"></span>        preventDefaultAction: false
<span id="line11818" class="line"></span>    };
<span id="line11819" class="line"></span>
<span id="line11820" class="line"></span>    /**
<span id="line11821" class="line"></span>     * Raised when a mouse or touch drag operation ends on the {@link OpenSeadragon.Viewer#canvas} element.
<span id="line11822" class="line"></span>     *
<span id="line11823" class="line"></span>     * @event canvas-drag-end
<span id="line11824" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line11825" class="line"></span>     * @type {object}
<span id="line11826" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line11827" class="line"></span>     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
<span id="line11828" class="line"></span>     * @property {String} pointerType - "mouse", "touch", "pen", etc.
<span id="line11829" class="line"></span>     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
<span id="line11830" class="line"></span>     * @property {Number} speed - Speed at the end of a drag gesture, in pixels per second.
<span id="line11831" class="line"></span>     * @property {Number} direction - Direction at the end of a drag gesture, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed &gt; 0.
<span id="line11832" class="line"></span>     * @property {Boolean} shift - True if the shift key was pressed during this event.
<span id="line11833" class="line"></span>     * @property {Object} originalEvent - The original DOM event.
<span id="line11834" class="line"></span>     * @property {Boolean} preventDefaultAction - Set to true to prevent default drag-end flick behaviour. Default: false.
<span id="line11835" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line11836" class="line"></span>     */
<span id="line11837" class="line"></span>     this.raiseEvent('canvas-drag-end', canvasDragEndEventArgs);
<span id="line11838" class="line"></span>
<span id="line11839" class="line"></span>    gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );
<span id="line11840" class="line"></span>
<span id="line11841" class="line"></span>    if (!canvasDragEndEventArgs.preventDefaultAction &amp;&amp; this.viewport) {
<span id="line11842" class="line"></span>        if ( !THIS[ this.hash ].draggingToZoom &amp;&amp;
<span id="line11843" class="line"></span>            gestureSettings.dragToPan &amp;&amp;
<span id="line11844" class="line"></span>            gestureSettings.flickEnabled &amp;&amp;
<span id="line11845" class="line"></span>            event.speed &gt;= gestureSettings.flickMinSpeed) {
<span id="line11846" class="line"></span>            let amplitudeX = 0;
<span id="line11847" class="line"></span>            if (this.panHorizontal) {
<span id="line11848" class="line"></span>                amplitudeX = gestureSettings.flickMomentum * event.speed *
<span id="line11849" class="line"></span>                    Math.cos(event.direction);
<span id="line11850" class="line"></span>            }
<span id="line11851" class="line"></span>            let amplitudeY = 0;
<span id="line11852" class="line"></span>            if (this.panVertical) {
<span id="line11853" class="line"></span>                amplitudeY = gestureSettings.flickMomentum * event.speed *
<span id="line11854" class="line"></span>                    Math.sin(event.direction);
<span id="line11855" class="line"></span>            }
<span id="line11856" class="line"></span>            const center = this.viewport.pixelFromPoint(
<span id="line11857" class="line"></span>                this.viewport.getCenter(true));
<span id="line11858" class="line"></span>            const target = this.viewport.pointFromPixel(
<span id="line11859" class="line"></span>                new $.Point(center.x - amplitudeX, center.y - amplitudeY));
<span id="line11860" class="line"></span>            this.viewport.panTo(target, false);
<span id="line11861" class="line"></span>        }
<span id="line11862" class="line"></span>        this.viewport.applyConstraints();
<span id="line11863" class="line"></span>    }
<span id="line11864" class="line"></span>
<span id="line11865" class="line"></span>
<span id="line11866" class="line"></span>    if( gestureSettings.dblClickDragToZoom &amp;&amp; THIS[ this.hash ].draggingToZoom === true ){
<span id="line11867" class="line"></span>        THIS[ this.hash ].draggingToZoom = false;
<span id="line11868" class="line"></span>    }
<span id="line11869" class="line"></span>
<span id="line11870" class="line"></span>
<span id="line11871" class="line"></span>}
<span id="line11872" class="line"></span>
<span id="line11873" class="line"></span>function onCanvasEnter( event ) {
<span id="line11874" class="line"></span>    /**
<span id="line11875" class="line"></span>     * Raised when a pointer enters the {@link OpenSeadragon.Viewer#canvas} element.
<span id="line11876" class="line"></span>     *
<span id="line11877" class="line"></span>     * @event canvas-enter
<span id="line11878" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line11879" class="line"></span>     * @type {object}
<span id="line11880" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line11881" class="line"></span>     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
<span id="line11882" class="line"></span>     * @property {String} pointerType - "mouse", "touch", "pen", etc.
<span id="line11883" class="line"></span>     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
<span id="line11884" class="line"></span>     * @property {Number} buttons - Current buttons pressed. A combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
<span id="line11885" class="line"></span>     * @property {Number} pointers - Number of pointers (all types) active in the tracked element.
<span id="line11886" class="line"></span>     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.
<span id="line11887" class="line"></span>     * @property {Boolean} buttonDownAny - Was the button down anywhere in the screen during the event. &lt;span style="color:red;"&gt;Deprecated. Use buttons instead.&lt;/span&gt;
<span id="line11888" class="line"></span>     * @property {Object} originalEvent - The original DOM event.
<span id="line11889" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line11890" class="line"></span>     */
<span id="line11891" class="line"></span>    this.raiseEvent( 'canvas-enter', {
<span id="line11892" class="line"></span>        tracker: event.eventSource,
<span id="line11893" class="line"></span>        pointerType: event.pointerType,
<span id="line11894" class="line"></span>        position: event.position,
<span id="line11895" class="line"></span>        buttons: event.buttons,
<span id="line11896" class="line"></span>        pointers: event.pointers,
<span id="line11897" class="line"></span>        insideElementPressed: event.insideElementPressed,
<span id="line11898" class="line"></span>        buttonDownAny: event.buttonDownAny,
<span id="line11899" class="line"></span>        originalEvent: event.originalEvent
<span id="line11900" class="line"></span>    });
<span id="line11901" class="line"></span>}
<span id="line11902" class="line"></span>
<span id="line11903" class="line"></span>function onCanvasLeave( event ) {
<span id="line11904" class="line"></span>    /**
<span id="line11905" class="line"></span>     * Raised when a pointer leaves the {@link OpenSeadragon.Viewer#canvas} element.
<span id="line11906" class="line"></span>     *
<span id="line11907" class="line"></span>     * @event canvas-exit
<span id="line11908" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line11909" class="line"></span>     * @type {object}
<span id="line11910" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line11911" class="line"></span>     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
<span id="line11912" class="line"></span>     * @property {String} pointerType - "mouse", "touch", "pen", etc.
<span id="line11913" class="line"></span>     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
<span id="line11914" class="line"></span>     * @property {Number} buttons - Current buttons pressed. A combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
<span id="line11915" class="line"></span>     * @property {Number} pointers - Number of pointers (all types) active in the tracked element.
<span id="line11916" class="line"></span>     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.
<span id="line11917" class="line"></span>     * @property {Boolean} buttonDownAny - Was the button down anywhere in the screen during the event. &lt;span style="color:red;"&gt;Deprecated. Use buttons instead.&lt;/span&gt;
<span id="line11918" class="line"></span>     * @property {Object} originalEvent - The original DOM event.
<span id="line11919" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line11920" class="line"></span>     */
<span id="line11921" class="line"></span>    this.raiseEvent( 'canvas-exit', {
<span id="line11922" class="line"></span>        tracker: event.eventSource,
<span id="line11923" class="line"></span>        pointerType: event.pointerType,
<span id="line11924" class="line"></span>        position: event.position,
<span id="line11925" class="line"></span>        buttons: event.buttons,
<span id="line11926" class="line"></span>        pointers: event.pointers,
<span id="line11927" class="line"></span>        insideElementPressed: event.insideElementPressed,
<span id="line11928" class="line"></span>        buttonDownAny: event.buttonDownAny,
<span id="line11929" class="line"></span>        originalEvent: event.originalEvent
<span id="line11930" class="line"></span>    });
<span id="line11931" class="line"></span>}
<span id="line11932" class="line"></span>
<span id="line11933" class="line"></span>function onCanvasPress( event ) {
<span id="line11934" class="line"></span>
<span id="line11935" class="line"></span>    /**
<span id="line11936" class="line"></span>     * Raised when the primary mouse button is pressed or touch starts on the {@link OpenSeadragon.Viewer#canvas} element.
<span id="line11937" class="line"></span>     *
<span id="line11938" class="line"></span>     * @event canvas-press
<span id="line11939" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line11940" class="line"></span>     * @type {object}
<span id="line11941" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line11942" class="line"></span>     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
<span id="line11943" class="line"></span>     * @property {String} pointerType - "mouse", "touch", "pen", etc.
<span id="line11944" class="line"></span>     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
<span id="line11945" class="line"></span>     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.
<span id="line11946" class="line"></span>     * @property {Boolean} insideElementReleased - True if the cursor still inside the tracked element when the button was released.
<span id="line11947" class="line"></span>     * @property {Object} originalEvent - The original DOM event.
<span id="line11948" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line11949" class="line"></span>     */
<span id="line11950" class="line"></span>    this.raiseEvent( 'canvas-press', {
<span id="line11951" class="line"></span>        tracker: event.eventSource,
<span id="line11952" class="line"></span>        pointerType: event.pointerType,
<span id="line11953" class="line"></span>        position: event.position,
<span id="line11954" class="line"></span>        insideElementPressed: event.insideElementPressed,
<span id="line11955" class="line"></span>        insideElementReleased: event.insideElementReleased,
<span id="line11956" class="line"></span>        originalEvent: event.originalEvent
<span id="line11957" class="line"></span>    });
<span id="line11958" class="line"></span>
<span id="line11959" class="line"></span>
<span id="line11960" class="line"></span>    const gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );
<span id="line11961" class="line"></span>    if ( gestureSettings.dblClickDragToZoom ){
<span id="line11962" class="line"></span>         const lastClickTime = THIS[ this.hash ].lastClickTime;
<span id="line11963" class="line"></span>         const currClickTime = $.now();
<span id="line11964" class="line"></span>
<span id="line11965" class="line"></span>        if ( lastClickTime === null) {
<span id="line11966" class="line"></span>            return;
<span id="line11967" class="line"></span>        }
<span id="line11968" class="line"></span>
<span id="line11969" class="line"></span>        if ((currClickTime - lastClickTime) &lt; this.dblClickTimeThreshold) {
<span id="line11970" class="line"></span>            THIS[ this.hash ].draggingToZoom = true;
<span id="line11971" class="line"></span>        }
<span id="line11972" class="line"></span>
<span id="line11973" class="line"></span>        THIS[ this.hash ].lastClickTime = null;
<span id="line11974" class="line"></span>    }
<span id="line11975" class="line"></span>
<span id="line11976" class="line"></span>}
<span id="line11977" class="line"></span>
<span id="line11978" class="line"></span>function onCanvasRelease( event ) {
<span id="line11979" class="line"></span>    /**
<span id="line11980" class="line"></span>     * Raised when the primary mouse button is released or touch ends on the {@link OpenSeadragon.Viewer#canvas} element.
<span id="line11981" class="line"></span>     *
<span id="line11982" class="line"></span>     * @event canvas-release
<span id="line11983" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line11984" class="line"></span>     * @type {object}
<span id="line11985" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line11986" class="line"></span>     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
<span id="line11987" class="line"></span>     * @property {String} pointerType - "mouse", "touch", "pen", etc.
<span id="line11988" class="line"></span>     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
<span id="line11989" class="line"></span>     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.
<span id="line11990" class="line"></span>     * @property {Boolean} insideElementReleased - True if the cursor still inside the tracked element when the button was released.
<span id="line11991" class="line"></span>     * @property {Object} originalEvent - The original DOM event.
<span id="line11992" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line11993" class="line"></span>     */
<span id="line11994" class="line"></span>    this.raiseEvent( 'canvas-release', {
<span id="line11995" class="line"></span>        tracker: event.eventSource,
<span id="line11996" class="line"></span>        pointerType: event.pointerType,
<span id="line11997" class="line"></span>        position: event.position,
<span id="line11998" class="line"></span>        insideElementPressed: event.insideElementPressed,
<span id="line11999" class="line"></span>        insideElementReleased: event.insideElementReleased,
<span id="line12000" class="line"></span>        originalEvent: event.originalEvent
<span id="line12001" class="line"></span>    });
<span id="line12002" class="line"></span>}
<span id="line12003" class="line"></span>
<span id="line12004" class="line"></span>function onCanvasNonPrimaryPress( event ) {
<span id="line12005" class="line"></span>    /**
<span id="line12006" class="line"></span>     * Raised when any non-primary pointer button is pressed on the {@link OpenSeadragon.Viewer#canvas} element.
<span id="line12007" class="line"></span>     *
<span id="line12008" class="line"></span>     * @event canvas-nonprimary-press
<span id="line12009" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line12010" class="line"></span>     * @type {object}
<span id="line12011" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line12012" class="line"></span>     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
<span id="line12013" class="line"></span>     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
<span id="line12014" class="line"></span>     * @property {String} pointerType - "mouse", "touch", "pen", etc.
<span id="line12015" class="line"></span>     * @property {Number} button - Button which caused the event.
<span id="line12016" class="line"></span>     *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
<span id="line12017" class="line"></span>     * @property {Number} buttons - Current buttons pressed.
<span id="line12018" class="line"></span>     *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
<span id="line12019" class="line"></span>     * @property {Object} originalEvent - The original DOM event.
<span id="line12020" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line12021" class="line"></span>     */
<span id="line12022" class="line"></span>    this.raiseEvent( 'canvas-nonprimary-press', {
<span id="line12023" class="line"></span>        tracker: event.eventSource,
<span id="line12024" class="line"></span>        position: event.position,
<span id="line12025" class="line"></span>        pointerType: event.pointerType,
<span id="line12026" class="line"></span>        button: event.button,
<span id="line12027" class="line"></span>        buttons: event.buttons,
<span id="line12028" class="line"></span>        originalEvent: event.originalEvent
<span id="line12029" class="line"></span>    });
<span id="line12030" class="line"></span>}
<span id="line12031" class="line"></span>
<span id="line12032" class="line"></span>function onCanvasNonPrimaryRelease( event ) {
<span id="line12033" class="line"></span>    /**
<span id="line12034" class="line"></span>     * Raised when any non-primary pointer button is released on the {@link OpenSeadragon.Viewer#canvas} element.
<span id="line12035" class="line"></span>     *
<span id="line12036" class="line"></span>     * @event canvas-nonprimary-release
<span id="line12037" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line12038" class="line"></span>     * @type {object}
<span id="line12039" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line12040" class="line"></span>     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
<span id="line12041" class="line"></span>     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
<span id="line12042" class="line"></span>     * @property {String} pointerType - "mouse", "touch", "pen", etc.
<span id="line12043" class="line"></span>     * @property {Number} button - Button which caused the event.
<span id="line12044" class="line"></span>     *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
<span id="line12045" class="line"></span>     * @property {Number} buttons - Current buttons pressed.
<span id="line12046" class="line"></span>     *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
<span id="line12047" class="line"></span>     * @property {Object} originalEvent - The original DOM event.
<span id="line12048" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line12049" class="line"></span>     */
<span id="line12050" class="line"></span>    this.raiseEvent( 'canvas-nonprimary-release', {
<span id="line12051" class="line"></span>        tracker: event.eventSource,
<span id="line12052" class="line"></span>        position: event.position,
<span id="line12053" class="line"></span>        pointerType: event.pointerType,
<span id="line12054" class="line"></span>        button: event.button,
<span id="line12055" class="line"></span>        buttons: event.buttons,
<span id="line12056" class="line"></span>        originalEvent: event.originalEvent
<span id="line12057" class="line"></span>    });
<span id="line12058" class="line"></span>}
<span id="line12059" class="line"></span>
<span id="line12060" class="line"></span>function onCanvasPinch( event ) {
<span id="line12061" class="line"></span>    let centerPt;
<span id="line12062" class="line"></span>    let lastCenterPt;
<span id="line12063" class="line"></span>    let panByPt;
<span id="line12064" class="line"></span>
<span id="line12065" class="line"></span>    const canvasPinchEventArgs = {
<span id="line12066" class="line"></span>        tracker: event.eventSource,
<span id="line12067" class="line"></span>        pointerType: event.pointerType,
<span id="line12068" class="line"></span>        gesturePoints: event.gesturePoints,
<span id="line12069" class="line"></span>        lastCenter: event.lastCenter,
<span id="line12070" class="line"></span>        center: event.center,
<span id="line12071" class="line"></span>        lastDistance: event.lastDistance,
<span id="line12072" class="line"></span>        distance: event.distance,
<span id="line12073" class="line"></span>        shift: event.shift,
<span id="line12074" class="line"></span>        originalEvent: event.originalEvent,
<span id="line12075" class="line"></span>        preventDefaultPanAction: false,
<span id="line12076" class="line"></span>        preventDefaultZoomAction: false,
<span id="line12077" class="line"></span>        preventDefaultRotateAction: false
<span id="line12078" class="line"></span>    };
<span id="line12079" class="line"></span>
<span id="line12080" class="line"></span>    /**
<span id="line12081" class="line"></span>     * Raised when a pinch event occurs on the {@link OpenSeadragon.Viewer#canvas} element.
<span id="line12082" class="line"></span>     *
<span id="line12083" class="line"></span>     * @event canvas-pinch
<span id="line12084" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line12085" class="line"></span>     * @type {object}
<span id="line12086" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line12087" class="line"></span>     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
<span id="line12088" class="line"></span>     * @property {String} pointerType - "mouse", "touch", "pen", etc.
<span id="line12089" class="line"></span>     * @property {Array.&lt;OpenSeadragon.MouseTracker.GesturePoint&gt;} gesturePoints - Gesture points associated with the gesture. Velocity data can be found here.
<span id="line12090" class="line"></span>     * @property {OpenSeadragon.Point} lastCenter - The previous center point of the two pinch contact points relative to the tracked element.
<span id="line12091" class="line"></span>     * @property {OpenSeadragon.Point} center - The center point of the two pinch contact points relative to the tracked element.
<span id="line12092" class="line"></span>     * @property {Number} lastDistance - The previous distance between the two pinch contact points in CSS pixels.
<span id="line12093" class="line"></span>     * @property {Number} distance - The distance between the two pinch contact points in CSS pixels.
<span id="line12094" class="line"></span>     * @property {Boolean} shift - True if the shift key was pressed during this event.
<span id="line12095" class="line"></span>     * @property {Object} originalEvent - The original DOM event.
<span id="line12096" class="line"></span>     * @property {Boolean} preventDefaultPanAction - Set to true to prevent default pinch to pan behaviour. Default: false.
<span id="line12097" class="line"></span>     * @property {Boolean} preventDefaultZoomAction - Set to true to prevent default pinch to zoom behaviour. Default: false.
<span id="line12098" class="line"></span>     * @property {Boolean} preventDefaultRotateAction - Set to true to prevent default pinch to rotate behaviour. Default: false.
<span id="line12099" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line12100" class="line"></span>     */
<span id="line12101" class="line"></span>     this.raiseEvent('canvas-pinch', canvasPinchEventArgs);
<span id="line12102" class="line"></span>
<span id="line12103" class="line"></span>    if ( this.viewport ) {
<span id="line12104" class="line"></span>        let gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );
<span id="line12105" class="line"></span>        if ( gestureSettings.pinchToZoom &amp;&amp;
<span id="line12106" class="line"></span>                    (!canvasPinchEventArgs.preventDefaultPanAction || !canvasPinchEventArgs.preventDefaultZoomAction) ) {
<span id="line12107" class="line"></span>            centerPt = this.viewport.pointFromPixel( event.center, true );
<span id="line12108" class="line"></span>            if ( gestureSettings.zoomToRefPoint &amp;&amp; !canvasPinchEventArgs.preventDefaultPanAction ) {
<span id="line12109" class="line"></span>                lastCenterPt = this.viewport.pointFromPixel( event.lastCenter, true );
<span id="line12110" class="line"></span>                panByPt = lastCenterPt.minus( centerPt );
<span id="line12111" class="line"></span>                if( !this.panHorizontal ) {
<span id="line12112" class="line"></span>                    panByPt.x = 0;
<span id="line12113" class="line"></span>                }
<span id="line12114" class="line"></span>                if( !this.panVertical ) {
<span id="line12115" class="line"></span>                    panByPt.y = 0;
<span id="line12116" class="line"></span>                }
<span id="line12117" class="line"></span>                this.viewport.panBy(panByPt, true);
<span id="line12118" class="line"></span>            }
<span id="line12119" class="line"></span>            if ( !canvasPinchEventArgs.preventDefaultZoomAction ) {
<span id="line12120" class="line"></span>                this.viewport.zoomBy( event.distance / event.lastDistance, centerPt, true );
<span id="line12121" class="line"></span>            }
<span id="line12122" class="line"></span>            this.viewport.applyConstraints();
<span id="line12123" class="line"></span>        }
<span id="line12124" class="line"></span>        if ( gestureSettings.pinchRotate &amp;&amp; !canvasPinchEventArgs.preventDefaultRotateAction ) {
<span id="line12125" class="line"></span>            // Pinch rotate
<span id="line12126" class="line"></span>            const angle1 = Math.atan2(event.gesturePoints[0].currentPos.y - event.gesturePoints[1].currentPos.y,
<span id="line12127" class="line"></span>                event.gesturePoints[0].currentPos.x - event.gesturePoints[1].currentPos.x);
<span id="line12128" class="line"></span>            const angle2 = Math.atan2(event.gesturePoints[0].lastPos.y - event.gesturePoints[1].lastPos.y,
<span id="line12129" class="line"></span>                event.gesturePoints[0].lastPos.x - event.gesturePoints[1].lastPos.x);
<span id="line12130" class="line"></span>            centerPt = this.viewport.pointFromPixel( event.center, true );
<span id="line12131" class="line"></span>            this.viewport.rotateTo(this.viewport.getRotation(true) + ((angle1 - angle2) * (180 / Math.PI)), centerPt, true);
<span id="line12132" class="line"></span>        }
<span id="line12133" class="line"></span>    }
<span id="line12134" class="line"></span>}
<span id="line12135" class="line"></span>
<span id="line12136" class="line"></span>function onCanvasFocus( event ) {
<span id="line12137" class="line"></span>
<span id="line12138" class="line"></span>    /**
<span id="line12139" class="line"></span>     * Raised when the {@link OpenSeadragon.Viewer#canvas} element gets keyboard focus.
<span id="line12140" class="line"></span>     *
<span id="line12141" class="line"></span>     * @event canvas-focus
<span id="line12142" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line12143" class="line"></span>     * @type {object}
<span id="line12144" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line12145" class="line"></span>     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
<span id="line12146" class="line"></span>     * @property {Object} originalEvent - The original DOM event.
<span id="line12147" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line12148" class="line"></span>     */
<span id="line12149" class="line"></span>    this.raiseEvent( 'canvas-focus', {
<span id="line12150" class="line"></span>        tracker: event.eventSource,
<span id="line12151" class="line"></span>        originalEvent: event.originalEvent
<span id="line12152" class="line"></span>    });
<span id="line12153" class="line"></span>}
<span id="line12154" class="line"></span>
<span id="line12155" class="line"></span>function onCanvasBlur( event ) {
<span id="line12156" class="line"></span>
<span id="line12157" class="line"></span>    // When canvas loses focus, clear all navigation key states.
<span id="line12158" class="line"></span>    for (const action in this._activeActions) {
<span id="line12159" class="line"></span>        this._activeActions[action] = false;
<span id="line12160" class="line"></span>    }
<span id="line12161" class="line"></span>    for (const action in this._navActionVirtuallyHeld) {
<span id="line12162" class="line"></span>        this._navActionVirtuallyHeld[action] = false;
<span id="line12163" class="line"></span>    }
<span id="line12164" class="line"></span>
<span id="line12165" class="line"></span>    /**
<span id="line12166" class="line"></span>     * Raised when the {@link OpenSeadragon.Viewer#canvas} element loses keyboard focus.
<span id="line12167" class="line"></span>     *
<span id="line12168" class="line"></span>     * @event canvas-blur
<span id="line12169" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line12170" class="line"></span>     * @type {object}
<span id="line12171" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line12172" class="line"></span>     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
<span id="line12173" class="line"></span>     * @property {Object} originalEvent - The original DOM event.
<span id="line12174" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line12175" class="line"></span>     */
<span id="line12176" class="line"></span>    this.raiseEvent( 'canvas-blur', {
<span id="line12177" class="line"></span>        tracker: event.eventSource,
<span id="line12178" class="line"></span>        originalEvent: event.originalEvent
<span id="line12179" class="line"></span>    });
<span id="line12180" class="line"></span>}
<span id="line12181" class="line"></span>
<span id="line12182" class="line"></span>function onCanvasScroll( event ) {
<span id="line12183" class="line"></span>    let canvasScrollEventArgs;
<span id="line12184" class="line"></span>    let gestureSettings;
<span id="line12185" class="line"></span>    let factor;
<span id="line12186" class="line"></span>
<span id="line12187" class="line"></span>    /* Certain scroll devices fire the scroll event way too fast so we are injecting a simple adjustment to keep things
<span id="line12188" class="line"></span>     * partially normalized. If we have already fired an event within the last 'minScrollDelta' milliseconds we skip
<span id="line12189" class="line"></span>     * this one and wait for the next event. */
<span id="line12190" class="line"></span>    const thisScrollTime = $.now();
<span id="line12191" class="line"></span>    const deltaScrollTime = thisScrollTime - this._lastScrollTime;
<span id="line12192" class="line"></span>    if (deltaScrollTime &gt; this.minScrollDeltaTime) {
<span id="line12193" class="line"></span>        this._lastScrollTime = thisScrollTime;
<span id="line12194" class="line"></span>
<span id="line12195" class="line"></span>        canvasScrollEventArgs = {
<span id="line12196" class="line"></span>            tracker: event.eventSource,
<span id="line12197" class="line"></span>            position: event.position,
<span id="line12198" class="line"></span>            scroll: event.scroll,
<span id="line12199" class="line"></span>            shift: event.shift,
<span id="line12200" class="line"></span>            originalEvent: event.originalEvent,
<span id="line12201" class="line"></span>            preventDefaultAction: false,
<span id="line12202" class="line"></span>            preventDefault: true
<span id="line12203" class="line"></span>        };
<span id="line12204" class="line"></span>
<span id="line12205" class="line"></span>        /**
<span id="line12206" class="line"></span>         * Raised when a scroll event occurs on the {@link OpenSeadragon.Viewer#canvas} element (mouse wheel).
<span id="line12207" class="line"></span>         *
<span id="line12208" class="line"></span>         * @event canvas-scroll
<span id="line12209" class="line"></span>         * @memberof OpenSeadragon.Viewer
<span id="line12210" class="line"></span>         * @type {object}
<span id="line12211" class="line"></span>         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line12212" class="line"></span>         * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
<span id="line12213" class="line"></span>         * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
<span id="line12214" class="line"></span>         * @property {Number} scroll - The scroll delta for the event.
<span id="line12215" class="line"></span>         * @property {Boolean} shift - True if the shift key was pressed during this event.
<span id="line12216" class="line"></span>         * @property {Object} originalEvent - The original DOM event.
<span id="line12217" class="line"></span>         * @property {Boolean} preventDefaultAction - Set to true to prevent default scroll to zoom behaviour. Default: false.
<span id="line12218" class="line"></span>         * @property {Boolean} preventDefault - Set to true to prevent the default user-agent's handling of the wheel event. Default: true.
<span id="line12219" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line12220" class="line"></span>         */
<span id="line12221" class="line"></span>         this.raiseEvent('canvas-scroll', canvasScrollEventArgs );
<span id="line12222" class="line"></span>
<span id="line12223" class="line"></span>        if ( !canvasScrollEventArgs.preventDefaultAction &amp;&amp; this.viewport ) {
<span id="line12224" class="line"></span>            if(this.viewport.flipped){
<span id="line12225" class="line"></span>                event.position.x = this.viewport.getContainerSize().x - event.position.x;
<span id="line12226" class="line"></span>            }
<span id="line12227" class="line"></span>
<span id="line12228" class="line"></span>            gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );
<span id="line12229" class="line"></span>            if ( gestureSettings.scrollToZoom ) {
<span id="line12230" class="line"></span>                factor = Math.pow( this.zoomPerScroll, event.scroll );
<span id="line12231" class="line"></span>                this.viewport.zoomBy(
<span id="line12232" class="line"></span>                    factor,
<span id="line12233" class="line"></span>                    gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel( event.position, true ) : null
<span id="line12234" class="line"></span>                );
<span id="line12235" class="line"></span>                this.viewport.applyConstraints();
<span id="line12236" class="line"></span>            }
<span id="line12237" class="line"></span>        }
<span id="line12238" class="line"></span>
<span id="line12239" class="line"></span>        event.preventDefault = canvasScrollEventArgs.preventDefault;
<span id="line12240" class="line"></span>    } else {
<span id="line12241" class="line"></span>        event.preventDefault = true;
<span id="line12242" class="line"></span>    }
<span id="line12243" class="line"></span>}
<span id="line12244" class="line"></span>
<span id="line12245" class="line"></span>function onContainerEnter( event ) {
<span id="line12246" class="line"></span>    THIS[ this.hash ].mouseInside = true;
<span id="line12247" class="line"></span>    abortControlsAutoHide( this );
<span id="line12248" class="line"></span>    /**
<span id="line12249" class="line"></span>     * Raised when the cursor enters the {@link OpenSeadragon.Viewer#container} element.
<span id="line12250" class="line"></span>     *
<span id="line12251" class="line"></span>     * @event container-enter
<span id="line12252" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line12253" class="line"></span>     * @type {object}
<span id="line12254" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line12255" class="line"></span>     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
<span id="line12256" class="line"></span>     * @property {String} pointerType - "mouse", "touch", "pen", etc.
<span id="line12257" class="line"></span>     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
<span id="line12258" class="line"></span>     * @property {Number} buttons - Current buttons pressed. A combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
<span id="line12259" class="line"></span>     * @property {Number} pointers - Number of pointers (all types) active in the tracked element.
<span id="line12260" class="line"></span>     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.
<span id="line12261" class="line"></span>     * @property {Boolean} buttonDownAny - Was the button down anywhere in the screen during the event. &lt;span style="color:red;"&gt;Deprecated. Use buttons instead.&lt;/span&gt;
<span id="line12262" class="line"></span>     * @property {Object} originalEvent - The original DOM event.
<span id="line12263" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line12264" class="line"></span>     */
<span id="line12265" class="line"></span>    this.raiseEvent( 'container-enter', {
<span id="line12266" class="line"></span>        tracker: event.eventSource,
<span id="line12267" class="line"></span>        pointerType: event.pointerType,
<span id="line12268" class="line"></span>        position: event.position,
<span id="line12269" class="line"></span>        buttons: event.buttons,
<span id="line12270" class="line"></span>        pointers: event.pointers,
<span id="line12271" class="line"></span>        insideElementPressed: event.insideElementPressed,
<span id="line12272" class="line"></span>        buttonDownAny: event.buttonDownAny,
<span id="line12273" class="line"></span>        originalEvent: event.originalEvent
<span id="line12274" class="line"></span>    });
<span id="line12275" class="line"></span>}
<span id="line12276" class="line"></span>
<span id="line12277" class="line"></span>function onContainerLeave( event ) {
<span id="line12278" class="line"></span>    if ( event.pointers &lt; 1 ) {
<span id="line12279" class="line"></span>        THIS[ this.hash ].mouseInside = false;
<span id="line12280" class="line"></span>        if ( !THIS[ this.hash ].animating ) {
<span id="line12281" class="line"></span>            beginControlsAutoHide( this );
<span id="line12282" class="line"></span>        }
<span id="line12283" class="line"></span>    }
<span id="line12284" class="line"></span>    /**
<span id="line12285" class="line"></span>     * Raised when the cursor leaves the {@link OpenSeadragon.Viewer#container} element.
<span id="line12286" class="line"></span>     *
<span id="line12287" class="line"></span>     * @event container-exit
<span id="line12288" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line12289" class="line"></span>     * @type {object}
<span id="line12290" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line12291" class="line"></span>     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
<span id="line12292" class="line"></span>     * @property {String} pointerType - "mouse", "touch", "pen", etc.
<span id="line12293" class="line"></span>     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
<span id="line12294" class="line"></span>     * @property {Number} buttons - Current buttons pressed. A combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
<span id="line12295" class="line"></span>     * @property {Number} pointers - Number of pointers (all types) active in the tracked element.
<span id="line12296" class="line"></span>     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.
<span id="line12297" class="line"></span>     * @property {Boolean} buttonDownAny - Was the button down anywhere in the screen during the event. &lt;span style="color:red;"&gt;Deprecated. Use buttons instead.&lt;/span&gt;
<span id="line12298" class="line"></span>     * @property {Object} originalEvent - The original DOM event.
<span id="line12299" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line12300" class="line"></span>     */
<span id="line12301" class="line"></span>    this.raiseEvent( 'container-exit', {
<span id="line12302" class="line"></span>        tracker: event.eventSource,
<span id="line12303" class="line"></span>        pointerType: event.pointerType,
<span id="line12304" class="line"></span>        position: event.position,
<span id="line12305" class="line"></span>        buttons: event.buttons,
<span id="line12306" class="line"></span>        pointers: event.pointers,
<span id="line12307" class="line"></span>        insideElementPressed: event.insideElementPressed,
<span id="line12308" class="line"></span>        buttonDownAny: event.buttonDownAny,
<span id="line12309" class="line"></span>        originalEvent: event.originalEvent
<span id="line12310" class="line"></span>    });
<span id="line12311" class="line"></span>}
<span id="line12312" class="line"></span>
<span id="line12313" class="line"></span>
<span id="line12314" class="line"></span>///////////////////////////////////////////////////////////////////////////////
<span id="line12315" class="line"></span>// Page update routines ( aka Views - for future reference )
<span id="line12316" class="line"></span>///////////////////////////////////////////////////////////////////////////////
<span id="line12317" class="line"></span>
<span id="line12318" class="line"></span>function updateMulti( viewer ) {
<span id="line12319" class="line"></span>    updateOnce( viewer );
<span id="line12320" class="line"></span>
<span id="line12321" class="line"></span>    // Request the next frame, unless we've been closed
<span id="line12322" class="line"></span>    if ( viewer.isOpen() ) {
<span id="line12323" class="line"></span>        viewer._updateRequestId = scheduleUpdate( viewer, updateMulti );
<span id="line12324" class="line"></span>    } else {
<span id="line12325" class="line"></span>        viewer._updateRequestId = false;
<span id="line12326" class="line"></span>    }
<span id="line12327" class="line"></span>}
<span id="line12328" class="line"></span>
<span id="line12329" class="line"></span>function doViewerResize(viewer, containerSize){
<span id="line12330" class="line"></span>    const viewport = viewer.viewport;
<span id="line12331" class="line"></span>    const zoom = viewport.getZoom();
<span id="line12332" class="line"></span>    const center = viewport.getCenter();
<span id="line12333" class="line"></span>    viewport.resize(containerSize, viewer.preserveImageSizeOnResize);
<span id="line12334" class="line"></span>    viewport.panTo(center, true);
<span id="line12335" class="line"></span>    let resizeRatio;
<span id="line12336" class="line"></span>    if (viewer.preserveImageSizeOnResize) {
<span id="line12337" class="line"></span>        resizeRatio = THIS[viewer.hash].prevContainerSize.x / containerSize.x;
<span id="line12338" class="line"></span>    } else {
<span id="line12339" class="line"></span>        const origin = new $.Point(0, 0);
<span id="line12340" class="line"></span>        const prevDiag = new $.Point(THIS[viewer.hash].prevContainerSize.x, THIS[viewer.hash].prevContainerSize.y).distanceTo(origin);
<span id="line12341" class="line"></span>        const newDiag = new $.Point(containerSize.x, containerSize.y).distanceTo(origin);
<span id="line12342" class="line"></span>        resizeRatio = newDiag / prevDiag * THIS[viewer.hash].prevContainerSize.x / containerSize.x;
<span id="line12343" class="line"></span>    }
<span id="line12344" class="line"></span>    viewport.zoomTo(zoom * resizeRatio, null, true);
<span id="line12345" class="line"></span>    THIS[viewer.hash].prevContainerSize = containerSize;
<span id="line12346" class="line"></span>    THIS[viewer.hash].forceRedraw = true;
<span id="line12347" class="line"></span>    THIS[viewer.hash].needsResize = false;
<span id="line12348" class="line"></span>    THIS[viewer.hash].forceResize = false;
<span id="line12349" class="line"></span>}
<span id="line12350" class="line"></span>
<span id="line12351" class="line"></span>function handleNavKeys(viewer) {
<span id="line12352" class="line"></span>    // Iterate over all navigation actions.
<span id="line12353" class="line"></span>    for (const action in viewer._activeActions) {
<span id="line12354" class="line"></span>        if (viewer._activeActions[action] || viewer._navActionVirtuallyHeld[action]) {
<span id="line12355" class="line"></span>            viewer._navActionFrames[action]++;
<span id="line12356" class="line"></span>            if (viewer._navActionFrames[action] &gt;= viewer._minNavActionFrames) {
<span id="line12357" class="line"></span>                viewer._navActionVirtuallyHeld[action] = false;
<span id="line12358" class="line"></span>            }
<span id="line12359" class="line"></span>        }
<span id="line12360" class="line"></span>    }
<span id="line12361" class="line"></span>
<span id="line12362" class="line"></span>    // Helper for action state
<span id="line12363" class="line"></span>    function isDown(action) {
<span id="line12364" class="line"></span>        return viewer._activeActions[action] || viewer._navActionVirtuallyHeld[action];
<span id="line12365" class="line"></span>    }
<span id="line12366" class="line"></span>
<span id="line12367" class="line"></span>    // Use the viewer's configured pan amount
<span id="line12368" class="line"></span>    const pixels = viewer.pixelsPerArrowPress / 10;
<span id="line12369" class="line"></span>    const panDelta = viewer.viewport.deltaPointsFromPixels(new OpenSeadragon.Point(pixels, pixels));
<span id="line12370" class="line"></span>
<span id="line12371" class="line"></span>    // 1. Zoom actions (priority: zoom disables pan)
<span id="line12372" class="line"></span>    if (isDown('zoomIn')) {
<span id="line12373" class="line"></span>        viewer.viewport.zoomBy(1.01, null, true);
<span id="line12374" class="line"></span>        viewer.viewport.applyConstraints();
<span id="line12375" class="line"></span>        return;
<span id="line12376" class="line"></span>    }
<span id="line12377" class="line"></span>    if (isDown('zoomOut')) {
<span id="line12378" class="line"></span>        viewer.viewport.zoomBy(0.99, null, true);
<span id="line12379" class="line"></span>        viewer.viewport.applyConstraints();
<span id="line12380" class="line"></span>        return;
<span id="line12381" class="line"></span>    }
<span id="line12382" class="line"></span>
<span id="line12383" class="line"></span>    // 2. Pan actions
<span id="line12384" class="line"></span>    let dx = 0;
<span id="line12385" class="line"></span>    let dy = 0;
<span id="line12386" class="line"></span>
<span id="line12387" class="line"></span>    if (!viewer.preventVerticalPan) {
<span id="line12388" class="line"></span>        if (isDown('panUp')) {
<span id="line12389" class="line"></span>            dy -= panDelta.y;
<span id="line12390" class="line"></span>        }
<span id="line12391" class="line"></span>        if (isDown('panDown')) {
<span id="line12392" class="line"></span>            dy += panDelta.y;
<span id="line12393" class="line"></span>        }
<span id="line12394" class="line"></span>    }
<span id="line12395" class="line"></span>
<span id="line12396" class="line"></span>    if (!viewer.preventHorizontalPan) {
<span id="line12397" class="line"></span>        if (isDown('panLeft')) {
<span id="line12398" class="line"></span>            dx -= panDelta.x;
<span id="line12399" class="line"></span>        }
<span id="line12400" class="line"></span>        if (isDown('panRight')) {
<span id="line12401" class="line"></span>            dx += panDelta.x;
<span id="line12402" class="line"></span>        }
<span id="line12403" class="line"></span>    }
<span id="line12404" class="line"></span>
<span id="line12405" class="line"></span>    if (dx !== 0 || dy !== 0) {
<span id="line12406" class="line"></span>        viewer.viewport.panBy(new OpenSeadragon.Point(dx, dy), true);
<span id="line12407" class="line"></span>        viewer.viewport.applyConstraints();
<span id="line12408" class="line"></span>    }
<span id="line12409" class="line"></span>}
<span id="line12410" class="line"></span>
<span id="line12411" class="line"></span>function updateOnce( viewer ) {
<span id="line12412" class="line"></span>
<span id="line12413" class="line"></span>    handleNavKeys(viewer);
<span id="line12414" class="line"></span>
<span id="line12415" class="line"></span>    //viewer.profiler.beginUpdate();
<span id="line12416" class="line"></span>
<span id="line12417" class="line"></span>    if (viewer._opening || !THIS[viewer.hash]) {
<span id="line12418" class="line"></span>        return;
<span id="line12419" class="line"></span>    }
<span id="line12420" class="line"></span>
<span id="line12421" class="line"></span>    let viewerWasResized = false;
<span id="line12422" class="line"></span>    if (viewer.autoResize || THIS[viewer.hash].forceResize){
<span id="line12423" class="line"></span>        let containerSize;
<span id="line12424" class="line"></span>        if(viewer._autoResizePolling){
<span id="line12425" class="line"></span>            containerSize = _getSafeElemSize(viewer.container);
<span id="line12426" class="line"></span>            const prevContainerSize = THIS[viewer.hash].prevContainerSize;
<span id="line12427" class="line"></span>            if (!containerSize.equals(prevContainerSize)) {
<span id="line12428" class="line"></span>                THIS[viewer.hash].needsResize = true;
<span id="line12429" class="line"></span>            }
<span id="line12430" class="line"></span>        }
<span id="line12431" class="line"></span>        if(THIS[viewer.hash].needsResize){
<span id="line12432" class="line"></span>            doViewerResize(viewer, containerSize || _getSafeElemSize(viewer.container));
<span id="line12433" class="line"></span>            viewerWasResized = true;
<span id="line12434" class="line"></span>        }
<span id="line12435" class="line"></span>
<span id="line12436" class="line"></span>    }
<span id="line12437" class="line"></span>
<span id="line12438" class="line"></span>
<span id="line12439" class="line"></span>
<span id="line12440" class="line"></span>    const viewportChange = viewer.viewport.update() || viewerWasResized;
<span id="line12441" class="line"></span>    let animated = viewer.world.update(viewportChange) || viewportChange;
<span id="line12442" class="line"></span>
<span id="line12443" class="line"></span>    if (viewportChange) {
<span id="line12444" class="line"></span>        /**
<span id="line12445" class="line"></span>         * Raised when any spring animation update occurs (zoom, pan, etc.),
<span id="line12446" class="line"></span>         * before the viewer has drawn the new location.
<span id="line12447" class="line"></span>         *
<span id="line12448" class="line"></span>         * @event viewport-change
<span id="line12449" class="line"></span>         * @memberof OpenSeadragon.Viewer
<span id="line12450" class="line"></span>         * @type {object}
<span id="line12451" class="line"></span>         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line12452" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line12453" class="line"></span>         */
<span id="line12454" class="line"></span>        viewer.raiseEvent('viewport-change');
<span id="line12455" class="line"></span>    }
<span id="line12456" class="line"></span>
<span id="line12457" class="line"></span>    if( viewer.referenceStrip ){
<span id="line12458" class="line"></span>        animated = viewer.referenceStrip.update( viewer.viewport ) || animated;
<span id="line12459" class="line"></span>    }
<span id="line12460" class="line"></span>
<span id="line12461" class="line"></span>    const currentAnimating = THIS[ viewer.hash ].animating;
<span id="line12462" class="line"></span>
<span id="line12463" class="line"></span>    if ( !currentAnimating &amp;&amp; animated ) {
<span id="line12464" class="line"></span>        /**
<span id="line12465" class="line"></span>         * Raised when any spring animation starts (zoom, pan, etc.).
<span id="line12466" class="line"></span>         *
<span id="line12467" class="line"></span>         * @event animation-start
<span id="line12468" class="line"></span>         * @memberof OpenSeadragon.Viewer
<span id="line12469" class="line"></span>         * @type {object}
<span id="line12470" class="line"></span>         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line12471" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line12472" class="line"></span>         */
<span id="line12473" class="line"></span>        viewer.raiseEvent( "animation-start" );
<span id="line12474" class="line"></span>        abortControlsAutoHide( viewer );
<span id="line12475" class="line"></span>    }
<span id="line12476" class="line"></span>
<span id="line12477" class="line"></span>    const isAnimationFinished = currentAnimating &amp;&amp; !animated;
<span id="line12478" class="line"></span>
<span id="line12479" class="line"></span>    if ( isAnimationFinished ) {
<span id="line12480" class="line"></span>        THIS[ viewer.hash ].animating = false;
<span id="line12481" class="line"></span>    }
<span id="line12482" class="line"></span>
<span id="line12483" class="line"></span>    if ( animated || isAnimationFinished || THIS[ viewer.hash ].forceRedraw || viewer.world.needsDraw() ) {
<span id="line12484" class="line"></span>        drawWorld( viewer );
<span id="line12485" class="line"></span>        viewer._drawOverlays();
<span id="line12486" class="line"></span>        if( viewer.navigator ){
<span id="line12487" class="line"></span>          viewer.navigator.update( viewer.viewport );
<span id="line12488" class="line"></span>        }
<span id="line12489" class="line"></span>
<span id="line12490" class="line"></span>        THIS[ viewer.hash ].forceRedraw = false;
<span id="line12491" class="line"></span>
<span id="line12492" class="line"></span>        if (animated) {
<span id="line12493" class="line"></span>            /**
<span id="line12494" class="line"></span>             * Raised when any spring animation update occurs (zoom, pan, etc.),
<span id="line12495" class="line"></span>             * after the viewer has drawn the new location.
<span id="line12496" class="line"></span>             *
<span id="line12497" class="line"></span>             * @event animation
<span id="line12498" class="line"></span>             * @memberof OpenSeadragon.Viewer
<span id="line12499" class="line"></span>             * @type {object}
<span id="line12500" class="line"></span>             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line12501" class="line"></span>             * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line12502" class="line"></span>             */
<span id="line12503" class="line"></span>            viewer.raiseEvent( "animation" );
<span id="line12504" class="line"></span>        }
<span id="line12505" class="line"></span>    }
<span id="line12506" class="line"></span>
<span id="line12507" class="line"></span>    if ( isAnimationFinished ) {
<span id="line12508" class="line"></span>        /**
<span id="line12509" class="line"></span>         * Raised when any spring animation ends (zoom, pan, etc.).
<span id="line12510" class="line"></span>         *
<span id="line12511" class="line"></span>         * @event animation-finish
<span id="line12512" class="line"></span>         * @memberof OpenSeadragon.Viewer
<span id="line12513" class="line"></span>         * @type {object}
<span id="line12514" class="line"></span>         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line12515" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line12516" class="line"></span>         */
<span id="line12517" class="line"></span>        viewer.raiseEvent( "animation-finish" );
<span id="line12518" class="line"></span>
<span id="line12519" class="line"></span>        if ( !THIS[ viewer.hash ].mouseInside ) {
<span id="line12520" class="line"></span>            beginControlsAutoHide( viewer );
<span id="line12521" class="line"></span>        }
<span id="line12522" class="line"></span>    }
<span id="line12523" class="line"></span>
<span id="line12524" class="line"></span>    THIS[ viewer.hash ].animating = animated;
<span id="line12525" class="line"></span>
<span id="line12526" class="line"></span>    //viewer.profiler.endUpdate();
<span id="line12527" class="line"></span>}
<span id="line12528" class="line"></span>
<span id="line12529" class="line"></span>function drawWorld( viewer ) {
<span id="line12530" class="line"></span>    viewer.imageLoader.clear();
<span id="line12531" class="line"></span>    viewer.world.draw();
<span id="line12532" class="line"></span>
<span id="line12533" class="line"></span>    /**
<span id="line12534" class="line"></span>     * &lt;em&gt;- Needs documentation -&lt;/em&gt;
<span id="line12535" class="line"></span>     *
<span id="line12536" class="line"></span>     * @event update-viewport
<span id="line12537" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line12538" class="line"></span>     * @type {object}
<span id="line12539" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line12540" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line12541" class="line"></span>     */
<span id="line12542" class="line"></span>    viewer.raiseEvent( 'update-viewport', {} );
<span id="line12543" class="line"></span>}
<span id="line12544" class="line"></span>
<span id="line12545" class="line"></span>///////////////////////////////////////////////////////////////////////////////
<span id="line12546" class="line"></span>// Navigation Controls
<span id="line12547" class="line"></span>///////////////////////////////////////////////////////////////////////////////
<span id="line12548" class="line"></span>function resolveUrl( prefix, url ) {
<span id="line12549" class="line"></span>    return prefix ? prefix + url : url;
<span id="line12550" class="line"></span>}
<span id="line12551" class="line"></span>
<span id="line12552" class="line"></span>
<span id="line12553" class="line"></span>function scheduleZoom( viewer ) {
<span id="line12554" class="line"></span>    $.requestAnimationFrame( $.delegate( viewer, doZoom ) );
<span id="line12555" class="line"></span>}
<span id="line12556" class="line"></span>
<span id="line12557" class="line"></span>
<span id="line12558" class="line"></span>function doZoom() {
<span id="line12559" class="line"></span>    if ( THIS[ this.hash ].zooming &amp;&amp; this.viewport) {
<span id="line12560" class="line"></span>        const currentTime     = $.now();
<span id="line12561" class="line"></span>        const deltaTime       = currentTime - THIS[ this.hash ].lastZoomTime;
<span id="line12562" class="line"></span>        const adjustedFactor  = Math.pow( THIS[ this.hash ].zoomFactor, deltaTime / 1000 );
<span id="line12563" class="line"></span>
<span id="line12564" class="line"></span>        this.viewport.zoomBy( adjustedFactor );
<span id="line12565" class="line"></span>        this.viewport.applyConstraints();
<span id="line12566" class="line"></span>        THIS[ this.hash ].lastZoomTime = currentTime;
<span id="line12567" class="line"></span>        scheduleZoom( this );
<span id="line12568" class="line"></span>    }
<span id="line12569" class="line"></span>}
<span id="line12570" class="line"></span>
<span id="line12571" class="line"></span>
<span id="line12572" class="line"></span>function lightUp() {
<span id="line12573" class="line"></span>    if (this.buttonGroup) {
<span id="line12574" class="line"></span>        this.buttonGroup.emulateEnter();
<span id="line12575" class="line"></span>        this.buttonGroup.emulateLeave();
<span id="line12576" class="line"></span>    }
<span id="line12577" class="line"></span>}
<span id="line12578" class="line"></span>
<span id="line12579" class="line"></span>
<span id="line12580" class="line"></span>function onHome() {
<span id="line12581" class="line"></span>    if ( this.viewport ) {
<span id="line12582" class="line"></span>        this.viewport.goHome();
<span id="line12583" class="line"></span>    }
<span id="line12584" class="line"></span>}
<span id="line12585" class="line"></span>
<span id="line12586" class="line"></span>
<span id="line12587" class="line"></span>function onFullScreen() {
<span id="line12588" class="line"></span>    if ( this.isFullPage() &amp;&amp; !$.isFullScreen() ) {
<span id="line12589" class="line"></span>        // Is fullPage but not fullScreen
<span id="line12590" class="line"></span>        this.setFullPage( false );
<span id="line12591" class="line"></span>    } else {
<span id="line12592" class="line"></span>        this.setFullScreen( !this.isFullPage() );
<span id="line12593" class="line"></span>    }
<span id="line12594" class="line"></span>    // correct for no mouseout event on change
<span id="line12595" class="line"></span>    if ( this.buttonGroup ) {
<span id="line12596" class="line"></span>        this.buttonGroup.emulateLeave();
<span id="line12597" class="line"></span>    }
<span id="line12598" class="line"></span>    this.fullPageButton.element.focus();
<span id="line12599" class="line"></span>    if ( this.viewport ) {
<span id="line12600" class="line"></span>        this.viewport.applyConstraints();
<span id="line12601" class="line"></span>    }
<span id="line12602" class="line"></span>}
<span id="line12603" class="line"></span>
<span id="line12604" class="line"></span>function onRotateLeft() {
<span id="line12605" class="line"></span>    if ( this.viewport ) {
<span id="line12606" class="line"></span>        let currRotation = this.viewport.getRotation();
<span id="line12607" class="line"></span>
<span id="line12608" class="line"></span>        if ( this.viewport.flipped ){
<span id="line12609" class="line"></span>          currRotation += this.rotationIncrement;
<span id="line12610" class="line"></span>        } else {
<span id="line12611" class="line"></span>          currRotation -= this.rotationIncrement;
<span id="line12612" class="line"></span>        }
<span id="line12613" class="line"></span>        this.viewport.setRotation(currRotation);
<span id="line12614" class="line"></span>    }
<span id="line12615" class="line"></span>}
<span id="line12616" class="line"></span>
<span id="line12617" class="line"></span>function onRotateRight() {
<span id="line12618" class="line"></span>    if ( this.viewport ) {
<span id="line12619" class="line"></span>        let currRotation = this.viewport.getRotation();
<span id="line12620" class="line"></span>
<span id="line12621" class="line"></span>        if ( this.viewport.flipped ){
<span id="line12622" class="line"></span>          currRotation -= this.rotationIncrement;
<span id="line12623" class="line"></span>        } else {
<span id="line12624" class="line"></span>          currRotation += this.rotationIncrement;
<span id="line12625" class="line"></span>        }
<span id="line12626" class="line"></span>        this.viewport.setRotation(currRotation);
<span id="line12627" class="line"></span>    }
<span id="line12628" class="line"></span>}
<span id="line12629" class="line"></span>/**
<span id="line12630" class="line"></span> * Note: When pressed flip control button
<span id="line12631" class="line"></span> */
<span id="line12632" class="line"></span>function onFlip() {
<span id="line12633" class="line"></span>   this.viewport.toggleFlip();
<span id="line12634" class="line"></span>}
<span id="line12635" class="line"></span>
<span id="line12636" class="line"></span>/**
<span id="line12637" class="line"></span> * Return the drawer type string for a candidate (string or DrawerBase constructor).
<span id="line12638" class="line"></span> * Used to normalize drawerCandidates to strings so includes('canvas') is reliable.
<span id="line12639" class="line"></span> * @private
<span id="line12640" class="line"></span> * @param {string|Function} candidate - Drawer type string or constructor
<span id="line12641" class="line"></span> * @returns {string|undefined} Type string, or undefined if not resolvable
<span id="line12642" class="line"></span> */
<span id="line12643" class="line"></span>function getDrawerTypeString(candidate) {
<span id="line12644" class="line"></span>    if (typeof candidate === 'string') {
<span id="line12645" class="line"></span>        return candidate;
<span id="line12646" class="line"></span>    }
<span id="line12647" class="line"></span>    const proto = candidate &amp;&amp; candidate.prototype;
<span id="line12648" class="line"></span>    if (proto &amp;&amp; proto instanceof OpenSeadragon.DrawerBase &amp;&amp; $.isFunction(proto.getType)) {
<span id="line12649" class="line"></span>        return proto.getType.call(candidate);
<span id="line12650" class="line"></span>    }
<span id="line12651" class="line"></span>    return undefined;
<span id="line12652" class="line"></span>}
<span id="line12653" class="line"></span>
<span id="line12654" class="line"></span>/**
<span id="line12655" class="line"></span> * Return the list of drawer type strings that 'auto' expands to (platform-dependent).
<span id="line12656" class="line"></span> * Uses the same detection as determineDrawer('auto'): on iOS-like devices, ['canvas'] only;
<span id="line12657" class="line"></span> * on all other platforms, ['webgl', 'canvas'] so webgl is tried first and canvas next if WebGL fails.
<span id="line12658" class="line"></span> * @private
<span id="line12659" class="line"></span> * @returns {string[]}
<span id="line12660" class="line"></span> */
<span id="line12661" class="line"></span>function getAutoDrawerCandidates() {
<span id="line12662" class="line"></span>    // Our WebGL drawer is not as performant on iOS at the moment, so we use canvas there.
<span id="line12663" class="line"></span>    // Note that modern iPads report themselves as Mac, so we also check for coarse pointer.
<span id="line12664" class="line"></span>    const isPrimaryTouch = window.matchMedia('(pointer: coarse)').matches;
<span id="line12665" class="line"></span>    const isIOSDevice = /iPad|iPhone|iPod|Mac/.test(navigator.userAgent) &amp;&amp; isPrimaryTouch;
<span id="line12666" class="line"></span>    return isIOSDevice ? ['canvas'] : ['webgl', 'canvas'];
<span id="line12667" class="line"></span>}
<span id="line12668" class="line"></span>
<span id="line12669" class="line"></span>/**
<span id="line12670" class="line"></span> * Find drawer
<span id="line12671" class="line"></span> */
<span id="line12672" class="line"></span>$.determineDrawer = function( id ){
<span id="line12673" class="line"></span>    if (id === 'auto') {
<span id="line12674" class="line"></span>        // Same platform detection as getAutoDrawerCandidates(); first entry is the preferred drawer type.
<span id="line12675" class="line"></span>        id = getAutoDrawerCandidates()[0];
<span id="line12676" class="line"></span>    }
<span id="line12677" class="line"></span>
<span id="line12678" class="line"></span>    for (const property in OpenSeadragon) {
<span id="line12679" class="line"></span>        const drawer = OpenSeadragon[ property ];
<span id="line12680" class="line"></span>        const proto = drawer.prototype;
<span id="line12681" class="line"></span>        if( proto &amp;&amp;
<span id="line12682" class="line"></span>            proto instanceof OpenSeadragon.DrawerBase &amp;&amp;
<span id="line12683" class="line"></span>            $.isFunction( proto.getType ) &amp;&amp;
<span id="line12684" class="line"></span>            proto.getType.call( drawer ) === id
<span id="line12685" class="line"></span>        ){
<span id="line12686" class="line"></span>            return drawer;
<span id="line12687" class="line"></span>        }
<span id="line12688" class="line"></span>    }
<span id="line12689" class="line"></span>    return null;
<span id="line12690" class="line"></span>};
<span id="line12691" class="line"></span>
<span id="line12692" class="line"></span>}( OpenSeadragon ));
<span id="line12693" class="line"></span>
<span id="line12694" class="line"></span>/*
<span id="line12695" class="line"></span> * OpenSeadragon - Navigator
<span id="line12696" class="line"></span> *
<span id="line12697" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line12698" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line12699" class="line"></span> *
<span id="line12700" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line12701" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line12702" class="line"></span> * met:
<span id="line12703" class="line"></span> *
<span id="line12704" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line12705" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line12706" class="line"></span> *
<span id="line12707" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line12708" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line12709" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line12710" class="line"></span> *
<span id="line12711" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line12712" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line12713" class="line"></span> *   this software without specific prior written permission.
<span id="line12714" class="line"></span> *
<span id="line12715" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line12716" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line12717" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line12718" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line12719" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line12720" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line12721" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line12722" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line12723" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line12724" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line12725" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line12726" class="line"></span> */
<span id="line12727" class="line"></span>
<span id="line12728" class="line"></span>(function( $ ){
<span id="line12729" class="line"></span>
<span id="line12730" class="line"></span>/**
<span id="line12731" class="line"></span> * @class Navigator
<span id="line12732" class="line"></span> * @classdesc The Navigator provides a small view of the current image as fixed
<span id="line12733" class="line"></span> * while representing the viewport as a moving box serving as a frame
<span id="line12734" class="line"></span> * of reference in the larger viewport as to which portion of the image
<span id="line12735" class="line"></span> * is currently being examined.  The navigator's viewport can be interacted
<span id="line12736" class="line"></span> * with using the keyboard or the mouse.
<span id="line12737" class="line"></span> *
<span id="line12738" class="line"></span> * @memberof OpenSeadragon
<span id="line12739" class="line"></span> * @extends OpenSeadragon.Viewer
<span id="line12740" class="line"></span> * @extends OpenSeadragon.EventSource
<span id="line12741" class="line"></span> * @param {Object} options - Navigator options
<span id="line12742" class="line"></span> * @param {Element} [options.element] - An element to use for the navigator.
<span id="line12743" class="line"></span> * @param {String} [options.id] - Id of the element to use for the navigator. However, this is ignored if {@link options.element} is provided.
<span id="line12744" class="line"></span> */
<span id="line12745" class="line"></span>$.Navigator = function( options ){
<span id="line12746" class="line"></span>
<span id="line12747" class="line"></span>    const viewer = options.viewer;
<span id="line12748" class="line"></span>    const _this = this;
<span id="line12749" class="line"></span>    let viewerSize;
<span id="line12750" class="line"></span>    let navigatorSize;
<span id="line12751" class="line"></span>
<span id="line12752" class="line"></span>    //We may need to create a new element and id if they did not
<span id="line12753" class="line"></span>    //provide the id for the existing element or the element itself
<span id="line12754" class="line"></span>    if( options.element || options.id ){
<span id="line12755" class="line"></span>        if ( options.element ) {
<span id="line12756" class="line"></span>            if ( options.id ){
<span id="line12757" class="line"></span>                $.console.warn("Given option.id for Navigator was ignored since option.element was provided and is being used instead.");
<span id="line12758" class="line"></span>            }
<span id="line12759" class="line"></span>
<span id="line12760" class="line"></span>            // Don't overwrite the element's id if it has one already
<span id="line12761" class="line"></span>            if ( options.element.id ) {
<span id="line12762" class="line"></span>                options.id = options.element.id;
<span id="line12763" class="line"></span>            } else {
<span id="line12764" class="line"></span>                options.id = 'navigator-' + $.now();
<span id="line12765" class="line"></span>            }
<span id="line12766" class="line"></span>
<span id="line12767" class="line"></span>            this.element = options.element;
<span id="line12768" class="line"></span>        } else {
<span id="line12769" class="line"></span>            this.element = document.getElementById( options.id );
<span id="line12770" class="line"></span>        }
<span id="line12771" class="line"></span>
<span id="line12772" class="line"></span>        options.controlOptions  = {
<span id="line12773" class="line"></span>            anchor:           $.ControlAnchor.NONE,
<span id="line12774" class="line"></span>            attachToViewer:   false,
<span id="line12775" class="line"></span>            autoFade:         false
<span id="line12776" class="line"></span>        };
<span id="line12777" class="line"></span>    } else {
<span id="line12778" class="line"></span>        options.id              = 'navigator-' + $.now();
<span id="line12779" class="line"></span>        this.element            = $.makeNeutralElement( "div" );
<span id="line12780" class="line"></span>        options.controlOptions  = {
<span id="line12781" class="line"></span>            anchor:           $.ControlAnchor.TOP_RIGHT,
<span id="line12782" class="line"></span>            attachToViewer:   true,
<span id="line12783" class="line"></span>            autoFade:         options.autoFade
<span id="line12784" class="line"></span>        };
<span id="line12785" class="line"></span>
<span id="line12786" class="line"></span>        if( options.position ){
<span id="line12787" class="line"></span>            if( 'BOTTOM_RIGHT' === options.position ){
<span id="line12788" class="line"></span>               options.controlOptions.anchor = $.ControlAnchor.BOTTOM_RIGHT;
<span id="line12789" class="line"></span>            } else if( 'BOTTOM_LEFT' === options.position ){
<span id="line12790" class="line"></span>               options.controlOptions.anchor = $.ControlAnchor.BOTTOM_LEFT;
<span id="line12791" class="line"></span>            } else if( 'TOP_RIGHT' === options.position ){
<span id="line12792" class="line"></span>               options.controlOptions.anchor = $.ControlAnchor.TOP_RIGHT;
<span id="line12793" class="line"></span>            } else if( 'TOP_LEFT' === options.position ){
<span id="line12794" class="line"></span>               options.controlOptions.anchor = $.ControlAnchor.TOP_LEFT;
<span id="line12795" class="line"></span>            } else if( 'ABSOLUTE' === options.position ){
<span id="line12796" class="line"></span>               options.controlOptions.anchor = $.ControlAnchor.ABSOLUTE;
<span id="line12797" class="line"></span>               options.controlOptions.top = options.top;
<span id="line12798" class="line"></span>               options.controlOptions.left = options.left;
<span id="line12799" class="line"></span>               options.controlOptions.height = options.height;
<span id="line12800" class="line"></span>               options.controlOptions.width = options.width;
<span id="line12801" class="line"></span>            }
<span id="line12802" class="line"></span>        }
<span id="line12803" class="line"></span>    }
<span id="line12804" class="line"></span>    this.element.id         = options.id;
<span id="line12805" class="line"></span>    this.element.className  += ' navigator';
<span id="line12806" class="line"></span>
<span id="line12807" class="line"></span>    options = $.extend( true, {
<span id="line12808" class="line"></span>        sizeRatio:     $.DEFAULT_SETTINGS.navigatorSizeRatio
<span id="line12809" class="line"></span>    }, options, {
<span id="line12810" class="line"></span>        element:                this.element,
<span id="line12811" class="line"></span>        tabIndex:               -1, // No keyboard navigation, omit from tab order
<span id="line12812" class="line"></span>        //These need to be overridden to prevent recursion since
<span id="line12813" class="line"></span>        //the navigator is a viewer and a viewer has a navigator
<span id="line12814" class="line"></span>        showNavigator:          false,
<span id="line12815" class="line"></span>        mouseNavEnabled:        false,
<span id="line12816" class="line"></span>        showNavigationControl:  false,
<span id="line12817" class="line"></span>        showSequenceControl:    false,
<span id="line12818" class="line"></span>        immediateRender:        true,
<span id="line12819" class="line"></span>        blendTime:              0,
<span id="line12820" class="line"></span>        animationTime:          options.animationTime,
<span id="line12821" class="line"></span>        // disable autoResize since resize behavior is implemented differently by the navigator
<span id="line12822" class="line"></span>        autoResize:             false,
<span id="line12823" class="line"></span>        // prevent resizing the navigator from adding unwanted space around the image
<span id="line12824" class="line"></span>        minZoomImageRatio:      1.0,
<span id="line12825" class="line"></span>        background:             options.background,
<span id="line12826" class="line"></span>        opacity:                options.opacity,
<span id="line12827" class="line"></span>        borderColor:            options.borderColor,
<span id="line12828" class="line"></span>        displayRegionColor:     options.displayRegionColor
<span id="line12829" class="line"></span>    });
<span id="line12830" class="line"></span>
<span id="line12831" class="line"></span>    options.minPixelRatio = this.minPixelRatio = viewer.minPixelRatio;
<span id="line12832" class="line"></span>
<span id="line12833" class="line"></span>    $.setElementTouchActionNone( this.element );
<span id="line12834" class="line"></span>
<span id="line12835" class="line"></span>    this.borderWidth = 2;
<span id="line12836" class="line"></span>    //At some browser magnification levels the display regions lines up correctly, but at some there appears to
<span id="line12837" class="line"></span>    //be a one pixel gap.
<span id="line12838" class="line"></span>    this.fudge = new $.Point(1, 1);
<span id="line12839" class="line"></span>    this.totalBorderWidths = new $.Point(this.borderWidth * 2, this.borderWidth * 2).minus(this.fudge);
<span id="line12840" class="line"></span>
<span id="line12841" class="line"></span>
<span id="line12842" class="line"></span>    if ( options.controlOptions.anchor !== $.ControlAnchor.NONE ) {
<span id="line12843" class="line"></span>        (function( style, borderWidth ){
<span id="line12844" class="line"></span>            style.margin        = '0px';
<span id="line12845" class="line"></span>            style.border        = borderWidth + 'px solid ' + options.borderColor;
<span id="line12846" class="line"></span>            style.padding       = '0px';
<span id="line12847" class="line"></span>            style.background    = options.background;
<span id="line12848" class="line"></span>            style.opacity       = options.opacity;
<span id="line12849" class="line"></span>            style.overflow      = 'hidden';
<span id="line12850" class="line"></span>        }( this.element.style, this.borderWidth));
<span id="line12851" class="line"></span>    }
<span id="line12852" class="line"></span>
<span id="line12853" class="line"></span>    this.displayRegion           = $.makeNeutralElement( "div" );
<span id="line12854" class="line"></span>    this.displayRegion.id        = this.element.id + '-displayregion';
<span id="line12855" class="line"></span>    this.displayRegion.className = 'displayregion';
<span id="line12856" class="line"></span>
<span id="line12857" class="line"></span>    (function( style, borderWidth ){
<span id="line12858" class="line"></span>        style.position      = 'relative';
<span id="line12859" class="line"></span>        style.top           = '0px';
<span id="line12860" class="line"></span>        style.left          = '0px';
<span id="line12861" class="line"></span>        style.fontSize      = '0px';
<span id="line12862" class="line"></span>        style.overflow      = 'hidden';
<span id="line12863" class="line"></span>        style.border        = borderWidth + 'px solid ' + options.displayRegionColor;
<span id="line12864" class="line"></span>        style.margin        = '0px';
<span id="line12865" class="line"></span>        style.padding       = '0px';
<span id="line12866" class="line"></span>        style.background    = 'transparent';
<span id="line12867" class="line"></span>
<span id="line12868" class="line"></span>        // We use square bracket notation on the statement below, because float is a keyword.
<span id="line12869" class="line"></span>        // This is important for the Google Closure compiler, if nothing else.
<span id="line12870" class="line"></span>        /*jshint sub:true */
<span id="line12871" class="line"></span>        style['float']      = 'left'; //Webkit
<span id="line12872" class="line"></span>
<span id="line12873" class="line"></span>        style.cssFloat      = 'left'; //Firefox
<span id="line12874" class="line"></span>        style.zIndex        = 999999999;
<span id="line12875" class="line"></span>        style.cursor        = 'default';
<span id="line12876" class="line"></span>        style.boxSizing     = 'content-box';
<span id="line12877" class="line"></span>    }( this.displayRegion.style, this.borderWidth ));
<span id="line12878" class="line"></span>    $.setElementPointerEventsNone( this.displayRegion );
<span id="line12879" class="line"></span>    $.setElementTouchActionNone( this.displayRegion );
<span id="line12880" class="line"></span>
<span id="line12881" class="line"></span>    this.displayRegionContainer = $.makeNeutralElement("div");
<span id="line12882" class="line"></span>    this.displayRegionContainer.id = this.element.id + '-displayregioncontainer';
<span id="line12883" class="line"></span>    this.displayRegionContainer.className = "displayregioncontainer";
<span id="line12884" class="line"></span>    this.displayRegionContainer.style.width = "100%";
<span id="line12885" class="line"></span>    this.displayRegionContainer.style.height = "100%";
<span id="line12886" class="line"></span>    $.setElementPointerEventsNone( this.displayRegionContainer );
<span id="line12887" class="line"></span>    $.setElementTouchActionNone( this.displayRegionContainer );
<span id="line12888" class="line"></span>
<span id="line12889" class="line"></span>    viewer.addControl(
<span id="line12890" class="line"></span>        this.element,
<span id="line12891" class="line"></span>        options.controlOptions
<span id="line12892" class="line"></span>    );
<span id="line12893" class="line"></span>
<span id="line12894" class="line"></span>    this._resizeWithViewer = options.controlOptions.anchor !== $.ControlAnchor.ABSOLUTE &amp;&amp;
<span id="line12895" class="line"></span>        options.controlOptions.anchor !== $.ControlAnchor.NONE;
<span id="line12896" class="line"></span>
<span id="line12897" class="line"></span>    if (options.width &amp;&amp; options.height) {
<span id="line12898" class="line"></span>        this.setWidth(options.width);
<span id="line12899" class="line"></span>        this.setHeight(options.height);
<span id="line12900" class="line"></span>    } else if ( this._resizeWithViewer ) {
<span id="line12901" class="line"></span>        viewerSize = $.getElementSize( viewer.element );
<span id="line12902" class="line"></span>        this.element.style.height = Math.round( viewerSize.y * options.sizeRatio ) + 'px';
<span id="line12903" class="line"></span>        this.element.style.width  = Math.round( viewerSize.x * options.sizeRatio ) + 'px';
<span id="line12904" class="line"></span>        this.oldViewerSize = viewerSize;
<span id="line12905" class="line"></span>        navigatorSize = $.getElementSize( this.element );
<span id="line12906" class="line"></span>        this.elementArea = navigatorSize.x * navigatorSize.y;
<span id="line12907" class="line"></span>    }
<span id="line12908" class="line"></span>
<span id="line12909" class="line"></span>    this.oldContainerSize = new $.Point( 0, 0 );
<span id="line12910" class="line"></span>
<span id="line12911" class="line"></span>    $.Viewer.apply( this, [ options ] );
<span id="line12912" class="line"></span>
<span id="line12913" class="line"></span>    this.displayRegionContainer.appendChild(this.displayRegion);
<span id="line12914" class="line"></span>    this.element.getElementsByTagName('div')[0].appendChild(this.displayRegionContainer);
<span id="line12915" class="line"></span>
<span id="line12916" class="line"></span>    function rotate(degrees, immediately) {
<span id="line12917" class="line"></span>        _setTransformRotate(_this.displayRegionContainer, degrees);
<span id="line12918" class="line"></span>        _setTransformRotate(_this.displayRegion, -degrees);
<span id="line12919" class="line"></span>        _this.viewport.setRotation(degrees, immediately);
<span id="line12920" class="line"></span>    }
<span id="line12921" class="line"></span>    if (options.navigatorRotate) {
<span id="line12922" class="line"></span>        const degrees = options.viewer.viewport ?
<span id="line12923" class="line"></span>            options.viewer.viewport.getRotation() :
<span id="line12924" class="line"></span>            options.viewer.degrees || 0;
<span id="line12925" class="line"></span>
<span id="line12926" class="line"></span>        rotate(degrees, true);
<span id="line12927" class="line"></span>        options.viewer.addHandler("rotate", function (args) {
<span id="line12928" class="line"></span>            rotate(args.degrees, args.immediately);
<span id="line12929" class="line"></span>        });
<span id="line12930" class="line"></span>    }
<span id="line12931" class="line"></span>
<span id="line12932" class="line"></span>
<span id="line12933" class="line"></span>    // Remove the base class' (Viewer's) innerTracker and replace it with our own
<span id="line12934" class="line"></span>    this.innerTracker.destroy();
<span id="line12935" class="line"></span>    this.innerTracker = new $.MouseTracker({
<span id="line12936" class="line"></span>        userData:        'Navigator.innerTracker',
<span id="line12937" class="line"></span>        element:         this.element, //this.canvas,
<span id="line12938" class="line"></span>        dragHandler:     $.delegate( this, onCanvasDrag ),
<span id="line12939" class="line"></span>        clickHandler:    $.delegate( this, onCanvasClick ),
<span id="line12940" class="line"></span>        releaseHandler:  $.delegate( this, onCanvasRelease ),
<span id="line12941" class="line"></span>        scrollHandler:   $.delegate( this, onCanvasScroll ),
<span id="line12942" class="line"></span>        preProcessEventHandler: function (eventInfo) {
<span id="line12943" class="line"></span>            if (eventInfo.eventType === 'wheel') {
<span id="line12944" class="line"></span>                //don't scroll the page up and down if the user is scrolling
<span id="line12945" class="line"></span>                //in the navigator
<span id="line12946" class="line"></span>                eventInfo.preventDefault = true;
<span id="line12947" class="line"></span>            }
<span id="line12948" class="line"></span>        }
<span id="line12949" class="line"></span>    });
<span id="line12950" class="line"></span>    this.outerTracker.userData = 'Navigator.outerTracker';
<span id="line12951" class="line"></span>
<span id="line12952" class="line"></span>    // this.innerTracker is attached to this.element...we need to allow pointer
<span id="line12953" class="line"></span>    //   events to pass through this Viewer's canvas/container elements so implicit
<span id="line12954" class="line"></span>    //   pointer capture works on touch devices
<span id="line12955" class="line"></span>    //TODO an alternative is to attach the new MouseTracker to this.canvas...not
<span id="line12956" class="line"></span>    //   sure why it isn't already (see MouseTracker constructor call above)
<span id="line12957" class="line"></span>    $.setElementPointerEventsNone( this.canvas );
<span id="line12958" class="line"></span>    $.setElementPointerEventsNone( this.container );
<span id="line12959" class="line"></span>
<span id="line12960" class="line"></span>    this.addHandler("reset-size", function() {
<span id="line12961" class="line"></span>        if (_this.viewport) {
<span id="line12962" class="line"></span>            _this.viewport.goHome(true);
<span id="line12963" class="line"></span>        }
<span id="line12964" class="line"></span>    });
<span id="line12965" class="line"></span>
<span id="line12966" class="line"></span>    viewer.world.addHandler("item-index-change", function(event) {
<span id="line12967" class="line"></span>        window.setTimeout(function(){
<span id="line12968" class="line"></span>            const item = _this.world.getItemAt(event.previousIndex);
<span id="line12969" class="line"></span>            _this.world.setItemIndex(item, event.newIndex);
<span id="line12970" class="line"></span>        }, 1);
<span id="line12971" class="line"></span>    });
<span id="line12972" class="line"></span>
<span id="line12973" class="line"></span>    viewer.world.addHandler("remove-item", function(event) {
<span id="line12974" class="line"></span>        const theirItem = event.item;
<span id="line12975" class="line"></span>        const myItem = _this._getMatchingItem(theirItem);
<span id="line12976" class="line"></span>        if (myItem) {
<span id="line12977" class="line"></span>            _this.world.removeItem(myItem);
<span id="line12978" class="line"></span>        }
<span id="line12979" class="line"></span>    });
<span id="line12980" class="line"></span>
<span id="line12981" class="line"></span>    this.update(viewer.viewport);
<span id="line12982" class="line"></span>};
<span id="line12983" class="line"></span>
<span id="line12984" class="line"></span>$.extend( $.Navigator.prototype, $.EventSource.prototype, $.Viewer.prototype, /** @lends OpenSeadragon.Navigator.prototype */{
<span id="line12985" class="line"></span>
<span id="line12986" class="line"></span>    /**
<span id="line12987" class="line"></span>     * Used to notify the navigator when its size has changed. Especially useful when the navigator is resizable.
<span id="line12988" class="line"></span>     * @function
<span id="line12989" class="line"></span>     */
<span id="line12990" class="line"></span>    updateSize: function () {
<span id="line12991" class="line"></span>        if ( this.viewport ) {
<span id="line12992" class="line"></span>            const containerSize = new $.Point(
<span id="line12993" class="line"></span>                    (this.container.clientWidth === 0 ? 1 : this.container.clientWidth),
<span id="line12994" class="line"></span>                    (this.container.clientHeight === 0 ? 1 : this.container.clientHeight)
<span id="line12995" class="line"></span>                );
<span id="line12996" class="line"></span>
<span id="line12997" class="line"></span>            if ( !containerSize.equals( this.oldContainerSize ) ) {
<span id="line12998" class="line"></span>                this.viewport.resize( containerSize, true );
<span id="line12999" class="line"></span>                this.viewport.goHome(true);
<span id="line13000" class="line"></span>                this.oldContainerSize = containerSize;
<span id="line13001" class="line"></span>                this.world.update();
<span id="line13002" class="line"></span>                this.world.draw();
<span id="line13003" class="line"></span>                this.update(this.viewer.viewport);
<span id="line13004" class="line"></span>            }
<span id="line13005" class="line"></span>        }
<span id="line13006" class="line"></span>    },
<span id="line13007" class="line"></span>
<span id="line13008" class="line"></span>    /**
<span id="line13009" class="line"></span>     * Explicitly sets the width of the navigator, in web coordinates. Disables automatic resizing.
<span id="line13010" class="line"></span>     * @param {Number|String} width - the new width, either a number of pixels or a CSS string, such as "100%"
<span id="line13011" class="line"></span>     */
<span id="line13012" class="line"></span>    setWidth: function(width) {
<span id="line13013" class="line"></span>        this.width = width;
<span id="line13014" class="line"></span>        this.element.style.width = typeof (width) === "number" ? (width + 'px') : width;
<span id="line13015" class="line"></span>        this._resizeWithViewer = false;
<span id="line13016" class="line"></span>        this.updateSize();
<span id="line13017" class="line"></span>    },
<span id="line13018" class="line"></span>
<span id="line13019" class="line"></span>    /**
<span id="line13020" class="line"></span>     * Explicitly sets the height of the navigator, in web coordinates. Disables automatic resizing.
<span id="line13021" class="line"></span>     * @param {Number|String} height - the new height, either a number of pixels or a CSS string, such as "100%"
<span id="line13022" class="line"></span>     */
<span id="line13023" class="line"></span>    setHeight: function(height) {
<span id="line13024" class="line"></span>        this.height = height;
<span id="line13025" class="line"></span>        this.element.style.height = typeof (height) === "number" ? (height + 'px') : height;
<span id="line13026" class="line"></span>        this._resizeWithViewer = false;
<span id="line13027" class="line"></span>        this.updateSize();
<span id="line13028" class="line"></span>    },
<span id="line13029" class="line"></span>
<span id="line13030" class="line"></span>    /**
<span id="line13031" class="line"></span>      * Flip navigator element
<span id="line13032" class="line"></span>      * @param {Boolean} state - Flip state to set.
<span id="line13033" class="line"></span>      */
<span id="line13034" class="line"></span>    setFlip: function(state) {
<span id="line13035" class="line"></span>      this.viewport.setFlip(state);
<span id="line13036" class="line"></span>
<span id="line13037" class="line"></span>      this.setDisplayTransform(this.viewer.viewport.getFlip() ? "scale(-1,1)" : "scale(1,1)");
<span id="line13038" class="line"></span>      return this;
<span id="line13039" class="line"></span>    },
<span id="line13040" class="line"></span>
<span id="line13041" class="line"></span>    setDisplayTransform: function(rule) {
<span id="line13042" class="line"></span>      setElementTransform(this.canvas, rule);
<span id="line13043" class="line"></span>      setElementTransform(this.element, rule);
<span id="line13044" class="line"></span>    },
<span id="line13045" class="line"></span>
<span id="line13046" class="line"></span>    /**
<span id="line13047" class="line"></span>     * Used to update the navigator minimap's viewport rectangle when a change in the viewer's viewport occurs.
<span id="line13048" class="line"></span>     * @function
<span id="line13049" class="line"></span>     * @param {OpenSeadragon.Viewport} [viewport] The viewport to display. Default: the viewport this navigator is tracking.
<span id="line13050" class="line"></span>     */
<span id="line13051" class="line"></span>    update: function( viewport ) {
<span id="line13052" class="line"></span>        let viewerSize;
<span id="line13053" class="line"></span>        let newWidth;
<span id="line13054" class="line"></span>        let newHeight;
<span id="line13055" class="line"></span>        let bounds;
<span id="line13056" class="line"></span>        let topleft;
<span id="line13057" class="line"></span>        let bottomright;
<span id="line13058" class="line"></span>
<span id="line13059" class="line"></span>        if(!viewport){
<span id="line13060" class="line"></span>            viewport = this.viewer.viewport;
<span id="line13061" class="line"></span>        }
<span id="line13062" class="line"></span>
<span id="line13063" class="line"></span>        viewerSize = $.getElementSize( this.viewer.element );
<span id="line13064" class="line"></span>        if ( this._resizeWithViewer &amp;&amp; viewerSize.x &amp;&amp; viewerSize.y &amp;&amp; !viewerSize.equals( this.oldViewerSize ) ) {
<span id="line13065" class="line"></span>            this.oldViewerSize = viewerSize;
<span id="line13066" class="line"></span>
<span id="line13067" class="line"></span>            if ( this.maintainSizeRatio || !this.elementArea) {
<span id="line13068" class="line"></span>                newWidth  = viewerSize.x * this.sizeRatio;
<span id="line13069" class="line"></span>                newHeight = viewerSize.y * this.sizeRatio;
<span id="line13070" class="line"></span>            } else {
<span id="line13071" class="line"></span>                newWidth = Math.sqrt(this.elementArea * (viewerSize.x / viewerSize.y));
<span id="line13072" class="line"></span>                newHeight = this.elementArea / newWidth;
<span id="line13073" class="line"></span>            }
<span id="line13074" class="line"></span>
<span id="line13075" class="line"></span>            this.element.style.width  = Math.round( newWidth ) + 'px';
<span id="line13076" class="line"></span>            this.element.style.height = Math.round( newHeight ) + 'px';
<span id="line13077" class="line"></span>
<span id="line13078" class="line"></span>            if (!this.elementArea) {
<span id="line13079" class="line"></span>                this.elementArea = newWidth * newHeight;
<span id="line13080" class="line"></span>            }
<span id="line13081" class="line"></span>
<span id="line13082" class="line"></span>            this.updateSize();
<span id="line13083" class="line"></span>        }
<span id="line13084" class="line"></span>
<span id="line13085" class="line"></span>        if (viewport &amp;&amp; this.viewport) {
<span id="line13086" class="line"></span>            bounds      = viewport.getBoundsNoRotate(true);
<span id="line13087" class="line"></span>            topleft     = this.viewport.pixelFromPointNoRotate(bounds.getTopLeft(), false);
<span id="line13088" class="line"></span>            bottomright = this.viewport.pixelFromPointNoRotate(bounds.getBottomRight(), false)
<span id="line13089" class="line"></span>                .minus( this.totalBorderWidths );
<span id="line13090" class="line"></span>
<span id="line13091" class="line"></span>            if (!this.navigatorRotate) {
<span id="line13092" class="line"></span>                const degrees = viewport.getRotation(true);
<span id="line13093" class="line"></span>                _setTransformRotate(this.displayRegion, -degrees);
<span id="line13094" class="line"></span>            }
<span id="line13095" class="line"></span>
<span id="line13096" class="line"></span>            //update style for navigator-box
<span id="line13097" class="line"></span>            const style = this.displayRegion.style;
<span id="line13098" class="line"></span>            style.display = this.world.getItemCount() ? 'block' : 'none';
<span id="line13099" class="line"></span>
<span id="line13100" class="line"></span>            style.top = topleft.y.toFixed(2) + "px";
<span id="line13101" class="line"></span>            style.left = topleft.x.toFixed(2) + "px";
<span id="line13102" class="line"></span>
<span id="line13103" class="line"></span>            const width = bottomright.x - topleft.x;
<span id="line13104" class="line"></span>            const height = bottomright.y - topleft.y;
<span id="line13105" class="line"></span>            // make sure width and height are non-negative so IE doesn't throw
<span id="line13106" class="line"></span>            style.width  = Math.round( Math.max( width, 0 ) ) + 'px';
<span id="line13107" class="line"></span>            style.height = Math.round( Math.max( height, 0 ) ) + 'px';
<span id="line13108" class="line"></span>        }
<span id="line13109" class="line"></span>
<span id="line13110" class="line"></span>    },
<span id="line13111" class="line"></span>
<span id="line13112" class="line"></span>    // overrides Viewer.addTiledImage
<span id="line13113" class="line"></span>    addTiledImage: function(options) {
<span id="line13114" class="line"></span>        const _this = this;
<span id="line13115" class="line"></span>
<span id="line13116" class="line"></span>        const original = options.originalTiledImage;
<span id="line13117" class="line"></span>        delete options.original;
<span id="line13118" class="line"></span>
<span id="line13119" class="line"></span>        const optionsClone = $.extend({}, options, {
<span id="line13120" class="line"></span>            success: function(event) {
<span id="line13121" class="line"></span>                const myItem = event.item;
<span id="line13122" class="line"></span>                myItem._originalForNavigator = original;
<span id="line13123" class="line"></span>                _this._matchBounds(myItem, original, true);
<span id="line13124" class="line"></span>                _this._matchOpacity(myItem, original);
<span id="line13125" class="line"></span>                _this._matchCompositeOperation(myItem, original);
<span id="line13126" class="line"></span>
<span id="line13127" class="line"></span>                function matchBounds() {
<span id="line13128" class="line"></span>                    _this._matchBounds(myItem, original);
<span id="line13129" class="line"></span>                }
<span id="line13130" class="line"></span>
<span id="line13131" class="line"></span>                function matchOpacity() {
<span id="line13132" class="line"></span>                    _this._matchOpacity(myItem, original);
<span id="line13133" class="line"></span>                }
<span id="line13134" class="line"></span>
<span id="line13135" class="line"></span>                function matchCompositeOperation() {
<span id="line13136" class="line"></span>                    _this._matchCompositeOperation(myItem, original);
<span id="line13137" class="line"></span>                }
<span id="line13138" class="line"></span>
<span id="line13139" class="line"></span>                original.addHandler('bounds-change', matchBounds);
<span id="line13140" class="line"></span>                original.addHandler('clip-change', matchBounds);
<span id="line13141" class="line"></span>                original.addHandler('opacity-change', matchOpacity);
<span id="line13142" class="line"></span>                original.addHandler('composite-operation-change', matchCompositeOperation);
<span id="line13143" class="line"></span>            }
<span id="line13144" class="line"></span>        });
<span id="line13145" class="line"></span>
<span id="line13146" class="line"></span>        return $.Viewer.prototype.addTiledImage.apply(this, [optionsClone]);
<span id="line13147" class="line"></span>    },
<span id="line13148" class="line"></span>
<span id="line13149" class="line"></span>    destroy: function() {
<span id="line13150" class="line"></span>        return $.Viewer.prototype.destroy.apply(this);
<span id="line13151" class="line"></span>    },
<span id="line13152" class="line"></span>
<span id="line13153" class="line"></span>    // private
<span id="line13154" class="line"></span>    _getMatchingItem: function(theirItem) {
<span id="line13155" class="line"></span>        const count = this.world.getItemCount();
<span id="line13156" class="line"></span>        for (let i = 0; i &lt; count; i++) {
<span id="line13157" class="line"></span>            let item = this.world.getItemAt(i);
<span id="line13158" class="line"></span>            if (item._originalForNavigator === theirItem) {
<span id="line13159" class="line"></span>                return item;
<span id="line13160" class="line"></span>            }
<span id="line13161" class="line"></span>        }
<span id="line13162" class="line"></span>
<span id="line13163" class="line"></span>        return null;
<span id="line13164" class="line"></span>    },
<span id="line13165" class="line"></span>
<span id="line13166" class="line"></span>    // private
<span id="line13167" class="line"></span>    _matchBounds: function(myItem, theirItem, immediately) {
<span id="line13168" class="line"></span>        const bounds = theirItem.getBoundsNoRotate();
<span id="line13169" class="line"></span>        myItem.setPosition(bounds.getTopLeft(), immediately);
<span id="line13170" class="line"></span>        myItem.setWidth(bounds.width, immediately);
<span id="line13171" class="line"></span>        myItem.setRotation(theirItem.getRotation(), immediately);
<span id="line13172" class="line"></span>        myItem.setClip(theirItem.getClip());
<span id="line13173" class="line"></span>        myItem.setFlip(theirItem.getFlip());
<span id="line13174" class="line"></span>    },
<span id="line13175" class="line"></span>
<span id="line13176" class="line"></span>    // private
<span id="line13177" class="line"></span>    _matchOpacity: function(myItem, theirItem) {
<span id="line13178" class="line"></span>        myItem.setOpacity(theirItem.opacity);
<span id="line13179" class="line"></span>    },
<span id="line13180" class="line"></span>
<span id="line13181" class="line"></span>    // private
<span id="line13182" class="line"></span>    _matchCompositeOperation: function(myItem, theirItem) {
<span id="line13183" class="line"></span>        myItem.setCompositeOperation(theirItem.compositeOperation);
<span id="line13184" class="line"></span>    }
<span id="line13185" class="line"></span>});
<span id="line13186" class="line"></span>
<span id="line13187" class="line"></span>
<span id="line13188" class="line"></span>/**
<span id="line13189" class="line"></span> * @private
<span id="line13190" class="line"></span> * @inner
<span id="line13191" class="line"></span> * @function
<span id="line13192" class="line"></span> */
<span id="line13193" class="line"></span>function onCanvasClick( event ) {
<span id="line13194" class="line"></span>  const canvasClickEventArgs = {
<span id="line13195" class="line"></span>    tracker: event.eventSource,
<span id="line13196" class="line"></span>    position: event.position,
<span id="line13197" class="line"></span>    quick: event.quick,
<span id="line13198" class="line"></span>    shift: event.shift,
<span id="line13199" class="line"></span>    originalEvent: event.originalEvent,
<span id="line13200" class="line"></span>    preventDefaultAction: false
<span id="line13201" class="line"></span>  };
<span id="line13202" class="line"></span>  /**
<span id="line13203" class="line"></span>   * Raised when a click event occurs on the {@link OpenSeadragon.Viewer#navigator} element.
<span id="line13204" class="line"></span>   *
<span id="line13205" class="line"></span>   * @event navigator-click
<span id="line13206" class="line"></span>   * @memberof OpenSeadragon.Viewer
<span id="line13207" class="line"></span>   * @type {object}
<span id="line13208" class="line"></span>   * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line13209" class="line"></span>   * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
<span id="line13210" class="line"></span>   * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
<span id="line13211" class="line"></span>   * @property {Boolean} quick - True only if the clickDistThreshold and clickTimeThreshold are both passed. Useful for differentiating between clicks and drags.
<span id="line13212" class="line"></span>   * @property {Boolean} shift - True if the shift key was pressed during this event.
<span id="line13213" class="line"></span>   * @property {Object} originalEvent - The original DOM event.
<span id="line13214" class="line"></span>   * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line13215" class="line"></span>   * @property {Boolean} preventDefaultAction - Set to true to prevent default click to zoom behaviour. Default: false.
<span id="line13216" class="line"></span>   */
<span id="line13217" class="line"></span>
<span id="line13218" class="line"></span>   this.viewer.raiseEvent('navigator-click', canvasClickEventArgs);
<span id="line13219" class="line"></span>
<span id="line13220" class="line"></span>   if ( !canvasClickEventArgs.preventDefaultAction &amp;&amp; event.quick &amp;&amp; this.viewer.viewport &amp;&amp; (this.panVertical || this.panHorizontal)) {
<span id="line13221" class="line"></span>    if(this.viewer.viewport.flipped) {
<span id="line13222" class="line"></span>      event.position.x = this.viewport.getContainerSize().x - event.position.x;
<span id="line13223" class="line"></span>    }
<span id="line13224" class="line"></span>    const target = this.viewport.pointFromPixel(event.position);
<span id="line13225" class="line"></span>    if (!this.panVertical) {
<span id="line13226" class="line"></span>      // perform only horizonal pan
<span id="line13227" class="line"></span>      target.y = this.viewer.viewport.getCenter(true).y;
<span id="line13228" class="line"></span>    } else if (!this.panHorizontal) {
<span id="line13229" class="line"></span>      // perform only vertical pan
<span id="line13230" class="line"></span>      target.x = this.viewer.viewport.getCenter(true).x;
<span id="line13231" class="line"></span>    }
<span id="line13232" class="line"></span>    this.viewer.viewport.panTo(target);
<span id="line13233" class="line"></span>    this.viewer.viewport.applyConstraints();
<span id="line13234" class="line"></span>  }
<span id="line13235" class="line"></span>
<span id="line13236" class="line"></span>}
<span id="line13237" class="line"></span>
<span id="line13238" class="line"></span>/**
<span id="line13239" class="line"></span> * @private
<span id="line13240" class="line"></span> * @inner
<span id="line13241" class="line"></span> * @function
<span id="line13242" class="line"></span> */
<span id="line13243" class="line"></span>function onCanvasDrag( event ) {
<span id="line13244" class="line"></span>    const canvasDragEventArgs = {
<span id="line13245" class="line"></span>      tracker: event.eventSource,
<span id="line13246" class="line"></span>      position: event.position,
<span id="line13247" class="line"></span>      delta: event.delta,
<span id="line13248" class="line"></span>      speed: event.speed,
<span id="line13249" class="line"></span>      direction: event.direction,
<span id="line13250" class="line"></span>      shift: event.shift,
<span id="line13251" class="line"></span>      originalEvent: event.originalEvent,
<span id="line13252" class="line"></span>      preventDefaultAction: false
<span id="line13253" class="line"></span>    };
<span id="line13254" class="line"></span>    /**
<span id="line13255" class="line"></span>     * Raised when a drag event occurs on the {@link OpenSeadragon.Viewer#navigator} element.
<span id="line13256" class="line"></span>     *
<span id="line13257" class="line"></span>     * @event navigator-drag
<span id="line13258" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line13259" class="line"></span>     * @type {object}
<span id="line13260" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line13261" class="line"></span>     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
<span id="line13262" class="line"></span>     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
<span id="line13263" class="line"></span>     * @property {OpenSeadragon.Point} delta - The x,y components of the difference between start drag and end drag.
<span id="line13264" class="line"></span>     * @property {Number} speed - Current computed speed, in pixels per second.
<span id="line13265" class="line"></span>     * @property {Number} direction - Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed &gt; 0.
<span id="line13266" class="line"></span>     * @property {Boolean} shift - True if the shift key was pressed during this event.
<span id="line13267" class="line"></span>     * @property {Object} originalEvent - The original DOM event.
<span id="line13268" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line13269" class="line"></span>     * @property {Boolean} preventDefaultAction - Set to true to prevent default drag to pan behaviour. Default: false.
<span id="line13270" class="line"></span>     */
<span id="line13271" class="line"></span>     this.viewer.raiseEvent('navigator-drag', canvasDragEventArgs);
<span id="line13272" class="line"></span>
<span id="line13273" class="line"></span>     if ( !canvasDragEventArgs.preventDefaultAction &amp;&amp; this.viewer.viewport ) {
<span id="line13274" class="line"></span>       if( !this.panHorizontal ){
<span id="line13275" class="line"></span>            event.delta.x = 0;
<span id="line13276" class="line"></span>        }
<span id="line13277" class="line"></span>        if( !this.panVertical ){
<span id="line13278" class="line"></span>            event.delta.y = 0;
<span id="line13279" class="line"></span>        }
<span id="line13280" class="line"></span>
<span id="line13281" class="line"></span>        if(this.viewer.viewport.flipped){
<span id="line13282" class="line"></span>            event.delta.x = -event.delta.x;
<span id="line13283" class="line"></span>        }
<span id="line13284" class="line"></span>
<span id="line13285" class="line"></span>        this.viewer.viewport.panBy(
<span id="line13286" class="line"></span>            this.viewport.deltaPointsFromPixels(
<span id="line13287" class="line"></span>                event.delta
<span id="line13288" class="line"></span>            )
<span id="line13289" class="line"></span>        );
<span id="line13290" class="line"></span>        if( this.viewer.constrainDuringPan ){
<span id="line13291" class="line"></span>            this.viewer.viewport.applyConstraints();
<span id="line13292" class="line"></span>        }
<span id="line13293" class="line"></span>    }
<span id="line13294" class="line"></span>}
<span id="line13295" class="line"></span>
<span id="line13296" class="line"></span>
<span id="line13297" class="line"></span>/**
<span id="line13298" class="line"></span> * @private
<span id="line13299" class="line"></span> * @inner
<span id="line13300" class="line"></span> * @function
<span id="line13301" class="line"></span> */
<span id="line13302" class="line"></span>function onCanvasRelease( event ) {
<span id="line13303" class="line"></span>    if ( event.insideElementPressed &amp;&amp; this.viewer.viewport ) {
<span id="line13304" class="line"></span>        this.viewer.viewport.applyConstraints();
<span id="line13305" class="line"></span>    }
<span id="line13306" class="line"></span>}
<span id="line13307" class="line"></span>
<span id="line13308" class="line"></span>
<span id="line13309" class="line"></span>/**
<span id="line13310" class="line"></span> * @private
<span id="line13311" class="line"></span> * @inner
<span id="line13312" class="line"></span> * @function
<span id="line13313" class="line"></span> */
<span id="line13314" class="line"></span>function onCanvasScroll( event ) {
<span id="line13315" class="line"></span>    const eventArgs = {
<span id="line13316" class="line"></span>        tracker: event.eventSource,
<span id="line13317" class="line"></span>        position: event.position,
<span id="line13318" class="line"></span>        scroll: event.scroll,
<span id="line13319" class="line"></span>        shift: event.shift,
<span id="line13320" class="line"></span>        originalEvent: event.originalEvent,
<span id="line13321" class="line"></span>        preventDefault: event.preventDefault
<span id="line13322" class="line"></span>    };
<span id="line13323" class="line"></span>
<span id="line13324" class="line"></span>    /**
<span id="line13325" class="line"></span>     * Raised when a scroll event occurs on the {@link OpenSeadragon.Viewer#navigator} element (mouse wheel, touch pinch, etc.).
<span id="line13326" class="line"></span>     *
<span id="line13327" class="line"></span>     * @event navigator-scroll
<span id="line13328" class="line"></span>     * @memberof OpenSeadragon.Viewer
<span id="line13329" class="line"></span>     * @type {object}
<span id="line13330" class="line"></span>     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line13331" class="line"></span>     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
<span id="line13332" class="line"></span>     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
<span id="line13333" class="line"></span>     * @property {Number} scroll - The scroll delta for the event.
<span id="line13334" class="line"></span>     * @property {Boolean} shift - True if the shift key was pressed during this event.
<span id="line13335" class="line"></span>     * @property {Object} originalEvent - The original DOM event.
<span id="line13336" class="line"></span>     * @property {Boolean} preventDefault - Set to true to prevent the default user-agent's handling of the wheel event.
<span id="line13337" class="line"></span>     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line13338" class="line"></span>     */
<span id="line13339" class="line"></span>    this.viewer.raiseEvent( 'navigator-scroll', eventArgs );
<span id="line13340" class="line"></span>
<span id="line13341" class="line"></span>    event.preventDefault = eventArgs.preventDefault;
<span id="line13342" class="line"></span>}
<span id="line13343" class="line"></span>
<span id="line13344" class="line"></span>/**
<span id="line13345" class="line"></span>    * @function
<span id="line13346" class="line"></span>    * @private
<span id="line13347" class="line"></span>    * @param {Object} element
<span id="line13348" class="line"></span>    * @param {Number} degrees
<span id="line13349" class="line"></span>    */
<span id="line13350" class="line"></span>function _setTransformRotate( element, degrees ) {
<span id="line13351" class="line"></span>  setElementTransform(element, "rotate(" + degrees + "deg)");
<span id="line13352" class="line"></span>}
<span id="line13353" class="line"></span>
<span id="line13354" class="line"></span>function setElementTransform( element, rule ) {
<span id="line13355" class="line"></span>  element.style.webkitTransform = rule;
<span id="line13356" class="line"></span>  element.style.mozTransform = rule;
<span id="line13357" class="line"></span>  element.style.msTransform = rule;
<span id="line13358" class="line"></span>  element.style.oTransform = rule;
<span id="line13359" class="line"></span>  element.style.transform = rule;
<span id="line13360" class="line"></span>}
<span id="line13361" class="line"></span>
<span id="line13362" class="line"></span>}( OpenSeadragon ));
<span id="line13363" class="line"></span>
<span id="line13364" class="line"></span>/*
<span id="line13365" class="line"></span> * OpenSeadragon - getString/setString
<span id="line13366" class="line"></span> *
<span id="line13367" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line13368" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line13369" class="line"></span> *
<span id="line13370" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line13371" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line13372" class="line"></span> * met:
<span id="line13373" class="line"></span> *
<span id="line13374" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line13375" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line13376" class="line"></span> *
<span id="line13377" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line13378" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line13379" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line13380" class="line"></span> *
<span id="line13381" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line13382" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line13383" class="line"></span> *   this software without specific prior written permission.
<span id="line13384" class="line"></span> *
<span id="line13385" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line13386" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line13387" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line13388" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line13389" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line13390" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line13391" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line13392" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line13393" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line13394" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line13395" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line13396" class="line"></span> */
<span id="line13397" class="line"></span>
<span id="line13398" class="line"></span>(function( $ ){
<span id="line13399" class="line"></span>
<span id="line13400" class="line"></span>//TODO: I guess this is where the i18n needs to be reimplemented.  I'll look
<span id="line13401" class="line"></span>//      into existing patterns for i18n in javascript but i think that mimicking
<span id="line13402" class="line"></span>//      pythons gettext might be a reasonable approach.
<span id="line13403" class="line"></span>const I18N = {
<span id="line13404" class="line"></span>    Errors: {
<span id="line13405" class="line"></span>        Dzc:            "Sorry, we don't support Deep Zoom Collections!",
<span id="line13406" class="line"></span>        Dzi:            "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
<span id="line13407" class="line"></span>        Xml:            "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
<span id="line13408" class="line"></span>        ImageFormat:    "Sorry, we don't support {0}-based Deep Zoom Images.",
<span id="line13409" class="line"></span>        Security:       "It looks like a security restriction stopped us from " +
<span id="line13410" class="line"></span>                        "loading this Deep Zoom Image.",
<span id="line13411" class="line"></span>        Status:         "This space unintentionally left blank ({0} {1}).",
<span id="line13412" class="line"></span>        OpenFailed:     "Unable to open {0}: {1}"
<span id="line13413" class="line"></span>    },
<span id="line13414" class="line"></span>
<span id="line13415" class="line"></span>    Tooltips: {
<span id="line13416" class="line"></span>        FullPage:       "Toggle full page",
<span id="line13417" class="line"></span>        Home:           "Go home",
<span id="line13418" class="line"></span>        ZoomIn:         "Zoom in",
<span id="line13419" class="line"></span>        ZoomOut:        "Zoom out",
<span id="line13420" class="line"></span>        NextPage:       "Next page",
<span id="line13421" class="line"></span>        PreviousPage:   "Previous page",
<span id="line13422" class="line"></span>        RotateLeft:     "Rotate left",
<span id="line13423" class="line"></span>        RotateRight:    "Rotate right",
<span id="line13424" class="line"></span>        Flip:           "Flip Horizontally"
<span id="line13425" class="line"></span>    }
<span id="line13426" class="line"></span>};
<span id="line13427" class="line"></span>
<span id="line13428" class="line"></span>$.extend( $, /** @lends OpenSeadragon */{
<span id="line13429" class="line"></span>
<span id="line13430" class="line"></span>    /**
<span id="line13431" class="line"></span>     * @function
<span id="line13432" class="line"></span>     * @param {String} property
<span id="line13433" class="line"></span>     */
<span id="line13434" class="line"></span>    getString: function( prop ) {
<span id="line13435" class="line"></span>
<span id="line13436" class="line"></span>        const props   = prop.split('.');
<span id="line13437" class="line"></span>        let string  = null;
<span id="line13438" class="line"></span>        const args    = arguments;
<span id="line13439" class="line"></span>        let container = I18N;
<span id="line13440" class="line"></span>        let i;
<span id="line13441" class="line"></span>
<span id="line13442" class="line"></span>        for (i = 0; i &lt; props.length - 1; i++) {
<span id="line13443" class="line"></span>            // in case not a subproperty
<span id="line13444" class="line"></span>            container = container[ props[ i ] ] || {};
<span id="line13445" class="line"></span>        }
<span id="line13446" class="line"></span>        string = container[ props[ i ] ];
<span id="line13447" class="line"></span>
<span id="line13448" class="line"></span>        if ( typeof ( string ) !== "string" ) {
<span id="line13449" class="line"></span>            $.console.error( "Untranslated source string:", prop );
<span id="line13450" class="line"></span>            string = ""; // FIXME: this breaks gettext()-style convention, which would return source
<span id="line13451" class="line"></span>        }
<span id="line13452" class="line"></span>
<span id="line13453" class="line"></span>        return string.replace(/\{\d+\}/g, function(capture) {
<span id="line13454" class="line"></span>            const i = parseInt( capture.match( /\d+/ ), 10 ) + 1;
<span id="line13455" class="line"></span>            return i &lt; args.length ?
<span id="line13456" class="line"></span>                args[ i ] :
<span id="line13457" class="line"></span>                "";
<span id="line13458" class="line"></span>        });
<span id="line13459" class="line"></span>    },
<span id="line13460" class="line"></span>
<span id="line13461" class="line"></span>    /**
<span id="line13462" class="line"></span>     * @function
<span id="line13463" class="line"></span>     * @param {String} property
<span id="line13464" class="line"></span>     * @param {*} value
<span id="line13465" class="line"></span>     */
<span id="line13466" class="line"></span>    setString: function( prop, value ) {
<span id="line13467" class="line"></span>
<span id="line13468" class="line"></span>        const props     = prop.split('.');
<span id="line13469" class="line"></span>        let container = I18N;
<span id="line13470" class="line"></span>        let i;
<span id="line13471" class="line"></span>
<span id="line13472" class="line"></span>        for ( i = 0; i &lt; props.length - 1; i++ ) {
<span id="line13473" class="line"></span>            if ( !container[ props[ i ] ] ) {
<span id="line13474" class="line"></span>                container[ props[ i ] ] = {};
<span id="line13475" class="line"></span>            }
<span id="line13476" class="line"></span>            container = container[ props[ i ] ];
<span id="line13477" class="line"></span>        }
<span id="line13478" class="line"></span>
<span id="line13479" class="line"></span>        container[ props[ i ] ] = value;
<span id="line13480" class="line"></span>    }
<span id="line13481" class="line"></span>
<span id="line13482" class="line"></span>});
<span id="line13483" class="line"></span>
<span id="line13484" class="line"></span>}( OpenSeadragon ));
<span id="line13485" class="line"></span>
<span id="line13486" class="line"></span>/*
<span id="line13487" class="line"></span> * OpenSeadragon - Point
<span id="line13488" class="line"></span> *
<span id="line13489" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line13490" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line13491" class="line"></span> *
<span id="line13492" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line13493" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line13494" class="line"></span> * met:
<span id="line13495" class="line"></span> *
<span id="line13496" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line13497" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line13498" class="line"></span> *
<span id="line13499" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line13500" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line13501" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line13502" class="line"></span> *
<span id="line13503" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line13504" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line13505" class="line"></span> *   this software without specific prior written permission.
<span id="line13506" class="line"></span> *
<span id="line13507" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line13508" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line13509" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line13510" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line13511" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line13512" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line13513" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line13514" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line13515" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line13516" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line13517" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line13518" class="line"></span> */
<span id="line13519" class="line"></span>
<span id="line13520" class="line"></span>(function( $ ){
<span id="line13521" class="line"></span>
<span id="line13522" class="line"></span>/**
<span id="line13523" class="line"></span> * @class Point
<span id="line13524" class="line"></span> * @classdesc A Point is really used as a 2-dimensional vector, equally useful for
<span id="line13525" class="line"></span> * representing a point on a plane, or the height and width of a plane
<span id="line13526" class="line"></span> * not requiring any other frame of reference.
<span id="line13527" class="line"></span> *
<span id="line13528" class="line"></span> * @memberof OpenSeadragon
<span id="line13529" class="line"></span> * @param {Number} [x] The vector component 'x'. Defaults to the origin at 0.
<span id="line13530" class="line"></span> * @param {Number} [y] The vector component 'y'. Defaults to the origin at 0.
<span id="line13531" class="line"></span> */
<span id="line13532" class="line"></span>$.Point = function( x, y ) {
<span id="line13533" class="line"></span>    /**
<span id="line13534" class="line"></span>     * The vector component 'x'.
<span id="line13535" class="line"></span>     * @member {Number} x
<span id="line13536" class="line"></span>     * @memberof OpenSeadragon.Point#
<span id="line13537" class="line"></span>     */
<span id="line13538" class="line"></span>    this.x = typeof ( x ) === "number" ? x : 0;
<span id="line13539" class="line"></span>    /**
<span id="line13540" class="line"></span>     * The vector component 'y'.
<span id="line13541" class="line"></span>     * @member {Number} y
<span id="line13542" class="line"></span>     * @memberof OpenSeadragon.Point#
<span id="line13543" class="line"></span>     */
<span id="line13544" class="line"></span>    this.y = typeof ( y ) === "number" ? y : 0;
<span id="line13545" class="line"></span>};
<span id="line13546" class="line"></span>
<span id="line13547" class="line"></span>/** @lends OpenSeadragon.Point.prototype */
<span id="line13548" class="line"></span>$.Point.prototype = {
<span id="line13549" class="line"></span>    /**
<span id="line13550" class="line"></span>     * @function
<span id="line13551" class="line"></span>     * @returns {OpenSeadragon.Point} a duplicate of this Point
<span id="line13552" class="line"></span>     */
<span id="line13553" class="line"></span>    clone: function() {
<span id="line13554" class="line"></span>        return new $.Point(this.x, this.y);
<span id="line13555" class="line"></span>    },
<span id="line13556" class="line"></span>
<span id="line13557" class="line"></span>    /**
<span id="line13558" class="line"></span>     * Add another Point to this point and return a new Point.
<span id="line13559" class="line"></span>     * @function
<span id="line13560" class="line"></span>     * @param {OpenSeadragon.Point} point The point to add vector components.
<span id="line13561" class="line"></span>     * @returns {OpenSeadragon.Point} A new point representing the sum of the
<span id="line13562" class="line"></span>     *  vector components
<span id="line13563" class="line"></span>     */
<span id="line13564" class="line"></span>    plus: function( point ) {
<span id="line13565" class="line"></span>        return new $.Point(
<span id="line13566" class="line"></span>            this.x + point.x,
<span id="line13567" class="line"></span>            this.y + point.y
<span id="line13568" class="line"></span>        );
<span id="line13569" class="line"></span>    },
<span id="line13570" class="line"></span>
<span id="line13571" class="line"></span>    /**
<span id="line13572" class="line"></span>     * Subtract another Point to this point and return a new Point.
<span id="line13573" class="line"></span>     * @function
<span id="line13574" class="line"></span>     * @param {OpenSeadragon.Point} point The point to subtract vector components.
<span id="line13575" class="line"></span>     * @returns {OpenSeadragon.Point} A new point representing the subtraction of the
<span id="line13576" class="line"></span>     *  vector components
<span id="line13577" class="line"></span>     */
<span id="line13578" class="line"></span>    minus: function( point ) {
<span id="line13579" class="line"></span>        return new $.Point(
<span id="line13580" class="line"></span>            this.x - point.x,
<span id="line13581" class="line"></span>            this.y - point.y
<span id="line13582" class="line"></span>        );
<span id="line13583" class="line"></span>    },
<span id="line13584" class="line"></span>
<span id="line13585" class="line"></span>    /**
<span id="line13586" class="line"></span>     * Multiply this point by a factor and return a new Point.
<span id="line13587" class="line"></span>     * @function
<span id="line13588" class="line"></span>     * @param {Number} factor The factor to multiply vector components.
<span id="line13589" class="line"></span>     * @returns {OpenSeadragon.Point} A new point representing the multiplication
<span id="line13590" class="line"></span>     *  of the vector components by the factor
<span id="line13591" class="line"></span>     */
<span id="line13592" class="line"></span>    times: function( factor ) {
<span id="line13593" class="line"></span>        return new $.Point(
<span id="line13594" class="line"></span>            this.x * factor,
<span id="line13595" class="line"></span>            this.y * factor
<span id="line13596" class="line"></span>        );
<span id="line13597" class="line"></span>    },
<span id="line13598" class="line"></span>
<span id="line13599" class="line"></span>    /**
<span id="line13600" class="line"></span>     * Divide this point by a factor and return a new Point.
<span id="line13601" class="line"></span>     * @function
<span id="line13602" class="line"></span>     * @param {Number} factor The factor to divide vector components.
<span id="line13603" class="line"></span>     * @returns {OpenSeadragon.Point} A new point representing the division of the
<span id="line13604" class="line"></span>     *  vector components by the factor
<span id="line13605" class="line"></span>     */
<span id="line13606" class="line"></span>    divide: function( factor ) {
<span id="line13607" class="line"></span>        return new $.Point(
<span id="line13608" class="line"></span>            this.x / factor,
<span id="line13609" class="line"></span>            this.y / factor
<span id="line13610" class="line"></span>        );
<span id="line13611" class="line"></span>    },
<span id="line13612" class="line"></span>
<span id="line13613" class="line"></span>    /**
<span id="line13614" class="line"></span>     * Compute the opposite of this point and return a new Point.
<span id="line13615" class="line"></span>     * @function
<span id="line13616" class="line"></span>     * @returns {OpenSeadragon.Point} A new point representing the opposite of the
<span id="line13617" class="line"></span>     *  vector components
<span id="line13618" class="line"></span>     */
<span id="line13619" class="line"></span>    negate: function() {
<span id="line13620" class="line"></span>        return new $.Point( -this.x, -this.y );
<span id="line13621" class="line"></span>    },
<span id="line13622" class="line"></span>
<span id="line13623" class="line"></span>    /**
<span id="line13624" class="line"></span>     * Compute the distance between this point and another point.
<span id="line13625" class="line"></span>     * @function
<span id="line13626" class="line"></span>     * @param {OpenSeadragon.Point} point The point to compute the distance with.
<span id="line13627" class="line"></span>     * @returns {Number} The distance between the 2 points
<span id="line13628" class="line"></span>     */
<span id="line13629" class="line"></span>    distanceTo: function( point ) {
<span id="line13630" class="line"></span>        return Math.sqrt(
<span id="line13631" class="line"></span>            Math.pow( this.x - point.x, 2 ) +
<span id="line13632" class="line"></span>            Math.pow( this.y - point.y, 2 )
<span id="line13633" class="line"></span>        );
<span id="line13634" class="line"></span>    },
<span id="line13635" class="line"></span>
<span id="line13636" class="line"></span>    /**
<span id="line13637" class="line"></span>     * Compute the squared distance between this point and another point.
<span id="line13638" class="line"></span>     * Useful for optimizing things like comparing distances.
<span id="line13639" class="line"></span>     * @function
<span id="line13640" class="line"></span>     * @param {OpenSeadragon.Point} point The point to compute the squared distance with.
<span id="line13641" class="line"></span>     * @returns {Number} The squared distance between the 2 points
<span id="line13642" class="line"></span>     */
<span id="line13643" class="line"></span>    squaredDistanceTo: function( point ) {
<span id="line13644" class="line"></span>        return Math.pow( this.x - point.x, 2 ) +
<span id="line13645" class="line"></span>            Math.pow( this.y - point.y, 2 );
<span id="line13646" class="line"></span>    },
<span id="line13647" class="line"></span>
<span id="line13648" class="line"></span>    /**
<span id="line13649" class="line"></span>     * Apply a function to each coordinate of this point and return a new point.
<span id="line13650" class="line"></span>     * @function
<span id="line13651" class="line"></span>     * @param {function} func The function to apply to each coordinate.
<span id="line13652" class="line"></span>     * @returns {OpenSeadragon.Point} A new point with the coordinates computed
<span id="line13653" class="line"></span>     * by the specified function
<span id="line13654" class="line"></span>     */
<span id="line13655" class="line"></span>    apply: function( func ) {
<span id="line13656" class="line"></span>        return new $.Point( func( this.x ), func( this.y ) );
<span id="line13657" class="line"></span>    },
<span id="line13658" class="line"></span>
<span id="line13659" class="line"></span>    /**
<span id="line13660" class="line"></span>     * Check if this point is equal to another one.
<span id="line13661" class="line"></span>     * @function
<span id="line13662" class="line"></span>     * @param {OpenSeadragon.Point} point The point to compare this point with.
<span id="line13663" class="line"></span>     * @returns {Boolean} true if they are equal, false otherwise.
<span id="line13664" class="line"></span>     */
<span id="line13665" class="line"></span>    equals: function( point ) {
<span id="line13666" class="line"></span>        return (
<span id="line13667" class="line"></span>            point instanceof $.Point
<span id="line13668" class="line"></span>        ) &amp;&amp; (
<span id="line13669" class="line"></span>            this.x === point.x
<span id="line13670" class="line"></span>        ) &amp;&amp; (
<span id="line13671" class="line"></span>            this.y === point.y
<span id="line13672" class="line"></span>        );
<span id="line13673" class="line"></span>    },
<span id="line13674" class="line"></span>
<span id="line13675" class="line"></span>    /**
<span id="line13676" class="line"></span>     * Rotates the point around the specified pivot
<span id="line13677" class="line"></span>     * From http://stackoverflow.com/questions/4465931/rotate-rectangle-around-a-point
<span id="line13678" class="line"></span>     * @function
<span id="line13679" class="line"></span>     * @param {Number} degress to rotate around the pivot.
<span id="line13680" class="line"></span>     * @param {OpenSeadragon.Point} [pivot=(0,0)] Point around which to rotate.
<span id="line13681" class="line"></span>     * Defaults to the origin.
<span id="line13682" class="line"></span>     * @returns {OpenSeadragon.Point}. A new point representing the point rotated around the specified pivot
<span id="line13683" class="line"></span>     */
<span id="line13684" class="line"></span>    rotate: function (degrees, pivot) {
<span id="line13685" class="line"></span>        pivot = pivot || new $.Point(0, 0);
<span id="line13686" class="line"></span>        let cos;
<span id="line13687" class="line"></span>        let sin;
<span id="line13688" class="line"></span>        // Avoid float computations when possible
<span id="line13689" class="line"></span>        if (degrees % 90 === 0) {
<span id="line13690" class="line"></span>            const d = $.positiveModulo(degrees, 360);
<span id="line13691" class="line"></span>            switch (d) {
<span id="line13692" class="line"></span>                case 0:
<span id="line13693" class="line"></span>                    cos = 1;
<span id="line13694" class="line"></span>                    sin = 0;
<span id="line13695" class="line"></span>                    break;
<span id="line13696" class="line"></span>                case 90:
<span id="line13697" class="line"></span>                    cos = 0;
<span id="line13698" class="line"></span>                    sin = 1;
<span id="line13699" class="line"></span>                    break;
<span id="line13700" class="line"></span>                case 180:
<span id="line13701" class="line"></span>                    cos = -1;
<span id="line13702" class="line"></span>                    sin = 0;
<span id="line13703" class="line"></span>                    break;
<span id="line13704" class="line"></span>                case 270:
<span id="line13705" class="line"></span>                    cos = 0;
<span id="line13706" class="line"></span>                    sin = -1;
<span id="line13707" class="line"></span>                    break;
<span id="line13708" class="line"></span>            }
<span id="line13709" class="line"></span>        } else {
<span id="line13710" class="line"></span>            const angle = degrees * Math.PI / 180.0;
<span id="line13711" class="line"></span>            cos = Math.cos(angle);
<span id="line13712" class="line"></span>            sin = Math.sin(angle);
<span id="line13713" class="line"></span>        }
<span id="line13714" class="line"></span>        const x = cos * (this.x - pivot.x) - sin * (this.y - pivot.y) + pivot.x;
<span id="line13715" class="line"></span>        const y = sin * (this.x - pivot.x) + cos * (this.y - pivot.y) + pivot.y;
<span id="line13716" class="line"></span>        return new $.Point(x, y);
<span id="line13717" class="line"></span>    },
<span id="line13718" class="line"></span>
<span id="line13719" class="line"></span>    /**
<span id="line13720" class="line"></span>     * Convert this point to a string in the format (x,y) where x and y are
<span id="line13721" class="line"></span>     * rounded to the nearest integer.
<span id="line13722" class="line"></span>     * @function
<span id="line13723" class="line"></span>     * @returns {String} A string representation of this point.
<span id="line13724" class="line"></span>     */
<span id="line13725" class="line"></span>    toString: function() {
<span id="line13726" class="line"></span>        return "(" + (Math.round(this.x * 100) / 100) + "," + (Math.round(this.y * 100) / 100) + ")";
<span id="line13727" class="line"></span>    }
<span id="line13728" class="line"></span>};
<span id="line13729" class="line"></span>
<span id="line13730" class="line"></span>}( OpenSeadragon ));
<span id="line13731" class="line"></span>
<span id="line13732" class="line"></span>/*
<span id="line13733" class="line"></span> * OpenSeadragon - TileSource
<span id="line13734" class="line"></span> *
<span id="line13735" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line13736" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line13737" class="line"></span> *
<span id="line13738" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line13739" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line13740" class="line"></span> * met:
<span id="line13741" class="line"></span> *
<span id="line13742" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line13743" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line13744" class="line"></span> *
<span id="line13745" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line13746" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line13747" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line13748" class="line"></span> *
<span id="line13749" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line13750" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line13751" class="line"></span> *   this software without specific prior written permission.
<span id="line13752" class="line"></span> *
<span id="line13753" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line13754" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line13755" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line13756" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line13757" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line13758" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line13759" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line13760" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line13761" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line13762" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line13763" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line13764" class="line"></span> */
<span id="line13765" class="line"></span>
<span id="line13766" class="line"></span>(function( $ ){
<span id="line13767" class="line"></span>
<span id="line13768" class="line"></span>
<span id="line13769" class="line"></span>/**
<span id="line13770" class="line"></span> * @typedef {Object} OpenSeadragon.TileSourceOptions
<span id="line13771" class="line"></span> * @property {String} [options.url]
<span id="line13772" class="line"></span> *      The URL for the data necessary for this TileSource.
<span id="line13773" class="line"></span> * @property {String} [options.referenceStripThumbnailUrl]
<span id="line13774" class="line"></span> *      The URL for a thumbnail image to be used by the reference strip
<span id="line13775" class="line"></span> * @property {Function} [options.success]
<span id="line13776" class="line"></span> *      A function to be called upon successful creation.
<span id="line13777" class="line"></span> * @property {Boolean} [options.ajaxWithCredentials]
<span id="line13778" class="line"></span> *      If this TileSource needs to make an AJAX call, this specifies whether to set
<span id="line13779" class="line"></span> *      the XHR's withCredentials (for accessing secure data).
<span id="line13780" class="line"></span> * @property {Object} [options.ajaxHeaders]
<span id="line13781" class="line"></span> *      A set of headers to include in AJAX requests.
<span id="line13782" class="line"></span> * @property {Boolean} [options.splitHashDataForPost]
<span id="line13783" class="line"></span> *      First occurrence of '#' in the options.url is used to split URL
<span id="line13784" class="line"></span> *      and the latter part is treated as POST data (applies to getImageInfo(...))
<span id="line13785" class="line"></span> *      Does not work if getImageInfo() is overridden and used (see the options description)
<span id="line13786" class="line"></span> * @property {Number} [options.width]
<span id="line13787" class="line"></span> *      Width of the source image at max resolution in pixels.
<span id="line13788" class="line"></span> * @property {Number} [options.height]
<span id="line13789" class="line"></span> *      Height of the source image at max resolution in pixels.
<span id="line13790" class="line"></span> * @property {Number} [options.tileSize]
<span id="line13791" class="line"></span> *      The size of the tiles to assumed to make up each pyramid layer in pixels.
<span id="line13792" class="line"></span> *      Tile size determines the point at which the image pyramid must be
<span id="line13793" class="line"></span> *      divided into a matrix of smaller images.
<span id="line13794" class="line"></span> *      Use options.tileWidth and options.tileHeight to support non-square tiles.
<span id="line13795" class="line"></span> * @property {Number} [options.tileWidth]
<span id="line13796" class="line"></span> *      The width of the tiles to assumed to make up each pyramid layer in pixels.
<span id="line13797" class="line"></span> * @property {Number} [options.tileHeight]
<span id="line13798" class="line"></span> *      The height of the tiles to assumed to make up each pyramid layer in pixels.
<span id="line13799" class="line"></span> * @property {Number} [options.tileOverlap]
<span id="line13800" class="line"></span> *      The number of pixels each tile is expected to overlap touching tiles.
<span id="line13801" class="line"></span> * @property {Number} [options.minLevel]
<span id="line13802" class="line"></span> *      The minimum level to attempt to load.
<span id="line13803" class="line"></span> * @property {Number} [options.maxLevel]
<span id="line13804" class="line"></span> *      The maximum level to attempt to load.
<span id="line13805" class="line"></span> * @property {Boolean} [options.ready=true]
<span id="line13806" class="line"></span> *      If true, the event 'ready' is called immediately after the TileSource is created.
<span id="line13807" class="line"></span> *      This is important because some flows rely on immediate initialization, which
<span id="line13808" class="line"></span> *      computes additional properties like dimensions or aspect ratio.
<span id="line13809" class="line"></span> *
<span id="line13810" class="line"></span> *
<span id="line13811" class="line"></span> *      TODO: could be removed completely:
<span id="line13812" class="line"></span> *        - do not use Tiled Image's getImageInfo, implement it separately
<span id="line13813" class="line"></span> *        - call getImageInfo as perviously, by default just call raiseEvent('ready', { tileSource: this })
<span id="line13814" class="line"></span> */
<span id="line13815" class="line"></span>
<span id="line13816" class="line"></span>/**
<span id="line13817" class="line"></span> * @class TileSource
<span id="line13818" class="line"></span> * @classdesc The TileSource contains the most basic implementation required to create a
<span id="line13819" class="line"></span> * smooth transition between layers in an image pyramid. It has only a single key
<span id="line13820" class="line"></span> * interface that must be implemented to complete its key functionality:
<span id="line13821" class="line"></span> * 'getTileUrl'.  It also has several optional interfaces that can be
<span id="line13822" class="line"></span> * implemented if a new TileSource wishes to support configuration via a simple
<span id="line13823" class="line"></span> * object or array ('configure') and if the tile source supports or requires
<span id="line13824" class="line"></span> * configuration via retrieval of a document on the network ala AJAX or JSONP,
<span id="line13825" class="line"></span> * ('getImageInfo').
<span id="line13826" class="line"></span> * &lt;br/&gt;
<span id="line13827" class="line"></span> * By default the image pyramid is split into N layers where the image's longest
<span id="line13828" class="line"></span> * side in M (in pixels), where N is the smallest integer which satisfies
<span id="line13829" class="line"></span> *      &lt;strong&gt;2^(N+1) &gt;= M&lt;/strong&gt;.
<span id="line13830" class="line"></span> *
<span id="line13831" class="line"></span> * @memberof OpenSeadragon
<span id="line13832" class="line"></span> * @extends OpenSeadragon.EventSource
<span id="line13833" class="line"></span> * @param {OpenSeadragon.TileSourceOptions|string} options
<span id="line13834" class="line"></span> *      You can either specify a URL, or literally define the TileSource (by specifying
<span id="line13835" class="line"></span> *      width, height, tileSize, tileOverlap, minLevel, and maxLevel). For the former,
<span id="line13836" class="line"></span> *      the extending class is expected to implement 'supports' and 'configure'.
<span id="line13837" class="line"></span> *      Note that _in this case, the child class of getImageInfo() is ignored!_
<span id="line13838" class="line"></span> *      For the latter, the construction is assumed to occur through
<span id="line13839" class="line"></span> *      the extending classes implementation of 'configure'.
<span id="line13840" class="line"></span> */
<span id="line13841" class="line"></span>$.TileSource = function( options ) {
<span id="line13842" class="line"></span>
<span id="line13843" class="line"></span>    // NOTE! Manually rewriting this to a class syntax is problematic, since apply(...) would have to be overridden
<span id="line13844" class="line"></span>    //   static apply( target, args ) {...}
<span id="line13845" class="line"></span>    // and check if target inherits TileSource and if not, copy all props to the __proto__ of the target
<span id="line13846" class="line"></span>    $.EventSource.apply( this );
<span id="line13847" class="line"></span>
<span id="line13848" class="line"></span>
<span id="line13849" class="line"></span>    /**
<span id="line13850" class="line"></span>     * The URL of the image to be loaded. Can be undefined if the configuration happened
<span id="line13851" class="line"></span>     * via plain object or class injection
<span id="line13852" class="line"></span>     * @member {String} url
<span id="line13853" class="line"></span>     * @memberof OpenSeadragon.TileSource#
<span id="line13854" class="line"></span>     */
<span id="line13855" class="line"></span>    this.url = null;
<span id="line13856" class="line"></span>    /**
<span id="line13857" class="line"></span>     * Ratio of width to height
<span id="line13858" class="line"></span>     * @member {Number} aspectRatio
<span id="line13859" class="line"></span>     * @memberof OpenSeadragon.TileSource#
<span id="line13860" class="line"></span>     */
<span id="line13861" class="line"></span>    /**
<span id="line13862" class="line"></span>     * Vector storing x and y dimensions ( width and height respectively ).
<span id="line13863" class="line"></span>     * @member {OpenSeadragon.Point} dimensions
<span id="line13864" class="line"></span>     * @memberof OpenSeadragon.TileSource#
<span id="line13865" class="line"></span>     */
<span id="line13866" class="line"></span>    /**
<span id="line13867" class="line"></span>     * The overlap in pixels each tile shares with its adjacent neighbors.
<span id="line13868" class="line"></span>     * @member {Number} tileOverlap
<span id="line13869" class="line"></span>     * @memberof OpenSeadragon.TileSource#
<span id="line13870" class="line"></span>     */
<span id="line13871" class="line"></span>    /**
<span id="line13872" class="line"></span>     * The minimum pyramid level this tile source supports or should attempt to load.
<span id="line13873" class="line"></span>     * @member {Number} minLevel
<span id="line13874" class="line"></span>     * @memberof OpenSeadragon.TileSource#
<span id="line13875" class="line"></span>     */
<span id="line13876" class="line"></span>    /**
<span id="line13877" class="line"></span>     * The maximum pyramid level this tile source supports or should attempt to load.
<span id="line13878" class="line"></span>     * @member {Number} maxLevel
<span id="line13879" class="line"></span>     * @memberof OpenSeadragon.TileSource#
<span id="line13880" class="line"></span>     */
<span id="line13881" class="line"></span>    /**
<span id="line13882" class="line"></span>     *
<span id="line13883" class="line"></span>     * @member {Boolean} ready
<span id="line13884" class="line"></span>     * @memberof OpenSeadragon.TileSource#
<span id="line13885" class="line"></span>     */
<span id="line13886" class="line"></span>
<span id="line13887" class="line"></span>    this.addHandler('ready', e =&gt; {
<span id="line13888" class="line"></span>        const source = e.tileSource;
<span id="line13889" class="line"></span>        //explicit configuration via positional args in constructor
<span id="line13890" class="line"></span>        //or the more idiomatic 'options' object
<span id="line13891" class="line"></span>        this.ready       = true;
<span id="line13892" class="line"></span>        this.aspectRatio = (source.width &amp;&amp; source.height) ?
<span id="line13893" class="line"></span>            (source.width / source.height) : 1;
<span id="line13894" class="line"></span>        this.dimensions  = new $.Point( source.width, source.height );
<span id="line13895" class="line"></span>
<span id="line13896" class="line"></span>        if ( source.tileSize ){
<span id="line13897" class="line"></span>            this._tileWidth = this._tileHeight = source.tileSize;
<span id="line13898" class="line"></span>            delete this.tileSize;
<span id="line13899" class="line"></span>        } else {
<span id="line13900" class="line"></span>            if( source.tileWidth ){
<span id="line13901" class="line"></span>                // We were passed tileWidth in options, but we want to rename it
<span id="line13902" class="line"></span>                // with a leading underscore to make clear that it is not safe to directly modify it
<span id="line13903" class="line"></span>                this._tileWidth = source.tileWidth;
<span id="line13904" class="line"></span>                delete this.tileWidth;
<span id="line13905" class="line"></span>            } else {
<span id="line13906" class="line"></span>                this._tileWidth = 0;
<span id="line13907" class="line"></span>            }
<span id="line13908" class="line"></span>
<span id="line13909" class="line"></span>            if( source.tileHeight ){
<span id="line13910" class="line"></span>                // See note above about renaming this.tileWidth
<span id="line13911" class="line"></span>                this._tileHeight = source.tileHeight;
<span id="line13912" class="line"></span>                delete this.tileHeight;
<span id="line13913" class="line"></span>            } else {
<span id="line13914" class="line"></span>                this._tileHeight = 0;
<span id="line13915" class="line"></span>            }
<span id="line13916" class="line"></span>        }
<span id="line13917" class="line"></span>
<span id="line13918" class="line"></span>        this.tileOverlap = source.tileOverlap ? source.tileOverlap : 0;
<span id="line13919" class="line"></span>        this.minLevel    = source.minLevel ? source.minLevel : 0;
<span id="line13920" class="line"></span>        this.maxLevel    = ( undefined !== source.maxLevel &amp;&amp; null !== source.maxLevel ) ?
<span id="line13921" class="line"></span>            source.maxLevel : (
<span id="line13922" class="line"></span>                ( source.width &amp;&amp; source.height ) ? Math.ceil(
<span id="line13923" class="line"></span>                    Math.log( Math.max( source.width, source.height ) ) /
<span id="line13924" class="line"></span>                    Math.log( 2 )
<span id="line13925" class="line"></span>                ) : 0
<span id="line13926" class="line"></span>            );
<span id="line13927" class="line"></span>        if( source.success &amp;&amp; $.isFunction( source.success ) ){
<span id="line13928" class="line"></span>            source.success( this );
<span id="line13929" class="line"></span>        }
<span id="line13930" class="line"></span>    }, null, Infinity); // important! go first to finish initialization
<span id="line13931" class="line"></span>
<span id="line13932" class="line"></span>    if( 'string' === $.type( options ) ){
<span id="line13933" class="line"></span>        this.url = options;
<span id="line13934" class="line"></span>        options = undefined;
<span id="line13935" class="line"></span>    } else {
<span id="line13936" class="line"></span>        //we allow options to override anything we don't treat as
<span id="line13937" class="line"></span>        //required via idiomatic options or which is functionally
<span id="line13938" class="line"></span>        //set depending on the state of the readiness of this tile
<span id="line13939" class="line"></span>        //source
<span id="line13940" class="line"></span>        $.extend( true, this, options );
<span id="line13941" class="line"></span>    }
<span id="line13942" class="line"></span>
<span id="line13943" class="line"></span>    if (this.url &amp;&amp; !this.ready) {
<span id="line13944" class="line"></span>        //in case the getImageInfo method is overridden and/or implies an
<span id="line13945" class="line"></span>        //async mechanism set some safe defaults first
<span id="line13946" class="line"></span>        this.aspectRatio = 1;
<span id="line13947" class="line"></span>        this.dimensions  = new $.Point( 10, 10 );
<span id="line13948" class="line"></span>        this._tileWidth  = 0;
<span id="line13949" class="line"></span>        this._tileHeight = 0;
<span id="line13950" class="line"></span>        this.tileOverlap = 0;
<span id="line13951" class="line"></span>        this.minLevel    = 0;
<span id="line13952" class="line"></span>        this.maxLevel    = 0;
<span id="line13953" class="line"></span>        this.ready       = false;
<span id="line13954" class="line"></span>        this._uniqueIdentifier = this.url;
<span id="line13955" class="line"></span>        //configuration via url implies the extending class
<span id="line13956" class="line"></span>        //implements and 'configure'
<span id="line13957" class="line"></span>        setTimeout(() =&gt; this.getImageInfo(this.url)); //needs async in case someone exits immediately
<span id="line13958" class="line"></span>    } else {
<span id="line13959" class="line"></span>        this._uniqueIdentifier = Math.floor(Math.random() * 1e10).toString(36);
<span id="line13960" class="line"></span>        // by default it used to fire immediately, so make the ready default
<span id="line13961" class="line"></span>        if (this.ready || this.ready === undefined) {
<span id="line13962" class="line"></span>            this.raiseEvent('ready', { tileSource: this });
<span id="line13963" class="line"></span>        } else {
<span id="line13964" class="line"></span>            setTimeout(() =&gt; this.raiseEvent('ready', { tileSource: this }));
<span id="line13965" class="line"></span>        }
<span id="line13966" class="line"></span>    }
<span id="line13967" class="line"></span>    return this;
<span id="line13968" class="line"></span>};
<span id="line13969" class="line"></span>
<span id="line13970" class="line"></span>/** @lends OpenSeadragon.TileSource.prototype */
<span id="line13971" class="line"></span>$.TileSource.prototype = {
<span id="line13972" class="line"></span>
<span id="line13973" class="line"></span>    getTileSize: function( level ) {
<span id="line13974" class="line"></span>        $.console.error(
<span id="line13975" class="line"></span>            "[TileSource.getTileSize] is deprecated. " +
<span id="line13976" class="line"></span>            "Use TileSource.getTileWidth() and TileSource.getTileHeight() instead"
<span id="line13977" class="line"></span>        );
<span id="line13978" class="line"></span>        return this._tileWidth;
<span id="line13979" class="line"></span>    },
<span id="line13980" class="line"></span>
<span id="line13981" class="line"></span>    /**
<span id="line13982" class="line"></span>     * Return the tileWidth for a given level.
<span id="line13983" class="line"></span>     * Subclasses should override this if tileWidth can be different at different levels
<span id="line13984" class="line"></span>     *   such as in IIIFTileSource.  Code should use this function rather than reading
<span id="line13985" class="line"></span>     *   from ._tileWidth directly.
<span id="line13986" class="line"></span>     * @function
<span id="line13987" class="line"></span>     * @param {Number} level
<span id="line13988" class="line"></span>     */
<span id="line13989" class="line"></span>    getTileWidth: function( level ) {
<span id="line13990" class="line"></span>        if (!this._tileWidth) {
<span id="line13991" class="line"></span>            return this.getTileSize(level);
<span id="line13992" class="line"></span>        }
<span id="line13993" class="line"></span>        return this._tileWidth;
<span id="line13994" class="line"></span>    },
<span id="line13995" class="line"></span>
<span id="line13996" class="line"></span>    /**
<span id="line13997" class="line"></span>     * Return the tileHeight for a given level.
<span id="line13998" class="line"></span>     * Subclasses should override this if tileHeight can be different at different levels
<span id="line13999" class="line"></span>     *   such as in IIIFTileSource.  Code should use this function rather than reading
<span id="line14000" class="line"></span>     *   from ._tileHeight directly.
<span id="line14001" class="line"></span>     * @function
<span id="line14002" class="line"></span>     * @param {Number} level
<span id="line14003" class="line"></span>     */
<span id="line14004" class="line"></span>    getTileHeight: function( level ) {
<span id="line14005" class="line"></span>        if (!this._tileHeight) {
<span id="line14006" class="line"></span>            return this.getTileSize(level);
<span id="line14007" class="line"></span>        }
<span id="line14008" class="line"></span>        return this._tileHeight;
<span id="line14009" class="line"></span>    },
<span id="line14010" class="line"></span>
<span id="line14011" class="line"></span>    /**
<span id="line14012" class="line"></span>     * Set the maxLevel to the given level, and perform the memoization of
<span id="line14013" class="line"></span>     * getLevelScale with the new maxLevel. This function can be useful if the
<span id="line14014" class="line"></span>     * memoization is required before the first call of getLevelScale, or both
<span id="line14015" class="line"></span>     * memoized getLevelScale and maxLevel should be changed accordingly.
<span id="line14016" class="line"></span>     * @function
<span id="line14017" class="line"></span>     * @param {Number} level
<span id="line14018" class="line"></span>     */
<span id="line14019" class="line"></span>    setMaxLevel: function( level ) {
<span id="line14020" class="line"></span>        this.maxLevel = level;
<span id="line14021" class="line"></span>        this._memoizeLevelScale();
<span id="line14022" class="line"></span>    },
<span id="line14023" class="line"></span>
<span id="line14024" class="line"></span>    /**
<span id="line14025" class="line"></span>     * @function
<span id="line14026" class="line"></span>     * @param {Number} level
<span id="line14027" class="line"></span>     */
<span id="line14028" class="line"></span>    getLevelScale: function( level ) {
<span id="line14029" class="line"></span>        // if getLevelScale is not memoized, we generate the memoized version
<span id="line14030" class="line"></span>        // at the first call and return the result
<span id="line14031" class="line"></span>        this._memoizeLevelScale();
<span id="line14032" class="line"></span>        return this.getLevelScale( level );
<span id="line14033" class="line"></span>    },
<span id="line14034" class="line"></span>
<span id="line14035" class="line"></span>    // private
<span id="line14036" class="line"></span>    _memoizeLevelScale: function() {
<span id="line14037" class="line"></span>        // see https://github.com/openseadragon/openseadragon/issues/22
<span id="line14038" class="line"></span>        // we use the tilesources implementation of getLevelScale to generate
<span id="line14039" class="line"></span>        // a memoized re-implementation
<span id="line14040" class="line"></span>        const levelScaleCache = {};
<span id="line14041" class="line"></span>        let i;
<span id="line14042" class="line"></span>        for( i = 0; i &lt;= this.maxLevel; i++ ){
<span id="line14043" class="line"></span>            levelScaleCache[ i ] = 1 / Math.pow(2, this.maxLevel - i);
<span id="line14044" class="line"></span>        }
<span id="line14045" class="line"></span>        this.getLevelScale = function( _level ){
<span id="line14046" class="line"></span>            return levelScaleCache[ _level ];
<span id="line14047" class="line"></span>        };
<span id="line14048" class="line"></span>    },
<span id="line14049" class="line"></span>
<span id="line14050" class="line"></span>    /**
<span id="line14051" class="line"></span>     * @function
<span id="line14052" class="line"></span>     * @param {Number} level
<span id="line14053" class="line"></span>     */
<span id="line14054" class="line"></span>    getNumTiles: function( level ) {
<span id="line14055" class="line"></span>        const scale = this.getLevelScale( level );
<span id="line14056" class="line"></span>        const x = Math.ceil( scale * this.dimensions.x / this.getTileWidth(level) );
<span id="line14057" class="line"></span>        const y = Math.ceil( scale * this.dimensions.y / this.getTileHeight(level) );
<span id="line14058" class="line"></span>
<span id="line14059" class="line"></span>        return new $.Point( x, y );
<span id="line14060" class="line"></span>    },
<span id="line14061" class="line"></span>
<span id="line14062" class="line"></span>    /**
<span id="line14063" class="line"></span>     * @function
<span id="line14064" class="line"></span>     * @param {Number} level
<span id="line14065" class="line"></span>     */
<span id="line14066" class="line"></span>    getPixelRatio: function( level ) {
<span id="line14067" class="line"></span>        const imageSizeScaled = this.dimensions.times( this.getLevelScale( level ) );
<span id="line14068" class="line"></span>        const rx = 1.0 / imageSizeScaled.x * $.pixelDensityRatio;
<span id="line14069" class="line"></span>        const ry = 1.0 / imageSizeScaled.y * $.pixelDensityRatio;
<span id="line14070" class="line"></span>
<span id="line14071" class="line"></span>        return new $.Point(rx, ry);
<span id="line14072" class="line"></span>    },
<span id="line14073" class="line"></span>
<span id="line14074" class="line"></span>
<span id="line14075" class="line"></span>    /**
<span id="line14076" class="line"></span>     * @function
<span id="line14077" class="line"></span>     * @returns {Number} The highest level in this tile source that can be contained in a single tile.
<span id="line14078" class="line"></span>     */
<span id="line14079" class="line"></span>    getClosestLevel: function() {
<span id="line14080" class="line"></span>        let i;
<span id="line14081" class="line"></span>        let tiles;
<span id="line14082" class="line"></span>
<span id="line14083" class="line"></span>        for (i = this.minLevel + 1; i &lt;= this.maxLevel; i++){
<span id="line14084" class="line"></span>            tiles = this.getNumTiles(i);
<span id="line14085" class="line"></span>            if (tiles.x &gt; 1 || tiles.y &gt; 1) {
<span id="line14086" class="line"></span>                break;
<span id="line14087" class="line"></span>            }
<span id="line14088" class="line"></span>        }
<span id="line14089" class="line"></span>
<span id="line14090" class="line"></span>        return i - 1;
<span id="line14091" class="line"></span>    },
<span id="line14092" class="line"></span>
<span id="line14093" class="line"></span>    /**
<span id="line14094" class="line"></span>     * @function
<span id="line14095" class="line"></span>     * @param {Number} level
<span id="line14096" class="line"></span>     * @param {OpenSeadragon.Point} point
<span id="line14097" class="line"></span>     */
<span id="line14098" class="line"></span>    getTileAtPoint: function(level, point) {
<span id="line14099" class="line"></span>        const validPoint = point.x &gt;= 0 &amp;&amp; point.x &lt;= 1 &amp;&amp;
<span id="line14100" class="line"></span>            point.y &gt;= 0 &amp;&amp; point.y &lt;= 1 / this.aspectRatio;
<span id="line14101" class="line"></span>        $.console.assert(validPoint, "[TileSource.getTileAtPoint] must be called with a valid point.");
<span id="line14102" class="line"></span>
<span id="line14103" class="line"></span>
<span id="line14104" class="line"></span>        const widthScaled = this.dimensions.x * this.getLevelScale(level);
<span id="line14105" class="line"></span>        const pixelX = point.x * widthScaled;
<span id="line14106" class="line"></span>        const pixelY = point.y * widthScaled;
<span id="line14107" class="line"></span>
<span id="line14108" class="line"></span>        let x = Math.floor(pixelX / this.getTileWidth(level));
<span id="line14109" class="line"></span>        let y = Math.floor(pixelY / this.getTileHeight(level));
<span id="line14110" class="line"></span>
<span id="line14111" class="line"></span>        // When point.x == 1 or point.y == 1 / this.aspectRatio we want to
<span id="line14112" class="line"></span>        // return the last tile of the row/column
<span id="line14113" class="line"></span>        if (point.x &gt;= 1) {
<span id="line14114" class="line"></span>            x = this.getNumTiles(level).x - 1;
<span id="line14115" class="line"></span>        }
<span id="line14116" class="line"></span>        const EPSILON = 1e-15;
<span id="line14117" class="line"></span>        if (point.y &gt;= 1 / this.aspectRatio - EPSILON) {
<span id="line14118" class="line"></span>            y = this.getNumTiles(level).y - 1;
<span id="line14119" class="line"></span>        }
<span id="line14120" class="line"></span>
<span id="line14121" class="line"></span>        return new $.Point(x, y);
<span id="line14122" class="line"></span>    },
<span id="line14123" class="line"></span>
<span id="line14124" class="line"></span>    /**
<span id="line14125" class="line"></span>     * @function
<span id="line14126" class="line"></span>     * @param {Number} level
<span id="line14127" class="line"></span>     * @param {Number} x
<span id="line14128" class="line"></span>     * @param {Number} y
<span id="line14129" class="line"></span>     * @param {Boolean} [isSource=false] Whether to return the source bounds of the tile.
<span id="line14130" class="line"></span>     * @returns {OpenSeadragon.Rect} Either where this tile fits (in normalized coordinates) or the
<span id="line14131" class="line"></span>     * portion of the tile to use as the source of the drawing operation (in pixels), depending on
<span id="line14132" class="line"></span>     * the isSource parameter.
<span id="line14133" class="line"></span>     */
<span id="line14134" class="line"></span>    getTileBounds: function( level, x, y, isSource ) {
<span id="line14135" class="line"></span>        const dimensionsScaled = this.dimensions.times( this.getLevelScale( level ) );
<span id="line14136" class="line"></span>        const tileWidth = this.getTileWidth(level);
<span id="line14137" class="line"></span>        const tileHeight = this.getTileHeight(level);
<span id="line14138" class="line"></span>        const px = ( x === 0 ) ? 0 : tileWidth * x - this.tileOverlap;
<span id="line14139" class="line"></span>        const py = ( y === 0 ) ? 0 : tileHeight * y - this.tileOverlap;
<span id="line14140" class="line"></span>        let sx = tileWidth + ( x === 0 ? 1 : 2 ) * this.tileOverlap;
<span id="line14141" class="line"></span>        let sy = tileHeight + ( y === 0 ? 1 : 2 ) * this.tileOverlap;
<span id="line14142" class="line"></span>        const scale = 1.0 / dimensionsScaled.x;
<span id="line14143" class="line"></span>
<span id="line14144" class="line"></span>        sx = Math.min( sx, dimensionsScaled.x - px );
<span id="line14145" class="line"></span>        sy = Math.min( sy, dimensionsScaled.y - py );
<span id="line14146" class="line"></span>
<span id="line14147" class="line"></span>        if (isSource) {
<span id="line14148" class="line"></span>            return new $.Rect(0, 0, sx, sy);
<span id="line14149" class="line"></span>        }
<span id="line14150" class="line"></span>
<span id="line14151" class="line"></span>        return new $.Rect( px * scale, py * scale, sx * scale, sy * scale );
<span id="line14152" class="line"></span>    },
<span id="line14153" class="line"></span>
<span id="line14154" class="line"></span>
<span id="line14155" class="line"></span>    /**
<span id="line14156" class="line"></span>     * Responsible for retrieving, and caching the
<span id="line14157" class="line"></span>     * image metadata pertinent to this TileSources implementation.
<span id="line14158" class="line"></span>     * There are three scenarios of opening a tile source: providing a parseable string, plain object, or an URL.
<span id="line14159" class="line"></span>     * This method is only called by OSD if the TileSource configuration is a non-parseable string (~url).
<span id="line14160" class="line"></span>     *
<span id="line14161" class="line"></span>     * Note: you can access the properties sent to the TileSource constructor via the options object
<span id="line14162" class="line"></span>     * directly on 'this' reference.
<span id="line14163" class="line"></span>     *
<span id="line14164" class="line"></span>     * The string can contain a hash `#` symbol, followed by
<span id="line14165" class="line"></span>     * key=value arguments. If this is the case, this method sends this
<span id="line14166" class="line"></span>     * data as a POST body.
<span id="line14167" class="line"></span>     *
<span id="line14168" class="line"></span>     * @function
<span id="line14169" class="line"></span>     * @param {String} url
<span id="line14170" class="line"></span>     * @throws {Error}
<span id="line14171" class="line"></span>     */
<span id="line14172" class="line"></span>    getImageInfo: function( url ) {
<span id="line14173" class="line"></span>        const _this = this;
<span id="line14174" class="line"></span>        let callbackName;
<span id="line14175" class="line"></span>        let callback;
<span id="line14176" class="line"></span>        let readySource;
<span id="line14177" class="line"></span>        let options;
<span id="line14178" class="line"></span>        let urlParts;
<span id="line14179" class="line"></span>        let filename;
<span id="line14180" class="line"></span>        let lastDot;
<span id="line14181" class="line"></span>
<span id="line14182" class="line"></span>
<span id="line14183" class="line"></span>        if( url ) {
<span id="line14184" class="line"></span>            urlParts = url.split( '/' );
<span id="line14185" class="line"></span>            filename = urlParts[ urlParts.length - 1 ];
<span id="line14186" class="line"></span>            lastDot  = filename.lastIndexOf( '.' );
<span id="line14187" class="line"></span>            if ( lastDot &gt; -1 ) {
<span id="line14188" class="line"></span>                urlParts[ urlParts.length - 1 ] = filename.slice( 0, lastDot );
<span id="line14189" class="line"></span>            }
<span id="line14190" class="line"></span>        }
<span id="line14191" class="line"></span>
<span id="line14192" class="line"></span>        let postData = null;
<span id="line14193" class="line"></span>        if (this.splitHashDataForPost) {
<span id="line14194" class="line"></span>            const hashIdx = url.indexOf("#");
<span id="line14195" class="line"></span>            if (hashIdx !== -1) {
<span id="line14196" class="line"></span>                postData = url.substring(hashIdx + 1);
<span id="line14197" class="line"></span>                url = url.substr(0, hashIdx);
<span id="line14198" class="line"></span>            }
<span id="line14199" class="line"></span>        }
<span id="line14200" class="line"></span>
<span id="line14201" class="line"></span>        callback = function( data ){
<span id="line14202" class="line"></span>            if( typeof (data) === "string" ) {
<span id="line14203" class="line"></span>                data = $.parseXml( data );
<span id="line14204" class="line"></span>            }
<span id="line14205" class="line"></span>            const $TileSource = $.TileSource.determineType( _this, data, url );
<span id="line14206" class="line"></span>            if ( !$TileSource ) {
<span id="line14207" class="line"></span>                /**
<span id="line14208" class="line"></span>                 * Raised when an error occurs loading a TileSource.
<span id="line14209" class="line"></span>                 *
<span id="line14210" class="line"></span>                 * @event open-failed
<span id="line14211" class="line"></span>                 * @memberof OpenSeadragon.TileSource
<span id="line14212" class="line"></span>                 * @type {object}
<span id="line14213" class="line"></span>                 * @property {OpenSeadragon.TileSource} eventSource - A reference to the TileSource which raised the event.
<span id="line14214" class="line"></span>                 * @property {String} message
<span id="line14215" class="line"></span>                 * @property {String} source
<span id="line14216" class="line"></span>                 * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line14217" class="line"></span>                 */
<span id="line14218" class="line"></span>                _this.raiseEvent( 'open-failed', { message: "Unable to load TileSource", source: url } );
<span id="line14219" class="line"></span>                return;
<span id="line14220" class="line"></span>            }
<span id="line14221" class="line"></span>
<span id="line14222" class="line"></span>            options = $TileSource.prototype.configure.apply( _this, [ data, url, postData ]);
<span id="line14223" class="line"></span>            if (options.ajaxWithCredentials === undefined) {
<span id="line14224" class="line"></span>                options.ajaxWithCredentials = _this.ajaxWithCredentials;
<span id="line14225" class="line"></span>            }
<span id="line14226" class="line"></span>
<span id="line14227" class="line"></span>            options.ready = true;  // force synchronous finish
<span id="line14228" class="line"></span>            readySource = new $TileSource( options );
<span id="line14229" class="line"></span>            _this.ready = true;
<span id="line14230" class="line"></span>            /**
<span id="line14231" class="line"></span>             * Raised when a TileSource is opened and initialized.
<span id="line14232" class="line"></span>             *
<span id="line14233" class="line"></span>             * @event ready
<span id="line14234" class="line"></span>             * @memberof OpenSeadragon.TileSource
<span id="line14235" class="line"></span>             * @type {object}
<span id="line14236" class="line"></span>             * @property {OpenSeadragon.TileSource} eventSource - A reference to the TileSource which raised the event.
<span id="line14237" class="line"></span>             * @property {Object} tileSource
<span id="line14238" class="line"></span>             * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line14239" class="line"></span>             */
<span id="line14240" class="line"></span>            _this.raiseEvent( 'ready', { tileSource: readySource } );
<span id="line14241" class="line"></span>        };
<span id="line14242" class="line"></span>
<span id="line14243" class="line"></span>        if( url.match(/\.js$/) ){
<span id="line14244" class="line"></span>            //TODO: Its not very flexible to require tile sources to end jsonp
<span id="line14245" class="line"></span>            //      request for info  with a url that ends with '.js' but for
<span id="line14246" class="line"></span>            //      now it's the only way I see to distinguish uniformly.
<span id="line14247" class="line"></span>            callbackName = url.split('/').pop().replace('.js', '');
<span id="line14248" class="line"></span>            $.jsonp({
<span id="line14249" class="line"></span>                url: url,
<span id="line14250" class="line"></span>                async: false,
<span id="line14251" class="line"></span>                callbackName: callbackName,
<span id="line14252" class="line"></span>                callback: callback
<span id="line14253" class="line"></span>            });
<span id="line14254" class="line"></span>        } else {
<span id="line14255" class="line"></span>            // request info via xhr asynchronously.
<span id="line14256" class="line"></span>            $.makeAjaxRequest( {
<span id="line14257" class="line"></span>                url: url,
<span id="line14258" class="line"></span>                postData: postData,
<span id="line14259" class="line"></span>                withCredentials: this.ajaxWithCredentials,
<span id="line14260" class="line"></span>                headers: this.ajaxHeaders,
<span id="line14261" class="line"></span>                success: function( xhr ) {
<span id="line14262" class="line"></span>                    const data = processResponse( xhr );
<span id="line14263" class="line"></span>                    callback( data );
<span id="line14264" class="line"></span>                },
<span id="line14265" class="line"></span>                error: function ( xhr, exc ) {
<span id="line14266" class="line"></span>                    let msg;
<span id="line14267" class="line"></span>
<span id="line14268" class="line"></span>                    /*
<span id="line14269" class="line"></span>                        IE &lt; 10 will block XHR requests to different origins. Any property access on the request
<span id="line14270" class="line"></span>                        object will raise an exception which we'll attempt to handle by formatting the original
<span id="line14271" class="line"></span>                        exception rather than the second one raised when we try to access xhr.status
<span id="line14272" class="line"></span>                     */
<span id="line14273" class="line"></span>                    try {
<span id="line14274" class="line"></span>                        msg = "HTTP " + xhr.status + " attempting to load TileSource: " + url;
<span id="line14275" class="line"></span>                    } catch ( e ) {
<span id="line14276" class="line"></span>                        let formattedExc;
<span id="line14277" class="line"></span>                        if ( typeof ( exc ) === "undefined" || !exc.toString ) {
<span id="line14278" class="line"></span>                            formattedExc = "Unknown error";
<span id="line14279" class="line"></span>                        } else {
<span id="line14280" class="line"></span>                            formattedExc = exc.toString();
<span id="line14281" class="line"></span>                        }
<span id="line14282" class="line"></span>
<span id="line14283" class="line"></span>                        msg = formattedExc + " attempting to load TileSource: " + url;
<span id="line14284" class="line"></span>                    }
<span id="line14285" class="line"></span>
<span id="line14286" class="line"></span>                    $.console.error(msg);
<span id="line14287" class="line"></span>
<span id="line14288" class="line"></span>                    /***
<span id="line14289" class="line"></span>                     * Raised when an error occurs loading a TileSource.
<span id="line14290" class="line"></span>                     *
<span id="line14291" class="line"></span>                     * @event open-failed
<span id="line14292" class="line"></span>                     * @memberof OpenSeadragon.TileSource
<span id="line14293" class="line"></span>                     * @type {object}
<span id="line14294" class="line"></span>                     * @property {OpenSeadragon.TileSource} eventSource - A reference to the TileSource which raised the event.
<span id="line14295" class="line"></span>                     * @property {String} message
<span id="line14296" class="line"></span>                     * @property {String} source
<span id="line14297" class="line"></span>                     * @property {String} postData - HTTP POST data (usually but not necessarily in k=v&amp;k2=v2... form,
<span id="line14298" class="line"></span>                     *      see TileSource::getTilePostData) or null
<span id="line14299" class="line"></span>                     * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line14300" class="line"></span>                     */
<span id="line14301" class="line"></span>                    _this.raiseEvent( 'open-failed', {
<span id="line14302" class="line"></span>                        message: msg,
<span id="line14303" class="line"></span>                        source: url,
<span id="line14304" class="line"></span>                        postData: postData
<span id="line14305" class="line"></span>                    });
<span id="line14306" class="line"></span>                }
<span id="line14307" class="line"></span>            });
<span id="line14308" class="line"></span>        }
<span id="line14309" class="line"></span>
<span id="line14310" class="line"></span>    },
<span id="line14311" class="line"></span>
<span id="line14312" class="line"></span>    /**
<span id="line14313" class="line"></span>     * Responsible for determining if the particular TileSource supports the
<span id="line14314" class="line"></span>     * data format ( and allowed to apply logic against the url the data was
<span id="line14315" class="line"></span>     * loaded from, if any ). Overriding implementations are expected to do
<span id="line14316" class="line"></span>     * something smart with data and / or url to determine support.  Also
<span id="line14317" class="line"></span>     * understand that iteration order of TileSources is not guaranteed so
<span id="line14318" class="line"></span>     * please make sure your data or url is expressive enough to ensure a simple
<span id="line14319" class="line"></span>     * and sufficient mechanism for clear determination.
<span id="line14320" class="line"></span>     * @function
<span id="line14321" class="line"></span>     * @param {String|Object|Array|Document} data
<span id="line14322" class="line"></span>     * @param {String} url - the url the data was loaded
<span id="line14323" class="line"></span>     *      from if any.
<span id="line14324" class="line"></span>     * @returns {Boolean}
<span id="line14325" class="line"></span>     */
<span id="line14326" class="line"></span>    supports: function( data, url ) {
<span id="line14327" class="line"></span>        return false;
<span id="line14328" class="line"></span>    },
<span id="line14329" class="line"></span>
<span id="line14330" class="line"></span>    /**
<span id="line14331" class="line"></span>     * Check whether two tileSources are equal. This is used for example
<span id="line14332" class="line"></span>     * when replacing tile-sources, which turns on the zombie cache before
<span id="line14333" class="line"></span>     * old item removal.
<span id="line14334" class="line"></span>     * @param {OpenSeadragon.TileSource} otherSource
<span id="line14335" class="line"></span>     * @returns {Boolean}
<span id="line14336" class="line"></span>     */
<span id="line14337" class="line"></span>    equals: function (otherSource) {
<span id="line14338" class="line"></span>        return this === otherSource;
<span id="line14339" class="line"></span>    },
<span id="line14340" class="line"></span>
<span id="line14341" class="line"></span>    /**
<span id="line14342" class="line"></span>     * Determines if this tile source data can be batched.
<span id="line14343" class="line"></span>     * @return {boolean}
<span id="line14344" class="line"></span>     */
<span id="line14345" class="line"></span>    batchEnabled() {
<span id="line14346" class="line"></span>        return false;
<span id="line14347" class="line"></span>    },
<span id="line14348" class="line"></span>
<span id="line14349" class="line"></span>    /**
<span id="line14350" class="line"></span>     * Determines if a tile request from a source (even itself!) can be batched with this source.
<span id="line14351" class="line"></span>     * By default, returns false -&gt; in this case, each tile falls to a single bucket alone.
<span id="line14352" class="line"></span>     * @param {OpenSeadragon.TileSource} otherSource
<span id="line14353" class="line"></span>     * @return {boolean}
<span id="line14354" class="line"></span>     */
<span id="line14355" class="line"></span>    batchCompatible(otherSource) {
<span id="line14356" class="line"></span>        return false;
<span id="line14357" class="line"></span>    },
<span id="line14358" class="line"></span>
<span id="line14359" class="line"></span>    /**
<span id="line14360" class="line"></span>     * Maximum batch size. Can, for example, be derived from (average) tile size of the source.
<span id="line14361" class="line"></span>     * @return {number} integer, number of max jobs per batch
<span id="line14362" class="line"></span>     */
<span id="line14363" class="line"></span>    batchMaxJobs() {
<span id="line14364" class="line"></span>        return -1;
<span id="line14365" class="line"></span>    },
<span id="line14366" class="line"></span>
<span id="line14367" class="line"></span>    /**
<span id="line14368" class="line"></span>     * How long to wait with a batch before processing. Big timeout means larger
<span id="line14369" class="line"></span>     * batches with fewer requests, at the cost of slower loading.
<span id="line14370" class="line"></span>     * @return {number} milliseconds to wait for tiles to be added to the batch before processing
<span id="line14371" class="line"></span>     */
<span id="line14372" class="line"></span>    batchTimeout() {
<span id="line14373" class="line"></span>        return 5;
<span id="line14374" class="line"></span>    },
<span id="line14375" class="line"></span>
<span id="line14376" class="line"></span>    /**
<span id="line14377" class="line"></span>     * Responsible for parsing and configuring the
<span id="line14378" class="line"></span>     * image metadata pertinent to this TileSources implementation.
<span id="line14379" class="line"></span>     * This method is not implemented by this class other than to throw an Error
<span id="line14380" class="line"></span>     * announcing you have to implement it.  Because of the variety of tile
<span id="line14381" class="line"></span>     * server technologies, and various specifications for building image
<span id="line14382" class="line"></span>     * pyramids, this method is here to allow easy integration.
<span id="line14383" class="line"></span>     * @function
<span id="line14384" class="line"></span>     * @param {String|Object|Array|Document} data
<span id="line14385" class="line"></span>     * @param {String} url - the url the data was loaded
<span id="line14386" class="line"></span>     *      from if any.
<span id="line14387" class="line"></span>     * @param {String} postData - HTTP POST data in k=v&amp;k2=v2... form or null value obtained from
<span id="line14388" class="line"></span>     *      the protocol URL after '#' sign if flag splitHashDataForPost set to 'true'
<span id="line14389" class="line"></span>     * @returns {Object} options - A dictionary of keyword arguments sufficient
<span id="line14390" class="line"></span>     *      to configure the tile source constructor (include all values you want to
<span id="line14391" class="line"></span>     *      instantiate the TileSource subclass with - what _options_ object should contain).
<span id="line14392" class="line"></span>     * @throws {Error}
<span id="line14393" class="line"></span>     */
<span id="line14394" class="line"></span>    configure: function( data, url, postData ) {
<span id="line14395" class="line"></span>        throw new Error( "Method not implemented." );
<span id="line14396" class="line"></span>    },
<span id="line14397" class="line"></span>
<span id="line14398" class="line"></span>    /**
<span id="line14399" class="line"></span>     * Shall this source need to free some objects
<span id="line14400" class="line"></span>     * upon unloading, it must be done here. For example, canvas
<span id="line14401" class="line"></span>     * size must be set to 0 for safari to free.
<span id="line14402" class="line"></span>     * @param {OpenSeadragon.Viewer} viewer
<span id="line14403" class="line"></span>     */
<span id="line14404" class="line"></span>    destroy: function ( viewer ) {
<span id="line14405" class="line"></span>        //no-op
<span id="line14406" class="line"></span>    },
<span id="line14407" class="line"></span>
<span id="line14408" class="line"></span>    /**
<span id="line14409" class="line"></span>     * Responsible for retrieving the url which will return an image for the
<span id="line14410" class="line"></span>     * region specified by the given x, y, and level components.
<span id="line14411" class="line"></span>     * This method is not implemented by this class other than to throw an Error
<span id="line14412" class="line"></span>     * announcing you have to implement it.  Because of the variety of tile
<span id="line14413" class="line"></span>     * server technologies, and various specifications for building image
<span id="line14414" class="line"></span>     * pyramids, this method is here to allow easy integration.
<span id="line14415" class="line"></span>     * @function
<span id="line14416" class="line"></span>     * @param {Number} level
<span id="line14417" class="line"></span>     * @param {Number} x
<span id="line14418" class="line"></span>     * @param {Number} y
<span id="line14419" class="line"></span>     * @returns {String|Function} url - A string for the url or a function that returns a url string.
<span id="line14420" class="line"></span>     * @throws {Error}
<span id="line14421" class="line"></span>     */
<span id="line14422" class="line"></span>    getTileUrl: function( level, x, y ) {
<span id="line14423" class="line"></span>        throw new Error( "Method not implemented." );
<span id="line14424" class="line"></span>    },
<span id="line14425" class="line"></span>
<span id="line14426" class="line"></span>    /**
<span id="line14427" class="line"></span>     * Must use AJAX in order to work, i.e. loadTilesWithAjax = true is set.
<span id="line14428" class="line"></span>     * If a value is returned, ajax issues POST request to the tile url.
<span id="line14429" class="line"></span>     * If null is returned, ajax issues GET request.
<span id="line14430" class="line"></span>     * The return value must comply to the header 'content type'.
<span id="line14431" class="line"></span>     *
<span id="line14432" class="line"></span>     * Examples (USED HEADER --&gt; getTilePostData CODE):
<span id="line14433" class="line"></span>     * 'Content-type': 'application/x-www-form-urlencoded' --&gt;
<span id="line14434" class="line"></span>     *   return "key1=value=1&amp;key2=value2";
<span id="line14435" class="line"></span>     *
<span id="line14436" class="line"></span>     * 'Content-type': 'application/x-www-form-urlencoded' --&gt;
<span id="line14437" class="line"></span>     *   return JSON.stringify({key: "value", number: 5});
<span id="line14438" class="line"></span>     *
<span id="line14439" class="line"></span>     * 'Content-type': 'multipart/form-data' --&gt;
<span id="line14440" class="line"></span>     *   let result = new FormData();
<span id="line14441" class="line"></span>     *   result.append("data", myData);
<span id="line14442" class="line"></span>     *   return result;
<span id="line14443" class="line"></span>     *
<span id="line14444" class="line"></span>     * IMPORTANT: in case you move all the logic on image fetching
<span id="line14445" class="line"></span>     * to post data, you must re-define 'getTileHashKey(...)' to
<span id="line14446" class="line"></span>     * stay unique for different tile images.
<span id="line14447" class="line"></span>     *
<span id="line14448" class="line"></span>     * @param {Number} level
<span id="line14449" class="line"></span>     * @param {Number} x
<span id="line14450" class="line"></span>     * @param {Number} y
<span id="line14451" class="line"></span>     * @returns {*|null} post data to send with tile configuration request
<span id="line14452" class="line"></span>     */
<span id="line14453" class="line"></span>    getTilePostData: function( level, x, y ) {
<span id="line14454" class="line"></span>        return null;
<span id="line14455" class="line"></span>    },
<span id="line14456" class="line"></span>
<span id="line14457" class="line"></span>    /**
<span id="line14458" class="line"></span>     * Responsible for retrieving the headers which will be attached to the image request for the
<span id="line14459" class="line"></span>     * region specified by the given x, y, and level components.
<span id="line14460" class="line"></span>     * This option is only relevant if {@link OpenSeadragon.Options}.loadTilesWithAjax is set to true.
<span id="line14461" class="line"></span>     * The headers returned here will override headers specified at the Viewer or TiledImage level.
<span id="line14462" class="line"></span>     * Specifying a falsy value for a header will clear its existing value set at the Viewer or
<span id="line14463" class="line"></span>     * TiledImage level (if any).
<span id="line14464" class="line"></span>     *
<span id="line14465" class="line"></span>     * Note that the headers of existing tiles don't automatically change when this function
<span id="line14466" class="line"></span>     * returns updated headers. To do that, you need to call {@link OpenSeadragon.Viewer#setAjaxHeaders}
<span id="line14467" class="line"></span>     * and propagate the changes.
<span id="line14468" class="line"></span>     *
<span id="line14469" class="line"></span>     * @function
<span id="line14470" class="line"></span>     * @param {Number} level
<span id="line14471" class="line"></span>     * @param {Number} x
<span id="line14472" class="line"></span>     * @param {Number} y
<span id="line14473" class="line"></span>     * @returns {Object}
<span id="line14474" class="line"></span>     */
<span id="line14475" class="line"></span>    getTileAjaxHeaders: function( level, x, y ) {
<span id="line14476" class="line"></span>        return {};
<span id="line14477" class="line"></span>    },
<span id="line14478" class="line"></span>
<span id="line14479" class="line"></span>    /**
<span id="line14480" class="line"></span>     * The tile cache object is uniquely determined by this key and used to lookup
<span id="line14481" class="line"></span>     * the image data in cache: keys should be different if images are different.
<span id="line14482" class="line"></span>     *
<span id="line14483" class="line"></span>     * You can return falsey tile cache key, in which case the tile will
<span id="line14484" class="line"></span>     * be created without invoking ImageJob --- but with data=null. Then,
<span id="line14485" class="line"></span>     * you are responsible for manually creating the cache data. This is useful
<span id="line14486" class="line"></span>     * particularly if you want to use empty TiledImage with client-side derived data
<span id="line14487" class="line"></span>     * only. The default tile-cache key is then called "" - an empty string.
<span id="line14488" class="line"></span>     *
<span id="line14489" class="line"></span>     * Note: default behaviour does not take into account post data.
<span id="line14490" class="line"></span>     * @param {Number} level tile level it was fetched with
<span id="line14491" class="line"></span>     * @param {Number} x x-coordinate in the pyramid level
<span id="line14492" class="line"></span>     * @param {Number} y y-coordinate in the pyramid level
<span id="line14493" class="line"></span>     * @param {String} url the tile was fetched with
<span id="line14494" class="line"></span>     * @param {Object} ajaxHeaders the tile was fetched with
<span id="line14495" class="line"></span>     * @param {*} postData data the tile was fetched with (type depends on getTilePostData(..) return type)
<span id="line14496" class="line"></span>     * @return {?String} can return the cache key or null, in that case an empty cache is initialized
<span id="line14497" class="line"></span>     *   without downloading any data for internal use: user has to define the cache contents manually, via
<span id="line14498" class="line"></span>     *   the cache interface of this class.
<span id="line14499" class="line"></span>     */
<span id="line14500" class="line"></span>    getTileHashKey: function(level, x, y, url, ajaxHeaders, postData) {
<span id="line14501" class="line"></span>        function withHeaders(hash) {
<span id="line14502" class="line"></span>            return ajaxHeaders ? hash + "+" + JSON.stringify(ajaxHeaders) : hash;
<span id="line14503" class="line"></span>        }
<span id="line14504" class="line"></span>
<span id="line14505" class="line"></span>        if (typeof url !== "string") {
<span id="line14506" class="line"></span>            return withHeaders(this._uniqueIdentifier + ":" + level + "/" + x + "_" + y);
<span id="line14507" class="line"></span>        }
<span id="line14508" class="line"></span>        return withHeaders(url);
<span id="line14509" class="line"></span>    },
<span id="line14510" class="line"></span>
<span id="line14511" class="line"></span>    /**
<span id="line14512" class="line"></span>     * @function
<span id="line14513" class="line"></span>     * @param {Number} level
<span id="line14514" class="line"></span>     * @param {Number} x
<span id="line14515" class="line"></span>     * @param {Number} y
<span id="line14516" class="line"></span>     */
<span id="line14517" class="line"></span>    tileExists: function( level, x, y ) {
<span id="line14518" class="line"></span>        const numTiles = this.getNumTiles( level );
<span id="line14519" class="line"></span>        return level &gt;= this.minLevel &amp;&amp;
<span id="line14520" class="line"></span>            level &lt;= this.maxLevel &amp;&amp;
<span id="line14521" class="line"></span>            x &gt;= 0 &amp;&amp;
<span id="line14522" class="line"></span>            y &gt;= 0 &amp;&amp;
<span id="line14523" class="line"></span>            x &lt; numTiles.x &amp;&amp;
<span id="line14524" class="line"></span>            y &lt; numTiles.y;
<span id="line14525" class="line"></span>    },
<span id="line14526" class="line"></span>
<span id="line14527" class="line"></span>    /**
<span id="line14528" class="line"></span>     * Decide whether tiles have transparency: this is crucial for correct images blending.
<span id="line14529" class="line"></span>     * Overriden on a tile level by setting tile.hasTransparency = true;
<span id="line14530" class="line"></span>     * @param context2D unused, deprecated argument
<span id="line14531" class="line"></span>     * @param url tile.getUrl() value for given tile
<span id="line14532" class="line"></span>     * @param ajaxHeaders tile.ajaxHeaders value for given tile
<span id="line14533" class="line"></span>     * @param post tile.post value for given tile
<span id="line14534" class="line"></span>     * @returns {boolean} true if the image has transparency
<span id="line14535" class="line"></span>     */
<span id="line14536" class="line"></span>    hasTransparency: function(context2D, url, ajaxHeaders, post) {
<span id="line14537" class="line"></span>        return url.match('.png');
<span id="line14538" class="line"></span>    },
<span id="line14539" class="line"></span>
<span id="line14540" class="line"></span>    /**
<span id="line14541" class="line"></span>     * Download tile data. The context attribute is the reference to the job object itself, which is extended
<span id="line14542" class="line"></span>     * by ImageLoader.addJob(options) options object, so there are also properties like context.source (reference to self).
<span id="line14543" class="line"></span>     *
<span id="line14544" class="line"></span>     * Note that if you override this function, you should override also downloadTileAbort().
<span id="line14545" class="line"></span>     * @param {OpenSeadragon.ImageJob} context job context that you have to call finish(...) on.
<span id="line14546" class="line"></span>     */
<span id="line14547" class="line"></span>    downloadTileStart: function (context) {
<span id="line14548" class="line"></span>        // Load the tile with an AJAX request if the loadWithAjax option is
<span id="line14549" class="line"></span>        // set. Otherwise load the image by setting the source property of the image object.
<span id="line14550" class="line"></span>
<span id="line14551" class="line"></span>        // TODO: the cors/creds is not optimal here:
<span id="line14552" class="line"></span>        //  - XMLHttpRequest can only setup credentials flag, so `ajaxWithCredentials` is a boolean
<span id="line14553" class="line"></span>        //  - &lt;img&gt; item can turn on/off cors, and include credentials if cors on, therefore `crossOriginPolicy` can have three values (one is null)
<span id="line14554" class="line"></span>        //  --&gt; we should merge these flags to a single value to avoid confusion with usage, and use modern fetch that can setup also cors to have consistent behavior
<span id="line14555" class="line"></span>        if (context.loadWithAjax) {
<span id="line14556" class="line"></span>            context.userData.request = $.makeAjaxRequest({
<span id="line14557" class="line"></span>                url: context.src,
<span id="line14558" class="line"></span>                withCredentials: context.ajaxWithCredentials,
<span id="line14559" class="line"></span>                headers: context.ajaxHeaders,
<span id="line14560" class="line"></span>                responseType: "arraybuffer",
<span id="line14561" class="line"></span>                postData: context.postData,
<span id="line14562" class="line"></span>                success: function(request) {
<span id="line14563" class="line"></span>                    let blb;
<span id="line14564" class="line"></span>                    // Make the raw data into a blob.
<span id="line14565" class="line"></span>                    // BlobBuilder fallback adapted from
<span id="line14566" class="line"></span>                    // http://stackoverflow.com/questions/15293694/blob-constructor-browser-compatibility
<span id="line14567" class="line"></span>                    try {
<span id="line14568" class="line"></span>                        blb = new window.Blob([request.response]);
<span id="line14569" class="line"></span>                    } catch (e) {
<span id="line14570" class="line"></span>                        const BlobBuilder = (
<span id="line14571" class="line"></span>                            window.BlobBuilder ||
<span id="line14572" class="line"></span>                            window.WebKitBlobBuilder ||
<span id="line14573" class="line"></span>                            window.MozBlobBuilder ||
<span id="line14574" class="line"></span>                            window.MSBlobBuilder
<span id="line14575" class="line"></span>                        );
<span id="line14576" class="line"></span>                        if (e.name === 'TypeError' &amp;&amp; BlobBuilder) {
<span id="line14577" class="line"></span>                            const bb = new BlobBuilder();
<span id="line14578" class="line"></span>                            bb.append(request.response);
<span id="line14579" class="line"></span>                            blb = bb.getBlob();
<span id="line14580" class="line"></span>                        }
<span id="line14581" class="line"></span>                    }
<span id="line14582" class="line"></span>                    // If the blob is empty for some reason consider the image load a failure.
<span id="line14583" class="line"></span>                    if (blb.size === 0) {
<span id="line14584" class="line"></span>                        context.fail("[downloadTileStart] Empty image response.", request);
<span id="line14585" class="line"></span>                    } else {
<span id="line14586" class="line"></span>                        context.finish(blb, request, "rasterBlob");
<span id="line14587" class="line"></span>                    }
<span id="line14588" class="line"></span>                },
<span id="line14589" class="line"></span>                error: function(request) {
<span id="line14590" class="line"></span>                    context.fail("[downloadTileStart] Image load aborted - XHR error", request);
<span id="line14591" class="line"></span>                }
<span id="line14592" class="line"></span>            });
<span id="line14593" class="line"></span>        } else {
<span id="line14594" class="line"></span>            // While we could just do this one-liner, we found out that downloading the data _before_ a cache is initialized
<span id="line14595" class="line"></span>            // works better in general cases. Network access is the most error-prone part, and this scenario better supports
<span id="line14596" class="line"></span>            // all default use-cases, including the fact that retry logic works only at this stage, not on the cache level.
<span id="line14597" class="line"></span>            //  context.finish(context.src, null, "__private__imageUrl");
<span id="line14598" class="line"></span>
<span id="line14599" class="line"></span>            const image = new Image();
<span id="line14600" class="line"></span>            context.userData.imageRequest = image;
<span id="line14601" class="line"></span>            image.onload = function () {
<span id="line14602" class="line"></span>                image.onload = image.onerror = image.onabort = null;
<span id="line14603" class="line"></span>                context.finish(image, null, "image");
<span id="line14604" class="line"></span>            };
<span id="line14605" class="line"></span>            image.onabort = image.onerror = function() {
<span id="line14606" class="line"></span>                image.onload = image.onerror = image.onabort = null;
<span id="line14607" class="line"></span>                context.fail("[downloadTileStart] Image load aborted or errored out.", null);
<span id="line14608" class="line"></span>            };
<span id="line14609" class="line"></span>            if (typeof context.crossOriginPolicy === "string") {
<span id="line14610" class="line"></span>                image.crossOrigin = context.crossOriginPolicy;
<span id="line14611" class="line"></span>            }
<span id="line14612" class="line"></span>            image.src = context.src;
<span id="line14613" class="line"></span>        }
<span id="line14614" class="line"></span>    },
<span id="line14615" class="line"></span>
<span id="line14616" class="line"></span>    /**
<span id="line14617" class="line"></span>     * Provide means of aborting the execution.
<span id="line14618" class="line"></span>     * Note that if you override this function, you should override also downloadTileStart().
<span id="line14619" class="line"></span>     * Note that calling job.abort() would create an infinite loop!
<span id="line14620" class="line"></span>     *
<span id="line14621" class="line"></span>     * @param {OpenSeadragon.ImageJob} context job, the same object as with downloadTileStart(..)
<span id="line14622" class="line"></span>     * @param {*} [context.userData] - Empty object to attach (and mainly read) your own data.
<span id="line14623" class="line"></span>     */
<span id="line14624" class="line"></span>    downloadTileAbort: function (context) {
<span id="line14625" class="line"></span>        if (context.userData.request) {
<span id="line14626" class="line"></span>            context.userData.request.abort();
<span id="line14627" class="line"></span>        }
<span id="line14628" class="line"></span>        if (context.userData.imageRequest) {
<span id="line14629" class="line"></span>            const image = context.userData.imageRequest;
<span id="line14630" class="line"></span>            image.onload = image.onerror = image.onabort = null;
<span id="line14631" class="line"></span>            image.src = "";
<span id="line14632" class="line"></span>        }
<span id="line14633" class="line"></span>    },
<span id="line14634" class="line"></span>
<span id="line14635" class="line"></span>    /**
<span id="line14636" class="line"></span>     * Handles the fetching of multiple tiles in a single operation.
<span id="line14637" class="line"></span>     * The TileSource is responsible for calling finish/fail on each of the individual job items
<span id="line14638" class="line"></span>     * carried by batchJob.jobs. Avoid calling finish/fail on `batchJob` itself.
<span id="line14639" class="line"></span>     *
<span id="line14640" class="line"></span>     * Note that failed batch jobs are retried in non-batched mode. You should therefore
<span id="line14641" class="line"></span>     * have a valid downloadTileStart implementation in any case.
<span id="line14642" class="line"></span>     *
<span id="line14643" class="line"></span>     * @param {OpenSeadragon.BatchImageJob} batchJob - The batch job containing .jobs array
<span id="line14644" class="line"></span>     */
<span id="line14645" class="line"></span>    downloadTileBatchStart(batchJob) {
<span id="line14646" class="line"></span>        // Fallback default implementation: process individually.
<span id="line14647" class="line"></span>        // Real implementations (e.g. for sprite sheets) should override this and use true batched approach.
<span id="line14648" class="line"></span>        for (let i = 0; i &lt; batchJob.jobs.length; i++) {
<span id="line14649" class="line"></span>            this.downloadTileStart(batchJob.jobs[i]);
<span id="line14650" class="line"></span>        }
<span id="line14651" class="line"></span>    },
<span id="line14652" class="line"></span>
<span id="line14653" class="line"></span>    /**
<span id="line14654" class="line"></span>     * Handles abortion of the fetching of multiple tiles.
<span id="line14655" class="line"></span>     * @param {OpenSeadragon.BatchImageJob} batchJob
<span id="line14656" class="line"></span>     */
<span id="line14657" class="line"></span>    downloadTileBatchAbort(batchJob) {
<span id="line14658" class="line"></span>        for (let i = 0; i &lt; batchJob.jobs.length; i++) {
<span id="line14659" class="line"></span>            this.downloadTileAbort(batchJob.jobs[i]);
<span id="line14660" class="line"></span>        }
<span id="line14661" class="line"></span>    },
<span id="line14662" class="line"></span>
<span id="line14663" class="line"></span>    /**
<span id="line14664" class="line"></span>     * Create cache object from the result of the download process. The
<span id="line14665" class="line"></span>     * cacheObject parameter should be used to attach the data to, there are no
<span id="line14666" class="line"></span>     * conventions on how it should be stored - all the logic is implemented within *TileCache() functions.
<span id="line14667" class="line"></span>     *
<span id="line14668" class="line"></span>     * Note that
<span id="line14669" class="line"></span>     *  - data is cached automatically as cacheObject.data
<span id="line14670" class="line"></span>     *  - if you override any of *TileCache() functions, you should override all of them.
<span id="line14671" class="line"></span>     *  - these functions might be called over shared cache object managed by other TileSources simultaneously.
<span id="line14672" class="line"></span>     * @param {OpenSeadragon.CacheRecord} cacheObject context cache object
<span id="line14673" class="line"></span>     * @param {*} data image data, the data sent to ImageJob.prototype.finish(), by default an Image object
<span id="line14674" class="line"></span>     * @param {OpenSeadragon.Tile} tile instance the cache was created with
<span id="line14675" class="line"></span>     * @deprecated
<span id="line14676" class="line"></span>     */
<span id="line14677" class="line"></span>    createTileCache: function(cacheObject, data, tile) {
<span id="line14678" class="line"></span>        $.console.error("[TileSource.createTileCache] has been deprecated. Use cache API of a tile instead.");
<span id="line14679" class="line"></span>        //no-op, we create the cache automatically
<span id="line14680" class="line"></span>    },
<span id="line14681" class="line"></span>
<span id="line14682" class="line"></span>    /**
<span id="line14683" class="line"></span>     * Cache object destructor, unset all properties you created to allow GC collection.
<span id="line14684" class="line"></span>     * Note that if you override any of *TileCache() functions, you should override all of them.
<span id="line14685" class="line"></span>     * Note that these functions might be called over shared cache object managed by other TileSources simultaneously.
<span id="line14686" class="line"></span>     * Original cache data is cacheObject.data, but do not delete it manually! It is taken care for,
<span id="line14687" class="line"></span>     * you might break things.
<span id="line14688" class="line"></span>     * @param {OpenSeadragon.CacheRecord} cacheObject context cache object
<span id="line14689" class="line"></span>     * @deprecated
<span id="line14690" class="line"></span>     */
<span id="line14691" class="line"></span>    destroyTileCache: function (cacheObject) {
<span id="line14692" class="line"></span>        $.console.error("[TileSource.destroyTileCache] has been deprecated. Use cache API of a tile instead.");
<span id="line14693" class="line"></span>        //no-op, handled internally
<span id="line14694" class="line"></span>    },
<span id="line14695" class="line"></span>
<span id="line14696" class="line"></span>    /**
<span id="line14697" class="line"></span>     * Raw data getter, should return anything that is compatible with the system, or undefined
<span id="line14698" class="line"></span>     * if the system can handle it.
<span id="line14699" class="line"></span>     * @param {OpenSeadragon.CacheRecord} cacheObject context cache object
<span id="line14700" class="line"></span>     * @returns {OpenSeadragon.Promise&lt;?&gt;} cache data
<span id="line14701" class="line"></span>     * @deprecated
<span id="line14702" class="line"></span>     */
<span id="line14703" class="line"></span>    getTileCacheData: function(cacheObject) {
<span id="line14704" class="line"></span>        $.console.error("[TileSource.getTileCacheData] has been deprecated. Use cache API of a tile instead.");
<span id="line14705" class="line"></span>        return cacheObject.getDataAs(undefined, false);
<span id="line14706" class="line"></span>    },
<span id="line14707" class="line"></span>
<span id="line14708" class="line"></span>    /**
<span id="line14709" class="line"></span>     * Compatibility image element getter
<span id="line14710" class="line"></span>     *  - plugins might need image representation of the data
<span id="line14711" class="line"></span>     *  - div HTML rendering relies on image element presence
<span id="line14712" class="line"></span>     * Note that if you override any of *TileCache() functions, you should override all of them.
<span id="line14713" class="line"></span>     * Note that these functions might be called over shared cache object managed by other TileSources simultaneously.
<span id="line14714" class="line"></span>     *  @param {OpenSeadragon.CacheRecord} cacheObject context cache object
<span id="line14715" class="line"></span>     *  @returns {Image} cache data as an Image
<span id="line14716" class="line"></span>     *  @deprecated
<span id="line14717" class="line"></span>     */
<span id="line14718" class="line"></span>    getTileCacheDataAsImage: function(cacheObject) {
<span id="line14719" class="line"></span>        $.console.error("[TileSource.getTileCacheDataAsImage] has been deprecated. Use cache API of a tile instead.");
<span id="line14720" class="line"></span>        return cacheObject.getImage();
<span id="line14721" class="line"></span>    },
<span id="line14722" class="line"></span>
<span id="line14723" class="line"></span>    /**
<span id="line14724" class="line"></span>     * Compatibility context 2D getter
<span id="line14725" class="line"></span>     *  - most heavily used rendering method is a canvas-based approach,
<span id="line14726" class="line"></span>     *    convert the data to a canvas and return it's 2D context
<span id="line14727" class="line"></span>     * Note that if you override any of *TileCache() functions, you should override all of them.
<span id="line14728" class="line"></span>     * @param {OpenSeadragon.CacheRecord} cacheObject context cache object
<span id="line14729" class="line"></span>     * @returns {CanvasRenderingContext2D} context of the canvas representation of the cache data
<span id="line14730" class="line"></span>     * @deprecated
<span id="line14731" class="line"></span>     */
<span id="line14732" class="line"></span>    getTileCacheDataAsContext2D: function(cacheObject) {
<span id="line14733" class="line"></span>        $.console.error("[TileSource.getTileCacheDataAsContext2D] has been deprecated. Use cache API of a tile instead.");
<span id="line14734" class="line"></span>        return cacheObject.getRenderedContext();
<span id="line14735" class="line"></span>    }
<span id="line14736" class="line"></span>};
<span id="line14737" class="line"></span>
<span id="line14738" class="line"></span>
<span id="line14739" class="line"></span>$.extend( true, $.TileSource.prototype, $.EventSource.prototype );
<span id="line14740" class="line"></span>
<span id="line14741" class="line"></span>
<span id="line14742" class="line"></span>/**
<span id="line14743" class="line"></span> * Decides whether to try to process the response as xml, json, or hand back
<span id="line14744" class="line"></span> * the text
<span id="line14745" class="line"></span> * @private
<span id="line14746" class="line"></span> * @inner
<span id="line14747" class="line"></span> * @function
<span id="line14748" class="line"></span> * @param {XMLHttpRequest} xhr - the completed network request
<span id="line14749" class="line"></span> */
<span id="line14750" class="line"></span>function processResponse( xhr ){
<span id="line14751" class="line"></span>    const responseText = xhr.responseText;
<span id="line14752" class="line"></span>    let status       = xhr.status;
<span id="line14753" class="line"></span>    let statusText;
<span id="line14754" class="line"></span>    let data;
<span id="line14755" class="line"></span>
<span id="line14756" class="line"></span>    if ( !xhr ) {
<span id="line14757" class="line"></span>        throw new Error( $.getString( "Errors.Security" ) );
<span id="line14758" class="line"></span>    } else if ( xhr.status !== 200 &amp;&amp; xhr.status !== 0 ) {
<span id="line14759" class="line"></span>        status     = xhr.status;
<span id="line14760" class="line"></span>        statusText = ( status === 404 ) ?
<span id="line14761" class="line"></span>            "Not Found" :
<span id="line14762" class="line"></span>            xhr.statusText;
<span id="line14763" class="line"></span>        throw new Error( $.getString( "Errors.Status", status, statusText ) );
<span id="line14764" class="line"></span>    }
<span id="line14765" class="line"></span>
<span id="line14766" class="line"></span>    if( responseText.match(/^\s*&lt;.*/) ){
<span id="line14767" class="line"></span>        try{
<span id="line14768" class="line"></span>            data = ( xhr.responseXML &amp;&amp; xhr.responseXML.documentElement ) ?
<span id="line14769" class="line"></span>                xhr.responseXML :
<span id="line14770" class="line"></span>                $.parseXml( responseText );
<span id="line14771" class="line"></span>        } catch (e){
<span id="line14772" class="line"></span>            data = xhr.responseText;
<span id="line14773" class="line"></span>        }
<span id="line14774" class="line"></span>    }else if( responseText.match(/\s*[{[].*/) ){
<span id="line14775" class="line"></span>        try{
<span id="line14776" class="line"></span>            data = $.parseJSON(responseText);
<span id="line14777" class="line"></span>        } catch(e){
<span id="line14778" class="line"></span>            data =  responseText;
<span id="line14779" class="line"></span>        }
<span id="line14780" class="line"></span>    }else{
<span id="line14781" class="line"></span>        data = responseText;
<span id="line14782" class="line"></span>    }
<span id="line14783" class="line"></span>    return data;
<span id="line14784" class="line"></span>}
<span id="line14785" class="line"></span>
<span id="line14786" class="line"></span>
<span id="line14787" class="line"></span>/**
<span id="line14788" class="line"></span> * Determines the TileSource Implementation by introspection of OpenSeadragon
<span id="line14789" class="line"></span> * namespace, calling each TileSource implementation of 'isType'
<span id="line14790" class="line"></span> * @private
<span id="line14791" class="line"></span> * @inner
<span id="line14792" class="line"></span> * @function
<span id="line14793" class="line"></span> * @param {Object|Array|Document} data - the tile source configuration object
<span id="line14794" class="line"></span> * @param {String} url - the url where the tile source configuration object was
<span id="line14795" class="line"></span> *      loaded from, if any.
<span id="line14796" class="line"></span> */
<span id="line14797" class="line"></span>$.TileSource.determineType = function( tileSource, data, url ){
<span id="line14798" class="line"></span>    for( const property in OpenSeadragon ){
<span id="line14799" class="line"></span>        if( property.match(/.+TileSource$/) &amp;&amp;
<span id="line14800" class="line"></span>            $.isFunction( OpenSeadragon[ property ] ) &amp;&amp;
<span id="line14801" class="line"></span>            $.isFunction( OpenSeadragon[ property ].prototype.supports ) &amp;&amp;
<span id="line14802" class="line"></span>            OpenSeadragon[ property ].prototype.supports.call( tileSource, data, url )
<span id="line14803" class="line"></span>        ){
<span id="line14804" class="line"></span>            return OpenSeadragon[ property ];
<span id="line14805" class="line"></span>        }
<span id="line14806" class="line"></span>    }
<span id="line14807" class="line"></span>
<span id="line14808" class="line"></span>    $.console.error( "No TileSource was able to open %s %s", url, data );
<span id="line14809" class="line"></span>
<span id="line14810" class="line"></span>    return null;
<span id="line14811" class="line"></span>};
<span id="line14812" class="line"></span>
<span id="line14813" class="line"></span>
<span id="line14814" class="line"></span>}( OpenSeadragon ));
<span id="line14815" class="line"></span>
<span id="line14816" class="line"></span>/*
<span id="line14817" class="line"></span> * OpenSeadragon - DziTileSource
<span id="line14818" class="line"></span> *
<span id="line14819" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line14820" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line14821" class="line"></span> *
<span id="line14822" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line14823" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line14824" class="line"></span> * met:
<span id="line14825" class="line"></span> *
<span id="line14826" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line14827" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line14828" class="line"></span> *
<span id="line14829" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line14830" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line14831" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line14832" class="line"></span> *
<span id="line14833" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line14834" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line14835" class="line"></span> *   this software without specific prior written permission.
<span id="line14836" class="line"></span> *
<span id="line14837" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line14838" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line14839" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line14840" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line14841" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line14842" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line14843" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line14844" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line14845" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line14846" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line14847" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line14848" class="line"></span> */
<span id="line14849" class="line"></span>
<span id="line14850" class="line"></span>(function( $ ){
<span id="line14851" class="line"></span>
<span id="line14852" class="line"></span>/**
<span id="line14853" class="line"></span> * @class DziTileSource
<span id="line14854" class="line"></span> * @memberof OpenSeadragon
<span id="line14855" class="line"></span> * @extends OpenSeadragon.TileSource
<span id="line14856" class="line"></span> * @param {Number|Object} width - the pixel width of the image or the idiomatic
<span id="line14857" class="line"></span> *      options object which is used instead of positional arguments.
<span id="line14858" class="line"></span> * @param {Number} height
<span id="line14859" class="line"></span> * @param {Number} tileSize
<span id="line14860" class="line"></span> * @param {Number} tileOverlap
<span id="line14861" class="line"></span> * @param {String} tilesUrl
<span id="line14862" class="line"></span> * @param {String} fileFormat
<span id="line14863" class="line"></span> * @param {OpenSeadragon.DisplayRect[]} displayRects
<span id="line14864" class="line"></span> * @property {String} tilesUrl
<span id="line14865" class="line"></span> * @property {String} fileFormat
<span id="line14866" class="line"></span> * @property {OpenSeadragon.DisplayRect[]} displayRects
<span id="line14867" class="line"></span> */
<span id="line14868" class="line"></span>$.DziTileSource = function( width, height, tileSize, tileOverlap, tilesUrl, fileFormat, displayRects, minLevel, maxLevel ) {
<span id="line14869" class="line"></span>    let level;
<span id="line14870" class="line"></span>    let options;
<span id="line14871" class="line"></span>
<span id="line14872" class="line"></span>    if( $.isPlainObject( width ) ){
<span id="line14873" class="line"></span>        options = width;
<span id="line14874" class="line"></span>    }else{
<span id="line14875" class="line"></span>        options = {
<span id="line14876" class="line"></span>            width: arguments[ 0 ],
<span id="line14877" class="line"></span>            height: arguments[ 1 ],
<span id="line14878" class="line"></span>            tileSize: arguments[ 2 ],
<span id="line14879" class="line"></span>            tileOverlap: arguments[ 3 ],
<span id="line14880" class="line"></span>            tilesUrl: arguments[ 4 ],
<span id="line14881" class="line"></span>            fileFormat: arguments[ 5 ],
<span id="line14882" class="line"></span>            displayRects: arguments[ 6 ],
<span id="line14883" class="line"></span>            minLevel: arguments[ 7 ],
<span id="line14884" class="line"></span>            maxLevel: arguments[ 8 ]
<span id="line14885" class="line"></span>        };
<span id="line14886" class="line"></span>    }
<span id="line14887" class="line"></span>
<span id="line14888" class="line"></span>    this._levelRects  = {};
<span id="line14889" class="line"></span>    this.tilesUrl     = options.tilesUrl;
<span id="line14890" class="line"></span>    this.fileFormat   = options.fileFormat;
<span id="line14891" class="line"></span>    this.displayRects = options.displayRects;
<span id="line14892" class="line"></span>    this.queryParams  = options.queryParams || "";
<span id="line14893" class="line"></span>
<span id="line14894" class="line"></span>    if ( this.displayRects ) {
<span id="line14895" class="line"></span>        for ( let i = this.displayRects.length - 1; i &gt;= 0; i-- ) {
<span id="line14896" class="line"></span>            const rect = this.displayRects[ i ];
<span id="line14897" class="line"></span>            for ( level = rect.minLevel; level &lt;= rect.maxLevel; level++ ) {
<span id="line14898" class="line"></span>                if ( !this._levelRects[ level ] ) {
<span id="line14899" class="line"></span>                    this._levelRects[ level ] = [];
<span id="line14900" class="line"></span>                }
<span id="line14901" class="line"></span>                this._levelRects[ level ].push( rect );
<span id="line14902" class="line"></span>            }
<span id="line14903" class="line"></span>        }
<span id="line14904" class="line"></span>    }
<span id="line14905" class="line"></span>
<span id="line14906" class="line"></span>    $.TileSource.apply( this, [ options ] );
<span id="line14907" class="line"></span>
<span id="line14908" class="line"></span>};
<span id="line14909" class="line"></span>
<span id="line14910" class="line"></span>$.extend( $.DziTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.DziTileSource.prototype */{
<span id="line14911" class="line"></span>
<span id="line14912" class="line"></span>
<span id="line14913" class="line"></span>    /**
<span id="line14914" class="line"></span>     * Determine if the data and/or url imply the image service is supported by
<span id="line14915" class="line"></span>     * this tile source.
<span id="line14916" class="line"></span>     * @function
<span id="line14917" class="line"></span>     * @param {Object|Array} data
<span id="line14918" class="line"></span>     * @param {String} [url]
<span id="line14919" class="line"></span>     */
<span id="line14920" class="line"></span>    supports: function( data, url ){
<span id="line14921" class="line"></span>        let ns;
<span id="line14922" class="line"></span>        if ( data.Image ) {
<span id="line14923" class="line"></span>            ns = data.Image.xmlns;
<span id="line14924" class="line"></span>        } else if ( data.documentElement) {
<span id="line14925" class="line"></span>            if ("Image" === data.documentElement.localName || "Image" === data.documentElement.tagName) {
<span id="line14926" class="line"></span>                ns = data.documentElement.namespaceURI;
<span id="line14927" class="line"></span>            }
<span id="line14928" class="line"></span>        }
<span id="line14929" class="line"></span>
<span id="line14930" class="line"></span>        ns = (ns || '').toLowerCase();
<span id="line14931" class="line"></span>
<span id="line14932" class="line"></span>        return (ns.indexOf('schemas.microsoft.com/deepzoom/2008') !== -1 ||
<span id="line14933" class="line"></span>            ns.indexOf('schemas.microsoft.com/deepzoom/2009') !== -1);
<span id="line14934" class="line"></span>    },
<span id="line14935" class="line"></span>
<span id="line14936" class="line"></span>    /**
<span id="line14937" class="line"></span>     *
<span id="line14938" class="line"></span>     * @function
<span id="line14939" class="line"></span>     * @param {Object|XMLDocument} data - the raw configuration
<span id="line14940" class="line"></span>     * @param {String} url - the url the data was retrieved from if any.
<span id="line14941" class="line"></span>     * @param {String} postData - HTTP POST data in k=v&amp;k2=v2... form or null
<span id="line14942" class="line"></span>     * @returns {Object} options - A dictionary of keyword arguments sufficient
<span id="line14943" class="line"></span>     *      to configure this tile sources constructor.
<span id="line14944" class="line"></span>     */
<span id="line14945" class="line"></span>    configure: function( data, url, postData ){
<span id="line14946" class="line"></span>
<span id="line14947" class="line"></span>        let options;
<span id="line14948" class="line"></span>
<span id="line14949" class="line"></span>        if( !$.isPlainObject(data) ){
<span id="line14950" class="line"></span>
<span id="line14951" class="line"></span>            options = configureFromXML( this, data );
<span id="line14952" class="line"></span>
<span id="line14953" class="line"></span>        }else{
<span id="line14954" class="line"></span>
<span id="line14955" class="line"></span>            options = configureFromObject( this, data );
<span id="line14956" class="line"></span>        }
<span id="line14957" class="line"></span>
<span id="line14958" class="line"></span>        if (url &amp;&amp; !options.tilesUrl) {
<span id="line14959" class="line"></span>            options.tilesUrl = url.replace(
<span id="line14960" class="line"></span>                    /([^/]+?)(\.(dzi|xml|js)?(\?[^/]*)?)?\/?$/, '$1_files/');
<span id="line14961" class="line"></span>
<span id="line14962" class="line"></span>            if (url.search(/\.(dzi|xml|js)\?/) !== -1) {
<span id="line14963" class="line"></span>                options.queryParams = url.match(/\?.*/);
<span id="line14964" class="line"></span>            }else{
<span id="line14965" class="line"></span>                options.queryParams = '';
<span id="line14966" class="line"></span>            }
<span id="line14967" class="line"></span>        }
<span id="line14968" class="line"></span>
<span id="line14969" class="line"></span>        return options;
<span id="line14970" class="line"></span>    },
<span id="line14971" class="line"></span>
<span id="line14972" class="line"></span>
<span id="line14973" class="line"></span>    /**
<span id="line14974" class="line"></span>     * @function
<span id="line14975" class="line"></span>     * @param {Number} level
<span id="line14976" class="line"></span>     * @param {Number} x
<span id="line14977" class="line"></span>     * @param {Number} y
<span id="line14978" class="line"></span>     */
<span id="line14979" class="line"></span>    getTileUrl: function( level, x, y ) {
<span id="line14980" class="line"></span>        return [ this.tilesUrl, level, '/', x, '_', y, '.', this.fileFormat, this.queryParams ].join( '' );
<span id="line14981" class="line"></span>    },
<span id="line14982" class="line"></span>
<span id="line14983" class="line"></span>
<span id="line14984" class="line"></span>    /**
<span id="line14985" class="line"></span>     * Equality comparator
<span id="line14986" class="line"></span>     */
<span id="line14987" class="line"></span>    equals: function(otherSource) {
<span id="line14988" class="line"></span>        return otherSource &amp;&amp; this.tilesUrl === otherSource.tilesUrl;
<span id="line14989" class="line"></span>    },
<span id="line14990" class="line"></span>
<span id="line14991" class="line"></span>
<span id="line14992" class="line"></span>    /**
<span id="line14993" class="line"></span>     * @function
<span id="line14994" class="line"></span>     * @param {Number} level
<span id="line14995" class="line"></span>     * @param {Number} x
<span id="line14996" class="line"></span>     * @param {Number} y
<span id="line14997" class="line"></span>     */
<span id="line14998" class="line"></span>    tileExists: function( level, x, y ) {
<span id="line14999" class="line"></span>        const rects = this._levelRects[ level ];
<span id="line15000" class="line"></span>        let scale;
<span id="line15001" class="line"></span>        let xMin;
<span id="line15002" class="line"></span>        let yMin;
<span id="line15003" class="line"></span>        let xMax;
<span id="line15004" class="line"></span>        let yMax;
<span id="line15005" class="line"></span>
<span id="line15006" class="line"></span>        if ((this.minLevel &amp;&amp; level &lt; this.minLevel) || (this.maxLevel &amp;&amp; level &gt; this.maxLevel)) {
<span id="line15007" class="line"></span>            return false;
<span id="line15008" class="line"></span>        }
<span id="line15009" class="line"></span>
<span id="line15010" class="line"></span>        if ( !rects || !rects.length ) {
<span id="line15011" class="line"></span>            return true;
<span id="line15012" class="line"></span>        }
<span id="line15013" class="line"></span>
<span id="line15014" class="line"></span>        for (let i = rects.length - 1; i &gt;= 0; i-- ) {
<span id="line15015" class="line"></span>            const rect = rects[ i ];
<span id="line15016" class="line"></span>
<span id="line15017" class="line"></span>            if ( level &lt; rect.minLevel || level &gt; rect.maxLevel ) {
<span id="line15018" class="line"></span>                continue;
<span id="line15019" class="line"></span>            }
<span id="line15020" class="line"></span>
<span id="line15021" class="line"></span>            scale = this.getLevelScale( level );
<span id="line15022" class="line"></span>            xMin = rect.x * scale;
<span id="line15023" class="line"></span>            yMin = rect.y * scale;
<span id="line15024" class="line"></span>            xMax = xMin + rect.width * scale;
<span id="line15025" class="line"></span>            yMax = yMin + rect.height * scale;
<span id="line15026" class="line"></span>
<span id="line15027" class="line"></span>            xMin = Math.floor( xMin / this._tileWidth );
<span id="line15028" class="line"></span>            yMin = Math.floor( yMin / this._tileWidth ); // DZI tiles are square, so we just use _tileWidth
<span id="line15029" class="line"></span>            xMax = Math.ceil( xMax / this._tileWidth );
<span id="line15030" class="line"></span>            yMax = Math.ceil( yMax / this._tileWidth );
<span id="line15031" class="line"></span>
<span id="line15032" class="line"></span>            if ( xMin &lt;= x &amp;&amp; x &lt; xMax &amp;&amp; yMin &lt;= y &amp;&amp; y &lt; yMax ) {
<span id="line15033" class="line"></span>                return true;
<span id="line15034" class="line"></span>            }
<span id="line15035" class="line"></span>        }
<span id="line15036" class="line"></span>
<span id="line15037" class="line"></span>        return false;
<span id="line15038" class="line"></span>    }
<span id="line15039" class="line"></span>});
<span id="line15040" class="line"></span>
<span id="line15041" class="line"></span>
<span id="line15042" class="line"></span>/**
<span id="line15043" class="line"></span> * @private
<span id="line15044" class="line"></span> * @inner
<span id="line15045" class="line"></span> * @function
<span id="line15046" class="line"></span> */
<span id="line15047" class="line"></span>function configureFromXML( tileSource, xmlDoc ){
<span id="line15048" class="line"></span>
<span id="line15049" class="line"></span>    if ( !xmlDoc || !xmlDoc.documentElement ) {
<span id="line15050" class="line"></span>        throw new Error( $.getString( "Errors.Xml" ) );
<span id="line15051" class="line"></span>    }
<span id="line15052" class="line"></span>
<span id="line15053" class="line"></span>    const root           = xmlDoc.documentElement;
<span id="line15054" class="line"></span>    const rootName       = root.localName || root.tagName;
<span id="line15055" class="line"></span>    const ns             = xmlDoc.documentElement.namespaceURI;
<span id="line15056" class="line"></span>    let configuration  = null;
<span id="line15057" class="line"></span>    const displayRects   = [];
<span id="line15058" class="line"></span>    let dispRectNodes;
<span id="line15059" class="line"></span>    let dispRectNode;
<span id="line15060" class="line"></span>    let rectNode;
<span id="line15061" class="line"></span>    let sizeNode;
<span id="line15062" class="line"></span>    let i;
<span id="line15063" class="line"></span>
<span id="line15064" class="line"></span>    if ( rootName === "Image" ) {
<span id="line15065" class="line"></span>
<span id="line15066" class="line"></span>        try {
<span id="line15067" class="line"></span>            sizeNode = root.getElementsByTagName("Size" )[ 0 ];
<span id="line15068" class="line"></span>            if (sizeNode === undefined) {
<span id="line15069" class="line"></span>                sizeNode = root.getElementsByTagNameNS(ns, "Size" )[ 0 ];
<span id="line15070" class="line"></span>            }
<span id="line15071" class="line"></span>
<span id="line15072" class="line"></span>            configuration = {
<span id="line15073" class="line"></span>                Image: {
<span id="line15074" class="line"></span>                    xmlns:       "http://schemas.microsoft.com/deepzoom/2008",
<span id="line15075" class="line"></span>                    Url:         root.getAttribute( "Url" ),
<span id="line15076" class="line"></span>                    Format:      root.getAttribute( "Format" ),
<span id="line15077" class="line"></span>                    DisplayRect: null,
<span id="line15078" class="line"></span>                    Overlap:     parseInt( root.getAttribute( "Overlap" ), 10 ),
<span id="line15079" class="line"></span>                    TileSize:    parseInt( root.getAttribute( "TileSize" ), 10 ),
<span id="line15080" class="line"></span>                    Size: {
<span id="line15081" class="line"></span>                        Height: parseInt( sizeNode.getAttribute( "Height" ), 10 ),
<span id="line15082" class="line"></span>                        Width:  parseInt( sizeNode.getAttribute( "Width" ), 10 )
<span id="line15083" class="line"></span>                    }
<span id="line15084" class="line"></span>                }
<span id="line15085" class="line"></span>            };
<span id="line15086" class="line"></span>
<span id="line15087" class="line"></span>            if ( !$.imageFormatSupported( configuration.Image.Format ) ) {
<span id="line15088" class="line"></span>                throw new Error(
<span id="line15089" class="line"></span>                    $.getString( "Errors.ImageFormat", configuration.Image.Format.toUpperCase() )
<span id="line15090" class="line"></span>                );
<span id="line15091" class="line"></span>            }
<span id="line15092" class="line"></span>
<span id="line15093" class="line"></span>            dispRectNodes = root.getElementsByTagName("DisplayRect" );
<span id="line15094" class="line"></span>            if (dispRectNodes === undefined) {
<span id="line15095" class="line"></span>                dispRectNodes = root.getElementsByTagNameNS(ns, "DisplayRect" )[ 0 ];
<span id="line15096" class="line"></span>            }
<span id="line15097" class="line"></span>
<span id="line15098" class="line"></span>            for ( i = 0; i &lt; dispRectNodes.length; i++ ) {
<span id="line15099" class="line"></span>                dispRectNode = dispRectNodes[ i ];
<span id="line15100" class="line"></span>                rectNode     = dispRectNode.getElementsByTagName("Rect" )[ 0 ];
<span id="line15101" class="line"></span>                if (rectNode === undefined) {
<span id="line15102" class="line"></span>                    rectNode = dispRectNode.getElementsByTagNameNS(ns, "Rect" )[ 0 ];
<span id="line15103" class="line"></span>                }
<span id="line15104" class="line"></span>
<span id="line15105" class="line"></span>                displayRects.push({
<span id="line15106" class="line"></span>                    Rect: {
<span id="line15107" class="line"></span>                        X: parseInt( rectNode.getAttribute( "X" ), 10 ),
<span id="line15108" class="line"></span>                        Y: parseInt( rectNode.getAttribute( "Y" ), 10 ),
<span id="line15109" class="line"></span>                        Width: parseInt( rectNode.getAttribute( "Width" ), 10 ),
<span id="line15110" class="line"></span>                        Height: parseInt( rectNode.getAttribute( "Height" ), 10 ),
<span id="line15111" class="line"></span>                        MinLevel: parseInt( dispRectNode.getAttribute( "MinLevel" ), 10 ),
<span id="line15112" class="line"></span>                        MaxLevel: parseInt( dispRectNode.getAttribute( "MaxLevel" ), 10 )
<span id="line15113" class="line"></span>                    }
<span id="line15114" class="line"></span>                });
<span id="line15115" class="line"></span>            }
<span id="line15116" class="line"></span>
<span id="line15117" class="line"></span>            if( displayRects.length ){
<span id="line15118" class="line"></span>                configuration.Image.DisplayRect = displayRects;
<span id="line15119" class="line"></span>            }
<span id="line15120" class="line"></span>
<span id="line15121" class="line"></span>            return configureFromObject( tileSource, configuration );
<span id="line15122" class="line"></span>
<span id="line15123" class="line"></span>        } catch ( e ) {
<span id="line15124" class="line"></span>            throw (e instanceof Error) ?
<span id="line15125" class="line"></span>                e :
<span id="line15126" class="line"></span>                new Error( $.getString("Errors.Dzi") );
<span id="line15127" class="line"></span>        }
<span id="line15128" class="line"></span>    } else if ( rootName === "Collection" ) {
<span id="line15129" class="line"></span>        throw new Error( $.getString( "Errors.Dzc" ) );
<span id="line15130" class="line"></span>    } else if ( rootName === "Error" ) {
<span id="line15131" class="line"></span>        const messageNode = root.getElementsByTagName("Message")[0];
<span id="line15132" class="line"></span>        const message = messageNode.firstChild.nodeValue;
<span id="line15133" class="line"></span>        throw new Error(message);
<span id="line15134" class="line"></span>    }
<span id="line15135" class="line"></span>
<span id="line15136" class="line"></span>    throw new Error( $.getString( "Errors.Dzi" ) );
<span id="line15137" class="line"></span>}
<span id="line15138" class="line"></span>
<span id="line15139" class="line"></span>/**
<span id="line15140" class="line"></span> * @private
<span id="line15141" class="line"></span> * @inner
<span id="line15142" class="line"></span> * @function
<span id="line15143" class="line"></span> */
<span id="line15144" class="line"></span>function configureFromObject( tileSource, configuration ){
<span id="line15145" class="line"></span>    const imageData     = configuration.Image;
<span id="line15146" class="line"></span>    const tilesUrl      = imageData.Url;
<span id="line15147" class="line"></span>    const fileFormat    = imageData.Format;
<span id="line15148" class="line"></span>    const sizeData      = imageData.Size;
<span id="line15149" class="line"></span>    const dispRectData  = imageData.DisplayRect || [];
<span id="line15150" class="line"></span>    const width         = parseInt( sizeData.Width, 10 );
<span id="line15151" class="line"></span>    const height        = parseInt( sizeData.Height, 10 );
<span id="line15152" class="line"></span>    const tileSize      = parseInt( imageData.TileSize, 10 );
<span id="line15153" class="line"></span>    const tileOverlap   = parseInt( imageData.Overlap, 10 );
<span id="line15154" class="line"></span>    const displayRects  = [];
<span id="line15155" class="line"></span>    let rectData;
<span id="line15156" class="line"></span>
<span id="line15157" class="line"></span>    //TODO: need to figure out out to better handle image format compatibility
<span id="line15158" class="line"></span>    //      which actually includes additional file formats like xml and pdf
<span id="line15159" class="line"></span>    //      and plain text for various tilesource implementations to avoid low
<span id="line15160" class="line"></span>    //      level errors.
<span id="line15161" class="line"></span>    //
<span id="line15162" class="line"></span>    //      For now, just don't perform the check.
<span id="line15163" class="line"></span>    //
<span id="line15164" class="line"></span>    /*if ( !imageFormatSupported( fileFormat ) ) {
<span id="line15165" class="line"></span>        throw new Error(
<span id="line15166" class="line"></span>            $.getString( "Errors.ImageFormat", fileFormat.toUpperCase() )
<span id="line15167" class="line"></span>        );
<span id="line15168" class="line"></span>    }*/
<span id="line15169" class="line"></span>
<span id="line15170" class="line"></span>    for (let i = 0; i &lt; dispRectData.length; i++ ) {
<span id="line15171" class="line"></span>        rectData = dispRectData[ i ].Rect;
<span id="line15172" class="line"></span>
<span id="line15173" class="line"></span>        displayRects.push( new $.DisplayRect(
<span id="line15174" class="line"></span>            parseInt( rectData.X, 10 ),
<span id="line15175" class="line"></span>            parseInt( rectData.Y, 10 ),
<span id="line15176" class="line"></span>            parseInt( rectData.Width, 10 ),
<span id="line15177" class="line"></span>            parseInt( rectData.Height, 10 ),
<span id="line15178" class="line"></span>            parseInt( rectData.MinLevel, 10 ),
<span id="line15179" class="line"></span>            parseInt( rectData.MaxLevel, 10 )
<span id="line15180" class="line"></span>        ));
<span id="line15181" class="line"></span>    }
<span id="line15182" class="line"></span>
<span id="line15183" class="line"></span>    return $.extend(true, {
<span id="line15184" class="line"></span>        width: width, /* width *required */
<span id="line15185" class="line"></span>        height: height, /* height *required */
<span id="line15186" class="line"></span>        tileSize: tileSize, /* tileSize *required */
<span id="line15187" class="line"></span>        tileOverlap: tileOverlap, /* tileOverlap *required */
<span id="line15188" class="line"></span>        minLevel: null, /* minLevel */
<span id="line15189" class="line"></span>        maxLevel: null, /* maxLevel */
<span id="line15190" class="line"></span>        tilesUrl: tilesUrl, /* tilesUrl */
<span id="line15191" class="line"></span>        fileFormat: fileFormat, /* fileFormat */
<span id="line15192" class="line"></span>        displayRects: displayRects /* displayRects */
<span id="line15193" class="line"></span>    }, configuration );
<span id="line15194" class="line"></span>
<span id="line15195" class="line"></span>}
<span id="line15196" class="line"></span>
<span id="line15197" class="line"></span>}( OpenSeadragon ));
<span id="line15198" class="line"></span>
<span id="line15199" class="line"></span>/*
<span id="line15200" class="line"></span> * OpenSeadragon - IIIFTileSource
<span id="line15201" class="line"></span> *
<span id="line15202" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line15203" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line15204" class="line"></span> *
<span id="line15205" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line15206" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line15207" class="line"></span> * met:
<span id="line15208" class="line"></span> *
<span id="line15209" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line15210" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line15211" class="line"></span> *
<span id="line15212" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line15213" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line15214" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line15215" class="line"></span> *
<span id="line15216" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line15217" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line15218" class="line"></span> *   this software without specific prior written permission.
<span id="line15219" class="line"></span> *
<span id="line15220" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line15221" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line15222" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line15223" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line15224" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line15225" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line15226" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line15227" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line15228" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line15229" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line15230" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line15231" class="line"></span> */
<span id="line15232" class="line"></span>
<span id="line15233" class="line"></span>(function( $ ){
<span id="line15234" class="line"></span>
<span id="line15235" class="line"></span>/**
<span id="line15236" class="line"></span> * @class IIIFTileSource
<span id="line15237" class="line"></span> * @classdesc A client implementation of the International Image Interoperability Framework
<span id="line15238" class="line"></span> * Format: Image API 1.0 - 3.0
<span id="line15239" class="line"></span> *
<span id="line15240" class="line"></span> * @memberof OpenSeadragon
<span id="line15241" class="line"></span> * @extends OpenSeadragon.TileSource
<span id="line15242" class="line"></span> * @see http://iiif.io/api/image/
<span id="line15243" class="line"></span> * @param {String} [options.tileFormat='jpg']
<span id="line15244" class="line"></span> *      The extension that will be used when requiring tiles.
<span id="line15245" class="line"></span> */
<span id="line15246" class="line"></span>$.IIIFTileSource = function( options ){
<span id="line15247" class="line"></span>
<span id="line15248" class="line"></span>    /* eslint-disable camelcase */
<span id="line15249" class="line"></span>
<span id="line15250" class="line"></span>    $.extend( true, this, options );
<span id="line15251" class="line"></span>
<span id="line15252" class="line"></span>    /* Normalizes v3-style 'id' keys to an "_id" internal property */
<span id="line15253" class="line"></span>    this._id = this["@id"] || this["id"] || this['identifier'] || null;
<span id="line15254" class="line"></span>
<span id="line15255" class="line"></span>    if ( !( this.height &amp;&amp; this.width &amp;&amp; this._id) ) {
<span id="line15256" class="line"></span>        throw new Error( 'IIIF required parameters (width, height, or id) not provided.' );
<span id="line15257" class="line"></span>    }
<span id="line15258" class="line"></span>
<span id="line15259" class="line"></span>    options.tileSizePerScaleFactor = {};
<span id="line15260" class="line"></span>
<span id="line15261" class="line"></span>    this.tileFormat = this.tileFormat || 'jpg';
<span id="line15262" class="line"></span>
<span id="line15263" class="line"></span>    this.version = options.version;
<span id="line15264" class="line"></span>
<span id="line15265" class="line"></span>    this.isLevel0 = checkLevel0( options );
<span id="line15266" class="line"></span>
<span id="line15267" class="line"></span>    // N.B. 2.0 renamed scale_factors to scaleFactors
<span id="line15268" class="line"></span>    if ( this.tile_width &amp;&amp; this.tile_height ) {
<span id="line15269" class="line"></span>        options.tileWidth = this.tile_width;
<span id="line15270" class="line"></span>        options.tileHeight = this.tile_height;
<span id="line15271" class="line"></span>    } else if ( this.tile_width ) {
<span id="line15272" class="line"></span>        options.tileSize = this.tile_width;
<span id="line15273" class="line"></span>    } else if ( this.tile_height ) {
<span id="line15274" class="line"></span>        options.tileSize = this.tile_height;
<span id="line15275" class="line"></span>    } else if ( this.tiles ) {
<span id="line15276" class="line"></span>        // Version 2.0 forwards
<span id="line15277" class="line"></span>        if ( this.tiles.length === 1 ) {
<span id="line15278" class="line"></span>            options.tileWidth  = this.tiles[0].width;
<span id="line15279" class="line"></span>            // Use height if provided, otherwise assume square tiles and use width.
<span id="line15280" class="line"></span>            options.tileHeight = this.tiles[0].height || this.tiles[0].width;
<span id="line15281" class="line"></span>            this.scale_factors = this.tiles[0].scaleFactors;
<span id="line15282" class="line"></span>        } else {
<span id="line15283" class="line"></span>            // Multiple tile sizes at different levels
<span id="line15284" class="line"></span>            this.scale_factors = [];
<span id="line15285" class="line"></span>            for (let t = 0; t &lt; this.tiles.length; t++ ) {
<span id="line15286" class="line"></span>                for (let sf = 0; sf &lt; this.tiles[t].scaleFactors.length; sf++) {
<span id="line15287" class="line"></span>                    const scaleFactor = this.tiles[t].scaleFactors[sf];
<span id="line15288" class="line"></span>                    this.scale_factors.push(scaleFactor);
<span id="line15289" class="line"></span>                    options.tileSizePerScaleFactor[scaleFactor] = {
<span id="line15290" class="line"></span>                        width: this.tiles[t].width,
<span id="line15291" class="line"></span>                        height: this.tiles[t].height || this.tiles[t].width
<span id="line15292" class="line"></span>                    };
<span id="line15293" class="line"></span>                }
<span id="line15294" class="line"></span>            }
<span id="line15295" class="line"></span>        }
<span id="line15296" class="line"></span>    } else if ( canBeTiled(options) ) {
<span id="line15297" class="line"></span>        // use the largest of tileOptions that is smaller than the short dimension
<span id="line15298" class="line"></span>        const shortDim = Math.min( this.height, this.width );
<span id="line15299" class="line"></span>        const tileOptions = [256, 512, 1024];
<span id="line15300" class="line"></span>        const smallerTiles = [];
<span id="line15301" class="line"></span>
<span id="line15302" class="line"></span>        for ( let c = 0; c &lt; tileOptions.length; c++ ) {
<span id="line15303" class="line"></span>            if ( tileOptions[c] &lt;= shortDim ) {
<span id="line15304" class="line"></span>                smallerTiles.push( tileOptions[c] );
<span id="line15305" class="line"></span>            }
<span id="line15306" class="line"></span>        }
<span id="line15307" class="line"></span>
<span id="line15308" class="line"></span>        if ( smallerTiles.length &gt; 0 ) {
<span id="line15309" class="line"></span>            options.tileSize = Math.max.apply( null, smallerTiles );
<span id="line15310" class="line"></span>        } else {
<span id="line15311" class="line"></span>            // If we're smaller than 256, just use the short side.
<span id="line15312" class="line"></span>            options.tileSize = shortDim;
<span id="line15313" class="line"></span>        }
<span id="line15314" class="line"></span>    } else if (this.sizes &amp;&amp; this.sizes.length &gt; 0) {
<span id="line15315" class="line"></span>        // This info.json can't be tiled, but we can still construct a legacy pyramid from the sizes array.
<span id="line15316" class="line"></span>        // In this mode, IIIFTileSource will call functions from the abstract baseTileSource or the
<span id="line15317" class="line"></span>        // LegacyTileSource instead of performing IIIF tiling.
<span id="line15318" class="line"></span>        this.emulateLegacyImagePyramid = true;
<span id="line15319" class="line"></span>
<span id="line15320" class="line"></span>        options.levels = constructLevels( this );
<span id="line15321" class="line"></span>        // use the largest available size to define tiles
<span id="line15322" class="line"></span>        $.extend( true, options, {
<span id="line15323" class="line"></span>            width: options.levels[ options.levels.length - 1 ].width,
<span id="line15324" class="line"></span>            height: options.levels[ options.levels.length - 1 ].height,
<span id="line15325" class="line"></span>            tileSize: Math.max( options.height, options.width ),
<span id="line15326" class="line"></span>            tileOverlap: 0,
<span id="line15327" class="line"></span>            minLevel: 0,
<span id="line15328" class="line"></span>            maxLevel: options.levels.length - 1
<span id="line15329" class="line"></span>        });
<span id="line15330" class="line"></span>        this.levels = options.levels;
<span id="line15331" class="line"></span>    } else {
<span id="line15332" class="line"></span>        $.console.error("Nothing in the info.json to construct image pyramids from");
<span id="line15333" class="line"></span>    }
<span id="line15334" class="line"></span>
<span id="line15335" class="line"></span>    if (!options.maxLevel &amp;&amp; !this.emulateLegacyImagePyramid) {
<span id="line15336" class="line"></span>        if (!this.scale_factors) {
<span id="line15337" class="line"></span>            options.maxLevel = Number(Math.round(Math.log(Math.max(this.width, this.height), 2)));
<span id="line15338" class="line"></span>        } else {
<span id="line15339" class="line"></span>            const maxScaleFactor = Math.max.apply(null, this.scale_factors);
<span id="line15340" class="line"></span>            options.maxLevel = Math.round(Math.log(maxScaleFactor) * Math.LOG2E);
<span id="line15341" class="line"></span>        }
<span id="line15342" class="line"></span>    }
<span id="line15343" class="line"></span>
<span id="line15344" class="line"></span>    // Create an array with precise resolution sizes if these have been supplied through the 'sizes' object
<span id="line15345" class="line"></span>    if( this.sizes ) {
<span id="line15346" class="line"></span>        let sizeLength = this.sizes.length;
<span id="line15347" class="line"></span>
<span id="line15348" class="line"></span>        // Create a copy of the sizes list and sort in ascending order
<span id="line15349" class="line"></span>        const sortedSizes = this.sizes.slice().sort(( size1, size2 ) =&gt; size1.width - size2.width);
<span id="line15350" class="line"></span>
<span id="line15351" class="line"></span>        // List may or may not include the full resolution size (should be last after sorting): add it if necessary
<span id="line15352" class="line"></span>        if( sortedSizes[sizeLength - 1].width &lt; this.width &amp;&amp; sortedSizes[sizeLength - 1].height &lt; this.height ) {
<span id="line15353" class="line"></span>            sortedSizes.push( {width: this.width, height: this.height} );
<span id="line15354" class="line"></span>            sizeLength++;
<span id="line15355" class="line"></span>        }
<span id="line15356" class="line"></span>
<span id="line15357" class="line"></span>        // Only try to use 'sizes' if the number of dimensions within exactly matches the number of resolution levels (maxLevel+1)
<span id="line15358" class="line"></span>        if ( sizeLength === options.maxLevel + 1 ) {
<span id="line15359" class="line"></span>
<span id="line15360" class="line"></span>            // If we have a list of scaleFactors, make sure each of our sizes really corresponds to the listed scales
<span id="line15361" class="line"></span>            let isResolutionList = 1;
<span id="line15362" class="line"></span>            if ( this.scale_factors &amp;&amp; this.scale_factors.length === sizeLength ) {
<span id="line15363" class="line"></span>                for ( let i = 0; i &lt; sizeLength; i++ ) {
<span id="line15364" class="line"></span>                    const factor = this.scale_factors[sizeLength - i - 1]; // Scale factor order is inverted
<span id="line15365" class="line"></span>                    if ( Math.round( this.width / sortedSizes[i].width ) !== factor ||
<span id="line15366" class="line"></span>                         Math.round( this.height / sortedSizes[i].height ) !== factor ) {
<span id="line15367" class="line"></span>                        isResolutionList = 0;
<span id="line15368" class="line"></span>                        break;
<span id="line15369" class="line"></span>                    }
<span id="line15370" class="line"></span>                }
<span id="line15371" class="line"></span>            }
<span id="line15372" class="line"></span>            // The 'sizes' array does indeed contain a list of resolution levels, so assign our sorted array
<span id="line15373" class="line"></span>            if ( isResolutionList === 1 ) {
<span id="line15374" class="line"></span>                this.levelSizes = sortedSizes;
<span id="line15375" class="line"></span>            }
<span id="line15376" class="line"></span>        }
<span id="line15377" class="line"></span>    }
<span id="line15378" class="line"></span>
<span id="line15379" class="line"></span>    $.TileSource.apply( this, [ options ] );
<span id="line15380" class="line"></span>};
<span id="line15381" class="line"></span>
<span id="line15382" class="line"></span>$.extend( $.IIIFTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.IIIFTileSource.prototype */{
<span id="line15383" class="line"></span>    /**
<span id="line15384" class="line"></span>     * Determine if the data and/or url imply the image service is supported by
<span id="line15385" class="line"></span>     * this tile source.
<span id="line15386" class="line"></span>     * @function
<span id="line15387" class="line"></span>     * @param {Object|Array} data
<span id="line15388" class="line"></span>     * @param {String} [url] - url
<span id="line15389" class="line"></span>     */
<span id="line15390" class="line"></span>
<span id="line15391" class="line"></span>    supports: function( data, url ) {
<span id="line15392" class="line"></span>        // Version 2.0 and forwards
<span id="line15393" class="line"></span>        if (data.protocol &amp;&amp; data.protocol === 'http://iiif.io/api/image') {
<span id="line15394" class="line"></span>            return true;
<span id="line15395" class="line"></span>        // Version 1.1
<span id="line15396" class="line"></span>        } else if ( data['@context'] &amp;&amp; (
<span id="line15397" class="line"></span>            data['@context'] === "http://library.stanford.edu/iiif/image-api/1.1/context.json" ||
<span id="line15398" class="line"></span>            data['@context'] === "http://iiif.io/api/image/1/context.json") ) {
<span id="line15399" class="line"></span>            // N.B. the iiif.io context is wrong, but where the representation lives so likely to be used
<span id="line15400" class="line"></span>            return true;
<span id="line15401" class="line"></span>
<span id="line15402" class="line"></span>        // Version 1.0
<span id="line15403" class="line"></span>        } else if ( data.profile &amp;&amp;
<span id="line15404" class="line"></span>            data.profile.indexOf("http://library.stanford.edu/iiif/image-api/compliance.html") === 0) {
<span id="line15405" class="line"></span>            return true;
<span id="line15406" class="line"></span>        } else if ( data.identifier &amp;&amp; data.width &amp;&amp; data.height ) {
<span id="line15407" class="line"></span>            return true;
<span id="line15408" class="line"></span>        } else if ( data.documentElement &amp;&amp;
<span id="line15409" class="line"></span>            "info" === data.documentElement.tagName &amp;&amp;
<span id="line15410" class="line"></span>            "http://library.stanford.edu/iiif/image-api/ns/" ===
<span id="line15411" class="line"></span>                data.documentElement.namespaceURI) {
<span id="line15412" class="line"></span>            return true;
<span id="line15413" class="line"></span>
<span id="line15414" class="line"></span>        // Not IIIF
<span id="line15415" class="line"></span>        } else {
<span id="line15416" class="line"></span>            return false;
<span id="line15417" class="line"></span>        }
<span id="line15418" class="line"></span>    },
<span id="line15419" class="line"></span>
<span id="line15420" class="line"></span>    /**
<span id="line15421" class="line"></span>     * A static function used to prepare an incoming IIIF Image API info.json
<span id="line15422" class="line"></span>     * response for processing by the tile handler. Normalizes data for all
<span id="line15423" class="line"></span>     * versions of IIIF (1.0, 1.1, 2.x, 3.x) and returns a data object that
<span id="line15424" class="line"></span>     * may be passed to the IIIFTileSource.
<span id="line15425" class="line"></span>     *
<span id="line15426" class="line"></span>     * @function
<span id="line15427" class="line"></span>     * @static
<span id="line15428" class="line"></span>     * @param {Object} data - the raw configuration
<span id="line15429" class="line"></span>     * @param {String} url - the url configuration was retrieved from
<span id="line15430" class="line"></span>     * @param {String} postData - HTTP POST data in k=v&amp;k2=v2... form or null
<span id="line15431" class="line"></span>     * @returns {Object} A normalized IIIF data object
<span id="line15432" class="line"></span>     * @example &lt;caption&gt;IIIF 2.x Info Looks like this&lt;/caption&gt;
<span id="line15433" class="line"></span>     * {
<span id="line15434" class="line"></span>     * "@context": "http://iiif.io/api/image/2/context.json",
<span id="line15435" class="line"></span>     * "@id": "http://iiif.example.com/prefix/1E34750D-38DB-4825-A38A-B60A345E591C",
<span id="line15436" class="line"></span>     * "protocol": "http://iiif.io/api/image",
<span id="line15437" class="line"></span>     * "height": 1024,
<span id="line15438" class="line"></span>     * "width": 775,
<span id="line15439" class="line"></span>     * "tiles" : [{"width":256, "scaleFactors":[1,2,4,8]}],
<span id="line15440" class="line"></span>     *  "profile": ["http://iiif.io/api/image/2/level1.json", {
<span id="line15441" class="line"></span>     *    "qualities": [ "native", "bitonal", "grey", "color" ],
<span id="line15442" class="line"></span>     *    "formats": [ "jpg", "png", "gif" ]
<span id="line15443" class="line"></span>     *   }]
<span id="line15444" class="line"></span>     * }
<span id="line15445" class="line"></span>     */
<span id="line15446" class="line"></span>    configure: function( data, url, postData ){
<span id="line15447" class="line"></span>        // Try to deduce our version and fake it upwards if needed
<span id="line15448" class="line"></span>        if ( !$.isPlainObject(data) ) {
<span id="line15449" class="line"></span>            const options = configureFromXml10( data );
<span id="line15450" class="line"></span>            options['@context'] = "http://iiif.io/api/image/1.0/context.json";
<span id="line15451" class="line"></span>            options["@id"] = url.replace('/info.xml', '');
<span id="line15452" class="line"></span>            options.version = 1;
<span id="line15453" class="line"></span>            return options;
<span id="line15454" class="line"></span>        } else {
<span id="line15455" class="line"></span>            if ( !data['@context'] ) {
<span id="line15456" class="line"></span>                data['@context'] = 'http://iiif.io/api/image/1.0/context.json';
<span id="line15457" class="line"></span>                data["@id"] = url.replace('/info.json', '');
<span id="line15458" class="line"></span>                data.version = 1;
<span id="line15459" class="line"></span>            } else {
<span id="line15460" class="line"></span>                let context = data['@context'];
<span id="line15461" class="line"></span>                if (Array.isArray(context)) {
<span id="line15462" class="line"></span>                    for (let i = 0; i &lt; context.length; i++) {
<span id="line15463" class="line"></span>                        if (typeof context[i] === 'string' &amp;&amp;
<span id="line15464" class="line"></span>                            ( /^http:\/\/iiif\.io\/api\/image\/[1-3]\/context\.json$/.test(context[i]) ||
<span id="line15465" class="line"></span>                            context[i] === 'http://library.stanford.edu/iiif/image-api/1.1/context.json' ) ) {
<span id="line15466" class="line"></span>                            context = context[i];
<span id="line15467" class="line"></span>                            break;
<span id="line15468" class="line"></span>                        }
<span id="line15469" class="line"></span>                    }
<span id="line15470" class="line"></span>                }
<span id="line15471" class="line"></span>                switch (context) {
<span id="line15472" class="line"></span>                    case 'http://iiif.io/api/image/1/context.json':
<span id="line15473" class="line"></span>                    case 'http://library.stanford.edu/iiif/image-api/1.1/context.json':
<span id="line15474" class="line"></span>                        data.version = 1;
<span id="line15475" class="line"></span>                        break;
<span id="line15476" class="line"></span>                    case 'http://iiif.io/api/image/2/context.json':
<span id="line15477" class="line"></span>                        data.version = 2;
<span id="line15478" class="line"></span>                        break;
<span id="line15479" class="line"></span>                    case 'http://iiif.io/api/image/3/context.json':
<span id="line15480" class="line"></span>                        data.version = 3;
<span id="line15481" class="line"></span>                        break;
<span id="line15482" class="line"></span>                    default:
<span id="line15483" class="line"></span>                        $.console.error('Data has a @context property which contains no known IIIF context URI.');
<span id="line15484" class="line"></span>                }
<span id="line15485" class="line"></span>            }
<span id="line15486" class="line"></span>
<span id="line15487" class="line"></span>            if (data.preferredFormats) {
<span id="line15488" class="line"></span>                for (let f = 0; f &lt; data.preferredFormats.length; f++ ) {
<span id="line15489" class="line"></span>                    if ( $.imageFormatSupported(data.preferredFormats[f]) ) {
<span id="line15490" class="line"></span>                        data.tileFormat = data.preferredFormats[f];
<span id="line15491" class="line"></span>                        break;
<span id="line15492" class="line"></span>                    }
<span id="line15493" class="line"></span>                }
<span id="line15494" class="line"></span>            }
<span id="line15495" class="line"></span>            return data;
<span id="line15496" class="line"></span>        }
<span id="line15497" class="line"></span>    },
<span id="line15498" class="line"></span>
<span id="line15499" class="line"></span>    /**
<span id="line15500" class="line"></span>     * Return the tileWidth for the given level.
<span id="line15501" class="line"></span>     * @function
<span id="line15502" class="line"></span>     * @param {Number} level
<span id="line15503" class="line"></span>     */
<span id="line15504" class="line"></span>    getTileWidth: function( level ) {
<span id="line15505" class="line"></span>
<span id="line15506" class="line"></span>        if(this.emulateLegacyImagePyramid) {
<span id="line15507" class="line"></span>            return $.TileSource.prototype.getTileWidth.call(this, level);
<span id="line15508" class="line"></span>        }
<span id="line15509" class="line"></span>
<span id="line15510" class="line"></span>        const scaleFactor = Math.pow(2, this.maxLevel - level);
<span id="line15511" class="line"></span>
<span id="line15512" class="line"></span>        if (this.tileSizePerScaleFactor &amp;&amp; this.tileSizePerScaleFactor[scaleFactor]) {
<span id="line15513" class="line"></span>            return this.tileSizePerScaleFactor[scaleFactor].width;
<span id="line15514" class="line"></span>        }
<span id="line15515" class="line"></span>        return this._tileWidth;
<span id="line15516" class="line"></span>    },
<span id="line15517" class="line"></span>
<span id="line15518" class="line"></span>    /**
<span id="line15519" class="line"></span>     * Return the tileHeight for the given level.
<span id="line15520" class="line"></span>     * @function
<span id="line15521" class="line"></span>     * @param {Number} level
<span id="line15522" class="line"></span>     */
<span id="line15523" class="line"></span>    getTileHeight: function( level ) {
<span id="line15524" class="line"></span>
<span id="line15525" class="line"></span>        if(this.emulateLegacyImagePyramid) {
<span id="line15526" class="line"></span>            return $.TileSource.prototype.getTileHeight.call(this, level);
<span id="line15527" class="line"></span>        }
<span id="line15528" class="line"></span>
<span id="line15529" class="line"></span>        const scaleFactor = Math.pow(2, this.maxLevel - level);
<span id="line15530" class="line"></span>
<span id="line15531" class="line"></span>        if (this.tileSizePerScaleFactor &amp;&amp; this.tileSizePerScaleFactor[scaleFactor]) {
<span id="line15532" class="line"></span>            return this.tileSizePerScaleFactor[scaleFactor].height;
<span id="line15533" class="line"></span>        }
<span id="line15534" class="line"></span>        return this._tileHeight;
<span id="line15535" class="line"></span>    },
<span id="line15536" class="line"></span>
<span id="line15537" class="line"></span>    /**
<span id="line15538" class="line"></span>     * @function
<span id="line15539" class="line"></span>     * @param {Number} level
<span id="line15540" class="line"></span>     */
<span id="line15541" class="line"></span>    getLevelScale: function ( level ) {
<span id="line15542" class="line"></span>
<span id="line15543" class="line"></span>        if(this.emulateLegacyImagePyramid) {
<span id="line15544" class="line"></span>            let levelScale = NaN;
<span id="line15545" class="line"></span>            if (this.levels.length &gt; 0 &amp;&amp; level &gt;= this.minLevel &amp;&amp; level &lt;= this.maxLevel) {
<span id="line15546" class="line"></span>                levelScale =
<span id="line15547" class="line"></span>                    this.levels[level].width /
<span id="line15548" class="line"></span>                    this.levels[this.maxLevel].width;
<span id="line15549" class="line"></span>            }
<span id="line15550" class="line"></span>            return levelScale;
<span id="line15551" class="line"></span>        }
<span id="line15552" class="line"></span>
<span id="line15553" class="line"></span>        return $.TileSource.prototype.getLevelScale.call(this, level);
<span id="line15554" class="line"></span>    },
<span id="line15555" class="line"></span>
<span id="line15556" class="line"></span>    /**
<span id="line15557" class="line"></span>     * @function
<span id="line15558" class="line"></span>     * @param {Number} level
<span id="line15559" class="line"></span>     */
<span id="line15560" class="line"></span>    getNumTiles: function( level ) {
<span id="line15561" class="line"></span>
<span id="line15562" class="line"></span>        if(this.emulateLegacyImagePyramid) {
<span id="line15563" class="line"></span>            const scale = this.getLevelScale(level);
<span id="line15564" class="line"></span>            if (scale) {
<span id="line15565" class="line"></span>                return new $.Point(1, 1);
<span id="line15566" class="line"></span>            } else {
<span id="line15567" class="line"></span>                return new $.Point(0, 0);
<span id="line15568" class="line"></span>            }
<span id="line15569" class="line"></span>        }
<span id="line15570" class="line"></span>
<span id="line15571" class="line"></span>        // Use supplied list of scaled resolution sizes if these exist
<span id="line15572" class="line"></span>        if( this.levelSizes ) {
<span id="line15573" class="line"></span>            const levelSize = this.levelSizes[level];
<span id="line15574" class="line"></span>            const x = Math.ceil( levelSize.width / this.getTileWidth(level) );
<span id="line15575" class="line"></span>            const y = Math.ceil( levelSize.height / this.getTileHeight(level) );
<span id="line15576" class="line"></span>            return new $.Point( x, y );
<span id="line15577" class="line"></span>        }
<span id="line15578" class="line"></span>        // Otherwise call default TileSource-&gt;getNumTiles() function
<span id="line15579" class="line"></span>        else {
<span id="line15580" class="line"></span>            return $.TileSource.prototype.getNumTiles.call(this, level);
<span id="line15581" class="line"></span>        }
<span id="line15582" class="line"></span>    },
<span id="line15583" class="line"></span>
<span id="line15584" class="line"></span>
<span id="line15585" class="line"></span>    /**
<span id="line15586" class="line"></span>     * @function
<span id="line15587" class="line"></span>     * @param {Number} level
<span id="line15588" class="line"></span>     * @param {OpenSeadragon.Point} point
<span id="line15589" class="line"></span>     */
<span id="line15590" class="line"></span>    getTileAtPoint: function( level, point ) {
<span id="line15591" class="line"></span>
<span id="line15592" class="line"></span>        if(this.emulateLegacyImagePyramid) {
<span id="line15593" class="line"></span>            return new $.Point(0, 0);
<span id="line15594" class="line"></span>        }
<span id="line15595" class="line"></span>
<span id="line15596" class="line"></span>        // Use supplied list of scaled resolution sizes if these exist
<span id="line15597" class="line"></span>        if( this.levelSizes ) {
<span id="line15598" class="line"></span>
<span id="line15599" class="line"></span>            const validPoint = point.x &gt;= 0 &amp;&amp; point.x &lt;= 1 &amp;&amp;
<span id="line15600" class="line"></span>                             point.y &gt;= 0 &amp;&amp; point.y &lt;= 1 / this.aspectRatio;
<span id="line15601" class="line"></span>            $.console.assert(validPoint, "[TileSource.getTileAtPoint] must be called with a valid point.");
<span id="line15602" class="line"></span>
<span id="line15603" class="line"></span>            const widthScaled = this.levelSizes[level].width;
<span id="line15604" class="line"></span>            const pixelX = point.x * widthScaled;
<span id="line15605" class="line"></span>            const pixelY = point.y * widthScaled;
<span id="line15606" class="line"></span>
<span id="line15607" class="line"></span>            let x = Math.floor(pixelX / this.getTileWidth(level));
<span id="line15608" class="line"></span>            let y = Math.floor(pixelY / this.getTileHeight(level));
<span id="line15609" class="line"></span>
<span id="line15610" class="line"></span>            // When point.x == 1 or point.y == 1 / this.aspectRatio we want to
<span id="line15611" class="line"></span>            // return the last tile of the row/column
<span id="line15612" class="line"></span>            if (point.x &gt;= 1) {
<span id="line15613" class="line"></span>                x = this.getNumTiles(level).x - 1;
<span id="line15614" class="line"></span>            }
<span id="line15615" class="line"></span>            const EPSILON = 1e-15;
<span id="line15616" class="line"></span>            if (point.y &gt;= 1 / this.aspectRatio - EPSILON) {
<span id="line15617" class="line"></span>                y = this.getNumTiles(level).y - 1;
<span id="line15618" class="line"></span>            }
<span id="line15619" class="line"></span>
<span id="line15620" class="line"></span>            return new $.Point(x, y);
<span id="line15621" class="line"></span>        }
<span id="line15622" class="line"></span>
<span id="line15623" class="line"></span>        // Otherwise call default TileSource-&gt;getTileAtPoint() function
<span id="line15624" class="line"></span>        return $.TileSource.prototype.getTileAtPoint.call(this, level, point);
<span id="line15625" class="line"></span>    },
<span id="line15626" class="line"></span>
<span id="line15627" class="line"></span>
<span id="line15628" class="line"></span>    /**
<span id="line15629" class="line"></span>     * Responsible for retrieving the url which will return an image for the
<span id="line15630" class="line"></span>     * region specified by the given x, y, and level components.
<span id="line15631" class="line"></span>     * @function
<span id="line15632" class="line"></span>     * @param {Number} level - z index
<span id="line15633" class="line"></span>     * @param {Number} x
<span id="line15634" class="line"></span>     * @param {Number} y
<span id="line15635" class="line"></span>     * @throws {Error}
<span id="line15636" class="line"></span>     */
<span id="line15637" class="line"></span>    getTileUrl: function( level, x, y ){
<span id="line15638" class="line"></span>
<span id="line15639" class="line"></span>        if(this.emulateLegacyImagePyramid) {
<span id="line15640" class="line"></span>            let url = null;
<span id="line15641" class="line"></span>            if ( this.levels.length &gt; 0 &amp;&amp; level &gt;= this.minLevel &amp;&amp; level &lt;= this.maxLevel ) {
<span id="line15642" class="line"></span>                url = this.levels[ level ].url;
<span id="line15643" class="line"></span>            }
<span id="line15644" class="line"></span>            return url;
<span id="line15645" class="line"></span>        }
<span id="line15646" class="line"></span>
<span id="line15647" class="line"></span>        //# constants
<span id="line15648" class="line"></span>        const IIIF_ROTATION = '0';
<span id="line15649" class="line"></span>            //## get the scale (level as a decimal)
<span id="line15650" class="line"></span>        const scale = Math.pow( 0.5, this.maxLevel - level );
<span id="line15651" class="line"></span>            //# image dimensions at this level
<span id="line15652" class="line"></span>        let levelWidth;
<span id="line15653" class="line"></span>        let levelHeight;
<span id="line15654" class="line"></span>
<span id="line15655" class="line"></span>            //## iiif region
<span id="line15656" class="line"></span>        let tileWidth;
<span id="line15657" class="line"></span>        let tileHeight;
<span id="line15658" class="line"></span>        let iiifTileSizeWidth;
<span id="line15659" class="line"></span>        let iiifTileSizeHeight;
<span id="line15660" class="line"></span>        let iiifRegion;
<span id="line15661" class="line"></span>        let iiifTileX;
<span id="line15662" class="line"></span>        let iiifTileY;
<span id="line15663" class="line"></span>        let iiifTileW;
<span id="line15664" class="line"></span>        let iiifTileH;
<span id="line15665" class="line"></span>        let iiifSize;
<span id="line15666" class="line"></span>        let iiifSizeW;
<span id="line15667" class="line"></span>        let iiifSizeH;
<span id="line15668" class="line"></span>        let iiifQuality;
<span id="line15669" class="line"></span>
<span id="line15670" class="line"></span>        // Use supplied list of scaled resolution sizes if these exist
<span id="line15671" class="line"></span>        if( this.levelSizes ) {
<span id="line15672" class="line"></span>            levelWidth = this.levelSizes[level].width;
<span id="line15673" class="line"></span>            levelHeight = this.levelSizes[level].height;
<span id="line15674" class="line"></span>        }
<span id="line15675" class="line"></span>        // Otherwise calculate the sizes ourselves
<span id="line15676" class="line"></span>        else {
<span id="line15677" class="line"></span>            levelWidth = Math.ceil( this.width * scale );
<span id="line15678" class="line"></span>            levelHeight = Math.ceil( this.height * scale );
<span id="line15679" class="line"></span>        }
<span id="line15680" class="line"></span>
<span id="line15681" class="line"></span>        tileWidth = this.getTileWidth(level);
<span id="line15682" class="line"></span>        tileHeight = this.getTileHeight(level);
<span id="line15683" class="line"></span>        iiifTileSizeWidth = Math.round( tileWidth / scale );
<span id="line15684" class="line"></span>        iiifTileSizeHeight = Math.round( tileHeight / scale );
<span id="line15685" class="line"></span>        if (this.version === 1) {
<span id="line15686" class="line"></span>            iiifQuality = "native." + this.tileFormat;
<span id="line15687" class="line"></span>        } else {
<span id="line15688" class="line"></span>            iiifQuality = "default." + this.tileFormat;
<span id="line15689" class="line"></span>        }
<span id="line15690" class="line"></span>        if ( levelWidth &lt; tileWidth &amp;&amp; levelHeight &lt; tileHeight ){
<span id="line15691" class="line"></span>            if ( this.version === 2 &amp;&amp; levelWidth === this.width ) {
<span id="line15692" class="line"></span>                iiifSize = "full";
<span id="line15693" class="line"></span>            } else if ( this.version === 3 &amp;&amp; levelWidth === this.width &amp;&amp; levelHeight === this.height ) {
<span id="line15694" class="line"></span>                iiifSize = "max";
<span id="line15695" class="line"></span>            } else if ( this.version === 3 ) {
<span id="line15696" class="line"></span>                iiifSize = levelWidth + "," + levelHeight;
<span id="line15697" class="line"></span>            } else {
<span id="line15698" class="line"></span>                iiifSize = levelWidth + ",";
<span id="line15699" class="line"></span>            }
<span id="line15700" class="line"></span>            iiifRegion = 'full';
<span id="line15701" class="line"></span>        } else {
<span id="line15702" class="line"></span>            iiifTileX = x * iiifTileSizeWidth;
<span id="line15703" class="line"></span>            iiifTileY = y * iiifTileSizeHeight;
<span id="line15704" class="line"></span>            iiifTileW = Math.min( iiifTileSizeWidth, this.width - iiifTileX );
<span id="line15705" class="line"></span>            iiifTileH = Math.min( iiifTileSizeHeight, this.height - iiifTileY );
<span id="line15706" class="line"></span>            if ( x === 0 &amp;&amp; y === 0 &amp;&amp; iiifTileW === this.width &amp;&amp; iiifTileH === this.height ) {
<span id="line15707" class="line"></span>                iiifRegion = "full";
<span id="line15708" class="line"></span>            } else {
<span id="line15709" class="line"></span>                iiifRegion = [ iiifTileX, iiifTileY, iiifTileW, iiifTileH ].join( ',' );
<span id="line15710" class="line"></span>            }
<span id="line15711" class="line"></span>            iiifSizeW = Math.min( tileWidth, levelWidth - (x * tileWidth) );
<span id="line15712" class="line"></span>            iiifSizeH = Math.min( tileHeight, levelHeight - (y * tileHeight) );
<span id="line15713" class="line"></span>            if ( this.version === 2 &amp;&amp; iiifSizeW === this.width ) {
<span id="line15714" class="line"></span>                iiifSize = "full";
<span id="line15715" class="line"></span>            } else if ( this.version === 3 &amp;&amp; iiifSizeW === this.width &amp;&amp; iiifSizeH === this.height ) {
<span id="line15716" class="line"></span>                iiifSize = "max";
<span id="line15717" class="line"></span>            } else if (this.isLevel0 &amp;&amp; this.version &lt; 3) {
<span id="line15718" class="line"></span>                iiifSize = iiifSizeW + ",";
<span id="line15719" class="line"></span>            } else {
<span id="line15720" class="line"></span>                iiifSize = iiifSizeW + "," + iiifSizeH;
<span id="line15721" class="line"></span>            }
<span id="line15722" class="line"></span>        }
<span id="line15723" class="line"></span>        const uri = [ this._id, iiifRegion, iiifSize, IIIF_ROTATION, iiifQuality ].join( '/' );
<span id="line15724" class="line"></span>
<span id="line15725" class="line"></span>        return uri;
<span id="line15726" class="line"></span>    },
<span id="line15727" class="line"></span>
<span id="line15728" class="line"></span>    /**
<span id="line15729" class="line"></span>     * Equality comparator
<span id="line15730" class="line"></span>     */
<span id="line15731" class="line"></span>    equals: function(otherSource) {
<span id="line15732" class="line"></span>        return otherSource &amp;&amp; this._id === otherSource._id;
<span id="line15733" class="line"></span>    },
<span id="line15734" class="line"></span>
<span id="line15735" class="line"></span>    __testonly__: {
<span id="line15736" class="line"></span>        canBeTiled: canBeTiled,
<span id="line15737" class="line"></span>        constructLevels: constructLevels
<span id="line15738" class="line"></span>    }
<span id="line15739" class="line"></span>
<span id="line15740" class="line"></span>  });
<span id="line15741" class="line"></span>
<span id="line15742" class="line"></span>    /**
<span id="line15743" class="line"></span>     * Determine whether we have a level 0 compliance profile
<span id="line15744" class="line"></span>     * @function
<span id="line15745" class="line"></span>     * @param {Object} options
<span id="line15746" class="line"></span>     * @param {Array|String} options.profile
<span id="line15747" class="line"></span>     * @returns {Boolean}
<span id="line15748" class="line"></span>     */
<span id="line15749" class="line"></span>    function checkLevel0 ( options ) {
<span id="line15750" class="line"></span>        const level0Profiles = [
<span id="line15751" class="line"></span>            "http://library.stanford.edu/iiif/image-api/compliance.html#level0",
<span id="line15752" class="line"></span>            "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0",
<span id="line15753" class="line"></span>            "http://iiif.io/api/image/2/level0.json",
<span id="line15754" class="line"></span>            "level0",
<span id="line15755" class="line"></span>            "https://iiif.io/api/image/3/level0.json"
<span id="line15756" class="line"></span>        ];
<span id="line15757" class="line"></span>        const profileLevel = Array.isArray(options.profile) ? options.profile[0] : options.profile;
<span id="line15758" class="line"></span>        const isLevel0 = (level0Profiles.indexOf(profileLevel) !== -1);
<span id="line15759" class="line"></span>        return isLevel0;
<span id="line15760" class="line"></span>    }
<span id="line15761" class="line"></span>
<span id="line15762" class="line"></span>
<span id="line15763" class="line"></span>    /**
<span id="line15764" class="line"></span>     * Determine whether arbitrary tile requests can be made against a service with the given profile
<span id="line15765" class="line"></span>     * @function
<span id="line15766" class="line"></span>     * @param {Object} options
<span id="line15767" class="line"></span>     * @param {Array|String} options.profile
<span id="line15768" class="line"></span>     * @param {Number} options.version
<span id="line15769" class="line"></span>     * @param {String[]} options.extraFeatures
<span id="line15770" class="line"></span>     * @returns {Boolean}
<span id="line15771" class="line"></span>     */
<span id="line15772" class="line"></span>    function canBeTiled ( options ) {
<span id="line15773" class="line"></span>        const isLevel0 = checkLevel0( options );
<span id="line15774" class="line"></span>        let hasCanonicalSizeFeature = false;
<span id="line15775" class="line"></span>        if ( options.version === 2 &amp;&amp; options.profile.length &gt; 1 &amp;&amp; options.profile[1].supports ) {
<span id="line15776" class="line"></span>            hasCanonicalSizeFeature = options.profile[1].supports.indexOf( "sizeByW" ) !== -1;
<span id="line15777" class="line"></span>        }
<span id="line15778" class="line"></span>        if ( options.version === 3 &amp;&amp; options.extraFeatures ) {
<span id="line15779" class="line"></span>            hasCanonicalSizeFeature = options.extraFeatures.indexOf( "sizeByWh" ) !== -1;
<span id="line15780" class="line"></span>        }
<span id="line15781" class="line"></span>        return !isLevel0 || hasCanonicalSizeFeature;
<span id="line15782" class="line"></span>    }
<span id="line15783" class="line"></span>
<span id="line15784" class="line"></span>
<span id="line15785" class="line"></span>    /**
<span id="line15786" class="line"></span>     * Build the legacy pyramid URLs (one tile per level)
<span id="line15787" class="line"></span>     * @function
<span id="line15788" class="line"></span>     * @param {object} options - infoJson
<span id="line15789" class="line"></span>     * @throws {Error}
<span id="line15790" class="line"></span>     */
<span id="line15791" class="line"></span>    function constructLevels(options) {
<span id="line15792" class="line"></span>        const levels = [];
<span id="line15793" class="line"></span>        for(let i = 0; i &lt; options.sizes.length; i++) {
<span id="line15794" class="line"></span>            levels.push({
<span id="line15795" class="line"></span>                url: options._id + '/full/' + options.sizes[i].width + ',' +
<span id="line15796" class="line"></span>                    (options.version === 3 ? options.sizes[i].height : '') +
<span id="line15797" class="line"></span>                    '/0/default.' + options.tileFormat,
<span id="line15798" class="line"></span>                width: options.sizes[i].width,
<span id="line15799" class="line"></span>                height: options.sizes[i].height
<span id="line15800" class="line"></span>            });
<span id="line15801" class="line"></span>        }
<span id="line15802" class="line"></span>        return levels.sort(function(a, b) {
<span id="line15803" class="line"></span>            return a.width - b.width;
<span id="line15804" class="line"></span>        });
<span id="line15805" class="line"></span>    }
<span id="line15806" class="line"></span>
<span id="line15807" class="line"></span>
<span id="line15808" class="line"></span>    function configureFromXml10(xmlDoc) {
<span id="line15809" class="line"></span>        //parse the xml
<span id="line15810" class="line"></span>        if ( !xmlDoc || !xmlDoc.documentElement ) {
<span id="line15811" class="line"></span>            throw new Error( $.getString( "Errors.Xml" ) );
<span id="line15812" class="line"></span>        }
<span id="line15813" class="line"></span>
<span id="line15814" class="line"></span>        const root            = xmlDoc.documentElement;
<span id="line15815" class="line"></span>        const rootName        = root.tagName;
<span id="line15816" class="line"></span>        let configuration   = null;
<span id="line15817" class="line"></span>
<span id="line15818" class="line"></span>        if ( rootName === "info" ) {
<span id="line15819" class="line"></span>            try {
<span id="line15820" class="line"></span>                configuration = {};
<span id="line15821" class="line"></span>                parseXML10( root, configuration );
<span id="line15822" class="line"></span>                return configuration;
<span id="line15823" class="line"></span>
<span id="line15824" class="line"></span>            } catch ( e ) {
<span id="line15825" class="line"></span>                throw (e instanceof Error) ?
<span id="line15826" class="line"></span>                    e :
<span id="line15827" class="line"></span>                    new Error( $.getString("Errors.IIIF") );
<span id="line15828" class="line"></span>            }
<span id="line15829" class="line"></span>        }
<span id="line15830" class="line"></span>        throw new Error( $.getString( "Errors.IIIF" ) );
<span id="line15831" class="line"></span>    }
<span id="line15832" class="line"></span>
<span id="line15833" class="line"></span>    function parseXML10( node, configuration, property ) {
<span id="line15834" class="line"></span>        if ( node.nodeType === 3 &amp;&amp; property ) {//text node
<span id="line15835" class="line"></span>            let value = node.nodeValue.trim();
<span id="line15836" class="line"></span>            if( value.match(/^\d*$/)){
<span id="line15837" class="line"></span>                value = Number( value );
<span id="line15838" class="line"></span>            }
<span id="line15839" class="line"></span>            if( !configuration[ property ] ){
<span id="line15840" class="line"></span>                configuration[ property ] = value;
<span id="line15841" class="line"></span>            }else{
<span id="line15842" class="line"></span>                if( !$.isArray( configuration[ property ] ) ){
<span id="line15843" class="line"></span>                    configuration[ property ] = [ configuration[ property ] ];
<span id="line15844" class="line"></span>                }
<span id="line15845" class="line"></span>                configuration[ property ].push( value );
<span id="line15846" class="line"></span>            }
<span id="line15847" class="line"></span>        } else if( node.nodeType === 1 ){
<span id="line15848" class="line"></span>            for( let i = 0; i &lt; node.childNodes.length; i++ ){
<span id="line15849" class="line"></span>                parseXML10( node.childNodes[ i ], configuration, node.nodeName );
<span id="line15850" class="line"></span>            }
<span id="line15851" class="line"></span>        }
<span id="line15852" class="line"></span>    }
<span id="line15853" class="line"></span>
<span id="line15854" class="line"></span>
<span id="line15855" class="line"></span>
<span id="line15856" class="line"></span>}( OpenSeadragon ));
<span id="line15857" class="line"></span>
<span id="line15858" class="line"></span>/**
<span id="line15859" class="line"></span> * OpenSeadragon - IIPTileSource
<span id="line15860" class="line"></span> *
<span id="line15861" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line15862" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line15863" class="line"></span> *
<span id="line15864" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line15865" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line15866" class="line"></span> * met:
<span id="line15867" class="line"></span> *
<span id="line15868" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line15869" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line15870" class="line"></span> *
<span id="line15871" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line15872" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line15873" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line15874" class="line"></span> *
<span id="line15875" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line15876" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line15877" class="line"></span> *   this software without specific prior written permission.
<span id="line15878" class="line"></span> *
<span id="line15879" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line15880" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line15881" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line15882" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line15883" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line15884" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line15885" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line15886" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line15887" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line15888" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line15889" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. *
<span id="line15890" class="line"></span> *
<span id="line15891" class="line"></span> */
<span id="line15892" class="line"></span>
<span id="line15893" class="line"></span>
<span id="line15894" class="line"></span>(function($) {
<span id="line15895" class="line"></span>
<span id="line15896" class="line"></span>  /**
<span id="line15897" class="line"></span>   * @class IIPTileSource
<span id="line15898" class="line"></span>   * @classdesc A tilesource implementation for the Internet Imaging Protocol (IIP).
<span id="line15899" class="line"></span>   *
<span id="line15900" class="line"></span>   * @memberof OpenSeadragon
<span id="line15901" class="line"></span>   * @extends OpenSeadragon.TileSource
<span id="line15902" class="line"></span>   * @see https://iipimage.sourceforge.io
<span id="line15903" class="line"></span>   *
<span id="line15904" class="line"></span>   * @param {String} iipsrv      - IIPImage host server path (ex: "https://host/fcgi-bin/iipsrv.fcgi" or "/fcgi-bin/iipsrv.fcgi")
<span id="line15905" class="line"></span>   * @param {String} image       - Image path and name on server (ex: "image.tif")
<span id="line15906" class="line"></span>   * @param {String} [format]    - Tile output format (default: "jpg")
<span id="line15907" class="line"></span>   * @param {Object} [transform] - Object containing image processing transforms
<span id="line15908" class="line"></span>   *                                        (supported transform: "stack","quality","contrast","color","invert",
<span id="line15909" class="line"></span>   *                                                              "colormap," "gamma","minmax","twist","hillshade".
<span id="line15910" class="line"></span>   *                                        See https://iipimage.sourceforge.io/documentation/protocol for how to use)
<span id="line15911" class="line"></span>   *
<span id="line15912" class="line"></span>   * Example: tileSources: {
<span id="line15913" class="line"></span>   *            iipsrv:    "/fcgi-bin/iipsrv.fcgi",
<span id="line15914" class="line"></span>   *            image:     "test.tif",
<span id="line15915" class="line"></span>   *            transform: {
<span id="line15916" class="line"></span>   *              gamma: 1.5,
<span id="line15917" class="line"></span>   *              invert: true
<span id="line15918" class="line"></span>   *            }
<span id="line15919" class="line"></span>   *          }
<span id="line15920" class="line"></span>   */
<span id="line15921" class="line"></span>
<span id="line15922" class="line"></span>  $.IIPTileSource = function(options) {
<span id="line15923" class="line"></span>
<span id="line15924" class="line"></span>    $.EventSource.call( this );
<span id="line15925" class="line"></span>
<span id="line15926" class="line"></span>    if( options &amp;&amp; options.iipsrv &amp;&amp; options.image ){
<span id="line15927" class="line"></span>      $.extend( this, options );
<span id="line15928" class="line"></span>      this.aspectRatio = 1;
<span id="line15929" class="line"></span>      this.dimensions  = new $.Point( 10, 10 );
<span id="line15930" class="line"></span>      this._tileWidth  = 0;
<span id="line15931" class="line"></span>      this._tileHeight = 0;
<span id="line15932" class="line"></span>      this.tileOverlap = 0;
<span id="line15933" class="line"></span>      this.minLevel    = 0;
<span id="line15934" class="line"></span>      this.maxLevel    = 0;
<span id="line15935" class="line"></span>      this.ready       = false;
<span id="line15936" class="line"></span>
<span id="line15937" class="line"></span>      // Query server for image metadata
<span id="line15938" class="line"></span>      const url = this.getMetadataUrl();
<span id="line15939" class="line"></span>      this.getImageInfo( url );
<span id="line15940" class="line"></span>    }
<span id="line15941" class="line"></span>  };
<span id="line15942" class="line"></span>
<span id="line15943" class="line"></span>
<span id="line15944" class="line"></span>  $.extend($.IIPTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.IIPTileSource.prototype */ {
<span id="line15945" class="line"></span>
<span id="line15946" class="line"></span>    /**
<span id="line15947" class="line"></span>     * Return URL string for image metadata
<span id="line15948" class="line"></span>     * @function
<span id="line15949" class="line"></span>     * @returns {String} url - The IIP URL needed for image metadata
<span id="line15950" class="line"></span>     */
<span id="line15951" class="line"></span>    getMetadataUrl: function() {
<span id="line15952" class="line"></span>      return this.iipsrv + '?FIF=' + this.image + '&amp;obj=IIP,1.0&amp;obj=Max-size&amp;obj=Tile-size&amp;obj=Resolution-number&amp;obj=Resolutions';
<span id="line15953" class="line"></span>    },
<span id="line15954" class="line"></span>
<span id="line15955" class="line"></span>
<span id="line15956" class="line"></span>    /**
<span id="line15957" class="line"></span>     * Determine if the data and/or url imply the image service is supported by
<span id="line15958" class="line"></span>     * this tile source.
<span id="line15959" class="line"></span>     * @function
<span id="line15960" class="line"></span>     * @param {Object|Array} data
<span id="line15961" class="line"></span>     * @param {String} [url]
<span id="line15962" class="line"></span>     */
<span id="line15963" class="line"></span>    supports: function(data, url) {
<span id="line15964" class="line"></span>      // Configuration must supply the IIP server endpoint and the image name
<span id="line15965" class="line"></span>      return ( data &amp;&amp; ("iipsrv" in data) &amp;&amp; ("image" in data) );
<span id="line15966" class="line"></span>    },
<span id="line15967" class="line"></span>
<span id="line15968" class="line"></span>
<span id="line15969" class="line"></span>    /**
<span id="line15970" class="line"></span>     * Parse IIP protocol response
<span id="line15971" class="line"></span>     * @function
<span id="line15972" class="line"></span>     * @param {Object|Array} data - raw metadata from an IIP server
<span id="line15973" class="line"></span>     */
<span id="line15974" class="line"></span>    parseIIP: function( data ) {
<span id="line15975" class="line"></span>
<span id="line15976" class="line"></span>      // Full image size
<span id="line15977" class="line"></span>      let tmp = data.split( "Max-size:" );
<span id="line15978" class="line"></span>      if(!tmp[1]){
<span id="line15979" class="line"></span>        throw new Error( "No Max-size returned" );
<span id="line15980" class="line"></span>      }
<span id="line15981" class="line"></span>      let size = tmp[1].split(" ");
<span id="line15982" class="line"></span>      this.width = parseInt( size[0], 10 );
<span id="line15983" class="line"></span>      this.height = parseInt( size[1], 10 );
<span id="line15984" class="line"></span>      this.dimensions = new $.Point( this.width, this.height );
<span id="line15985" class="line"></span>
<span id="line15986" class="line"></span>      // Calculate aspect ratio
<span id="line15987" class="line"></span>      this.aspectRatio = this.width / this.height;
<span id="line15988" class="line"></span>
<span id="line15989" class="line"></span>      // Tile size
<span id="line15990" class="line"></span>      tmp = data.split( "Tile-size:" );
<span id="line15991" class="line"></span>      if(!tmp[1]){
<span id="line15992" class="line"></span>        throw new Error( "No Tile-size returned" );
<span id="line15993" class="line"></span>      }
<span id="line15994" class="line"></span>      size = tmp[1].split(" ");
<span id="line15995" class="line"></span>      this._tileWidth = parseInt(size[0], 10);
<span id="line15996" class="line"></span>      this._tileHeight = parseInt(size[1], 10);
<span id="line15997" class="line"></span>
<span id="line15998" class="line"></span>      // Number of resolution levels
<span id="line15999" class="line"></span>      tmp = data.split( "Resolution-number:" );
<span id="line16000" class="line"></span>      const numRes = parseInt(tmp[1], 10);
<span id="line16001" class="line"></span>      this.minLevel = 0;
<span id="line16002" class="line"></span>      this.maxLevel = numRes - 1;
<span id="line16003" class="line"></span>      this.tileOverlap = 0;
<span id="line16004" class="line"></span>
<span id="line16005" class="line"></span>      // Size of each resolution
<span id="line16006" class="line"></span>      tmp = data.split( "Resolutions:" );
<span id="line16007" class="line"></span>      size = tmp[1].split(",");
<span id="line16008" class="line"></span>      const len = size.length;
<span id="line16009" class="line"></span>      this.levelSizes = new Array(len);
<span id="line16010" class="line"></span>      for( let n = 0; n &lt; len; n++ ) {
<span id="line16011" class="line"></span>        const res = size[n].split(" ");
<span id="line16012" class="line"></span>        const w = parseInt(res[0], 10);
<span id="line16013" class="line"></span>        const h = parseInt(res[1], 10);
<span id="line16014" class="line"></span>        this.levelSizes[n] = {width: w, height: h};
<span id="line16015" class="line"></span>      }
<span id="line16016" class="line"></span>    },
<span id="line16017" class="line"></span>
<span id="line16018" class="line"></span>
<span id="line16019" class="line"></span>    /**
<span id="line16020" class="line"></span>     * Retrieve image metadata from an IIP-compatible server
<span id="line16021" class="line"></span>     *
<span id="line16022" class="line"></span>     * @function
<span id="line16023" class="line"></span>     * @param {String} url
<span id="line16024" class="line"></span>     * @throws {Error}
<span id="line16025" class="line"></span>     */
<span id="line16026" class="line"></span>    getImageInfo: function( url ) {
<span id="line16027" class="line"></span>
<span id="line16028" class="line"></span>      const _this = this;
<span id="line16029" class="line"></span>
<span id="line16030" class="line"></span>      $.makeAjaxRequest( {
<span id="line16031" class="line"></span>        url: url,
<span id="line16032" class="line"></span>        type: "GET",
<span id="line16033" class="line"></span>        async: false,
<span id="line16034" class="line"></span>        withCredentials: this.ajaxWithCredentials,
<span id="line16035" class="line"></span>        headers: this.ajaxHeaders,
<span id="line16036" class="line"></span>        success: function( xhr ) {
<span id="line16037" class="line"></span>          try {
<span id="line16038" class="line"></span>            OpenSeadragon[ "IIPTileSource" ].prototype.parseIIP.call( _this, xhr.responseText );
<span id="line16039" class="line"></span>            _this.ready = true;
<span id="line16040" class="line"></span>            _this.raiseEvent( 'ready', { tileSource: _this } );
<span id="line16041" class="line"></span>          }
<span id="line16042" class="line"></span>          catch( e ) {
<span id="line16043" class="line"></span>            const msg = "IIPTileSource: Error parsing IIP metadata: " + e.message;
<span id="line16044" class="line"></span>            _this.raiseEvent( 'open-failed', { message: msg, source: url } );
<span id="line16045" class="line"></span>          }
<span id="line16046" class="line"></span>        },
<span id="line16047" class="line"></span>        error: function ( xhr, exc ) {
<span id="line16048" class="line"></span>          const msg = "IIPTileSource: Unable to get IIP metadata from " + url;
<span id="line16049" class="line"></span>          $.console.error( msg );
<span id="line16050" class="line"></span>          _this.raiseEvent( 'open-failed', { message: msg, source: url });
<span id="line16051" class="line"></span>        }
<span id="line16052" class="line"></span>      });
<span id="line16053" class="line"></span>    },
<span id="line16054" class="line"></span>
<span id="line16055" class="line"></span>
<span id="line16056" class="line"></span>    /**
<span id="line16057" class="line"></span>     * Parse and configure the image metadata
<span id="line16058" class="line"></span>     * @function
<span id="line16059" class="line"></span>     * @param {String|Object|Array|Document} data
<span id="line16060" class="line"></span>     * @param {String} url - the url the data was loaded
<span id="line16061" class="line"></span>     *      from if any.
<span id="line16062" class="line"></span>     * @param {String} postData - HTTP POST data in k=v&amp;k2=v2... form or null value obtained from
<span id="line16063" class="line"></span>     *      the protocol URL after '#' sign if flag splitHashDataForPost set to 'true'
<span id="line16064" class="line"></span>     * @returns {Object} options - A dictionary of keyword arguments sufficient
<span id="line16065" class="line"></span>     *      to configure the tile source constructor (include all values you want to
<span id="line16066" class="line"></span>     *      instantiate the TileSource subclass with - what _options_ object should contain).
<span id="line16067" class="line"></span>     * @throws {Error}
<span id="line16068" class="line"></span>     */
<span id="line16069" class="line"></span>    configure: function( options, url, postData ) {
<span id="line16070" class="line"></span>      return options;
<span id="line16071" class="line"></span>    },
<span id="line16072" class="line"></span>
<span id="line16073" class="line"></span>
<span id="line16074" class="line"></span>    /**
<span id="line16075" class="line"></span>     * @function
<span id="line16076" class="line"></span>     * @param {Number} level
<span id="line16077" class="line"></span>     */
<span id="line16078" class="line"></span>    getNumTiles: function( level ) {
<span id="line16079" class="line"></span>        const levelSize = this.levelSizes[level];
<span id="line16080" class="line"></span>        let x = Math.ceil( levelSize.width / this._tileWidth );
<span id="line16081" class="line"></span>        let y = Math.ceil( levelSize.height / this._tileHeight );
<span id="line16082" class="line"></span>        return new $.Point( x, y );
<span id="line16083" class="line"></span>    },
<span id="line16084" class="line"></span>
<span id="line16085" class="line"></span>
<span id="line16086" class="line"></span>    /**
<span id="line16087" class="line"></span>     * Determine the url which will return an image for the region specified by the given x, y, and level components.
<span id="line16088" class="line"></span>     * Takes into account image processing parameters that have been set in constructor
<span id="line16089" class="line"></span>     * @function
<span id="line16090" class="line"></span>     * @param {Number} level
<span id="line16091" class="line"></span>     * @param {Number} x
<span id="line16092" class="line"></span>     * @param {Number} y
<span id="line16093" class="line"></span>     */
<span id="line16094" class="line"></span>    getTileUrl: function(level, x, y) {
<span id="line16095" class="line"></span>
<span id="line16096" class="line"></span>      // Get the exact size of this level and calculate the number of tiles across
<span id="line16097" class="line"></span>      const levelSize = this.levelSizes[level];
<span id="line16098" class="line"></span>      const ntlx = Math.ceil( levelSize.width / this._tileWidth );
<span id="line16099" class="line"></span>
<span id="line16100" class="line"></span>      // Set the base URL
<span id="line16101" class="line"></span>      let url = this.iipsrv + '?FIF=' + this.image + '&amp;';
<span id="line16102" class="line"></span>
<span id="line16103" class="line"></span>      // Apply any image procesing transform
<span id="line16104" class="line"></span>      if( this.transform ){
<span id="line16105" class="line"></span>
<span id="line16106" class="line"></span>        if( this.transform.stack ) {
<span id="line16107" class="line"></span>          url += 'SDS=' + this.transform.stack + '&amp;';
<span id="line16108" class="line"></span>        }
<span id="line16109" class="line"></span>        if( this.transform.contrast ) {
<span id="line16110" class="line"></span>          url += 'CNT=' + this.transform.contrast + '&amp;';
<span id="line16111" class="line"></span>        }
<span id="line16112" class="line"></span>        if( this.transform.gamma ) {
<span id="line16113" class="line"></span>          url += 'GAM=' + this.transform.gamma + '&amp;';
<span id="line16114" class="line"></span>        }
<span id="line16115" class="line"></span>        if( this.transform.invert &amp;&amp; this.transform.invert === true ) {
<span id="line16116" class="line"></span>          url += 'INV&amp;';
<span id="line16117" class="line"></span>        }
<span id="line16118" class="line"></span>        if( this.transform.color ) {
<span id="line16119" class="line"></span>          url += 'COL=' + this.transform.color + '&amp;';
<span id="line16120" class="line"></span>        }
<span id="line16121" class="line"></span>        if( this.transform.twist ) {
<span id="line16122" class="line"></span>          url += 'CTW=' + this.transform.twist + '&amp;';
<span id="line16123" class="line"></span>        }
<span id="line16124" class="line"></span>        if( this.transform.convolution ) {
<span id="line16125" class="line"></span>          url += 'CNV=' + this.transform.convolution + '&amp;';
<span id="line16126" class="line"></span>        }
<span id="line16127" class="line"></span>        if( this.transform.quality ) {
<span id="line16128" class="line"></span>          url += 'QLT=' + this.transform.quality + '&amp;';
<span id="line16129" class="line"></span>        }
<span id="line16130" class="line"></span>        if( this.transform.colormap ) {
<span id="line16131" class="line"></span>          url += 'CMP=' + this.transform.colormap + '&amp;';
<span id="line16132" class="line"></span>        }
<span id="line16133" class="line"></span>        if( this.transform.minmax ) {
<span id="line16134" class="line"></span>          url += 'MINMAX=' + this.transform.minmax + '&amp;';
<span id="line16135" class="line"></span>        }
<span id="line16136" class="line"></span>        if( this.transform.hillshade ) {
<span id="line16137" class="line"></span>          url += 'SHD=' + this.transform.hillshade + '&amp;';
<span id="line16138" class="line"></span>        }
<span id="line16139" class="line"></span>      }
<span id="line16140" class="line"></span>
<span id="line16141" class="line"></span>      // Our output command depends on the requested image format
<span id="line16142" class="line"></span>      let format = "JTL";
<span id="line16143" class="line"></span>      if (this.format === "png") {
<span id="line16144" class="line"></span>          format = "PTL";
<span id="line16145" class="line"></span>      } else if (this.format === "webp" ) {
<span id="line16146" class="line"></span>          format = "WTL";
<span id="line16147" class="line"></span>      } else if (this.format === "avif" ) {
<span id="line16148" class="line"></span>          format = "ATL";
<span id="line16149" class="line"></span>      }
<span id="line16150" class="line"></span>
<span id="line16151" class="line"></span>      // Calculate the tile index for this resolution
<span id="line16152" class="line"></span>      const tile = (y * ntlx) + x;
<span id="line16153" class="line"></span>
<span id="line16154" class="line"></span>      return url + format + '=' + level + ',' + tile;
<span id="line16155" class="line"></span>    }
<span id="line16156" class="line"></span>
<span id="line16157" class="line"></span>  });
<span id="line16158" class="line"></span>
<span id="line16159" class="line"></span>  $.extend( true, $.IIPTileSource.prototype, $.EventSource.prototype );
<span id="line16160" class="line"></span>
<span id="line16161" class="line"></span>}(OpenSeadragon));
<span id="line16162" class="line"></span>
<span id="line16163" class="line"></span>/**
<span id="line16164" class="line"></span> * OpenSeadragon - IrisTileSource
<span id="line16165" class="line"></span> *
<span id="line16166" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line16167" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line16168" class="line"></span> *
<span id="line16169" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line16170" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line16171" class="line"></span> * met:
<span id="line16172" class="line"></span> *
<span id="line16173" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line16174" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line16175" class="line"></span> *
<span id="line16176" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line16177" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line16178" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line16179" class="line"></span> *
<span id="line16180" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line16181" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line16182" class="line"></span> *   this software without specific prior written permission.
<span id="line16183" class="line"></span> *
<span id="line16184" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line16185" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line16186" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line16187" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line16188" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line16189" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line16190" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line16191" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line16192" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line16193" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line16194" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. *
<span id="line16195" class="line"></span> *
<span id="line16196" class="line"></span> */
<span id="line16197" class="line"></span>
<span id="line16198" class="line"></span>(function($) {
<span id="line16199" class="line"></span>
<span id="line16200" class="line"></span>  /**
<span id="line16201" class="line"></span>   * @class IrisTileSource
<span id="line16202" class="line"></span>   * @classdesc A tilesource implementation for use with Iris images.
<span id="line16203" class="line"></span>   *
<span id="line16204" class="line"></span>   * @memberof OpenSeadragon
<span id="line16205" class="line"></span>   * @extends OpenSeadragon.TileSource
<span id="line16206" class="line"></span>   *
<span id="line16207" class="line"></span>   * @param {String} type       - iris
<span id="line16208" class="line"></span>   * @param {String} serverUrl  - Iris host server path (ex: "http://localhost:3000")
<span id="line16209" class="line"></span>   * @param {String} slideId    - Image id (ex: "12345" for 12345.iris)
<span id="line16210" class="line"></span>   * @param {Object} [metadata] - Optional metadata object to use instead of fetching
<span id="line16211" class="line"></span>   *
<span id="line16212" class="line"></span>   * Example: tileSources: {
<span id="line16213" class="line"></span>   *            type:         "iris",
<span id="line16214" class="line"></span>   *            serverUrl:    "http://localhost:3000",
<span id="line16215" class="line"></span>   *            slideId:      "12345"
<span id="line16216" class="line"></span>   *          }
<span id="line16217" class="line"></span>   */
<span id="line16218" class="line"></span>
<span id="line16219" class="line"></span>  $.IrisTileSource = function(options) {
<span id="line16220" class="line"></span>
<span id="line16221" class="line"></span>    $.TileSource.apply(this, [options]);
<span id="line16222" class="line"></span>    if (!options.serverUrl || !options.slideId) {
<span id="line16223" class="line"></span>      throw new Error("IrisTileSource requires serverUrl and slideId");
<span id="line16224" class="line"></span>    }
<span id="line16225" class="line"></span>    this.serverUrl = options.serverUrl;
<span id="line16226" class="line"></span>    this.slideId = options.slideId;
<span id="line16227" class="line"></span>    this.ready = false;
<span id="line16228" class="line"></span>
<span id="line16229" class="line"></span>    if (options.metadata) {
<span id="line16230" class="line"></span>      this.parseMetadata(options.metadata);
<span id="line16231" class="line"></span>      this.ready = true;
<span id="line16232" class="line"></span>      this.raiseEvent('ready', { tileSource: this });
<span id="line16233" class="line"></span>    } else {
<span id="line16234" class="line"></span>      const url = this.getMetadataUrl();
<span id="line16235" class="line"></span>      this.getImageInfo(url);
<span id="line16236" class="line"></span>    }
<span id="line16237" class="line"></span>  };
<span id="line16238" class="line"></span>
<span id="line16239" class="line"></span>  $.extend($.IrisTileSource.prototype, $.TileSource.prototype, {
<span id="line16240" class="line"></span>    /**
<span id="line16241" class="line"></span>     * Return URL string for image metadata
<span id="line16242" class="line"></span>     * @function
<span id="line16243" class="line"></span>     * @returns {String} url - The Iris metadata URL
<span id="line16244" class="line"></span>     */
<span id="line16245" class="line"></span>    getMetadataUrl: function() {
<span id="line16246" class="line"></span>      return this.serverUrl + '/slides/' + this.slideId + '/metadata';
<span id="line16247" class="line"></span>    },
<span id="line16248" class="line"></span>
<span id="line16249" class="line"></span>    /**
<span id="line16250" class="line"></span>     * Determine if the data implies the image service is supported by this tile source.
<span id="line16251" class="line"></span>     * @function
<span id="line16252" class="line"></span>     * @param {Object} data - The raw metadata object to check
<span id="line16253" class="line"></span>     * @returns {Boolean} - True if supported, false otherwise
<span id="line16254" class="line"></span>     */
<span id="line16255" class="line"></span>    supports: function(data) {
<span id="line16256" class="line"></span>      return (data &amp;&amp; data.type === "iris" &amp;&amp; data.serverUrl &amp;&amp; data.slideId);
<span id="line16257" class="line"></span>    },
<span id="line16258" class="line"></span>
<span id="line16259" class="line"></span>    /**
<span id="line16260" class="line"></span>     * Parse Iris protocol metadata response
<span id="line16261" class="line"></span>     * @function
<span id="line16262" class="line"></span>     * @param {Object} data - Raw metadata from Iris server
<span id="line16263" class="line"></span>     */
<span id="line16264" class="line"></span>    parseMetadata: function(data) {
<span id="line16265" class="line"></span>      this._tileWidth = 256;
<span id="line16266" class="line"></span>      this._tileHeight = 256;
<span id="line16267" class="line"></span>
<span id="line16268" class="line"></span>      this.tileSize = this._tileWidth;
<span id="line16269" class="line"></span>      this.tileOverlap = 0;
<span id="line16270" class="line"></span>
<span id="line16271" class="line"></span>      const layers = data.extent.layers;
<span id="line16272" class="line"></span>
<span id="line16273" class="line"></span>      const maxLayer = layers.length - 1;
<span id="line16274" class="line"></span>      const maxScale = layers[maxLayer].scale;
<span id="line16275" class="line"></span>
<span id="line16276" class="line"></span>      this.width = Math.ceil(data.extent.width * maxScale);
<span id="line16277" class="line"></span>      this.height = Math.ceil(data.extent.height * maxScale);
<span id="line16278" class="line"></span>
<span id="line16279" class="line"></span>      this.dimensions = new $.Point(this.width, this.height);
<span id="line16280" class="line"></span>      this.aspectRatio = this.width / this.height;
<span id="line16281" class="line"></span>      this.levelSizes = layers.map(level =&gt; ({
<span id="line16282" class="line"></span>        width: Math.ceil(level.x_tiles * this._tileWidth),
<span id="line16283" class="line"></span>        height: Math.ceil(level.y_tiles * this._tileHeight),
<span id="line16284" class="line"></span>        xTiles: Math.ceil(level.x_tiles),
<span id="line16285" class="line"></span>        yTiles: Math.ceil(level.y_tiles)
<span id="line16286" class="line"></span>      }));
<span id="line16287" class="line"></span>
<span id="line16288" class="line"></span>      this.levelScales = layers.map(level =&gt; level.scale / maxScale);
<span id="line16289" class="line"></span>
<span id="line16290" class="line"></span>      this.minLevel = 0;
<span id="line16291" class="line"></span>      this.maxLevel = Math.ceil(this.levelSizes.length - 1);
<span id="line16292" class="line"></span>    },
<span id="line16293" class="line"></span>
<span id="line16294" class="line"></span>    /**
<span id="line16295" class="line"></span>     * Retrieve image metadata from an Iris-compatible server
<span id="line16296" class="line"></span>     * @function
<span id="line16297" class="line"></span>     * @param {String} url - The metadata URL
<span id="line16298" class="line"></span>     */
<span id="line16299" class="line"></span>    getImageInfo: function(url) {
<span id="line16300" class="line"></span>      const _this = this;
<span id="line16301" class="line"></span>
<span id="line16302" class="line"></span>      $.makeAjaxRequest({
<span id="line16303" class="line"></span>        url: url,
<span id="line16304" class="line"></span>        type: "GET",
<span id="line16305" class="line"></span>        async: true,
<span id="line16306" class="line"></span>        success: function(xhr) {
<span id="line16307" class="line"></span>          try {
<span id="line16308" class="line"></span>            const data = JSON.parse(xhr.responseText);
<span id="line16309" class="line"></span>            _this.parseMetadata(data);
<span id="line16310" class="line"></span>            _this.ready = true;
<span id="line16311" class="line"></span>            _this.raiseEvent('ready', { tileSource: _this });
<span id="line16312" class="line"></span>          }
<span id="line16313" class="line"></span>          catch (e) {
<span id="line16314" class="line"></span>            const msg = "IrisTileSource: Error parsing metadata: " + e.message;
<span id="line16315" class="line"></span>            $.console.error(msg);
<span id="line16316" class="line"></span>            _this.raiseEvent('open-failed', { message: msg, source: url });
<span id="line16317" class="line"></span>          }
<span id="line16318" class="line"></span>        },
<span id="line16319" class="line"></span>        error: function(xhr, exc) {
<span id="line16320" class="line"></span>          const msg = "IrisTileSource: Unable to get metadata from " + url;
<span id="line16321" class="line"></span>          $.console.error(msg);
<span id="line16322" class="line"></span>          _this.raiseEvent('open-failed', { message: msg, source: url });
<span id="line16323" class="line"></span>        }
<span id="line16324" class="line"></span>      });
<span id="line16325" class="line"></span>    },
<span id="line16326" class="line"></span>
<span id="line16327" class="line"></span>    /**
<span id="line16328" class="line"></span>     * Get the number of tiles at a given level
<span id="line16329" class="line"></span>     * @function
<span id="line16330" class="line"></span>     * @param {Number} level - The image depth level
<span id="line16331" class="line"></span>     * @returns {OpenSeadragon.Point} - Number of tiles in x and y directions
<span id="line16332" class="line"></span>     */
<span id="line16333" class="line"></span>    getNumTiles: function(level) {
<span id="line16334" class="line"></span>      if (level &lt; this.minLevel || level &gt; this.maxLevel || !this.levelSizes[level]) {
<span id="line16335" class="line"></span>        return new $.Point(0, 0);
<span id="line16336" class="line"></span>      }
<span id="line16337" class="line"></span>      return new $.Point(
<span id="line16338" class="line"></span>        Math.ceil(this.levelSizes[level].xTiles),
<span id="line16339" class="line"></span>        Math.ceil(this.levelSizes[level].yTiles)
<span id="line16340" class="line"></span>      );
<span id="line16341" class="line"></span>    },
<span id="line16342" class="line"></span>
<span id="line16343" class="line"></span>    /**
<span id="line16344" class="line"></span>     * Determine the URL which will return an image for the region specified by the given x, y, and level components.
<span id="line16345" class="line"></span>     * @function
<span id="line16346" class="line"></span>     * @param {Number} level - The zoom level
<span id="line16347" class="line"></span>     * @param {Number} x - The x tile index
<span id="line16348" class="line"></span>     * @param {Number} y - The y tile index
<span id="line16349" class="line"></span>     * @returns {String} - The tile URL
<span id="line16350" class="line"></span>     */
<span id="line16351" class="line"></span>    getTileUrl: function(level, x, y) {
<span id="line16352" class="line"></span>      const pos = y * this.levelSizes[level].xTiles + x;
<span id="line16353" class="line"></span>      return `${this.serverUrl}/slides/${this.slideId}/layers/${level}/tiles/${pos}`;
<span id="line16354" class="line"></span>    },
<span id="line16355" class="line"></span>
<span id="line16356" class="line"></span>    /**
<span id="line16357" class="line"></span>     * Get the scale for a given level
<span id="line16358" class="line"></span>     * @function
<span id="line16359" class="line"></span>     * @param {Number} level - The image depth level
<span id="line16360" class="line"></span>     * @returns {Number} - The scale for the level
<span id="line16361" class="line"></span>     */
<span id="line16362" class="line"></span>    getLevelScale: function(level) {
<span id="line16363" class="line"></span>      return this.levelScales[level];
<span id="line16364" class="line"></span>    },
<span id="line16365" class="line"></span>
<span id="line16366" class="line"></span>    /**
<span id="line16367" class="line"></span>     * Retrieve and immediately return the options object
<span id="line16368" class="line"></span>     * @function
<span id="line16369" class="line"></span>     * @param {Object} options - Options object
<span id="line16370" class="line"></span>     * @returns {Object} - The options object
<span id="line16371" class="line"></span>     */
<span id="line16372" class="line"></span>    configure: function (options) {
<span id="line16373" class="line"></span>      return options;
<span id="line16374" class="line"></span>    }
<span id="line16375" class="line"></span>  });
<span id="line16376" class="line"></span>
<span id="line16377" class="line"></span>  $.extend(true, $.IrisTileSource.prototype, $.EventSource.prototype);
<span id="line16378" class="line"></span>
<span id="line16379" class="line"></span>}(OpenSeadragon));
<span id="line16380" class="line"></span>
<span id="line16381" class="line"></span>/*
<span id="line16382" class="line"></span> * OpenSeadragon - OsmTileSource
<span id="line16383" class="line"></span> *
<span id="line16384" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line16385" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line16386" class="line"></span> *
<span id="line16387" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line16388" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line16389" class="line"></span> * met:
<span id="line16390" class="line"></span> *
<span id="line16391" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line16392" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line16393" class="line"></span> *
<span id="line16394" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line16395" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line16396" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line16397" class="line"></span> *
<span id="line16398" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line16399" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line16400" class="line"></span> *   this software without specific prior written permission.
<span id="line16401" class="line"></span> *
<span id="line16402" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line16403" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line16404" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line16405" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line16406" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line16407" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line16408" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line16409" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line16410" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line16411" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line16412" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line16413" class="line"></span> */
<span id="line16414" class="line"></span>
<span id="line16415" class="line"></span>/*
<span id="line16416" class="line"></span> * Derived from the OSM tile source in Rainer Simon's seajax-utils project
<span id="line16417" class="line"></span> * &lt;http://github.com/rsimon/seajax-utils&gt;.  Rainer Simon has contributed
<span id="line16418" class="line"></span> * the included code to the OpenSeadragon project under the New BSD license;
<span id="line16419" class="line"></span> * see &lt;https://github.com/openseadragon/openseadragon/issues/58&gt;.
<span id="line16420" class="line"></span> */
<span id="line16421" class="line"></span>
<span id="line16422" class="line"></span>
<span id="line16423" class="line"></span>(function( $ ){
<span id="line16424" class="line"></span>
<span id="line16425" class="line"></span>/**
<span id="line16426" class="line"></span> * @class OsmTileSource
<span id="line16427" class="line"></span> * @classdesc A tilesource implementation for OpenStreetMap.&lt;br&gt;&lt;br&gt;
<span id="line16428" class="line"></span> *
<span id="line16429" class="line"></span> * Note 1. Zoomlevels. Deep Zoom and OSM define zoom levels differently. In  Deep
<span id="line16430" class="line"></span> * Zoom, level 0 equals an image of 1x1 pixels. In OSM, level 0 equals an image of
<span id="line16431" class="line"></span> * 256x256 levels (see http://gasi.ch/blog/inside-deep-zoom-2). I.e. there is a
<span id="line16432" class="line"></span> * difference of log2(256)=8 levels.&lt;br&gt;&lt;br&gt;
<span id="line16433" class="line"></span> *
<span id="line16434" class="line"></span> * Note 2. Image dimension. According to the OSM Wiki
<span id="line16435" class="line"></span> * (http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Zoom_levels)
<span id="line16436" class="line"></span> * the highest Mapnik zoom level has 262.144x262.144 tiles, with a 256x256
<span id="line16437" class="line"></span> * pixel size. I.e. the Deep Zoom image dimension is 67.108.864x67.108.864
<span id="line16438" class="line"></span> * pixels.
<span id="line16439" class="line"></span> * OSM now supports higher max zoom (e.g. 19), but this default is
<span id="line16440" class="line"></span> * based on zoom level 18: 2^18 tiles * 256px.
<span id="line16441" class="line"></span> *
<span id="line16442" class="line"></span> * @memberof OpenSeadragon
<span id="line16443" class="line"></span> * @extends OpenSeadragon.TileSource
<span id="line16444" class="line"></span> * @param {Number|Object} width - the pixel width of the image or the idiomatic
<span id="line16445" class="line"></span> *      options object which is used instead of positional arguments.
<span id="line16446" class="line"></span> * @param {Number} height
<span id="line16447" class="line"></span> * @param {Number} tileSize
<span id="line16448" class="line"></span> * @param {Number} tileOverlap
<span id="line16449" class="line"></span> * @param {String} tilesUrl
<span id="line16450" class="line"></span> */
<span id="line16451" class="line"></span>$.OsmTileSource = function( width, height, tileSize, tileOverlap, tilesUrl ) {
<span id="line16452" class="line"></span>    let options;
<span id="line16453" class="line"></span>
<span id="line16454" class="line"></span>    if( $.isPlainObject( width ) ){
<span id="line16455" class="line"></span>        options = width;
<span id="line16456" class="line"></span>    }else{
<span id="line16457" class="line"></span>        options = {
<span id="line16458" class="line"></span>            width: arguments[0],
<span id="line16459" class="line"></span>            height: arguments[1],
<span id="line16460" class="line"></span>            tileSize: arguments[2],
<span id="line16461" class="line"></span>            tileOverlap: arguments[3],
<span id="line16462" class="line"></span>            tilesUrl: arguments[4]
<span id="line16463" class="line"></span>        };
<span id="line16464" class="line"></span>    }
<span id="line16465" class="line"></span>    //apply default setting for standard public OpenStreatMaps service
<span id="line16466" class="line"></span>    //but allow them to be specified so fliks can host there own instance
<span id="line16467" class="line"></span>    //or apply against other services supportting the same standard
<span id="line16468" class="line"></span>    if( !options.width || !options.height ){
<span id="line16469" class="line"></span>        options.width = 67108864;
<span id="line16470" class="line"></span>        options.height = 67108864;
<span id="line16471" class="line"></span>    }
<span id="line16472" class="line"></span>    if( !options.tileSize ){
<span id="line16473" class="line"></span>        options.tileSize = 256;
<span id="line16474" class="line"></span>        options.tileOverlap = 0;
<span id="line16475" class="line"></span>    }
<span id="line16476" class="line"></span>    if( !options.tilesUrl ){
<span id="line16477" class="line"></span>        options.tilesUrl = "http://tile.openstreetmap.org/";
<span id="line16478" class="line"></span>    }
<span id="line16479" class="line"></span>    options.minLevel = 8;
<span id="line16480" class="line"></span>
<span id="line16481" class="line"></span>    $.TileSource.apply( this, [ options ] );
<span id="line16482" class="line"></span>
<span id="line16483" class="line"></span>};
<span id="line16484" class="line"></span>
<span id="line16485" class="line"></span>$.extend( $.OsmTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.OsmTileSource.prototype */{
<span id="line16486" class="line"></span>
<span id="line16487" class="line"></span>
<span id="line16488" class="line"></span>    /**
<span id="line16489" class="line"></span>     * Determine if the data and/or url imply the image service is supported by
<span id="line16490" class="line"></span>     * this tile source.
<span id="line16491" class="line"></span>     * @function
<span id="line16492" class="line"></span>     * @param {Object|Array} data
<span id="line16493" class="line"></span>     * @param {String} [url]
<span id="line16494" class="line"></span>     */
<span id="line16495" class="line"></span>    supports: function( data, url ){
<span id="line16496" class="line"></span>        return (
<span id="line16497" class="line"></span>            data.type &amp;&amp;
<span id="line16498" class="line"></span>            "openstreetmaps" === data.type
<span id="line16499" class="line"></span>        );
<span id="line16500" class="line"></span>    },
<span id="line16501" class="line"></span>
<span id="line16502" class="line"></span>    /**
<span id="line16503" class="line"></span>     *
<span id="line16504" class="line"></span>     * @function
<span id="line16505" class="line"></span>     * @param {Object} data - the raw configuration
<span id="line16506" class="line"></span>     * @param {String} url - the url the data was retrieved from if any.
<span id="line16507" class="line"></span>     * @param {String} postData - HTTP POST data in k=v&amp;k2=v2... form or null
<span id="line16508" class="line"></span>     * @returns {Object} options - A dictionary of keyword arguments sufficient
<span id="line16509" class="line"></span>     *      to configure this tile sources constructor.
<span id="line16510" class="line"></span>     */
<span id="line16511" class="line"></span>    configure: function( data, url, postData ){
<span id="line16512" class="line"></span>        return data;
<span id="line16513" class="line"></span>    },
<span id="line16514" class="line"></span>
<span id="line16515" class="line"></span>
<span id="line16516" class="line"></span>    /**
<span id="line16517" class="line"></span>     * @function
<span id="line16518" class="line"></span>     * @param {Number} level
<span id="line16519" class="line"></span>     * @param {Number} x
<span id="line16520" class="line"></span>     * @param {Number} y
<span id="line16521" class="line"></span>     */
<span id="line16522" class="line"></span>    getTileUrl: function( level, x, y ) {
<span id="line16523" class="line"></span>        return this.tilesUrl + (level - 8) + "/" + x + "/" + y + ".png";
<span id="line16524" class="line"></span>    },
<span id="line16525" class="line"></span>
<span id="line16526" class="line"></span>    /**
<span id="line16527" class="line"></span>     * Equality comparator
<span id="line16528" class="line"></span>     */
<span id="line16529" class="line"></span>    equals: function(otherSource) {
<span id="line16530" class="line"></span>        return otherSource &amp;&amp; this.tilesUrl === otherSource.tilesUrl;
<span id="line16531" class="line"></span>    }
<span id="line16532" class="line"></span>});
<span id="line16533" class="line"></span>
<span id="line16534" class="line"></span>
<span id="line16535" class="line"></span>}( OpenSeadragon ));
<span id="line16536" class="line"></span>
<span id="line16537" class="line"></span>/*
<span id="line16538" class="line"></span> * OpenSeadragon - TmsTileSource
<span id="line16539" class="line"></span> *
<span id="line16540" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line16541" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line16542" class="line"></span> *
<span id="line16543" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line16544" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line16545" class="line"></span> * met:
<span id="line16546" class="line"></span> *
<span id="line16547" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line16548" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line16549" class="line"></span> *
<span id="line16550" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line16551" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line16552" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line16553" class="line"></span> *
<span id="line16554" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line16555" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line16556" class="line"></span> *   this software without specific prior written permission.
<span id="line16557" class="line"></span> *
<span id="line16558" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line16559" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line16560" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line16561" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line16562" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line16563" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line16564" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line16565" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line16566" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line16567" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line16568" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line16569" class="line"></span> */
<span id="line16570" class="line"></span>
<span id="line16571" class="line"></span>/*
<span id="line16572" class="line"></span> * Derived from the TMS tile source in Rainer Simon's seajax-utils project
<span id="line16573" class="line"></span> * &lt;http://github.com/rsimon/seajax-utils&gt;.  Rainer Simon has contributed
<span id="line16574" class="line"></span> * the included code to the OpenSeadragon project under the New BSD license;
<span id="line16575" class="line"></span> * see &lt;https://github.com/openseadragon/openseadragon/issues/58&gt;.
<span id="line16576" class="line"></span> */
<span id="line16577" class="line"></span>
<span id="line16578" class="line"></span>
<span id="line16579" class="line"></span>(function( $ ){
<span id="line16580" class="line"></span>
<span id="line16581" class="line"></span>/**
<span id="line16582" class="line"></span> * @class TmsTileSource
<span id="line16583" class="line"></span> * @classdesc A tilesource implementation for Tiled Map Services (TMS).
<span id="line16584" class="line"></span> * TMS tile scheme ( [ as supported by OpenLayers ] is described here
<span id="line16585" class="line"></span> * ( http://openlayers.org/dev/examples/tms.html ).
<span id="line16586" class="line"></span> *
<span id="line16587" class="line"></span> * @memberof OpenSeadragon
<span id="line16588" class="line"></span> * @extends OpenSeadragon.TileSource
<span id="line16589" class="line"></span> * @param {Number|Object} width - the pixel width of the image or the idiomatic
<span id="line16590" class="line"></span> *      options object which is used instead of positional arguments.
<span id="line16591" class="line"></span> * @param {Number} height
<span id="line16592" class="line"></span> * @param {Number} tileSize
<span id="line16593" class="line"></span> * @param {Number} tileOverlap
<span id="line16594" class="line"></span> * @param {String} tilesUrl
<span id="line16595" class="line"></span> */
<span id="line16596" class="line"></span>$.TmsTileSource = function( width, height, tileSize, tileOverlap, tilesUrl ) {
<span id="line16597" class="line"></span>    let options;
<span id="line16598" class="line"></span>
<span id="line16599" class="line"></span>    if( $.isPlainObject( width ) ){
<span id="line16600" class="line"></span>        options = width;
<span id="line16601" class="line"></span>    }else{
<span id="line16602" class="line"></span>        options = {
<span id="line16603" class="line"></span>            width: arguments[0],
<span id="line16604" class="line"></span>            height: arguments[1],
<span id="line16605" class="line"></span>            tileSize: arguments[2],
<span id="line16606" class="line"></span>            tileOverlap: arguments[3],
<span id="line16607" class="line"></span>            tilesUrl: arguments[4]
<span id="line16608" class="line"></span>        };
<span id="line16609" class="line"></span>    }
<span id="line16610" class="line"></span>    // TMS has integer multiples of 256 for width/height and adds buffer
<span id="line16611" class="line"></span>    // if necessary -&gt; account for this!
<span id="line16612" class="line"></span>    const bufferedWidth = Math.ceil(options.width / 256) * 256;
<span id="line16613" class="line"></span>    const bufferedHeight = Math.ceil(options.height / 256) * 256;
<span id="line16614" class="line"></span>    let max;
<span id="line16615" class="line"></span>
<span id="line16616" class="line"></span>    // Compute number of zoomlevels in this tileset
<span id="line16617" class="line"></span>    if (bufferedWidth &gt; bufferedHeight) {
<span id="line16618" class="line"></span>        max = bufferedWidth / 256;
<span id="line16619" class="line"></span>    } else {
<span id="line16620" class="line"></span>        max = bufferedHeight / 256;
<span id="line16621" class="line"></span>    }
<span id="line16622" class="line"></span>    options.maxLevel = Math.ceil(Math.log(max) / Math.log(2)) - 1;
<span id="line16623" class="line"></span>    options.tileSize = 256;
<span id="line16624" class="line"></span>    options.width = bufferedWidth;
<span id="line16625" class="line"></span>    options.height = bufferedHeight;
<span id="line16626" class="line"></span>
<span id="line16627" class="line"></span>    $.TileSource.apply( this, [ options ] );
<span id="line16628" class="line"></span>
<span id="line16629" class="line"></span>};
<span id="line16630" class="line"></span>
<span id="line16631" class="line"></span>$.extend( $.TmsTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.TmsTileSource.prototype */{
<span id="line16632" class="line"></span>
<span id="line16633" class="line"></span>
<span id="line16634" class="line"></span>    /**
<span id="line16635" class="line"></span>     * Determine if the data and/or url imply the image service is supported by
<span id="line16636" class="line"></span>     * this tile source.
<span id="line16637" class="line"></span>     * @function
<span id="line16638" class="line"></span>     * @param {Object|Array} data
<span id="line16639" class="line"></span>     * @param {String} [url]
<span id="line16640" class="line"></span>     */
<span id="line16641" class="line"></span>    supports: function( data, url ){
<span id="line16642" class="line"></span>        return ( data.type &amp;&amp; "tiledmapservice" === data.type );
<span id="line16643" class="line"></span>    },
<span id="line16644" class="line"></span>
<span id="line16645" class="line"></span>    /**
<span id="line16646" class="line"></span>     *
<span id="line16647" class="line"></span>     * @function
<span id="line16648" class="line"></span>     * @param {Object} data - the raw configuration
<span id="line16649" class="line"></span>     * @param {String} url - the url the data was retrieved from if any.
<span id="line16650" class="line"></span>     * @param {String} postData - HTTP POST data in k=v&amp;k2=v2... form or null
<span id="line16651" class="line"></span>     * @returns {Object} options - A dictionary of keyword arguments sufficient
<span id="line16652" class="line"></span>     *      to configure this tile sources constructor.
<span id="line16653" class="line"></span>     */
<span id="line16654" class="line"></span>    configure: function( data, url, postData ){
<span id="line16655" class="line"></span>        return data;
<span id="line16656" class="line"></span>    },
<span id="line16657" class="line"></span>
<span id="line16658" class="line"></span>
<span id="line16659" class="line"></span>    /**
<span id="line16660" class="line"></span>     * @function
<span id="line16661" class="line"></span>     * @param {Number} level
<span id="line16662" class="line"></span>     * @param {Number} x
<span id="line16663" class="line"></span>     * @param {Number} y
<span id="line16664" class="line"></span>     */
<span id="line16665" class="line"></span>    getTileUrl: function( level, x, y ) {
<span id="line16666" class="line"></span>        // Convert from Deep Zoom definition to TMS zoom definition
<span id="line16667" class="line"></span>        const yTiles = this.getNumTiles( level ).y - 1;
<span id="line16668" class="line"></span>
<span id="line16669" class="line"></span>        return this.tilesUrl + level + "/" + x + "/" + (yTiles - y) + ".png";
<span id="line16670" class="line"></span>    },
<span id="line16671" class="line"></span>
<span id="line16672" class="line"></span>    /**
<span id="line16673" class="line"></span>     * Equality comparator
<span id="line16674" class="line"></span>     */
<span id="line16675" class="line"></span>    equals: function (otherSource) {
<span id="line16676" class="line"></span>        return otherSource &amp;&amp; this.tilesUrl === otherSource.tilesUrl;
<span id="line16677" class="line"></span>    }
<span id="line16678" class="line"></span>});
<span id="line16679" class="line"></span>
<span id="line16680" class="line"></span>
<span id="line16681" class="line"></span>}( OpenSeadragon ));
<span id="line16682" class="line"></span>
<span id="line16683" class="line"></span>(function($) {
<span id="line16684" class="line"></span>
<span id="line16685" class="line"></span>    /**
<span id="line16686" class="line"></span>     * @class ZoomifyTileSource
<span id="line16687" class="line"></span>     * @classdesc A tilesource implementation for the zoomify format.
<span id="line16688" class="line"></span>     *
<span id="line16689" class="line"></span>     * A description of the format can be found here:
<span id="line16690" class="line"></span>     * https://ecommons.cornell.edu/bitstream/handle/1813/5410/Introducing_Zoomify_Image.pdf
<span id="line16691" class="line"></span>     *
<span id="line16692" class="line"></span>     * There are two ways of creating a zoomify tilesource for openseadragon
<span id="line16693" class="line"></span>     *
<span id="line16694" class="line"></span>     * 1) Supplying all necessary information in the tilesource object. A minimal example object for this method looks like this:
<span id="line16695" class="line"></span>     *
<span id="line16696" class="line"></span>     * {
<span id="line16697" class="line"></span>     *      type: "zoomifytileservice",
<span id="line16698" class="line"></span>     *      width: 1000,
<span id="line16699" class="line"></span>     *      height: 1000,
<span id="line16700" class="line"></span>     *      tilesUrl: "/test/data/zoomify/"
<span id="line16701" class="line"></span>     * }
<span id="line16702" class="line"></span>     *
<span id="line16703" class="line"></span>     * The tileSize is set to 256 (the usual Zoomify default) when it is not defined. The tileUrl must the path to the image _directory_.
<span id="line16704" class="line"></span>     *
<span id="line16705" class="line"></span>     * 2) Loading image metadata from xml file: (CURRENTLY NOT SUPPORTED)
<span id="line16706" class="line"></span>     *
<span id="line16707" class="line"></span>     * When creating zoomify formatted images one "xml" like file with name ImageProperties.xml
<span id="line16708" class="line"></span>     * will be created as well. Here is an example of such a file:
<span id="line16709" class="line"></span>     *
<span id="line16710" class="line"></span>     * &lt;IMAGE_PROPERTIES WIDTH="1000" HEIGHT="1000" NUMTILES="21" NUMIMAGES="1" VERSION="1.8" TILESIZE="256" /&gt;
<span id="line16711" class="line"></span>     *
<span id="line16712" class="line"></span>     * To use this xml file as metadata source you must supply the path to the ImageProperties.xml file and leave out all other parameters:
<span id="line16713" class="line"></span>     * As stated above, this method of loading a zoomify tilesource is currently not supported
<span id="line16714" class="line"></span>     *
<span id="line16715" class="line"></span>     * {
<span id="line16716" class="line"></span>     *      type: "zoomifytileservice",
<span id="line16717" class="line"></span>     *      tilesUrl: "/test/data/zoomify/ImageProperties.xml"
<span id="line16718" class="line"></span>     * }
<span id="line16719" class="line"></span>
<span id="line16720" class="line"></span>    *
<span id="line16721" class="line"></span>    * @memberof OpenSeadragon
<span id="line16722" class="line"></span>     * @extends OpenSeadragon.TileSource
<span id="line16723" class="line"></span>     * @param {Number} width - the pixel width of the image.
<span id="line16724" class="line"></span>     * @param {Number} height
<span id="line16725" class="line"></span>     * @param {Number} tileSize
<span id="line16726" class="line"></span>     * @param {String} tilesUrl
<span id="line16727" class="line"></span>     */
<span id="line16728" class="line"></span>    $.ZoomifyTileSource = function(options) {
<span id="line16729" class="line"></span>        if(typeof options.tileSize === 'undefined'){
<span id="line16730" class="line"></span>            options.tileSize = 256;
<span id="line16731" class="line"></span>        }
<span id="line16732" class="line"></span>
<span id="line16733" class="line"></span>        if(typeof options.fileFormat === 'undefined'){
<span id="line16734" class="line"></span>            options.fileFormat = 'jpg';
<span id="line16735" class="line"></span>            this.fileFormat = options.fileFormat;
<span id="line16736" class="line"></span>        }
<span id="line16737" class="line"></span>
<span id="line16738" class="line"></span>        const currentImageSize = {
<span id="line16739" class="line"></span>            x: options.width,
<span id="line16740" class="line"></span>            y: options.height
<span id="line16741" class="line"></span>        };
<span id="line16742" class="line"></span>        options.imageSizes = [{
<span id="line16743" class="line"></span>            x: options.width,
<span id="line16744" class="line"></span>            y: options.height
<span id="line16745" class="line"></span>        }];
<span id="line16746" class="line"></span>        options.gridSize = [this._getGridSize(options.width, options.height, options.tileSize)];
<span id="line16747" class="line"></span>
<span id="line16748" class="line"></span>        while (parseInt(currentImageSize.x, 10) &gt; options.tileSize || parseInt(currentImageSize.y, 10) &gt; options.tileSize) {
<span id="line16749" class="line"></span>            currentImageSize.x = Math.floor(currentImageSize.x / 2);
<span id="line16750" class="line"></span>            currentImageSize.y = Math.floor(currentImageSize.y / 2);
<span id="line16751" class="line"></span>            options.imageSizes.push({
<span id="line16752" class="line"></span>                x: currentImageSize.x,
<span id="line16753" class="line"></span>                y: currentImageSize.y
<span id="line16754" class="line"></span>            });
<span id="line16755" class="line"></span>            options.gridSize.push(this._getGridSize(currentImageSize.x, currentImageSize.y, options.tileSize));
<span id="line16756" class="line"></span>        }
<span id="line16757" class="line"></span>        options.imageSizes.reverse();
<span id="line16758" class="line"></span>        options.gridSize.reverse();
<span id="line16759" class="line"></span>        options.minLevel = 0;
<span id="line16760" class="line"></span>        options.maxLevel = options.gridSize.length - 1;
<span id="line16761" class="line"></span>
<span id="line16762" class="line"></span>        $.TileSource.apply(this, [options]);
<span id="line16763" class="line"></span>    };
<span id="line16764" class="line"></span>
<span id="line16765" class="line"></span>    $.extend($.ZoomifyTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.ZoomifyTileSource.prototype */ {
<span id="line16766" class="line"></span>
<span id="line16767" class="line"></span>        //private
<span id="line16768" class="line"></span>        _getGridSize: function(width, height, tileSize) {
<span id="line16769" class="line"></span>            return {
<span id="line16770" class="line"></span>                x: Math.ceil(width / tileSize),
<span id="line16771" class="line"></span>                y: Math.ceil(height / tileSize)
<span id="line16772" class="line"></span>            };
<span id="line16773" class="line"></span>        },
<span id="line16774" class="line"></span>
<span id="line16775" class="line"></span>        //private
<span id="line16776" class="line"></span>        _calculateAbsoluteTileNumber: function(level, x, y) {
<span id="line16777" class="line"></span>            let num = 0;
<span id="line16778" class="line"></span>            let size = {};
<span id="line16779" class="line"></span>
<span id="line16780" class="line"></span>            //Sum up all tiles below the level we want the number of tiles
<span id="line16781" class="line"></span>            for (let z = 0; z &lt; level; z++) {
<span id="line16782" class="line"></span>                size = this.gridSize[z];
<span id="line16783" class="line"></span>                num += size.x * size.y;
<span id="line16784" class="line"></span>            }
<span id="line16785" class="line"></span>            //Add the tiles of the level
<span id="line16786" class="line"></span>            size = this.gridSize[level];
<span id="line16787" class="line"></span>            num += size.x * y + x;
<span id="line16788" class="line"></span>            return num;
<span id="line16789" class="line"></span>        },
<span id="line16790" class="line"></span>
<span id="line16791" class="line"></span>        /**
<span id="line16792" class="line"></span>         * Determine if the data and/or url imply the image service is supported by
<span id="line16793" class="line"></span>         * this tile source.
<span id="line16794" class="line"></span>         * @function
<span id="line16795" class="line"></span>         * @param {Object|Array} data
<span id="line16796" class="line"></span>         * @param {String} [url]
<span id="line16797" class="line"></span>         */
<span id="line16798" class="line"></span>        supports: function(data, url) {
<span id="line16799" class="line"></span>            return (data.type &amp;&amp; "zoomifytileservice" === data.type);
<span id="line16800" class="line"></span>        },
<span id="line16801" class="line"></span>
<span id="line16802" class="line"></span>        /**
<span id="line16803" class="line"></span>         *
<span id="line16804" class="line"></span>         * @function
<span id="line16805" class="line"></span>         * @param {Object} data - the raw configuration
<span id="line16806" class="line"></span>         * @param {String} url - the url the data was retrieved from if any.
<span id="line16807" class="line"></span>         * @param {String} postData - HTTP POST data in k=v&amp;k2=v2... form or null
<span id="line16808" class="line"></span>         * @returns {Object} options - A dictionary of keyword arguments sufficient
<span id="line16809" class="line"></span>         *      to configure this tile sources constructor.
<span id="line16810" class="line"></span>         */
<span id="line16811" class="line"></span>        configure: function(data, url, postData) {
<span id="line16812" class="line"></span>            return data;
<span id="line16813" class="line"></span>        },
<span id="line16814" class="line"></span>
<span id="line16815" class="line"></span>        /**
<span id="line16816" class="line"></span>         * @function
<span id="line16817" class="line"></span>         * @param {Number} level
<span id="line16818" class="line"></span>         * @param {Number} x
<span id="line16819" class="line"></span>         * @param {Number} y
<span id="line16820" class="line"></span>         */
<span id="line16821" class="line"></span>        getTileUrl: function(level, x, y) {
<span id="line16822" class="line"></span>            //console.log(level);
<span id="line16823" class="line"></span>            let result = 0;
<span id="line16824" class="line"></span>            const num = this._calculateAbsoluteTileNumber(level, x, y);
<span id="line16825" class="line"></span>            result = Math.floor(num / 256);
<span id="line16826" class="line"></span>            return this.tilesUrl + 'TileGroup' + result + '/' + level + '-' + x + '-' + y + '.' + this.fileFormat;
<span id="line16827" class="line"></span>
<span id="line16828" class="line"></span>        },
<span id="line16829" class="line"></span>
<span id="line16830" class="line"></span>        /**
<span id="line16831" class="line"></span>         * Equality comparator
<span id="line16832" class="line"></span>         */
<span id="line16833" class="line"></span>        equals: function (otherSource) {
<span id="line16834" class="line"></span>            return otherSource &amp;&amp; this.tilesUrl === otherSource.tilesUrl;
<span id="line16835" class="line"></span>        }
<span id="line16836" class="line"></span>    });
<span id="line16837" class="line"></span>
<span id="line16838" class="line"></span>}(OpenSeadragon));
<span id="line16839" class="line"></span>
<span id="line16840" class="line"></span>
<span id="line16841" class="line"></span>/*
<span id="line16842" class="line"></span> * OpenSeadragon - LegacyTileSource
<span id="line16843" class="line"></span> *
<span id="line16844" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line16845" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line16846" class="line"></span> *
<span id="line16847" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line16848" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line16849" class="line"></span> * met:
<span id="line16850" class="line"></span> *
<span id="line16851" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line16852" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line16853" class="line"></span> *
<span id="line16854" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line16855" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line16856" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line16857" class="line"></span> *
<span id="line16858" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line16859" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line16860" class="line"></span> *   this software without specific prior written permission.
<span id="line16861" class="line"></span> *
<span id="line16862" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line16863" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line16864" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line16865" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line16866" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line16867" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line16868" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line16869" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line16870" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line16871" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line16872" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line16873" class="line"></span> */
<span id="line16874" class="line"></span>
<span id="line16875" class="line"></span>(function( $ ){
<span id="line16876" class="line"></span>
<span id="line16877" class="line"></span>/**
<span id="line16878" class="line"></span> * @class LegacyTileSource
<span id="line16879" class="line"></span> * @classdesc The LegacyTileSource allows simple, traditional image pyramids to be loaded
<span id="line16880" class="line"></span> * into an OpenSeadragon Viewer.  Basically, this translates to the historically
<span id="line16881" class="line"></span> * common practice of starting with a 'master' image, maybe a tiff for example,
<span id="line16882" class="line"></span> * and generating a set of 'service' images like one or more thumbnails, a medium
<span id="line16883" class="line"></span> * resolution image and a high resolution image in standard web formats like
<span id="line16884" class="line"></span> * png or jpg.
<span id="line16885" class="line"></span> *
<span id="line16886" class="line"></span> * @memberof OpenSeadragon
<span id="line16887" class="line"></span> * @extends OpenSeadragon.TileSource
<span id="line16888" class="line"></span> * @param {Array} levels An array of file descriptions, each is an object with
<span id="line16889" class="line"></span> *      a 'url', a 'width', and a 'height'.  Overriding classes can expect more
<span id="line16890" class="line"></span> *      properties but these properties are sufficient for this implementation.
<span id="line16891" class="line"></span> *      Additionally, the levels are required to be listed in order from
<span id="line16892" class="line"></span> *      smallest to largest.
<span id="line16893" class="line"></span> * @property {Number} aspectRatio
<span id="line16894" class="line"></span> * @property {Number} dimensions
<span id="line16895" class="line"></span> * @property {Number} tileSize
<span id="line16896" class="line"></span> * @property {Number} tileOverlap
<span id="line16897" class="line"></span> * @property {Number} minLevel
<span id="line16898" class="line"></span> * @property {Number} maxLevel
<span id="line16899" class="line"></span> * @property {Array}  levels
<span id="line16900" class="line"></span> */
<span id="line16901" class="line"></span>$.LegacyTileSource = function( levels ) {
<span id="line16902" class="line"></span>
<span id="line16903" class="line"></span>    let options;
<span id="line16904" class="line"></span>    let width;
<span id="line16905" class="line"></span>    let height;
<span id="line16906" class="line"></span>
<span id="line16907" class="line"></span>    if( $.isArray( levels ) ){
<span id="line16908" class="line"></span>        options = {
<span id="line16909" class="line"></span>            type: 'legacy-image-pyramid',
<span id="line16910" class="line"></span>            levels: levels
<span id="line16911" class="line"></span>        };
<span id="line16912" class="line"></span>    }
<span id="line16913" class="line"></span>
<span id="line16914" class="line"></span>    //clean up the levels to make sure we support all formats
<span id="line16915" class="line"></span>    options.levels = filterFiles( options.levels );
<span id="line16916" class="line"></span>
<span id="line16917" class="line"></span>    if ( options.levels.length &gt; 0 ) {
<span id="line16918" class="line"></span>        width = options.levels[ options.levels.length - 1 ].width;
<span id="line16919" class="line"></span>        height = options.levels[ options.levels.length - 1 ].height;
<span id="line16920" class="line"></span>    }
<span id="line16921" class="line"></span>    else {
<span id="line16922" class="line"></span>        width = 0;
<span id="line16923" class="line"></span>        height = 0;
<span id="line16924" class="line"></span>        $.console.error( "No supported image formats found" );
<span id="line16925" class="line"></span>    }
<span id="line16926" class="line"></span>
<span id="line16927" class="line"></span>    $.extend( true, options, {
<span id="line16928" class="line"></span>        width: width,
<span id="line16929" class="line"></span>        height: height,
<span id="line16930" class="line"></span>        tileSize: Math.max( height, width ),
<span id="line16931" class="line"></span>        tileOverlap: 0,
<span id="line16932" class="line"></span>        minLevel: 0,
<span id="line16933" class="line"></span>        maxLevel: options.levels.length &gt; 0 ? options.levels.length - 1 : 0
<span id="line16934" class="line"></span>    } );
<span id="line16935" class="line"></span>
<span id="line16936" class="line"></span>    $.TileSource.apply( this, [ options ] );
<span id="line16937" class="line"></span>
<span id="line16938" class="line"></span>    this.levels = options.levels;
<span id="line16939" class="line"></span>};
<span id="line16940" class="line"></span>
<span id="line16941" class="line"></span>$.extend( $.LegacyTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.LegacyTileSource.prototype */{
<span id="line16942" class="line"></span>    /**
<span id="line16943" class="line"></span>     * Determine if the data and/or url imply the image service is supported by
<span id="line16944" class="line"></span>     * this tile source.
<span id="line16945" class="line"></span>     * @function
<span id="line16946" class="line"></span>     * @param {Object|Array} data
<span id="line16947" class="line"></span>     * @param {String} [url]
<span id="line16948" class="line"></span>     */
<span id="line16949" class="line"></span>    supports: function( data, url ){
<span id="line16950" class="line"></span>        return (
<span id="line16951" class="line"></span>            data.type &amp;&amp;
<span id="line16952" class="line"></span>            "legacy-image-pyramid" === data.type
<span id="line16953" class="line"></span>        ) || (
<span id="line16954" class="line"></span>            data.documentElement &amp;&amp;
<span id="line16955" class="line"></span>            "legacy-image-pyramid" === data.documentElement.getAttribute('type')
<span id="line16956" class="line"></span>        );
<span id="line16957" class="line"></span>    },
<span id="line16958" class="line"></span>
<span id="line16959" class="line"></span>
<span id="line16960" class="line"></span>    /**
<span id="line16961" class="line"></span>     *
<span id="line16962" class="line"></span>     * @function
<span id="line16963" class="line"></span>     * @param {Object|XMLDocument} configuration - the raw configuration
<span id="line16964" class="line"></span>     * @param {String} dataUrl - the url the data was retrieved from if any.
<span id="line16965" class="line"></span>     * @param {String} postData - HTTP POST data in k=v&amp;k2=v2... form or null
<span id="line16966" class="line"></span>     * @returns {Object} options - A dictionary of keyword arguments sufficient
<span id="line16967" class="line"></span>     *      to configure this tile sources constructor.
<span id="line16968" class="line"></span>     */
<span id="line16969" class="line"></span>    configure: function( configuration, dataUrl, postData ){
<span id="line16970" class="line"></span>
<span id="line16971" class="line"></span>        let options;
<span id="line16972" class="line"></span>
<span id="line16973" class="line"></span>        if( !$.isPlainObject(configuration) ){
<span id="line16974" class="line"></span>
<span id="line16975" class="line"></span>            options = configureFromXML( this, configuration );
<span id="line16976" class="line"></span>
<span id="line16977" class="line"></span>        }else{
<span id="line16978" class="line"></span>
<span id="line16979" class="line"></span>            options = configureFromObject( this, configuration );
<span id="line16980" class="line"></span>        }
<span id="line16981" class="line"></span>
<span id="line16982" class="line"></span>        return options;
<span id="line16983" class="line"></span>
<span id="line16984" class="line"></span>    },
<span id="line16985" class="line"></span>
<span id="line16986" class="line"></span>    /**
<span id="line16987" class="line"></span>     * @function
<span id="line16988" class="line"></span>     * @param {Number} level
<span id="line16989" class="line"></span>     */
<span id="line16990" class="line"></span>    getLevelScale: function ( level ) {
<span id="line16991" class="line"></span>        let levelScale = NaN;
<span id="line16992" class="line"></span>        if ( this.levels.length &gt; 0 &amp;&amp; level &gt;= this.minLevel &amp;&amp; level &lt;= this.maxLevel ) {
<span id="line16993" class="line"></span>            levelScale =
<span id="line16994" class="line"></span>                this.levels[ level ].width /
<span id="line16995" class="line"></span>                this.levels[ this.maxLevel ].width;
<span id="line16996" class="line"></span>        }
<span id="line16997" class="line"></span>        return levelScale;
<span id="line16998" class="line"></span>    },
<span id="line16999" class="line"></span>
<span id="line17000" class="line"></span>    /**
<span id="line17001" class="line"></span>     * @function
<span id="line17002" class="line"></span>     * @param {Number} level
<span id="line17003" class="line"></span>     */
<span id="line17004" class="line"></span>    getNumTiles: function( level ) {
<span id="line17005" class="line"></span>        const scale = this.getLevelScale( level );
<span id="line17006" class="line"></span>        if ( scale ){
<span id="line17007" class="line"></span>            return new $.Point( 1, 1 );
<span id="line17008" class="line"></span>        } else {
<span id="line17009" class="line"></span>            return new $.Point( 0, 0 );
<span id="line17010" class="line"></span>        }
<span id="line17011" class="line"></span>    },
<span id="line17012" class="line"></span>
<span id="line17013" class="line"></span>    /**
<span id="line17014" class="line"></span>     * This method is not implemented by this class other than to throw an Error
<span id="line17015" class="line"></span>     * announcing you have to implement it.  Because of the variety of tile
<span id="line17016" class="line"></span>     * server technologies, and various specifications for building image
<span id="line17017" class="line"></span>     * pyramids, this method is here to allow easy integration.
<span id="line17018" class="line"></span>     * @function
<span id="line17019" class="line"></span>     * @param {Number} level
<span id="line17020" class="line"></span>     * @param {Number} x
<span id="line17021" class="line"></span>     * @param {Number} y
<span id="line17022" class="line"></span>     * @throws {Error}
<span id="line17023" class="line"></span>     */
<span id="line17024" class="line"></span>    getTileUrl: function ( level, x, y ) {
<span id="line17025" class="line"></span>        let url = null;
<span id="line17026" class="line"></span>        if ( this.levels.length &gt; 0 &amp;&amp; level &gt;= this.minLevel &amp;&amp; level &lt;= this.maxLevel ) {
<span id="line17027" class="line"></span>            url = this.levels[ level ].url;
<span id="line17028" class="line"></span>        }
<span id="line17029" class="line"></span>        return url;
<span id="line17030" class="line"></span>    },
<span id="line17031" class="line"></span>
<span id="line17032" class="line"></span>    /**
<span id="line17033" class="line"></span>     * Equality comparator
<span id="line17034" class="line"></span>     */
<span id="line17035" class="line"></span>    equals: function (otherSource) {
<span id="line17036" class="line"></span>        if (!otherSource || !otherSource.levels || otherSource.levels.length !== this.levels.length) {
<span id="line17037" class="line"></span>            return false;
<span id="line17038" class="line"></span>        }
<span id="line17039" class="line"></span>        for (let i = this.minLevel; i &lt;= this.maxLevel; i++) {
<span id="line17040" class="line"></span>            if (this.levels[i].url !== otherSource.levels[i].url) {
<span id="line17041" class="line"></span>                return false;
<span id="line17042" class="line"></span>            }
<span id="line17043" class="line"></span>        }
<span id="line17044" class="line"></span>        return true;
<span id="line17045" class="line"></span>    }
<span id="line17046" class="line"></span>} );
<span id="line17047" class="line"></span>
<span id="line17048" class="line"></span>/**
<span id="line17049" class="line"></span> * This method removes any files from the Array which don't conform to our
<span id="line17050" class="line"></span> * basic requirements for a 'level' in the LegacyTileSource.
<span id="line17051" class="line"></span> * @private
<span id="line17052" class="line"></span> * @inner
<span id="line17053" class="line"></span> * @function
<span id="line17054" class="line"></span> */
<span id="line17055" class="line"></span>function filterFiles( files ){
<span id="line17056" class="line"></span>    const filtered = [];
<span id="line17057" class="line"></span>    let file;
<span id="line17058" class="line"></span>
<span id="line17059" class="line"></span>    for( let i = 0; i &lt; files.length; i++ ){
<span id="line17060" class="line"></span>        file = files[ i ];
<span id="line17061" class="line"></span>        if( file.height &amp;&amp;
<span id="line17062" class="line"></span>            file.width &amp;&amp;
<span id="line17063" class="line"></span>            file.url ){
<span id="line17064" class="line"></span>            //This is sufficient to serve as a level
<span id="line17065" class="line"></span>            filtered.push({
<span id="line17066" class="line"></span>                url: file.url,
<span id="line17067" class="line"></span>                width: Number( file.width ),
<span id="line17068" class="line"></span>                height: Number( file.height )
<span id="line17069" class="line"></span>            });
<span id="line17070" class="line"></span>        }
<span id="line17071" class="line"></span>        else {
<span id="line17072" class="line"></span>            $.console.error( 'Unsupported image format: %s', file.url ? file.url : '&lt;no URL&gt;' );
<span id="line17073" class="line"></span>        }
<span id="line17074" class="line"></span>    }
<span id="line17075" class="line"></span>
<span id="line17076" class="line"></span>    return filtered.sort(function(a, b) {
<span id="line17077" class="line"></span>        return a.height - b.height;
<span id="line17078" class="line"></span>    });
<span id="line17079" class="line"></span>
<span id="line17080" class="line"></span>}
<span id="line17081" class="line"></span>
<span id="line17082" class="line"></span>/**
<span id="line17083" class="line"></span> * @private
<span id="line17084" class="line"></span> * @inner
<span id="line17085" class="line"></span> * @function
<span id="line17086" class="line"></span> */
<span id="line17087" class="line"></span>function configureFromXML( tileSource, xmlDoc ){
<span id="line17088" class="line"></span>
<span id="line17089" class="line"></span>    if ( !xmlDoc || !xmlDoc.documentElement ) {
<span id="line17090" class="line"></span>        throw new Error( $.getString( "Errors.Xml" ) );
<span id="line17091" class="line"></span>    }
<span id="line17092" class="line"></span>
<span id="line17093" class="line"></span>    const root         = xmlDoc.documentElement;
<span id="line17094" class="line"></span>    const rootName     = root.tagName;
<span id="line17095" class="line"></span>    let conf         = null;
<span id="line17096" class="line"></span>    let levels       = [];
<span id="line17097" class="line"></span>    let level;
<span id="line17098" class="line"></span>
<span id="line17099" class="line"></span>    if ( rootName === "image" ) {
<span id="line17100" class="line"></span>
<span id="line17101" class="line"></span>        try {
<span id="line17102" class="line"></span>            conf = {
<span id="line17103" class="line"></span>                type:        root.getAttribute( "type" ),
<span id="line17104" class="line"></span>                levels:      []
<span id="line17105" class="line"></span>            };
<span id="line17106" class="line"></span>
<span id="line17107" class="line"></span>            levels = root.getElementsByTagName( "level" );
<span id="line17108" class="line"></span>            for ( let i = 0; i &lt; levels.length; i++ ) {
<span id="line17109" class="line"></span>                level = levels[ i ];
<span id="line17110" class="line"></span>
<span id="line17111" class="line"></span>                conf.levels.push({
<span id="line17112" class="line"></span>                    url:    level.getAttribute( "url" ),
<span id="line17113" class="line"></span>                    width:  parseInt( level.getAttribute( "width" ), 10 ),
<span id="line17114" class="line"></span>                    height: parseInt( level.getAttribute( "height" ), 10 )
<span id="line17115" class="line"></span>                });
<span id="line17116" class="line"></span>            }
<span id="line17117" class="line"></span>
<span id="line17118" class="line"></span>            return configureFromObject( tileSource, conf );
<span id="line17119" class="line"></span>
<span id="line17120" class="line"></span>        } catch ( e ) {
<span id="line17121" class="line"></span>            throw (e instanceof Error) ?
<span id="line17122" class="line"></span>                e :
<span id="line17123" class="line"></span>                new Error( 'Unknown error parsing Legacy Image Pyramid XML.' );
<span id="line17124" class="line"></span>        }
<span id="line17125" class="line"></span>    } else if ( rootName === "collection" ) {
<span id="line17126" class="line"></span>        throw new Error( 'Legacy Image Pyramid Collections not yet supported.' );
<span id="line17127" class="line"></span>    } else if ( rootName === "error" ) {
<span id="line17128" class="line"></span>        throw new Error( 'Error: ' + xmlDoc );
<span id="line17129" class="line"></span>    }
<span id="line17130" class="line"></span>
<span id="line17131" class="line"></span>    throw new Error( 'Unknown element ' + rootName );
<span id="line17132" class="line"></span>}
<span id="line17133" class="line"></span>
<span id="line17134" class="line"></span>/**
<span id="line17135" class="line"></span> * @private
<span id="line17136" class="line"></span> * @inner
<span id="line17137" class="line"></span> * @function
<span id="line17138" class="line"></span> */
<span id="line17139" class="line"></span>function configureFromObject( tileSource, configuration ){
<span id="line17140" class="line"></span>
<span id="line17141" class="line"></span>    return configuration.levels;
<span id="line17142" class="line"></span>
<span id="line17143" class="line"></span>}
<span id="line17144" class="line"></span>
<span id="line17145" class="line"></span>}( OpenSeadragon ));
<span id="line17146" class="line"></span>
<span id="line17147" class="line"></span>/*
<span id="line17148" class="line"></span> * OpenSeadragon - ImageTileSource
<span id="line17149" class="line"></span> *
<span id="line17150" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line17151" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line17152" class="line"></span> *
<span id="line17153" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line17154" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line17155" class="line"></span> * met:
<span id="line17156" class="line"></span> *
<span id="line17157" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line17158" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line17159" class="line"></span> *
<span id="line17160" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line17161" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line17162" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line17163" class="line"></span> *
<span id="line17164" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line17165" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line17166" class="line"></span> *   this software without specific prior written permission.
<span id="line17167" class="line"></span> *
<span id="line17168" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line17169" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line17170" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line17171" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line17172" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line17173" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line17174" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line17175" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line17176" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line17177" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line17178" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line17179" class="line"></span> */
<span id="line17180" class="line"></span>(function ($) {
<span id="line17181" class="line"></span>/**
<span id="line17182" class="line"></span> * @class ImageTileSource
<span id="line17183" class="line"></span> * @classdesc The ImageTileSource allows a simple image to be loaded
<span id="line17184" class="line"></span> * into an OpenSeadragon Viewer.
<span id="line17185" class="line"></span> * There are 2 ways to open an ImageTileSource:
<span id="line17186" class="line"></span> * 1. viewer.open({type: 'image', url: fooUrl});
<span id="line17187" class="line"></span> * 2. viewer.open(new OpenSeadragon.ImageTileSource({url: fooUrl}));
<span id="line17188" class="line"></span> *
<span id="line17189" class="line"></span> * With the first syntax, the crossOriginPolicy, ajaxWithCredentials and
<span id="line17190" class="line"></span> * useCanvas options are inherited from the viewer if they are not
<span id="line17191" class="line"></span> * specified directly in the options object.
<span id="line17192" class="line"></span> *
<span id="line17193" class="line"></span> * @memberof OpenSeadragon
<span id="line17194" class="line"></span> * @extends OpenSeadragon.TileSource
<span id="line17195" class="line"></span> * @param {Object} options Options object.
<span id="line17196" class="line"></span> * @param {String} options.url URL of the image
<span id="line17197" class="line"></span> * @param {Boolean} [options.buildPyramid=true] If set to true (default), a
<span id="line17198" class="line"></span> * pyramid will be built internally to provide a better downsampling.
<span id="line17199" class="line"></span> * @param {String|Boolean} [options.crossOriginPolicy=false] Valid values are
<span id="line17200" class="line"></span> * 'Anonymous', 'use-credentials', and false. If false, image requests will
<span id="line17201" class="line"></span> * not use CORS preventing internal pyramid building for images from other
<span id="line17202" class="line"></span> * domains.
<span id="line17203" class="line"></span> * @param {String|Boolean} [options.ajaxWithCredentials=false] Whether to set
<span id="line17204" class="line"></span> * the withCredentials XHR flag for AJAX requests (when loading tile sources).
<span id="line17205" class="line"></span> * @param {Boolean} [options.useCanvas=true] Set to false to prevent any use
<span id="line17206" class="line"></span> * of the canvas API.
<span id="line17207" class="line"></span> */
<span id="line17208" class="line"></span>$.ImageTileSource = class extends $.TileSource {
<span id="line17209" class="line"></span>
<span id="line17210" class="line"></span>    constructor(props) {
<span id="line17211" class="line"></span>        super($.extend({
<span id="line17212" class="line"></span>            buildPyramid: true,
<span id="line17213" class="line"></span>            crossOriginPolicy: false,
<span id="line17214" class="line"></span>            ajaxWithCredentials: false,
<span id="line17215" class="line"></span>        }, props));
<span id="line17216" class="line"></span>    }
<span id="line17217" class="line"></span>
<span id="line17218" class="line"></span>    /**
<span id="line17219" class="line"></span>     * Determine if the data and/or url imply the image service is supported by
<span id="line17220" class="line"></span>     * this tile source.
<span id="line17221" class="line"></span>     * @function
<span id="line17222" class="line"></span>     * @param {Object|Array} data
<span id="line17223" class="line"></span>     * @param {String} [url]
<span id="line17224" class="line"></span>     */
<span id="line17225" class="line"></span>    supports(data, url) {
<span id="line17226" class="line"></span>        return data.type &amp;&amp; data.type === "image";
<span id="line17227" class="line"></span>    }
<span id="line17228" class="line"></span>    /**
<span id="line17229" class="line"></span>     *
<span id="line17230" class="line"></span>     * @function
<span id="line17231" class="line"></span>     * @param {Object} options - the options
<span id="line17232" class="line"></span>     * @param {String} dataUrl - the url the image was retrieved from, if any.
<span id="line17233" class="line"></span>     * @param {String} postData - HTTP POST data in k=v&amp;k2=v2... form or null
<span id="line17234" class="line"></span>     * @returns {Object} options - A dictionary of keyword arguments sufficient
<span id="line17235" class="line"></span>     *      to configure this tile sources constructor.
<span id="line17236" class="line"></span>     */
<span id="line17237" class="line"></span>    configure(options, dataUrl, postData) {
<span id="line17238" class="line"></span>        return options;
<span id="line17239" class="line"></span>    }
<span id="line17240" class="line"></span>    /**
<span id="line17241" class="line"></span>     * Responsible for retrieving, and caching the
<span id="line17242" class="line"></span>     * image metadata pertinent to this TileSources implementation.
<span id="line17243" class="line"></span>     * @function
<span id="line17244" class="line"></span>     * @param {String} url
<span id="line17245" class="line"></span>     * @throws {Error}
<span id="line17246" class="line"></span>     */
<span id="line17247" class="line"></span>    getImageInfo(url) {
<span id="line17248" class="line"></span>        const image = new Image(),
<span id="line17249" class="line"></span>            _this = this;
<span id="line17250" class="line"></span>
<span id="line17251" class="line"></span>        if (this.crossOriginPolicy) {
<span id="line17252" class="line"></span>            image.crossOrigin = this.crossOriginPolicy;
<span id="line17253" class="line"></span>        }
<span id="line17254" class="line"></span>
<span id="line17255" class="line"></span>        $.addEvent(image, 'load', function () {
<span id="line17256" class="line"></span>            _this.width = image.naturalWidth;
<span id="line17257" class="line"></span>            _this.height = image.naturalHeight;
<span id="line17258" class="line"></span>            _this.tileWidth = _this.width;
<span id="line17259" class="line"></span>            _this.tileHeight = _this.height;
<span id="line17260" class="line"></span>            _this.tileOverlap = 0;
<span id="line17261" class="line"></span>            _this.minLevel = 0;
<span id="line17262" class="line"></span>            _this.image = image;
<span id="line17263" class="line"></span>            _this.levels = _this._buildLevels(image);
<span id="line17264" class="line"></span>            _this.maxLevel = _this.levels.length - 1;
<span id="line17265" class="line"></span>
<span id="line17266" class="line"></span>            // Note: this event is documented elsewhere, in TileSource
<span id="line17267" class="line"></span>            _this.raiseEvent('ready', {tileSource: _this});
<span id="line17268" class="line"></span>        });
<span id="line17269" class="line"></span>
<span id="line17270" class="line"></span>        $.addEvent(image, 'error', function () {
<span id="line17271" class="line"></span>            _this.image = null;
<span id="line17272" class="line"></span>            // Note: this event is documented elsewhere, in TileSource
<span id="line17273" class="line"></span>            _this.raiseEvent('open-failed', {
<span id="line17274" class="line"></span>                message: "Error loading image at " + url,
<span id="line17275" class="line"></span>                source: url
<span id="line17276" class="line"></span>            });
<span id="line17277" class="line"></span>        });
<span id="line17278" class="line"></span>
<span id="line17279" class="line"></span>        image.src = url;
<span id="line17280" class="line"></span>    }
<span id="line17281" class="line"></span>    /**
<span id="line17282" class="line"></span>     * @function
<span id="line17283" class="line"></span>     * @param {Number} level
<span id="line17284" class="line"></span>     */
<span id="line17285" class="line"></span>    getLevelScale(level) {
<span id="line17286" class="line"></span>        let levelScale = NaN;
<span id="line17287" class="line"></span>        if (level &gt;= this.minLevel &amp;&amp; level &lt;= this.maxLevel) {
<span id="line17288" class="line"></span>            levelScale =
<span id="line17289" class="line"></span>                this.levels[level].width /
<span id="line17290" class="line"></span>                this.levels[this.maxLevel].width;
<span id="line17291" class="line"></span>        }
<span id="line17292" class="line"></span>        return levelScale;
<span id="line17293" class="line"></span>    }
<span id="line17294" class="line"></span>    /**
<span id="line17295" class="line"></span>     * @function
<span id="line17296" class="line"></span>     * @param {Number} level
<span id="line17297" class="line"></span>     */
<span id="line17298" class="line"></span>    getNumTiles(level) {
<span id="line17299" class="line"></span>        if (this.getLevelScale(level)) {
<span id="line17300" class="line"></span>            return new $.Point(1, 1);
<span id="line17301" class="line"></span>        }
<span id="line17302" class="line"></span>        return new $.Point(0, 0);
<span id="line17303" class="line"></span>    }
<span id="line17304" class="line"></span>    /**
<span id="line17305" class="line"></span>     * Retrieves a tile url
<span id="line17306" class="line"></span>     * @function
<span id="line17307" class="line"></span>     * @param {Number} level Level of the tile
<span id="line17308" class="line"></span>     * @param {Number} x x coordinate of the tile
<span id="line17309" class="line"></span>     * @param {Number} y y coordinate of the tile
<span id="line17310" class="line"></span>     */
<span id="line17311" class="line"></span>    getTileUrl(level, x, y) {
<span id="line17312" class="line"></span>        if (level === this.maxLevel) {
<span id="line17313" class="line"></span>            return this.url; //for original image, preserve url
<span id="line17314" class="line"></span>        }
<span id="line17315" class="line"></span>        //make up url by positional args
<span id="line17316" class="line"></span>        return `${this.url}?l=${level}&amp;x=${x}&amp;y=${y}`;
<span id="line17317" class="line"></span>    }
<span id="line17318" class="line"></span>
<span id="line17319" class="line"></span>    /**
<span id="line17320" class="line"></span>     * Equality comparator
<span id="line17321" class="line"></span>     */
<span id="line17322" class="line"></span>    equals(otherSource) {
<span id="line17323" class="line"></span>        return this.url === otherSource.url;
<span id="line17324" class="line"></span>    }
<span id="line17325" class="line"></span>
<span id="line17326" class="line"></span>    getTilePostData(level, x, y) {
<span id="line17327" class="line"></span>        return {level: level, x: x, y: y};
<span id="line17328" class="line"></span>    }
<span id="line17329" class="line"></span>
<span id="line17330" class="line"></span>    /**
<span id="line17331" class="line"></span>     * Retrieves a tile context 2D
<span id="line17332" class="line"></span>     * @deprecated
<span id="line17333" class="line"></span>     */
<span id="line17334" class="line"></span>    getContext2D(level, x, y) {
<span id="line17335" class="line"></span>        $.console.error('Using [TiledImage.getContext2D] (for plain images only) is deprecated. ' +
<span id="line17336" class="line"></span>            'Use overridden downloadTileStart (https://openseadragon.github.io/examples/advanced-data-model/) instead.');
<span id="line17337" class="line"></span>        return this._createContext2D();
<span id="line17338" class="line"></span>    }
<span id="line17339" class="line"></span>
<span id="line17340" class="line"></span>    downloadTileStart(job) {
<span id="line17341" class="line"></span>        const tileData = job.postData;
<span id="line17342" class="line"></span>        if (tileData.level === this.maxLevel) {
<span id="line17343" class="line"></span>            job.finish(this.image, null, "image");
<span id="line17344" class="line"></span>            return;
<span id="line17345" class="line"></span>        }
<span id="line17346" class="line"></span>
<span id="line17347" class="line"></span>        if (tileData.level &gt;= this.minLevel &amp;&amp; tileData.level &lt;= this.maxLevel) {
<span id="line17348" class="line"></span>            const levelData = this.levels[tileData.level];
<span id="line17349" class="line"></span>            const context = this._createContext2D(this.image, levelData.width, levelData.height);
<span id="line17350" class="line"></span>            job.finish(context, null, "context2d");
<span id="line17351" class="line"></span>            return;
<span id="line17352" class="line"></span>        }
<span id="line17353" class="line"></span>        job.fail(`Invalid level ${tileData.level} for plain image source. Did you forget to set buildPyramid=true?`);
<span id="line17354" class="line"></span>    }
<span id="line17355" class="line"></span>
<span id="line17356" class="line"></span>    downloadTileAbort(job) {
<span id="line17357" class="line"></span>        //no-op
<span id="line17358" class="line"></span>    }
<span id="line17359" class="line"></span>
<span id="line17360" class="line"></span>    // private
<span id="line17361" class="line"></span>    //
<span id="line17362" class="line"></span>    // Builds the different levels of the pyramid if possible
<span id="line17363" class="line"></span>    // (i.e. if canvas API enabled and no canvas tainting issue).
<span id="line17364" class="line"></span>    _buildLevels(image) {
<span id="line17365" class="line"></span>        const levels = [{
<span id="line17366" class="line"></span>            url: image.src,
<span id="line17367" class="line"></span>            width: image.naturalWidth,
<span id="line17368" class="line"></span>            height:  image.naturalHeight
<span id="line17369" class="line"></span>        }];
<span id="line17370" class="line"></span>
<span id="line17371" class="line"></span>        if (!this.buildPyramid || !$.supportsCanvas || !this.useCanvas) {
<span id="line17372" class="line"></span>            return levels;
<span id="line17373" class="line"></span>        }
<span id="line17374" class="line"></span>
<span id="line17375" class="line"></span>        let currentWidth = image.naturalWidth,
<span id="line17376" class="line"></span>            currentHeight = image.naturalHeight;
<span id="line17377" class="line"></span>        // We build smaller levels until either width or height becomes
<span id="line17378" class="line"></span>        // 2 pixel wide.
<span id="line17379" class="line"></span>        while (currentWidth &gt;= 2 &amp;&amp; currentHeight &gt;= 2) {
<span id="line17380" class="line"></span>            currentWidth = Math.floor(currentWidth / 2);
<span id="line17381" class="line"></span>            currentHeight = Math.floor(currentHeight / 2);
<span id="line17382" class="line"></span>
<span id="line17383" class="line"></span>            levels.push({
<span id="line17384" class="line"></span>                width: currentWidth,
<span id="line17385" class="line"></span>                height: currentHeight,
<span id="line17386" class="line"></span>            });
<span id="line17387" class="line"></span>        }
<span id="line17388" class="line"></span>        return levels.reverse();
<span id="line17389" class="line"></span>    }
<span id="line17390" class="line"></span>
<span id="line17391" class="line"></span>
<span id="line17392" class="line"></span>    _createContext2D(data, w, h) {
<span id="line17393" class="line"></span>        const canvas = document.createElement("canvas"),
<span id="line17394" class="line"></span>            context = canvas.getContext("2d");
<span id="line17395" class="line"></span>
<span id="line17396" class="line"></span>
<span id="line17397" class="line"></span>        canvas.width = w;
<span id="line17398" class="line"></span>        canvas.height = h;
<span id="line17399" class="line"></span>        context.drawImage(data, 0, 0, w, h);
<span id="line17400" class="line"></span>        return context;
<span id="line17401" class="line"></span>    }
<span id="line17402" class="line"></span>};
<span id="line17403" class="line"></span>
<span id="line17404" class="line"></span>}(OpenSeadragon));
<span id="line17405" class="line"></span>
<span id="line17406" class="line"></span>/*
<span id="line17407" class="line"></span> * OpenSeadragon - TileSourceCollection
<span id="line17408" class="line"></span> *
<span id="line17409" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line17410" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line17411" class="line"></span> *
<span id="line17412" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line17413" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line17414" class="line"></span> * met:
<span id="line17415" class="line"></span> *
<span id="line17416" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line17417" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line17418" class="line"></span> *
<span id="line17419" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line17420" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line17421" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line17422" class="line"></span> *
<span id="line17423" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line17424" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line17425" class="line"></span> *   this software without specific prior written permission.
<span id="line17426" class="line"></span> *
<span id="line17427" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line17428" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line17429" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line17430" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line17431" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line17432" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line17433" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line17434" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line17435" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line17436" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line17437" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line17438" class="line"></span> */
<span id="line17439" class="line"></span>
<span id="line17440" class="line"></span>(function($) {
<span id="line17441" class="line"></span>
<span id="line17442" class="line"></span>// deprecated
<span id="line17443" class="line"></span>$.TileSourceCollection = function(tileSize, tileSources, rows, layout) {
<span id="line17444" class="line"></span>    $.console.error('TileSourceCollection is deprecated; use World instead');
<span id="line17445" class="line"></span>};
<span id="line17446" class="line"></span>
<span id="line17447" class="line"></span>}(OpenSeadragon));
<span id="line17448" class="line"></span>
<span id="line17449" class="line"></span>/*
<span id="line17450" class="line"></span> * OpenSeadragon - Queue
<span id="line17451" class="line"></span> *
<span id="line17452" class="line"></span> * Copyright (C) 2024 OpenSeadragon contributors (modified)
<span id="line17453" class="line"></span> * Copyright (C) Google Inc., The Closure Library Authors.
<span id="line17454" class="line"></span> * https://github.com/google/closure-library
<span id="line17455" class="line"></span> *
<span id="line17456" class="line"></span> * SPDX-License-Identifier: Apache-2.0
<span id="line17457" class="line"></span> */
<span id="line17458" class="line"></span>
<span id="line17459" class="line"></span>(function($) {
<span id="line17460" class="line"></span>
<span id="line17461" class="line"></span>const OpenSeadragon = $; // alias for JSDoc
<span id="line17462" class="line"></span>
<span id="line17463" class="line"></span>/**
<span id="line17464" class="line"></span> * @class OpenSeadragon.PriorityQueue
<span id="line17465" class="line"></span> * @classdesc Fast priority queue. Implemented as a Heap.
<span id="line17466" class="line"></span> */
<span id="line17467" class="line"></span>OpenSeadragon.PriorityQueue = class PriorityQueue {
<span id="line17468" class="line"></span>
<span id="line17469" class="line"></span>    /**
<span id="line17470" class="line"></span>     * @param {?OpenSeadragon.PriorityQueue} optHeap Optional Heap or
<span id="line17471" class="line"></span>     *     Object to initialize heap with.
<span id="line17472" class="line"></span>     */
<span id="line17473" class="line"></span>    constructor(optHeap = undefined) {
<span id="line17474" class="line"></span>        /**
<span id="line17475" class="line"></span>         * The nodes of the heap.
<span id="line17476" class="line"></span>         *
<span id="line17477" class="line"></span>         * This is a densely packed array containing all nodes of the heap, using
<span id="line17478" class="line"></span>         * the standard flat representation of a tree as an array (i.e. element [0]
<span id="line17479" class="line"></span>         * at the top, with [1] and [2] as the second row, [3] through [6] as the
<span id="line17480" class="line"></span>         * third, etc). Thus, the children of element `i` are `2i+1` and `2i+2`, and
<span id="line17481" class="line"></span>         * the parent of element `i` is `(i-1)/2`.
<span id="line17482" class="line"></span>         *
<span id="line17483" class="line"></span>         * The only invariant is that children's keys must be greater than parents'.
<span id="line17484" class="line"></span>         *
<span id="line17485" class="line"></span>         * @private
<span id="line17486" class="line"></span>         */
<span id="line17487" class="line"></span>        this.nodes_ = [];
<span id="line17488" class="line"></span>
<span id="line17489" class="line"></span>        if (optHeap) {
<span id="line17490" class="line"></span>            this.insertAll(optHeap);
<span id="line17491" class="line"></span>        }
<span id="line17492" class="line"></span>    }
<span id="line17493" class="line"></span>
<span id="line17494" class="line"></span>    /**
<span id="line17495" class="line"></span>     * Insert the given value into the heap with the given key.
<span id="line17496" class="line"></span>     * @param {K} key The key.
<span id="line17497" class="line"></span>     * @param {V} value The value.
<span id="line17498" class="line"></span>     */
<span id="line17499" class="line"></span>    insert(key, value) {
<span id="line17500" class="line"></span>        this.insertNode(new Node(key, value));
<span id="line17501" class="line"></span>    }
<span id="line17502" class="line"></span>
<span id="line17503" class="line"></span>    /**
<span id="line17504" class="line"></span>     * Insert node item.
<span id="line17505" class="line"></span>     * @param node
<span id="line17506" class="line"></span>     */
<span id="line17507" class="line"></span>    insertNode(node) {
<span id="line17508" class="line"></span>        const nodes = this.nodes_;
<span id="line17509" class="line"></span>        node.index = nodes.length;
<span id="line17510" class="line"></span>        nodes.push(node);
<span id="line17511" class="line"></span>        this.moveUp_(node.index);
<span id="line17512" class="line"></span>    }
<span id="line17513" class="line"></span>
<span id="line17514" class="line"></span>    /**
<span id="line17515" class="line"></span>     * Adds multiple key-value pairs from another Heap or Object
<span id="line17516" class="line"></span>     * @param {?OpenSeadragon.PriorityQueue} heap Object containing the data to add.
<span id="line17517" class="line"></span>     */
<span id="line17518" class="line"></span>    insertAll(heap) {
<span id="line17519" class="line"></span>        let keys, values;
<span id="line17520" class="line"></span>        if (heap instanceof $.PriorityQueue) {
<span id="line17521" class="line"></span>            keys = heap.getKeys();
<span id="line17522" class="line"></span>            values = heap.getValues();
<span id="line17523" class="line"></span>
<span id="line17524" class="line"></span>            // If it is a heap and the current heap is empty, I can rely on the fact
<span id="line17525" class="line"></span>            // that the keys/values are in the correct order to put in the underlying
<span id="line17526" class="line"></span>            // structure.
<span id="line17527" class="line"></span>            if (this.getCount() &lt;= 0) {
<span id="line17528" class="line"></span>                const nodes = this.nodes_;
<span id="line17529" class="line"></span>                for (let i = 0; i &lt; keys.length; i++) {
<span id="line17530" class="line"></span>                    const node = new Node(keys[i], values[i]);
<span id="line17531" class="line"></span>                    node.index = nodes.length;
<span id="line17532" class="line"></span>                    nodes.push(node);
<span id="line17533" class="line"></span>                }
<span id="line17534" class="line"></span>                return;
<span id="line17535" class="line"></span>            }
<span id="line17536" class="line"></span>        } else {
<span id="line17537" class="line"></span>            throw "insertAll supports only OpenSeadragon.PriorityQueue object!";
<span id="line17538" class="line"></span>        }
<span id="line17539" class="line"></span>
<span id="line17540" class="line"></span>        for (let i = 0; i &lt; keys.length; i++) {
<span id="line17541" class="line"></span>            this.insert(keys[i], values[i]);
<span id="line17542" class="line"></span>        }
<span id="line17543" class="line"></span>    }
<span id="line17544" class="line"></span>
<span id="line17545" class="line"></span>    /**
<span id="line17546" class="line"></span>     * Retrieves and removes the root value of this heap.
<span id="line17547" class="line"></span>     * @return {Node} The root node item removed from the root of the heap. Returns
<span id="line17548" class="line"></span>     *     undefined if the heap is empty.
<span id="line17549" class="line"></span>     */
<span id="line17550" class="line"></span>    remove() {
<span id="line17551" class="line"></span>        const nodes = this.nodes_;
<span id="line17552" class="line"></span>        const count = nodes.length;
<span id="line17553" class="line"></span>        const rootNode = nodes[0];
<span id="line17554" class="line"></span>        if (count &lt;= 0) {
<span id="line17555" class="line"></span>            return undefined;
<span id="line17556" class="line"></span>        } else if (count == 1) {  // eslint-disable-line
<span id="line17557" class="line"></span>            nodes.length = 0;
<span id="line17558" class="line"></span>        } else {
<span id="line17559" class="line"></span>            nodes[0] = nodes.pop();
<span id="line17560" class="line"></span>            if (nodes[0]) {
<span id="line17561" class="line"></span>                nodes[0].index = 0;
<span id="line17562" class="line"></span>            }
<span id="line17563" class="line"></span>            this.moveDown_(0);
<span id="line17564" class="line"></span>        }
<span id="line17565" class="line"></span>        if (rootNode) {
<span id="line17566" class="line"></span>            delete rootNode.index;
<span id="line17567" class="line"></span>        }
<span id="line17568" class="line"></span>        return rootNode;
<span id="line17569" class="line"></span>    }
<span id="line17570" class="line"></span>
<span id="line17571" class="line"></span>    /**
<span id="line17572" class="line"></span>     * Retrieves but does not remove the root value of this heap.
<span id="line17573" class="line"></span>     * @return {V} The value at the root of the heap. Returns
<span id="line17574" class="line"></span>     *     undefined if the heap is empty.
<span id="line17575" class="line"></span>     */
<span id="line17576" class="line"></span>    peek() {
<span id="line17577" class="line"></span>        const nodes = this.nodes_;
<span id="line17578" class="line"></span>        if (nodes.length == 0) {  // eslint-disable-line
<span id="line17579" class="line"></span>            return undefined;
<span id="line17580" class="line"></span>        }
<span id="line17581" class="line"></span>        return nodes[0].value;
<span id="line17582" class="line"></span>    }
<span id="line17583" class="line"></span>
<span id="line17584" class="line"></span>    /**
<span id="line17585" class="line"></span>     * Retrieves but does not remove the key of the root node of this heap.
<span id="line17586" class="line"></span>     * @return {string} The key at the root of the heap. Returns undefined if the
<span id="line17587" class="line"></span>     *     heap is empty.
<span id="line17588" class="line"></span>     */
<span id="line17589" class="line"></span>    peekKey() {
<span id="line17590" class="line"></span>        return this.nodes_[0] &amp;&amp; this.nodes_[0].key;
<span id="line17591" class="line"></span>    }
<span id="line17592" class="line"></span>
<span id="line17593" class="line"></span>    /**
<span id="line17594" class="line"></span>     * Move the node up in hierarchy
<span id="line17595" class="line"></span>     * @param {Node} node the node
<span id="line17596" class="line"></span>     * @param {K} key new ley, must be smaller than current key
<span id="line17597" class="line"></span>     */
<span id="line17598" class="line"></span>    decreaseKey(node, key) {
<span id="line17599" class="line"></span>        if (node.index === undefined) {
<span id="line17600" class="line"></span>            node.key = key;
<span id="line17601" class="line"></span>            this.insertNode(node);
<span id="line17602" class="line"></span>        } else {
<span id="line17603" class="line"></span>            node.key = key;
<span id="line17604" class="line"></span>            this.moveUp_(node.index);
<span id="line17605" class="line"></span>        }
<span id="line17606" class="line"></span>    }
<span id="line17607" class="line"></span>
<span id="line17608" class="line"></span>    /**
<span id="line17609" class="line"></span>     * Moves the node at the given index down to its proper place in the heap.
<span id="line17610" class="line"></span>     * @param {number} index The index of the node to move down.
<span id="line17611" class="line"></span>     * @private
<span id="line17612" class="line"></span>     */
<span id="line17613" class="line"></span>    moveDown_(index) {
<span id="line17614" class="line"></span>        const nodes = this.nodes_;
<span id="line17615" class="line"></span>        const count = nodes.length;
<span id="line17616" class="line"></span>
<span id="line17617" class="line"></span>        // Save the node being moved down.
<span id="line17618" class="line"></span>        const node = nodes[index];
<span id="line17619" class="line"></span>        // While the current node has a child.
<span id="line17620" class="line"></span>        while (index &lt; (count &gt;&gt; 1)) {
<span id="line17621" class="line"></span>            const leftChildIndex = this.getLeftChildIndex_(index);
<span id="line17622" class="line"></span>            const rightChildIndex = this.getRightChildIndex_(index);
<span id="line17623" class="line"></span>
<span id="line17624" class="line"></span>            // Determine the index of the smaller child.
<span id="line17625" class="line"></span>            const smallerChildIndex = rightChildIndex &lt; count &amp;&amp;
<span id="line17626" class="line"></span>            nodes[rightChildIndex].key &lt; nodes[leftChildIndex].key ?
<span id="line17627" class="line"></span>                rightChildIndex :
<span id="line17628" class="line"></span>                leftChildIndex;
<span id="line17629" class="line"></span>
<span id="line17630" class="line"></span>            // If the node being moved down is smaller than its children, the node
<span id="line17631" class="line"></span>            // has found the correct index it should be at.
<span id="line17632" class="line"></span>            if (nodes[smallerChildIndex].key &gt; node.key) {
<span id="line17633" class="line"></span>                break;
<span id="line17634" class="line"></span>            }
<span id="line17635" class="line"></span>
<span id="line17636" class="line"></span>            // If not, then take the smaller child as the current node.
<span id="line17637" class="line"></span>            nodes[index] = nodes[smallerChildIndex];
<span id="line17638" class="line"></span>            nodes[index].index = index;
<span id="line17639" class="line"></span>            index = smallerChildIndex;
<span id="line17640" class="line"></span>        }
<span id="line17641" class="line"></span>        nodes[index] = node;
<span id="line17642" class="line"></span>        if (node) {
<span id="line17643" class="line"></span>            node.index = index;
<span id="line17644" class="line"></span>        }
<span id="line17645" class="line"></span>    }
<span id="line17646" class="line"></span>
<span id="line17647" class="line"></span>    /**
<span id="line17648" class="line"></span>     * Moves the node at the given index up to its proper place in the heap.
<span id="line17649" class="line"></span>     * @param {number} index The index of the node to move up.
<span id="line17650" class="line"></span>     * @private
<span id="line17651" class="line"></span>     */
<span id="line17652" class="line"></span>    moveUp_(index) {
<span id="line17653" class="line"></span>        const nodes = this.nodes_;
<span id="line17654" class="line"></span>        const node = nodes[index];
<span id="line17655" class="line"></span>
<span id="line17656" class="line"></span>        // While the node being moved up is not at the root.
<span id="line17657" class="line"></span>        while (index &gt; 0) {
<span id="line17658" class="line"></span>            // If the parent is greater than the node being moved up, move the parent
<span id="line17659" class="line"></span>            // down.
<span id="line17660" class="line"></span>            const parentIndex = this.getParentIndex_(index);
<span id="line17661" class="line"></span>            if (nodes[parentIndex].key &gt; node.key) {
<span id="line17662" class="line"></span>                nodes[index] = nodes[parentIndex];
<span id="line17663" class="line"></span>                nodes[index].index = index;
<span id="line17664" class="line"></span>                index = parentIndex;
<span id="line17665" class="line"></span>            } else {
<span id="line17666" class="line"></span>                break;
<span id="line17667" class="line"></span>            }
<span id="line17668" class="line"></span>        }
<span id="line17669" class="line"></span>        nodes[index] = node;
<span id="line17670" class="line"></span>        if (node) {
<span id="line17671" class="line"></span>            node.index = index;
<span id="line17672" class="line"></span>        }
<span id="line17673" class="line"></span>    }
<span id="line17674" class="line"></span>
<span id="line17675" class="line"></span>    /**
<span id="line17676" class="line"></span>     * Gets the index of the left child of the node at the given index.
<span id="line17677" class="line"></span>     * @param {number} index The index of the node to get the left child for.
<span id="line17678" class="line"></span>     * @return {number} The index of the left child.
<span id="line17679" class="line"></span>     * @private
<span id="line17680" class="line"></span>     */
<span id="line17681" class="line"></span>    getLeftChildIndex_(index) {
<span id="line17682" class="line"></span>        return index * 2 + 1;
<span id="line17683" class="line"></span>    }
<span id="line17684" class="line"></span>
<span id="line17685" class="line"></span>    /**
<span id="line17686" class="line"></span>     * Gets the index of the right child of the node at the given index.
<span id="line17687" class="line"></span>     * @param {number} index The index of the node to get the right child for.
<span id="line17688" class="line"></span>     * @return {number} The index of the right child.
<span id="line17689" class="line"></span>     * @private
<span id="line17690" class="line"></span>     */
<span id="line17691" class="line"></span>    getRightChildIndex_(index) {
<span id="line17692" class="line"></span>        return index * 2 + 2;
<span id="line17693" class="line"></span>    }
<span id="line17694" class="line"></span>
<span id="line17695" class="line"></span>    /**
<span id="line17696" class="line"></span>     * Gets the index of the parent of the node at the given index.
<span id="line17697" class="line"></span>     * @param {number} index The index of the node to get the parent for.
<span id="line17698" class="line"></span>     * @return {number} The index of the parent.
<span id="line17699" class="line"></span>     * @private
<span id="line17700" class="line"></span>     */
<span id="line17701" class="line"></span>    getParentIndex_(index) {
<span id="line17702" class="line"></span>        return (index - 1) &gt;&gt; 1;
<span id="line17703" class="line"></span>    }
<span id="line17704" class="line"></span>
<span id="line17705" class="line"></span>    /**
<span id="line17706" class="line"></span>     * Gets the values of the heap.
<span id="line17707" class="line"></span>     * @return {!Array&lt;*&gt;} The values in the heap.
<span id="line17708" class="line"></span>     */
<span id="line17709" class="line"></span>    getValues() {
<span id="line17710" class="line"></span>        return this.nodes_.map(n =&gt; n.value);
<span id="line17711" class="line"></span>    }
<span id="line17712" class="line"></span>
<span id="line17713" class="line"></span>    /**
<span id="line17714" class="line"></span>     * Gets the keys of the heap.
<span id="line17715" class="line"></span>     * @return {!Array&lt;string&gt;} The keys in the heap.
<span id="line17716" class="line"></span>     */
<span id="line17717" class="line"></span>    getKeys() {
<span id="line17718" class="line"></span>        return this.nodes_.map(n =&gt; n.key);
<span id="line17719" class="line"></span>    }
<span id="line17720" class="line"></span>
<span id="line17721" class="line"></span>    /**
<span id="line17722" class="line"></span>     * Whether the heap contains the given value.
<span id="line17723" class="line"></span>     * @param {V} val The value to check for.
<span id="line17724" class="line"></span>     * @return {boolean} Whether the heap contains the value.
<span id="line17725" class="line"></span>     */
<span id="line17726" class="line"></span>    containsValue(val) {
<span id="line17727" class="line"></span>        return this.nodes_.some((node) =&gt; node.value == val);  // eslint-disable-line
<span id="line17728" class="line"></span>    }
<span id="line17729" class="line"></span>
<span id="line17730" class="line"></span>    /**
<span id="line17731" class="line"></span>     * Whether the heap contains the given key.
<span id="line17732" class="line"></span>     * @param {string} key The key to check for.
<span id="line17733" class="line"></span>     * @return {boolean} Whether the heap contains the key.
<span id="line17734" class="line"></span>     */
<span id="line17735" class="line"></span>    containsKey(key) {
<span id="line17736" class="line"></span>        return this.nodes_.some((node) =&gt; node.value == key);  // eslint-disable-line
<span id="line17737" class="line"></span>    }
<span id="line17738" class="line"></span>
<span id="line17739" class="line"></span>    /**
<span id="line17740" class="line"></span>     * Clones a heap and returns a new heap
<span id="line17741" class="line"></span>     * @return {!OpenSeadragon.PriorityQueue} A new Heap with the same key-value pairs.
<span id="line17742" class="line"></span>     */
<span id="line17743" class="line"></span>    clone() {
<span id="line17744" class="line"></span>        return new $.PriorityQueue(this);
<span id="line17745" class="line"></span>    }
<span id="line17746" class="line"></span>
<span id="line17747" class="line"></span>    /**
<span id="line17748" class="line"></span>     * The number of key-value pairs in the map
<span id="line17749" class="line"></span>     * @return {number} The number of pairs.
<span id="line17750" class="line"></span>     */
<span id="line17751" class="line"></span>    getCount() {
<span id="line17752" class="line"></span>        return this.nodes_.length;
<span id="line17753" class="line"></span>    }
<span id="line17754" class="line"></span>
<span id="line17755" class="line"></span>    /**
<span id="line17756" class="line"></span>     * Returns true if this heap contains no elements.
<span id="line17757" class="line"></span>     * @return {boolean} Whether this heap contains no elements.
<span id="line17758" class="line"></span>     */
<span id="line17759" class="line"></span>    isEmpty() {
<span id="line17760" class="line"></span>        return this.nodes_.length === 0;
<span id="line17761" class="line"></span>    }
<span id="line17762" class="line"></span>
<span id="line17763" class="line"></span>    /**
<span id="line17764" class="line"></span>     * Removes all elements from the heap.
<span id="line17765" class="line"></span>     */
<span id="line17766" class="line"></span>    clear() {
<span id="line17767" class="line"></span>        this.nodes_.length = 0;
<span id="line17768" class="line"></span>    }
<span id="line17769" class="line"></span>};
<span id="line17770" class="line"></span>
<span id="line17771" class="line"></span>/**
<span id="line17772" class="line"></span> * @private
<span id="line17773" class="line"></span> */
<span id="line17774" class="line"></span>OpenSeadragon.PriorityQueue.Node = class Node {
<span id="line17775" class="line"></span>    constructor(key, value) {
<span id="line17776" class="line"></span>        /**
<span id="line17777" class="line"></span>         * The key.
<span id="line17778" class="line"></span>         * @type {K}
<span id="line17779" class="line"></span>         * @private
<span id="line17780" class="line"></span>         */
<span id="line17781" class="line"></span>        this.key = key;
<span id="line17782" class="line"></span>
<span id="line17783" class="line"></span>        /**
<span id="line17784" class="line"></span>         * The value.
<span id="line17785" class="line"></span>         * @type {V}
<span id="line17786" class="line"></span>         * @private
<span id="line17787" class="line"></span>         */
<span id="line17788" class="line"></span>        this.value = value;
<span id="line17789" class="line"></span>
<span id="line17790" class="line"></span>        /**
<span id="line17791" class="line"></span>         * The node index value. Updated in the heap.
<span id="line17792" class="line"></span>         * @type {number}
<span id="line17793" class="line"></span>         * @private
<span id="line17794" class="line"></span>         */
<span id="line17795" class="line"></span>        this.index = 0;
<span id="line17796" class="line"></span>    }
<span id="line17797" class="line"></span>
<span id="line17798" class="line"></span>    clone() {
<span id="line17799" class="line"></span>        return new Node(this.key, this.value);
<span id="line17800" class="line"></span>    }
<span id="line17801" class="line"></span>};
<span id="line17802" class="line"></span>
<span id="line17803" class="line"></span>}(OpenSeadragon));
<span id="line17804" class="line"></span>
<span id="line17805" class="line"></span>/*
<span id="line17806" class="line"></span> * OpenSeadragon.converter (static property)
<span id="line17807" class="line"></span> *
<span id="line17808" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line17809" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line17810" class="line"></span>
<span id="line17811" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line17812" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line17813" class="line"></span> * met:
<span id="line17814" class="line"></span> *
<span id="line17815" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line17816" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line17817" class="line"></span> *
<span id="line17818" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line17819" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line17820" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line17821" class="line"></span> *
<span id="line17822" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line17823" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line17824" class="line"></span> *   this software without specific prior written permission.
<span id="line17825" class="line"></span> *
<span id="line17826" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line17827" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line17828" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line17829" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line17830" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line17831" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line17832" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line17833" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line17834" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line17835" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line17836" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line17837" class="line"></span> */
<span id="line17838" class="line"></span>
<span id="line17839" class="line"></span>(function($){
<span id="line17840" class="line"></span>
<span id="line17841" class="line"></span>const OpenSeadragon = $; // alias for JSDoc
<span id="line17842" class="line"></span>
<span id="line17843" class="line"></span>/**
<span id="line17844" class="line"></span> * modified from https://gist.github.com/Prottoy2938/66849e04b0bac459606059f5f9f3aa1a
<span id="line17845" class="line"></span> * @private
<span id="line17846" class="line"></span> */
<span id="line17847" class="line"></span>class WeightedGraph {
<span id="line17848" class="line"></span>    constructor() {
<span id="line17849" class="line"></span>        this.adjacencyList = {};
<span id="line17850" class="line"></span>        this.vertices = {};
<span id="line17851" class="line"></span>    }
<span id="line17852" class="line"></span>
<span id="line17853" class="line"></span>    /**
<span id="line17854" class="line"></span>     * Add vertex to graph
<span id="line17855" class="line"></span>     * @param vertex unique vertex ID
<span id="line17856" class="line"></span>     * @return {boolean} true if inserted, false if exists (no-op)
<span id="line17857" class="line"></span>     */
<span id="line17858" class="line"></span>    addVertex(vertex) {
<span id="line17859" class="line"></span>        if (!this.vertices[vertex]) {
<span id="line17860" class="line"></span>            this.vertices[vertex] = new $.PriorityQueue.Node(0, vertex);
<span id="line17861" class="line"></span>            this.adjacencyList[vertex] = [];
<span id="line17862" class="line"></span>            return true;
<span id="line17863" class="line"></span>        }
<span id="line17864" class="line"></span>        return false;
<span id="line17865" class="line"></span>    }
<span id="line17866" class="line"></span>
<span id="line17867" class="line"></span>    /**
<span id="line17868" class="line"></span>     * Add edge to graph
<span id="line17869" class="line"></span>     * @param vertex1 id, must exist by calling addVertex()
<span id="line17870" class="line"></span>     * @param vertex2 id, must exist by calling addVertex()
<span id="line17871" class="line"></span>     * @param weight
<span id="line17872" class="line"></span>     * @param transform function that transforms on path vertex1 -&gt; vertex2
<span id="line17873" class="line"></span>     * @return {boolean} true if new edge, false if replaced existing
<span id="line17874" class="line"></span>     */
<span id="line17875" class="line"></span>    addEdge(vertex1, vertex2, weight, transform) {
<span id="line17876" class="line"></span>        if (weight &lt; 0) {
<span id="line17877" class="line"></span>            $.console.error("WeightedGraph: negative weights will make for invalid shortest path computation!");
<span id="line17878" class="line"></span>        }
<span id="line17879" class="line"></span>        const outgoingPaths = this.adjacencyList[vertex1],
<span id="line17880" class="line"></span>            replacedEdgeIndex = outgoingPaths.findIndex(edge =&gt; edge.target === this.vertices[vertex2]),
<span id="line17881" class="line"></span>            newEdge = { target: this.vertices[vertex2], origin: this.vertices[vertex1], weight, transform };
<span id="line17882" class="line"></span>        if (replacedEdgeIndex &lt; 0) {
<span id="line17883" class="line"></span>            this.adjacencyList[vertex1].push(newEdge);
<span id="line17884" class="line"></span>            return true;
<span id="line17885" class="line"></span>        }
<span id="line17886" class="line"></span>        this.adjacencyList[vertex1][replacedEdgeIndex] = newEdge;
<span id="line17887" class="line"></span>        return false;
<span id="line17888" class="line"></span>    }
<span id="line17889" class="line"></span>
<span id="line17890" class="line"></span>    /**
<span id="line17891" class="line"></span>     * @return {{path: ConversionStep[], cost: number}|undefined} cheapest path from start to finish
<span id="line17892" class="line"></span>     */
<span id="line17893" class="line"></span>    dijkstra(start, finish) {
<span id="line17894" class="line"></span>        const path = []; //to return at end
<span id="line17895" class="line"></span>        if (start === finish) {
<span id="line17896" class="line"></span>            return { path: path, cost: 0 };
<span id="line17897" class="line"></span>        }
<span id="line17898" class="line"></span>        const nodes = new OpenSeadragon.PriorityQueue();
<span id="line17899" class="line"></span>        let smallestNode;
<span id="line17900" class="line"></span>        //build up initial state
<span id="line17901" class="line"></span>        for (let vertex in this.vertices) {
<span id="line17902" class="line"></span>            vertex = this.vertices[vertex];
<span id="line17903" class="line"></span>            if (vertex.value === start) {
<span id="line17904" class="line"></span>                vertex.key = 0; //keys are known distances
<span id="line17905" class="line"></span>                nodes.insertNode(vertex);
<span id="line17906" class="line"></span>            } else {
<span id="line17907" class="line"></span>                vertex.key = Infinity;
<span id="line17908" class="line"></span>                delete vertex.index;
<span id="line17909" class="line"></span>            }
<span id="line17910" class="line"></span>            vertex._previous = null;
<span id="line17911" class="line"></span>        }
<span id="line17912" class="line"></span>        // as long as there is something to visit
<span id="line17913" class="line"></span>        while (nodes.getCount() &gt; 0) {
<span id="line17914" class="line"></span>            smallestNode = nodes.remove();
<span id="line17915" class="line"></span>            if (smallestNode.value === finish) {
<span id="line17916" class="line"></span>                break;
<span id="line17917" class="line"></span>            }
<span id="line17918" class="line"></span>            const neighbors = this.adjacencyList[smallestNode.value];
<span id="line17919" class="line"></span>            for (const neighborKey in neighbors) {
<span id="line17920" class="line"></span>                const edge = neighbors[neighborKey];
<span id="line17921" class="line"></span>                //relax node
<span id="line17922" class="line"></span>                const newCost = smallestNode.key + edge.weight;
<span id="line17923" class="line"></span>                const nextNeighbor = edge.target;
<span id="line17924" class="line"></span>                if (newCost &lt; nextNeighbor.key) {
<span id="line17925" class="line"></span>                    nextNeighbor._previous = smallestNode;
<span id="line17926" class="line"></span>                    //key change
<span id="line17927" class="line"></span>                    nodes.decreaseKey(nextNeighbor, newCost);
<span id="line17928" class="line"></span>                }
<span id="line17929" class="line"></span>            }
<span id="line17930" class="line"></span>        }
<span id="line17931" class="line"></span>
<span id="line17932" class="line"></span>        if (!smallestNode || !smallestNode._previous || smallestNode.value !== finish) {
<span id="line17933" class="line"></span>            return undefined; //no path
<span id="line17934" class="line"></span>        }
<span id="line17935" class="line"></span>
<span id="line17936" class="line"></span>        const finalCost = smallestNode.key; //final weight last node
<span id="line17937" class="line"></span>
<span id="line17938" class="line"></span>        // done, build the shortest path
<span id="line17939" class="line"></span>        while (smallestNode._previous) {
<span id="line17940" class="line"></span>            //backtrack
<span id="line17941" class="line"></span>            const to = smallestNode.value,
<span id="line17942" class="line"></span>                parent = smallestNode._previous,
<span id="line17943" class="line"></span>                from = parent.value;
<span id="line17944" class="line"></span>
<span id="line17945" class="line"></span>            path.push(this.adjacencyList[from].find(x =&gt; x.target.value === to));
<span id="line17946" class="line"></span>            smallestNode = parent;
<span id="line17947" class="line"></span>        }
<span id="line17948" class="line"></span>
<span id="line17949" class="line"></span>        return {
<span id="line17950" class="line"></span>            path: path.reverse(),
<span id="line17951" class="line"></span>            cost: finalCost
<span id="line17952" class="line"></span>        };
<span id="line17953" class="line"></span>    }
<span id="line17954" class="line"></span>}
<span id="line17955" class="line"></span>
<span id="line17956" class="line"></span>let _imageConversionWorker;
<span id="line17957" class="line"></span>let _conversionId = 0;
<span id="line17958" class="line"></span>// id -&gt; { resolve, reject, timer? }
<span id="line17959" class="line"></span>const _pendingConversions = new Map();
<span id="line17960" class="line"></span>let __warnedNoSAB = false;
<span id="line17961" class="line"></span>const __hasSAB = typeof SharedArrayBuffer !== 'undefined' &amp;&amp; self.crossOriginIsolated === true;
<span id="line17962" class="line"></span>
<span id="line17963" class="line"></span>function getIBWorker() {
<span id="line17964" class="line"></span>    if (_imageConversionWorker) {
<span id="line17965" class="line"></span>        return _imageConversionWorker;
<span id="line17966" class="line"></span>    }
<span id="line17967" class="line"></span>
<span id="line17968" class="line"></span>    const code = `
<span id="line17969" class="line"></span>self.onmessage = async (e) =&gt; {
<span id="line17970" class="line"></span>  const { id, op, } = e.data;
<span id="line17971" class="line"></span>  let error;
<span id="line17972" class="line"></span>  try {
<span id="line17973" class="line"></span>    if (op === 'decodeFromBlob') {
<span id="line17974" class="line"></span>      const bmp = await createImageBitmap(e.data.blob, { colorSpaceConversion: 'none' });
<span id="line17975" class="line"></span>      postMessage({ id, ok: true, bmp }, [bmp]);
<span id="line17976" class="line"></span>      return;
<span id="line17977" class="line"></span>    }
<span id="line17978" class="line"></span>    if (op === 'decodeFromBytes') {
<span id="line17979" class="line"></span>      const u8 = new Uint8Array(e.data.bytes);
<span id="line17980" class="line"></span>      const b  = new Blob([u8], { type: e.data.mime || '' });
<span id="line17981" class="line"></span>      const bmp = await createImageBitmap(b, { colorSpaceConversion: 'none' });
<span id="line17982" class="line"></span>      postMessage({ id, ok: true, bmp }, [bmp]);
<span id="line17983" class="line"></span>      return;
<span id="line17984" class="line"></span>    }
<span id="line17985" class="line"></span>    if (op === 'fetchDecode') {
<span id="line17986" class="line"></span>      const res = await fetch(e.data.url, e.data.setup);
<span id="line17987" class="line"></span>      if (!res.ok) throw new Error('HTTP ' + res.status);
<span id="line17988" class="line"></span>      const b = await res.blob();
<span id="line17989" class="line"></span>      const bmp = await createImageBitmap(b, { colorSpaceConversion: 'none' });
<span id="line17990" class="line"></span>      postMessage({ id, ok: true, bmp }, [bmp]);
<span id="line17991" class="line"></span>      return;
<span id="line17992" class="line"></span>    }
<span id="line17993" class="line"></span>    error = 'Unknown op: ' + op;
<span id="line17994" class="line"></span>  } catch (err) {
<span id="line17995" class="line"></span>    error = String(err &amp;&amp; err.message || err);
<span id="line17996" class="line"></span>  }
<span id="line17997" class="line"></span>  postMessage({ id, ok: false, err: error });
<span id="line17998" class="line"></span>};
<span id="line17999" class="line"></span>`;
<span id="line18000" class="line"></span>    // eslint-disable-next-line compat/compat
<span id="line18001" class="line"></span>    const url = URL.createObjectURL(new Blob([code], { type: 'text/javascript' }));
<span id="line18002" class="line"></span>    _imageConversionWorker = new Worker(url);
<span id="line18003" class="line"></span>
<span id="line18004" class="line"></span>    _imageConversionWorker.onmessage = (e) =&gt; {
<span id="line18005" class="line"></span>        const { id, ok, bmp, err } = e.data || {};
<span id="line18006" class="line"></span>        const entry = _pendingConversions.get(id);
<span id="line18007" class="line"></span>        if (!entry) {
<span id="line18008" class="line"></span>            return;
<span id="line18009" class="line"></span>        }
<span id="line18010" class="line"></span>        _pendingConversions.delete(id);
<span id="line18011" class="line"></span>        if (entry.timer) {
<span id="line18012" class="line"></span>            clearTimeout(entry.timer);
<span id="line18013" class="line"></span>            entry.timer = null;
<span id="line18014" class="line"></span>        }
<span id="line18015" class="line"></span>        if (ok) {
<span id="line18016" class="line"></span>            entry.resolve(bmp);
<span id="line18017" class="line"></span>        } else {
<span id="line18018" class="line"></span>            entry.reject(new Error(err));
<span id="line18019" class="line"></span>        }
<span id="line18020" class="line"></span>    };
<span id="line18021" class="line"></span>
<span id="line18022" class="line"></span>    _imageConversionWorker.onerror = (e) =&gt; {
<span id="line18023" class="line"></span>        for (const [, entry] of _pendingConversions) {
<span id="line18024" class="line"></span>            if (entry.timer) {
<span id="line18025" class="line"></span>                clearTimeout(entry.timer);
<span id="line18026" class="line"></span>                entry.timer = null;
<span id="line18027" class="line"></span>            }
<span id="line18028" class="line"></span>            entry.reject(new Error('Worker error'));
<span id="line18029" class="line"></span>        }
<span id="line18030" class="line"></span>        _pendingConversions.clear();
<span id="line18031" class="line"></span>    };
<span id="line18032" class="line"></span>    return _imageConversionWorker;
<span id="line18033" class="line"></span>}
<span id="line18034" class="line"></span>
<span id="line18035" class="line"></span>function postWorker(op, payload, { timeoutMs = 15000 } = {}) {
<span id="line18036" class="line"></span>    const worker = getIBWorker();
<span id="line18037" class="line"></span>    const id = ++_conversionId;
<span id="line18038" class="line"></span>
<span id="line18039" class="line"></span>    return new $.Promise((resolve, reject) =&gt; {
<span id="line18040" class="line"></span>        // possibly test $.supportsPromise here as well...
<span id="line18041" class="line"></span>        payload.id = id;
<span id="line18042" class="line"></span>        payload.op = op;
<span id="line18043" class="line"></span>
<span id="line18044" class="line"></span>        const entry = { resolve, reject, timer: null };
<span id="line18045" class="line"></span>        if (timeoutMs &gt; 0) {
<span id="line18046" class="line"></span>            entry.timer = setTimeout(() =&gt; {
<span id="line18047" class="line"></span>                entry.timer = null;
<span id="line18048" class="line"></span>                _pendingConversions.delete(id);
<span id="line18049" class="line"></span>                reject(new Error(`Worker timeout (${op})`));
<span id="line18050" class="line"></span>            }, timeoutMs);
<span id="line18051" class="line"></span>        }
<span id="line18052" class="line"></span>        _pendingConversions.set(id, entry);
<span id="line18053" class="line"></span>
<span id="line18054" class="line"></span>        if (op === 'decodeFromBytes') {
<span id="line18055" class="line"></span>            if (__hasSAB) {
<span id="line18056" class="line"></span>                const u8 = payload.u8;
<span id="line18057" class="line"></span>                // eslint-disable-next-line no-undef
<span id="line18058" class="line"></span>                const sab = new SharedArrayBuffer(u8.byteLength);
<span id="line18059" class="line"></span>                new Uint8Array(sab).set(u8);
<span id="line18060" class="line"></span>                worker.postMessage({ id, op, bytes: sab, mime: payload.mime });
<span id="line18061" class="line"></span>            } else {
<span id="line18062" class="line"></span>                if (!__warnedNoSAB) {
<span id="line18063" class="line"></span>                    __warnedNoSAB = true;
<span id="line18064" class="line"></span>                    console.warn('[Converter] SharedArrayBuffer unavailable; falling back to ArrayBuffer.');
<span id="line18065" class="line"></span>                }
<span id="line18066" class="line"></span>                const u8 = payload.u8;
<span id="line18067" class="line"></span>                const tight = (u8.byteOffset === 0 &amp;&amp; u8.byteLength === u8.buffer.byteLength) ? u8 : u8.slice();
<span id="line18068" class="line"></span>                worker.postMessage({ id, op, bytes: tight.buffer, mime: payload.mime }, [tight.buffer]);
<span id="line18069" class="line"></span>            }
<span id="line18070" class="line"></span>            return;
<span id="line18071" class="line"></span>        }
<span id="line18072" class="line"></span>
<span id="line18073" class="line"></span>        worker.postMessage(payload);
<span id="line18074" class="line"></span>    });
<span id="line18075" class="line"></span>}
<span id="line18076" class="line"></span>
<span id="line18077" class="line"></span>/**
<span id="line18078" class="line"></span> * Edge.transform function on the conversion path in OpenSeadragon.converter.getConversionPath().
<span id="line18079" class="line"></span> *  It can be also conversion to undefined if used as destructor implementation.
<span id="line18080" class="line"></span> *
<span id="line18081" class="line"></span> * @callback TypeConverter
<span id="line18082" class="line"></span> * @memberof OpenSeadragon
<span id="line18083" class="line"></span> * @param {OpenSeadragon.Tile} tile reference tile that owns the data
<span id="line18084" class="line"></span> * @param {any} data data in the input format
<span id="line18085" class="line"></span> * @returns {any} data in the output format
<span id="line18086" class="line"></span> */
<span id="line18087" class="line"></span>
<span id="line18088" class="line"></span>/**
<span id="line18089" class="line"></span> * Destructor called every time a data type is to be destroyed or converted to another type.
<span id="line18090" class="line"></span> *
<span id="line18091" class="line"></span> * @callback TypeDestructor
<span id="line18092" class="line"></span> * @memberof OpenSeadragon
<span id="line18093" class="line"></span> * @param {any} data data in the format the destructor is registered for
<span id="line18094" class="line"></span> * @returns {any} can return any value that is carried over to the caller if desirable.
<span id="line18095" class="line"></span> *   Note: not used by the OSD cache system.
<span id="line18096" class="line"></span> */
<span id="line18097" class="line"></span>
<span id="line18098" class="line"></span>/**
<span id="line18099" class="line"></span> * Node on the conversion path in OpenSeadragon.converter.getConversionPath().
<span id="line18100" class="line"></span> *
<span id="line18101" class="line"></span> * @typedef {Object} ConversionStep
<span id="line18102" class="line"></span> * @memberof OpenSeadragon
<span id="line18103" class="line"></span> * @param {OpenSeadragon.PriorityQueue.Node} target - Target node of the conversion step.
<span id="line18104" class="line"></span> *  Its value is the target format.
<span id="line18105" class="line"></span> * @param {OpenSeadragon.PriorityQueue.Node} origin - Origin node of the conversion step.
<span id="line18106" class="line"></span> *  Its value is the origin format.
<span id="line18107" class="line"></span> * @param {number} weight cost of the conversion
<span id="line18108" class="line"></span> * @param {TypeConverter} transform the conversion itself
<span id="line18109" class="line"></span> */
<span id="line18110" class="line"></span>
<span id="line18111" class="line"></span>/**
<span id="line18112" class="line"></span> * Class that orchestrates automated data types conversion. Do not instantiate
<span id="line18113" class="line"></span> * this class, use OpenSeadragon.converter - a global instance, instead.
<span id="line18114" class="line"></span> *
<span id="line18115" class="line"></span> * Types are defined to closely describe the data type, e.g. "url" is insufficient,
<span id="line18116" class="line"></span> * because url can point to many different data types. Another bad example is 'canvas'
<span id="line18117" class="line"></span> * as canvas can have different underlying rendering implementations and thus differ
<span id="line18118" class="line"></span> * in behavior. The following data types supported by
<span id="line18119" class="line"></span> * OpenSeadragon core are:
<span id="line18120" class="line"></span> * - "image" - HTMLImageElement, an &lt;image&gt; object
<span id="line18121" class="line"></span> * - "context2d" - HtmlRenderingContext2D, a 2D canvas context
<span id="line18122" class="line"></span> * - "rasterBlob" - Blob, a binary file-like object carrying image data
<span id="line18123" class="line"></span> * - "imageBitmap" - an ImageBitmap object
<span id="line18124" class="line"></span> *
<span id="line18125" class="line"></span> * The system uses these to deliver desired data from TileSource (which implements fetching logics)
<span id="line18126" class="line"></span> * through plugins to the renderer with preserving data type compatibility. Typical example is:
<span id="line18127" class="line"></span> *  TiledImage downloads and creates Image object with type 'image'. It submits
<span id="line18128" class="line"></span> *  to the system object of data type 'image'. The system runs this object through
<span id="line18129" class="line"></span> *  possible plugins integrated into the invalidation routine (by default none),
<span id="line18130" class="line"></span> *  and finishes by conversion for the WebGL renderer, which would most likely be "image"
<span id="line18131" class="line"></span> *  object, because the conversion in this case is not even necessary, as the drawer publishes
<span id="line18132" class="line"></span> *  the image type as one of its supported ones.
<span id="line18133" class="line"></span> *  If some plugin required context2d type, the pipeline would deliver this type and used
<span id="line18134" class="line"></span> *  it also for WebGL, as texture loading function accepts canvas object as well as image.
<span id="line18135" class="line"></span> *
<span id="line18136" class="line"></span> * @class OpenSeadragon.DataTypeConverter
<span id="line18137" class="line"></span> * @memberOf OpenSeadragon
<span id="line18138" class="line"></span> */
<span id="line18139" class="line"></span>OpenSeadragon.DataTypeConverter = class DataTypeConverter {
<span id="line18140" class="line"></span>
<span id="line18141" class="line"></span>    constructor() {
<span id="line18142" class="line"></span>        this.graph = new WeightedGraph();
<span id="line18143" class="line"></span>        this.destructors = {};
<span id="line18144" class="line"></span>        this.copyings = {};
<span id="line18145" class="line"></span>
<span id="line18146" class="line"></span>        // Teaching OpenSeadragon built-in conversions:
<span id="line18147" class="line"></span>        const imageCreator = (tile, url) =&gt; new $.Promise((resolve, reject) =&gt; {
<span id="line18148" class="line"></span>            if (!$.supportsAsync) {
<span id="line18149" class="line"></span>                return reject("Not supported in sync mode!");
<span id="line18150" class="line"></span>            }
<span id="line18151" class="line"></span>            const img = new Image();
<span id="line18152" class="line"></span>            img.onerror = img.onabort = e =&gt; reject(`Failed to load image: ${url}`);
<span id="line18153" class="line"></span>            img.onload = () =&gt; resolve(img);
<span id="line18154" class="line"></span>            if (tile.tiledImage &amp;&amp; tile.tiledImage.crossOriginPolicy) {
<span id="line18155" class="line"></span>                img.crossOrigin = tile.tiledImage.crossOriginPolicy;
<span id="line18156" class="line"></span>            }
<span id="line18157" class="line"></span>            img.src = url;
<span id="line18158" class="line"></span>            return undefined;
<span id="line18159" class="line"></span>        });
<span id="line18160" class="line"></span>        const canvasContextCreator = (tile, imageData) =&gt; {
<span id="line18161" class="line"></span>            const canvas = document.createElement('canvas');
<span id="line18162" class="line"></span>            canvas.width = imageData.width;
<span id="line18163" class="line"></span>            canvas.height = imageData.height;
<span id="line18164" class="line"></span>            const context = canvas.getContext('2d', { willReadFrequently: true });
<span id="line18165" class="line"></span>            context.drawImage(imageData, 0, 0);
<span id="line18166" class="line"></span>            return context;
<span id="line18167" class="line"></span>        };
<span id="line18168" class="line"></span>
<span id="line18169" class="line"></span>        this.learn("rasterBlob", "image", (tile, blob) =&gt; new $.Promise((resolve, reject) =&gt; {
<span id="line18170" class="line"></span>            // eslint-disable-next-line compat/compat
<span id="line18171" class="line"></span>            const url = (window.URL || window.webkitURL).createObjectURL(blob);
<span id="line18172" class="line"></span>            if (!$.supportsAsync) {
<span id="line18173" class="line"></span>                return reject("Not supported in sync mode!");
<span id="line18174" class="line"></span>            }
<span id="line18175" class="line"></span>            const img = new Image();
<span id="line18176" class="line"></span>            img.onerror = img.onabort = e =&gt; {
<span id="line18177" class="line"></span>                // eslint-disable-next-line compat/compat
<span id="line18178" class="line"></span>                (window.URL || window.webkitURL).revokeObjectURL(blob);
<span id="line18179" class="line"></span>                reject(e);
<span id="line18180" class="line"></span>            };
<span id="line18181" class="line"></span>            img.onload = () =&gt; {
<span id="line18182" class="line"></span>                // eslint-disable-next-line compat/compat
<span id="line18183" class="line"></span>                (window.URL || window.webkitURL).revokeObjectURL(blob);
<span id="line18184" class="line"></span>                resolve(img);
<span id="line18185" class="line"></span>            };
<span id="line18186" class="line"></span>            img.decoding = 'async';
<span id="line18187" class="line"></span>            img.src = url;
<span id="line18188" class="line"></span>            return undefined;
<span id="line18189" class="line"></span>        }), 1, 2);
<span id="line18190" class="line"></span>
<span id="line18191" class="line"></span>        this.learn("context2d", "rasterBlob", (tile, ctx) =&gt; new $.Promise((resolve, reject) =&gt; {
<span id="line18192" class="line"></span>            if (!$.supportsAsync) {
<span id="line18193" class="line"></span>                return reject("Not supported in sync mode!");
<span id="line18194" class="line"></span>            }
<span id="line18195" class="line"></span>            ctx.canvas.toBlob(resolve);
<span id="line18196" class="line"></span>            return undefined;
<span id="line18197" class="line"></span>        }), 1, 2);
<span id="line18198" class="line"></span>
<span id="line18199" class="line"></span>        // rasterBlob -&gt; imageBitmap (preferred fast path)
<span id="line18200" class="line"></span>        this.learn("rasterBlob", "imageBitmap", (tile, blob) =&gt; new $.Promise((resolve, reject) =&gt; {
<span id="line18201" class="line"></span>            if (!$.supportsAsync) {
<span id="line18202" class="line"></span>                return reject("Not supported in sync mode!");
<span id="line18203" class="line"></span>            }
<span id="line18204" class="line"></span>            if (_imageConversionWorker) {
<span id="line18205" class="line"></span>                postWorker('decodeFromBlob', { blob }).then(resolve).catch(reject);
<span id="line18206" class="line"></span>            } else {
<span id="line18207" class="line"></span>                // Fallback main thread
<span id="line18208" class="line"></span>                createImageBitmap(blob, { colorSpaceConversion: 'none' }).then(resolve).catch(reject);
<span id="line18209" class="line"></span>            }
<span id="line18210" class="line"></span>            return undefined;
<span id="line18211" class="line"></span>        }), 1, 1);
<span id="line18212" class="line"></span>
<span id="line18213" class="line"></span>        this.learn("imageBitmap", "context2d", (tile, bmp) =&gt; {
<span id="line18214" class="line"></span>            const canvas = document.createElement('canvas');
<span id="line18215" class="line"></span>            canvas.width = bmp.width;
<span id="line18216" class="line"></span>            canvas.height = bmp.height;
<span id="line18217" class="line"></span>            const ctx = canvas.getContext('2d', { willReadFrequently: true });
<span id="line18218" class="line"></span>            ctx.drawImage(bmp, 0, 0);
<span id="line18219" class="line"></span>            return ctx;
<span id="line18220" class="line"></span>        }, 1, 2);
<span id="line18221" class="line"></span>
<span id="line18222" class="line"></span>        this.learn("image", "imageBitmap", (tile, img) =&gt; {
<span id="line18223" class="line"></span>            return createImageBitmap(img, { colorSpaceConversion: 'none' });
<span id="line18224" class="line"></span>        }, 1, 2);
<span id="line18225" class="line"></span>        this.learn("image", "context2d", canvasContextCreator, 1, 2);
<span id="line18226" class="line"></span>
<span id="line18227" class="line"></span>        //Copies
<span id="line18228" class="line"></span>        this.learn("image", "image", (tile, image) =&gt; imageCreator(tile, image.src), 1, 1);
<span id="line18229" class="line"></span>        this.learn("context2d", "context2d", (tile, ctx) =&gt; canvasContextCreator(tile, ctx.canvas));
<span id="line18230" class="line"></span>        this.learn("rasterBlob", "rasterBlob", (tile, blob) =&gt; blob, 0, 1); //blobs are immutable, no need to copy
<span id="line18231" class="line"></span>        this.learn("imageBitmap", "imageBitmap", (tile, bmp) =&gt; new $.Promise((resolve, reject) =&gt; {
<span id="line18232" class="line"></span>            try {
<span id="line18233" class="line"></span>                if (!$.supportsAsync) {
<span id="line18234" class="line"></span>                    return reject("Not supported in sync mode!");
<span id="line18235" class="line"></span>                }
<span id="line18236" class="line"></span>                if (!bmp) {
<span id="line18237" class="line"></span>                    return reject(new Error("No ImageBitmap to copy"));
<span id="line18238" class="line"></span>                }
<span id="line18239" class="line"></span>
<span id="line18240" class="line"></span>                if (typeof OffscreenCanvas !== 'undefined' &amp;&amp; bmp.width &amp;&amp; bmp.height) {
<span id="line18241" class="line"></span>                    const oc = new OffscreenCanvas(bmp.width, bmp.height);
<span id="line18242" class="line"></span>                    const ctx = oc.getContext('2d', { willReadFrequently: false });
<span id="line18243" class="line"></span>                    ctx.drawImage(bmp, 0, 0);
<span id="line18244" class="line"></span>
<span id="line18245" class="line"></span>                    if (typeof oc.transferToImageBitmap === 'function') {
<span id="line18246" class="line"></span>                        const copy = oc.transferToImageBitmap();
<span id="line18247" class="line"></span>                        return resolve(copy);
<span id="line18248" class="line"></span>                    }
<span id="line18249" class="line"></span>                    return createImageBitmap(oc, { colorSpaceConversion: 'none' }).then(resolve);
<span id="line18250" class="line"></span>                }
<span id="line18251" class="line"></span>                // Fallback
<span id="line18252" class="line"></span>                return createImageBitmap(bmp, { colorSpaceConversion: 'none' }).then(resolve);
<span id="line18253" class="line"></span>            } catch (e) {
<span id="line18254" class="line"></span>                return reject(e);
<span id="line18255" class="line"></span>            }
<span id="line18256" class="line"></span>        }), 1, 1);
<span id="line18257" class="line"></span>        /**
<span id="line18258" class="line"></span>         * Free up canvas memory
<span id="line18259" class="line"></span>         * (iOS 12 or higher on 2GB RAM device has only 224MB canvas memory,
<span id="line18260" class="line"></span>         * and Safari keeps canvas until its height and width will be set to 0).
<span id="line18261" class="line"></span>         */
<span id="line18262" class="line"></span>        this.learnDestroy("context2d", ctx =&gt; {
<span id="line18263" class="line"></span>            ctx.canvas.width = 0;
<span id="line18264" class="line"></span>            ctx.canvas.height = 0;
<span id="line18265" class="line"></span>        });
<span id="line18266" class="line"></span>    }
<span id="line18267" class="line"></span>
<span id="line18268" class="line"></span>    /**
<span id="line18269" class="line"></span>     * Unique identifier (unlike toString.call(x)) to be guessed
<span id="line18270" class="line"></span>     * from the data value. This type guess is more strict than
<span id="line18271" class="line"></span>     * OpenSeadragon.type() implementation, but for most type recognition
<span id="line18272" class="line"></span>     * this test relies on the output of OpenSeadragon.type().
<span id="line18273" class="line"></span>     *
<span id="line18274" class="line"></span>     * Note: although we try to implement the type guessing, do
<span id="line18275" class="line"></span>     * not rely on this functionality! Prefer explicit type declaration.
<span id="line18276" class="line"></span>     *
<span id="line18277" class="line"></span>     * @function guessType
<span id="line18278" class="line"></span>     * @param x object to get unique identifier for
<span id="line18279" class="line"></span>     *  - can be array, in that case, alphabetically-ordered list of inner unique types
<span id="line18280" class="line"></span>     *    is returned (null, undefined are ignored)
<span id="line18281" class="line"></span>     *  - if $.isPlainObject(x) is true, then the object can define
<span id="line18282" class="line"></span>     *    getType function to specify its type
<span id="line18283" class="line"></span>     *  - otherwise, toString.call(x) is applied to get the parameter description
<span id="line18284" class="line"></span>     * @return {string} unique variable descriptor
<span id="line18285" class="line"></span>     */
<span id="line18286" class="line"></span>    guessType(x) {
<span id="line18287" class="line"></span>        if (Array.isArray(x)) {
<span id="line18288" class="line"></span>            const types = [];
<span id="line18289" class="line"></span>            for (const item of x) {
<span id="line18290" class="line"></span>                if (item === undefined || item === null) {
<span id="line18291" class="line"></span>                    continue;
<span id="line18292" class="line"></span>                }
<span id="line18293" class="line"></span>
<span id="line18294" class="line"></span>                const type = this.guessType(item);
<span id="line18295" class="line"></span>                if (!types.includes(type)) {
<span id="line18296" class="line"></span>                    types.push(type);
<span id="line18297" class="line"></span>                }
<span id="line18298" class="line"></span>            }
<span id="line18299" class="line"></span>            types.sort();
<span id="line18300" class="line"></span>            return `Array [${types.join(",")}]`;
<span id="line18301" class="line"></span>        }
<span id="line18302" class="line"></span>
<span id="line18303" class="line"></span>        const guessType = $.type(x);
<span id="line18304" class="line"></span>        if (guessType === "dom-node") {
<span id="line18305" class="line"></span>            //distinguish nodes
<span id="line18306" class="line"></span>            return guessType.nodeName.toLowerCase();
<span id="line18307" class="line"></span>        }
<span id="line18308" class="line"></span>
<span id="line18309" class="line"></span>        if (guessType === "object") {
<span id="line18310" class="line"></span>            if ($.isFunction(x.getType)) {
<span id="line18311" class="line"></span>                return x.getType();
<span id="line18312" class="line"></span>            }
<span id="line18313" class="line"></span>        }
<span id="line18314" class="line"></span>        return guessType;
<span id="line18315" class="line"></span>    }
<span id="line18316" class="line"></span>
<span id="line18317" class="line"></span>    /**
<span id="line18318" class="line"></span>     * Teach the system to convert data type 'from' -&gt; 'to'
<span id="line18319" class="line"></span>     * @param {string} from unique ID of the data item 'from'
<span id="line18320" class="line"></span>     * @param {string} to unique ID of the data item 'to'
<span id="line18321" class="line"></span>     * @param {OpenSeadragon.TypeConverter} callback converter that takes two arguments: a tile reference, and
<span id="line18322" class="line"></span>     *  a data object of a type 'from'; and converts this data object to type 'to'. It can return also the value
<span id="line18323" class="line"></span>     *  wrapped in a Promise (returned in resolve) or it can be async function.
<span id="line18324" class="line"></span>     * @param {Number} [costPower=0] positive cost class of the conversion, smaller or equal than 7.
<span id="line18325" class="line"></span>     *   Should reflect the actual cost of the conversion:
<span id="line18326" class="line"></span>     *   - if nothing must be done and only reference is retrieved (or a constant operation done),
<span id="line18327" class="line"></span>     *     return 0 (default)
<span id="line18328" class="line"></span>     *   - if a linear amount of work is necessary,
<span id="line18329" class="line"></span>     *     return 1
<span id="line18330" class="line"></span>     *   ... and so on, basically the number in O() complexity power exponent (for simplification)
<span id="line18331" class="line"></span>     * @param {Number} [costMultiplier=1] multiplier of the cost class, e.g. O(3n^2) would
<span id="line18332" class="line"></span>     *   use costPower=2, costMultiplier=3; can be between 1 and 10^5
<span id="line18333" class="line"></span>     */
<span id="line18334" class="line"></span>    learn(from, to, callback, costPower = 0, costMultiplier = 1) {
<span id="line18335" class="line"></span>        $.console.assert(costPower &gt;= 0 &amp;&amp; costPower &lt;= 7, "[DataTypeConverter] Conversion costPower must be between &lt;0, 7&gt;.");
<span id="line18336" class="line"></span>        $.console.assert($.isFunction(callback), "[DataTypeConverter:learn] Callback must be a valid function!");
<span id="line18337" class="line"></span>
<span id="line18338" class="line"></span>        if (from === to) {
<span id="line18339" class="line"></span>            this.copyings[to] = callback;
<span id="line18340" class="line"></span>        } else {
<span id="line18341" class="line"></span>            //we won't know if somebody added multiple edges, though it will choose some edge anyway
<span id="line18342" class="line"></span>            costPower++;
<span id="line18343" class="line"></span>            costMultiplier = Math.min(Math.max(costMultiplier, 1), 10 ^ 5);
<span id="line18344" class="line"></span>            this.graph.addVertex(from);
<span id="line18345" class="line"></span>            this.graph.addVertex(to);
<span id="line18346" class="line"></span>            this.graph.addEdge(from, to, costPower * 10 ^ 5 + costMultiplier, callback);
<span id="line18347" class="line"></span>            this._known = {}; //invalidate precomputed paths :/
<span id="line18348" class="line"></span>        }
<span id="line18349" class="line"></span>    }
<span id="line18350" class="line"></span>
<span id="line18351" class="line"></span>    /**
<span id="line18352" class="line"></span>     * Teach the system to destroy data type 'type'
<span id="line18353" class="line"></span>     * for example, textures loaded to GPU have to be also manually removed when not needed anymore.
<span id="line18354" class="line"></span>     * Needs to be defined only when the created object has extra deletion process.
<span id="line18355" class="line"></span>     * @param {string} type
<span id="line18356" class="line"></span>     * @param {OpenSeadragon.TypeDestructor} callback destructor, receives the object created,
<span id="line18357" class="line"></span>     *   it is basically a type conversion to 'undefined' - thus the type.
<span id="line18358" class="line"></span>     */
<span id="line18359" class="line"></span>    learnDestroy(type, callback) {
<span id="line18360" class="line"></span>        this.destructors[type] = callback;
<span id="line18361" class="line"></span>    }
<span id="line18362" class="line"></span>
<span id="line18363" class="line"></span>    /**
<span id="line18364" class="line"></span>     * Convert data item x of type 'from' to any of the 'to' types, chosen is the cheapest known conversion.
<span id="line18365" class="line"></span>     * Data is destroyed upon conversion. For different behavior, implement your conversion using the
<span id="line18366" class="line"></span>     * path rules obtained from getConversionPath().
<span id="line18367" class="line"></span>     * Note: conversion DOES NOT COPY data if [to] contains type 'from' (e.g., the cheapest conversion is no conversion).
<span id="line18368" class="line"></span>     * It automatically calls destructor on immediate types, but NOT on the x and the result. You should call these
<span id="line18369" class="line"></span>     * manually if these should be destroyed.
<span id="line18370" class="line"></span>     * @param {OpenSeadragon.Tile} tile
<span id="line18371" class="line"></span>     * @param {any} data data item to convert
<span id="line18372" class="line"></span>     * @param {string} from data item type
<span id="line18373" class="line"></span>     * @param {string} to desired type(s)
<span id="line18374" class="line"></span>     * @return {OpenSeadragon.Promise&lt;?&gt;} promise resolution with type 'to', or rejection if conversion failed.
<span id="line18375" class="line"></span>     */
<span id="line18376" class="line"></span>    convert(tile, data, from, ...to) {
<span id="line18377" class="line"></span>        const conversionPath = this.getConversionPath(from, to);
<span id="line18378" class="line"></span>        if (!conversionPath) {
<span id="line18379" class="line"></span>            $.console.error(`[OpenSeadragon.converter.convert] Conversion ${from} ---&gt; ${to} cannot be done!`);
<span id="line18380" class="line"></span>            return $.Promise.resolve();
<span id="line18381" class="line"></span>        }
<span id="line18382" class="line"></span>
<span id="line18383" class="line"></span>        const stepCount = conversionPath.length;
<span id="line18384" class="line"></span>        const _this = this;
<span id="line18385" class="line"></span>        const step = (x, i, destroy = true) =&gt; {
<span id="line18386" class="line"></span>            if (i &gt;= stepCount) {
<span id="line18387" class="line"></span>                return $.Promise.resolve(x);
<span id="line18388" class="line"></span>            }
<span id="line18389" class="line"></span>            const edge = conversionPath[i];
<span id="line18390" class="line"></span>            let y;
<span id="line18391" class="line"></span>            try {
<span id="line18392" class="line"></span>                y = edge.transform(tile, x);
<span id="line18393" class="line"></span>            } catch (err) {
<span id="line18394" class="line"></span>                if (destroy) {
<span id="line18395" class="line"></span>                    _this.destroy(x, edge.origin.value);
<span id="line18396" class="line"></span>                }
<span id="line18397" class="line"></span>                return $.Promise.reject(`[OpenSeadragon.converter.convert] sync failure (while converting using ${edge.origin.value} -&gt; ${edge.target.value})`);
<span id="line18398" class="line"></span>            }
<span id="line18399" class="line"></span>            if (y === undefined) {
<span id="line18400" class="line"></span>                if (destroy) {
<span id="line18401" class="line"></span>                    _this.destroy(x, edge.origin.value);
<span id="line18402" class="line"></span>                }
<span id="line18403" class="line"></span>                return $.Promise.reject(`[OpenSeadragon.converter.convert] data mid result undefined value (while converting using ${edge.origin.value} -&gt; ${edge.target.value})`);
<span id="line18404" class="line"></span>            }
<span id="line18405" class="line"></span>            //node.value holds the type string
<span id="line18406" class="line"></span>            if (destroy) {
<span id="line18407" class="line"></span>                _this.destroy(x, edge.origin.value);
<span id="line18408" class="line"></span>            }
<span id="line18409" class="line"></span>            const result = $.type(y) === "promise" ? y : $.Promise.resolve(y);
<span id="line18410" class="line"></span>            return result.then(res =&gt; step(res, i + 1));
<span id="line18411" class="line"></span>        };
<span id="line18412" class="line"></span>        //destroy only mid-results, but not the original value
<span id="line18413" class="line"></span>        return step(data, 0, false);
<span id="line18414" class="line"></span>    }
<span id="line18415" class="line"></span>
<span id="line18416" class="line"></span>    /**
<span id="line18417" class="line"></span>     * Copy the data item given.
<span id="line18418" class="line"></span>     * @param {OpenSeadragon.Tile} tile
<span id="line18419" class="line"></span>     * @param {any} data data item to convert
<span id="line18420" class="line"></span>     * @param {string} type data type
<span id="line18421" class="line"></span>     * @return {OpenSeadragon.Promise&lt;?&gt;|undefined} promise resolution with data passed from constructor
<span id="line18422" class="line"></span>     */
<span id="line18423" class="line"></span>    copy(tile, data, type) {
<span id="line18424" class="line"></span>        const copyTransform = this.copyings[type];
<span id="line18425" class="line"></span>        if (copyTransform) {
<span id="line18426" class="line"></span>            const y = copyTransform(tile, data);
<span id="line18427" class="line"></span>            return $.type(y) === "promise" ? y : $.Promise.resolve(y);
<span id="line18428" class="line"></span>        }
<span id="line18429" class="line"></span>        $.console.warn(`[OpenSeadragon.converter.copy] is not supported with type %s`, type);
<span id="line18430" class="line"></span>        return $.Promise.resolve(undefined);
<span id="line18431" class="line"></span>    }
<span id="line18432" class="line"></span>
<span id="line18433" class="line"></span>    /**
<span id="line18434" class="line"></span>     * Destroy the data item given.
<span id="line18435" class="line"></span>     * @param {string} type data type
<span id="line18436" class="line"></span>     * @param {any} data
<span id="line18437" class="line"></span>     * @return {OpenSeadragon.Promise&lt;any&gt;|undefined} promise resolution with data passed from constructor, or undefined
<span id="line18438" class="line"></span>     *  if not such conversion exists
<span id="line18439" class="line"></span>     */
<span id="line18440" class="line"></span>    destroy(data, type) {
<span id="line18441" class="line"></span>        const destructor = this.destructors[type];
<span id="line18442" class="line"></span>        if (destructor) {
<span id="line18443" class="line"></span>            const y = destructor(data);
<span id="line18444" class="line"></span>            return $.type(y) === "promise" ? y : $.Promise.resolve(y);
<span id="line18445" class="line"></span>        }
<span id="line18446" class="line"></span>        return undefined;
<span id="line18447" class="line"></span>    }
<span id="line18448" class="line"></span>
<span id="line18449" class="line"></span>    /**
<span id="line18450" class="line"></span>     * Get possible system type conversions and cache result.
<span id="line18451" class="line"></span>     * @param {string} from data item type
<span id="line18452" class="line"></span>     * @param {string|string[]} to array of accepted types
<span id="line18453" class="line"></span>     * @return {ConversionStep[]|undefined} array of required conversions (returns empty array
<span id="line18454" class="line"></span>     *  for from===to), or undefined if the system cannot convert between given types.
<span id="line18455" class="line"></span>     *  Each object has 'transform' function that converts between neighbouring types, such
<span id="line18456" class="line"></span>     *  that x = arr[i].transform(x) is valid input for converter arr[i+1].transform(), e.g.
<span id="line18457" class="line"></span>     *  arr[i+1].transform(arr[i].transform( ... )) is a valid conversion procedure.
<span id="line18458" class="line"></span>     *
<span id="line18459" class="line"></span>     *  Note: if a function is returned, it is a callback called once the data is ready.
<span id="line18460" class="line"></span>     */
<span id="line18461" class="line"></span>    getConversionPath(from, to) {
<span id="line18462" class="line"></span>        let bestConverterPath;
<span id="line18463" class="line"></span>        let knownFrom = this._known[from];
<span id="line18464" class="line"></span>        if (!knownFrom) {
<span id="line18465" class="line"></span>            this._known[from] = knownFrom = {};
<span id="line18466" class="line"></span>        }
<span id="line18467" class="line"></span>
<span id="line18468" class="line"></span>        if (Array.isArray(to)) {
<span id="line18469" class="line"></span>            $.console.assert(to.length &gt; 0, "[getConversionPath] conversion 'to' type must be defined.");
<span id="line18470" class="line"></span>            let bestCost = Infinity;
<span id="line18471" class="line"></span>
<span id="line18472" class="line"></span>            for (const outType of to) {
<span id="line18473" class="line"></span>                let conversion = knownFrom[outType];
<span id="line18474" class="line"></span>                if (conversion === undefined) {
<span id="line18475" class="line"></span>                    knownFrom[outType] = conversion = this.graph.dijkstra(from, outType);
<span id="line18476" class="line"></span>                }
<span id="line18477" class="line"></span>                if (conversion &amp;&amp; bestCost &gt; conversion.cost) {
<span id="line18478" class="line"></span>                    bestConverterPath = conversion;
<span id="line18479" class="line"></span>                    bestCost = conversion.cost;
<span id="line18480" class="line"></span>                }
<span id="line18481" class="line"></span>            }
<span id="line18482" class="line"></span>        } else {
<span id="line18483" class="line"></span>            $.console.assert(typeof to === "string", "[getConversionPath] conversion 'to' type must be defined.");
<span id="line18484" class="line"></span>            bestConverterPath = knownFrom[to];
<span id="line18485" class="line"></span>            if (bestConverterPath === undefined) {
<span id="line18486" class="line"></span>                bestConverterPath = this.graph.dijkstra(from, to);
<span id="line18487" class="line"></span>                this._known[from][to] = bestConverterPath;
<span id="line18488" class="line"></span>            }
<span id="line18489" class="line"></span>        }
<span id="line18490" class="line"></span>
<span id="line18491" class="line"></span>        return bestConverterPath ? bestConverterPath.path : undefined;
<span id="line18492" class="line"></span>    }
<span id="line18493" class="line"></span>
<span id="line18494" class="line"></span>    /**
<span id="line18495" class="line"></span>     * Get the final type of the conversion path.
<span id="line18496" class="line"></span>     * @param {ConversionStep[]} path
<span id="line18497" class="line"></span>     * @return {undefined|string}  undefined if invalid path
<span id="line18498" class="line"></span>     */
<span id="line18499" class="line"></span>    getConversionPathFinalType(path) {
<span id="line18500" class="line"></span>        if (!path || !path.length) {
<span id="line18501" class="line"></span>            return undefined;
<span id="line18502" class="line"></span>        }
<span id="line18503" class="line"></span>        return path[path.length - 1].target.value;
<span id="line18504" class="line"></span>    }
<span id="line18505" class="line"></span>
<span id="line18506" class="line"></span>    /**
<span id="line18507" class="line"></span>     * Return a list of known conversion types
<span id="line18508" class="line"></span>     * @return {string[]}
<span id="line18509" class="line"></span>     */
<span id="line18510" class="line"></span>    getKnownTypes() {
<span id="line18511" class="line"></span>        return Object.keys(this.graph.vertices);
<span id="line18512" class="line"></span>    }
<span id="line18513" class="line"></span>
<span id="line18514" class="line"></span>    /**
<span id="line18515" class="line"></span>     * Check whether given type is known to the converter
<span id="line18516" class="line"></span>     * @param {string} type type to test
<span id="line18517" class="line"></span>     * @return {boolean}
<span id="line18518" class="line"></span>     */
<span id="line18519" class="line"></span>    existsType(type) {
<span id="line18520" class="line"></span>        return !!this.graph.vertices[type];
<span id="line18521" class="line"></span>    }
<span id="line18522" class="line"></span>};
<span id="line18523" class="line"></span>
<span id="line18524" class="line"></span>/**
<span id="line18525" class="line"></span> * Static converter available throughout OpenSeadragon.
<span id="line18526" class="line"></span> *
<span id="line18527" class="line"></span> * Built-in conversions include types:
<span id="line18528" class="line"></span> *  - context2d    canvas 2d context
<span id="line18529" class="line"></span> *  - image        HTMLImage element
<span id="line18530" class="line"></span> *  - url    url string carrying or pointing to 2D raster data
<span id="line18531" class="line"></span> *  - canvas       HTMLCanvas element
<span id="line18532" class="line"></span> *
<span id="line18533" class="line"></span> * @type OpenSeadragon.DataTypeConverter
<span id="line18534" class="line"></span> * @memberOf OpenSeadragon
<span id="line18535" class="line"></span> */
<span id="line18536" class="line"></span>$.converter = new $.DataTypeConverter();
<span id="line18537" class="line"></span>
<span id="line18538" class="line"></span>// Image URL -&gt; image private conversion, used in tests (was public originally, but made private to
<span id="line18539" class="line"></span>// discourage bad practices by forcing conversion API to deal with URLs that download data
<span id="line18540" class="line"></span>$.converter.learn("__private__imageUrl", "imageBitmap", (tile, url) =&gt; new $.Promise((resolve, reject) =&gt; {
<span id="line18541" class="line"></span>    if (!$.supportsAsync) {
<span id="line18542" class="line"></span>        return reject("Not supported in sync mode!");
<span id="line18543" class="line"></span>    }
<span id="line18544" class="line"></span>    let setup;
<span id="line18545" class="line"></span>    if (tile.tiledImage &amp;&amp; tile.tiledImage.crossOriginPolicy) {
<span id="line18546" class="line"></span>        const policy = tile.tiledImage.crossOriginPolicy;
<span id="line18547" class="line"></span>        if (policy === 'anonymous') {
<span id="line18548" class="line"></span>            setup = {
<span id="line18549" class="line"></span>                mode: 'cors',
<span id="line18550" class="line"></span>                credentials: 'omit',
<span id="line18551" class="line"></span>            };
<span id="line18552" class="line"></span>        } else if (policy === 'use-credentials') {
<span id="line18553" class="line"></span>            setup = {
<span id="line18554" class="line"></span>                mode: 'cors',
<span id="line18555" class="line"></span>                credentials: 'include',
<span id="line18556" class="line"></span>            };
<span id="line18557" class="line"></span>        } else if (policy) {
<span id="line18558" class="line"></span>            $.console.error(`Unsupported crossOriginPolicy ${policy}. Ignoring the property.`);
<span id="line18559" class="line"></span>        }
<span id="line18560" class="line"></span>    }
<span id="line18561" class="line"></span>    if (_imageConversionWorker) {
<span id="line18562" class="line"></span>        return postWorker('fetchDecode', { url, setup }).then(resolve).catch(reject);
<span id="line18563" class="line"></span>    }
<span id="line18564" class="line"></span>    // Fallback to the main thread
<span id="line18565" class="line"></span>    // eslint-disable-next-line compat/compat
<span id="line18566" class="line"></span>    return fetch(url, setup).then(res =&gt; {
<span id="line18567" class="line"></span>        if (!res.ok) {
<span id="line18568" class="line"></span>            throw new Error(`HTTP ${res.status} loading ${url}`);
<span id="line18569" class="line"></span>        }
<span id="line18570" class="line"></span>        return res.blob();
<span id="line18571" class="line"></span>    }).then(blob =&gt; createImageBitmap(blob, { colorSpaceConversion: 'none' })
<span id="line18572" class="line"></span>    ).then(resolve).catch(reject);
<span id="line18573" class="line"></span>}), 1, 1);
<span id="line18574" class="line"></span>$.converter.learn("__private__imageUrl", "__private__imageUrl", (tile, url) =&gt; url, 0, 1); //strings are immutable, no need to copy
<span id="line18575" class="line"></span>}(OpenSeadragon));
<span id="line18576" class="line"></span>
<span id="line18577" class="line"></span>/*
<span id="line18578" class="line"></span> * OpenSeadragon - Button
<span id="line18579" class="line"></span> *
<span id="line18580" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line18581" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line18582" class="line"></span> *
<span id="line18583" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line18584" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line18585" class="line"></span> * met:
<span id="line18586" class="line"></span> *
<span id="line18587" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line18588" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line18589" class="line"></span> *
<span id="line18590" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line18591" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line18592" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line18593" class="line"></span> *
<span id="line18594" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line18595" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line18596" class="line"></span> *   this software without specific prior written permission.
<span id="line18597" class="line"></span> *
<span id="line18598" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line18599" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line18600" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line18601" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line18602" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line18603" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line18604" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line18605" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line18606" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line18607" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line18608" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line18609" class="line"></span> */
<span id="line18610" class="line"></span>
<span id="line18611" class="line"></span>(function( $ ){
<span id="line18612" class="line"></span>
<span id="line18613" class="line"></span>/**
<span id="line18614" class="line"></span> * An enumeration of button states
<span id="line18615" class="line"></span> * @member ButtonState
<span id="line18616" class="line"></span> * @memberof OpenSeadragon
<span id="line18617" class="line"></span> * @static
<span id="line18618" class="line"></span> * @type {Object}
<span id="line18619" class="line"></span> * @property {Number} REST
<span id="line18620" class="line"></span> * @property {Number} GROUP
<span id="line18621" class="line"></span> * @property {Number} HOVER
<span id="line18622" class="line"></span> * @property {Number} DOWN
<span id="line18623" class="line"></span> */
<span id="line18624" class="line"></span>$.ButtonState = {
<span id="line18625" class="line"></span>    REST:   0,
<span id="line18626" class="line"></span>    GROUP:  1,
<span id="line18627" class="line"></span>    HOVER:  2,
<span id="line18628" class="line"></span>    DOWN:   3
<span id="line18629" class="line"></span>};
<span id="line18630" class="line"></span>
<span id="line18631" class="line"></span>/**
<span id="line18632" class="line"></span> * @class Button
<span id="line18633" class="line"></span> * @classdesc Manages events, hover states for individual buttons, tool-tips, as well
<span id="line18634" class="line"></span> * as fading the buttons out when the user has not interacted with them
<span id="line18635" class="line"></span> * for a specified period.
<span id="line18636" class="line"></span> *
<span id="line18637" class="line"></span> * @memberof OpenSeadragon
<span id="line18638" class="line"></span> * @extends OpenSeadragon.EventSource
<span id="line18639" class="line"></span> * @param {Object} options
<span id="line18640" class="line"></span> * @param {Element} [options.element=null] Element to use as the button. If not specified, an HTML &amp;lt;div&amp;gt; element is created.
<span id="line18641" class="line"></span> * @param {String} [options.tooltip=null] Provides context help for the button when the
<span id="line18642" class="line"></span> *  user hovers over it.
<span id="line18643" class="line"></span> * @param {String} [options.srcRest=null] URL of image to use in 'rest' state.
<span id="line18644" class="line"></span> * @param {String} [options.srcGroup=null] URL of image to use in 'up' state.
<span id="line18645" class="line"></span> * @param {String} [options.srcHover=null] URL of image to use in 'hover' state.
<span id="line18646" class="line"></span> * @param {String} [options.srcDown=null] URL of image to use in 'down' state.
<span id="line18647" class="line"></span> * @param {Number} [options.fadeDelay=0] How long to wait before fading.
<span id="line18648" class="line"></span> * @param {Number} [options.fadeLength=2000] How long should it take to fade the button.
<span id="line18649" class="line"></span> * @param {OpenSeadragon.EventHandler} [options.onPress=null] Event handler callback for {@link OpenSeadragon.Button.event:press}.
<span id="line18650" class="line"></span> * @param {OpenSeadragon.EventHandler} [options.onRelease=null] Event handler callback for {@link OpenSeadragon.Button.event:release}.
<span id="line18651" class="line"></span> * @param {OpenSeadragon.EventHandler} [options.onClick=null] Event handler callback for {@link OpenSeadragon.Button.event:click}.
<span id="line18652" class="line"></span> * @param {OpenSeadragon.EventHandler} [options.onEnter=null] Event handler callback for {@link OpenSeadragon.Button.event:enter}.
<span id="line18653" class="line"></span> * @param {OpenSeadragon.EventHandler} [options.onExit=null] Event handler callback for {@link OpenSeadragon.Button.event:exit}.
<span id="line18654" class="line"></span> * @param {OpenSeadragon.EventHandler} [options.onFocus=null] Event handler callback for {@link OpenSeadragon.Button.event:focus}.
<span id="line18655" class="line"></span> * @param {OpenSeadragon.EventHandler} [options.onBlur=null] Event handler callback for {@link OpenSeadragon.Button.event:blur}.
<span id="line18656" class="line"></span> * @param {Object} [options.userData=null] Arbitrary object to be passed unchanged to any attached handler methods.
<span id="line18657" class="line"></span> */
<span id="line18658" class="line"></span>$.Button = function( options ) {
<span id="line18659" class="line"></span>
<span id="line18660" class="line"></span>    const _this = this;
<span id="line18661" class="line"></span>
<span id="line18662" class="line"></span>    $.EventSource.call( this );
<span id="line18663" class="line"></span>
<span id="line18664" class="line"></span>    $.extend( true, this, {
<span id="line18665" class="line"></span>
<span id="line18666" class="line"></span>        tooltip:            null,
<span id="line18667" class="line"></span>        srcRest:            null,
<span id="line18668" class="line"></span>        srcGroup:           null,
<span id="line18669" class="line"></span>        srcHover:           null,
<span id="line18670" class="line"></span>        srcDown:            null,
<span id="line18671" class="line"></span>        clickTimeThreshold: $.DEFAULT_SETTINGS.clickTimeThreshold,
<span id="line18672" class="line"></span>        clickDistThreshold: $.DEFAULT_SETTINGS.clickDistThreshold,
<span id="line18673" class="line"></span>        /**
<span id="line18674" class="line"></span>         * How long to wait before fading.
<span id="line18675" class="line"></span>         * @member {Number} fadeDelay
<span id="line18676" class="line"></span>         * @memberof OpenSeadragon.Button#
<span id="line18677" class="line"></span>         */
<span id="line18678" class="line"></span>        fadeDelay:          0,
<span id="line18679" class="line"></span>        /**
<span id="line18680" class="line"></span>         * How long should it take to fade the button.
<span id="line18681" class="line"></span>         * @member {Number} fadeLength
<span id="line18682" class="line"></span>         * @memberof OpenSeadragon.Button#
<span id="line18683" class="line"></span>         */
<span id="line18684" class="line"></span>        fadeLength:         2000,
<span id="line18685" class="line"></span>        onPress:            null,
<span id="line18686" class="line"></span>        onRelease:          null,
<span id="line18687" class="line"></span>        onClick:            null,
<span id="line18688" class="line"></span>        onEnter:            null,
<span id="line18689" class="line"></span>        onExit:             null,
<span id="line18690" class="line"></span>        onFocus:            null,
<span id="line18691" class="line"></span>        onBlur:             null,
<span id="line18692" class="line"></span>        userData:           null
<span id="line18693" class="line"></span>
<span id="line18694" class="line"></span>    }, options );
<span id="line18695" class="line"></span>
<span id="line18696" class="line"></span>    /**
<span id="line18697" class="line"></span>     * The button element.
<span id="line18698" class="line"></span>     * @member {Element} element
<span id="line18699" class="line"></span>     * @memberof OpenSeadragon.Button#
<span id="line18700" class="line"></span>     */
<span id="line18701" class="line"></span>    this.element = options.element || $.makeNeutralElement("div");
<span id="line18702" class="line"></span>
<span id="line18703" class="line"></span>    //if the user has specified the element to bind the control to explicitly
<span id="line18704" class="line"></span>    //then do not add the default control images
<span id="line18705" class="line"></span>    if ( !options.element ) {
<span id="line18706" class="line"></span>        this.imgRest      = $.makeTransparentImage( this.srcRest );
<span id="line18707" class="line"></span>        this.imgGroup     = $.makeTransparentImage( this.srcGroup );
<span id="line18708" class="line"></span>        this.imgHover     = $.makeTransparentImage( this.srcHover );
<span id="line18709" class="line"></span>        this.imgDown      = $.makeTransparentImage( this.srcDown );
<span id="line18710" class="line"></span>
<span id="line18711" class="line"></span>        this.imgRest.alt  =
<span id="line18712" class="line"></span>        this.imgGroup.alt =
<span id="line18713" class="line"></span>        this.imgHover.alt =
<span id="line18714" class="line"></span>        this.imgDown.alt  =
<span id="line18715" class="line"></span>            this.tooltip;
<span id="line18716" class="line"></span>
<span id="line18717" class="line"></span>        // Allow pointer events to pass through the img elements so implicit
<span id="line18718" class="line"></span>        //   pointer capture works on touch devices
<span id="line18719" class="line"></span>        $.setElementPointerEventsNone( this.imgRest );
<span id="line18720" class="line"></span>        $.setElementPointerEventsNone( this.imgGroup );
<span id="line18721" class="line"></span>        $.setElementPointerEventsNone( this.imgHover );
<span id="line18722" class="line"></span>        $.setElementPointerEventsNone( this.imgDown );
<span id="line18723" class="line"></span>
<span id="line18724" class="line"></span>        this.element.style.position = "relative";
<span id="line18725" class="line"></span>        $.setElementTouchActionNone( this.element );
<span id="line18726" class="line"></span>
<span id="line18727" class="line"></span>        this.imgGroup.style.position =
<span id="line18728" class="line"></span>        this.imgHover.style.position =
<span id="line18729" class="line"></span>        this.imgDown.style.position  =
<span id="line18730" class="line"></span>            "absolute";
<span id="line18731" class="line"></span>
<span id="line18732" class="line"></span>        this.imgGroup.style.top =
<span id="line18733" class="line"></span>        this.imgHover.style.top =
<span id="line18734" class="line"></span>        this.imgDown.style.top  =
<span id="line18735" class="line"></span>            "0px";
<span id="line18736" class="line"></span>
<span id="line18737" class="line"></span>        this.imgGroup.style.left =
<span id="line18738" class="line"></span>        this.imgHover.style.left =
<span id="line18739" class="line"></span>        this.imgDown.style.left  =
<span id="line18740" class="line"></span>            "0px";
<span id="line18741" class="line"></span>
<span id="line18742" class="line"></span>        this.imgHover.style.visibility =
<span id="line18743" class="line"></span>        this.imgDown.style.visibility  =
<span id="line18744" class="line"></span>            "hidden";
<span id="line18745" class="line"></span>
<span id="line18746" class="line"></span>        this.element.appendChild( this.imgRest );
<span id="line18747" class="line"></span>        this.element.appendChild( this.imgGroup );
<span id="line18748" class="line"></span>        this.element.appendChild( this.imgHover );
<span id="line18749" class="line"></span>        this.element.appendChild( this.imgDown );
<span id="line18750" class="line"></span>    }
<span id="line18751" class="line"></span>
<span id="line18752" class="line"></span>
<span id="line18753" class="line"></span>    this.addHandler("press", this.onPress);
<span id="line18754" class="line"></span>    this.addHandler("release", this.onRelease);
<span id="line18755" class="line"></span>    this.addHandler("click", this.onClick);
<span id="line18756" class="line"></span>    this.addHandler("enter", this.onEnter);
<span id="line18757" class="line"></span>    this.addHandler("exit", this.onExit);
<span id="line18758" class="line"></span>    this.addHandler("focus", this.onFocus);
<span id="line18759" class="line"></span>    this.addHandler("blur", this.onBlur);
<span id="line18760" class="line"></span>
<span id="line18761" class="line"></span>    /**
<span id="line18762" class="line"></span>     * The button's current state.
<span id="line18763" class="line"></span>     * @member {OpenSeadragon.ButtonState} currentState
<span id="line18764" class="line"></span>     * @memberof OpenSeadragon.Button#
<span id="line18765" class="line"></span>     */
<span id="line18766" class="line"></span>    this.currentState = $.ButtonState.GROUP;
<span id="line18767" class="line"></span>
<span id="line18768" class="line"></span>    // When the button last began to fade.
<span id="line18769" class="line"></span>    this.fadeBeginTime  = null;
<span id="line18770" class="line"></span>    // Whether this button should fade after user stops interacting with the viewport.
<span id="line18771" class="line"></span>    this.shouldFade     = false;
<span id="line18772" class="line"></span>
<span id="line18773" class="line"></span>    this.element.style.display  = "inline-block";
<span id="line18774" class="line"></span>    this.element.style.position = "relative";
<span id="line18775" class="line"></span>    this.element.title          = this.tooltip;
<span id="line18776" class="line"></span>
<span id="line18777" class="line"></span>    /**
<span id="line18778" class="line"></span>     * Tracks mouse/touch/key events on the button.
<span id="line18779" class="line"></span>     * @member {OpenSeadragon.MouseTracker} tracker
<span id="line18780" class="line"></span>     * @memberof OpenSeadragon.Button#
<span id="line18781" class="line"></span>     */
<span id="line18782" class="line"></span>    this.tracker = new $.MouseTracker({
<span id="line18783" class="line"></span>
<span id="line18784" class="line"></span>        userData:           'Button.tracker',
<span id="line18785" class="line"></span>        element:            this.element,
<span id="line18786" class="line"></span>        clickTimeThreshold: this.clickTimeThreshold,
<span id="line18787" class="line"></span>        clickDistThreshold: this.clickDistThreshold,
<span id="line18788" class="line"></span>
<span id="line18789" class="line"></span>        enterHandler: function( event ) {
<span id="line18790" class="line"></span>            if ( event.insideElementPressed ) {
<span id="line18791" class="line"></span>                inTo( _this, $.ButtonState.DOWN );
<span id="line18792" class="line"></span>                /**
<span id="line18793" class="line"></span>                 * Raised when the cursor enters the Button element.
<span id="line18794" class="line"></span>                 *
<span id="line18795" class="line"></span>                 * @event enter
<span id="line18796" class="line"></span>                 * @memberof OpenSeadragon.Button
<span id="line18797" class="line"></span>                 * @type {object}
<span id="line18798" class="line"></span>                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
<span id="line18799" class="line"></span>                 * @property {Object} originalEvent - The original DOM event.
<span id="line18800" class="line"></span>                 * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line18801" class="line"></span>                 */
<span id="line18802" class="line"></span>                _this.raiseEvent( "enter", { originalEvent: event.originalEvent } );
<span id="line18803" class="line"></span>            } else if ( !event.buttonDownAny ) {
<span id="line18804" class="line"></span>                inTo( _this, $.ButtonState.HOVER );
<span id="line18805" class="line"></span>            }
<span id="line18806" class="line"></span>        },
<span id="line18807" class="line"></span>
<span id="line18808" class="line"></span>        focusHandler: function ( event ) {
<span id="line18809" class="line"></span>            _this.tracker.enterHandler( event );
<span id="line18810" class="line"></span>            /**
<span id="line18811" class="line"></span>             * Raised when the Button element receives focus.
<span id="line18812" class="line"></span>             *
<span id="line18813" class="line"></span>             * @event focus
<span id="line18814" class="line"></span>             * @memberof OpenSeadragon.Button
<span id="line18815" class="line"></span>             * @type {object}
<span id="line18816" class="line"></span>             * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
<span id="line18817" class="line"></span>             * @property {Object} originalEvent - The original DOM event.
<span id="line18818" class="line"></span>             * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line18819" class="line"></span>             */
<span id="line18820" class="line"></span>            _this.raiseEvent( "focus", { originalEvent: event.originalEvent } );
<span id="line18821" class="line"></span>        },
<span id="line18822" class="line"></span>
<span id="line18823" class="line"></span>        leaveHandler: function( event ) {
<span id="line18824" class="line"></span>            outTo( _this, $.ButtonState.GROUP );
<span id="line18825" class="line"></span>            if ( event.insideElementPressed ) {
<span id="line18826" class="line"></span>                /**
<span id="line18827" class="line"></span>                 * Raised when the cursor leaves the Button element.
<span id="line18828" class="line"></span>                 *
<span id="line18829" class="line"></span>                 * @event exit
<span id="line18830" class="line"></span>                 * @memberof OpenSeadragon.Button
<span id="line18831" class="line"></span>                 * @type {object}
<span id="line18832" class="line"></span>                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
<span id="line18833" class="line"></span>                 * @property {Object} originalEvent - The original DOM event.
<span id="line18834" class="line"></span>                 * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line18835" class="line"></span>                 */
<span id="line18836" class="line"></span>                _this.raiseEvent( "exit", { originalEvent: event.originalEvent } );
<span id="line18837" class="line"></span>            }
<span id="line18838" class="line"></span>        },
<span id="line18839" class="line"></span>
<span id="line18840" class="line"></span>        blurHandler: function ( event ) {
<span id="line18841" class="line"></span>            _this.tracker.leaveHandler( event );
<span id="line18842" class="line"></span>            /**
<span id="line18843" class="line"></span>             * Raised when the Button element loses focus.
<span id="line18844" class="line"></span>             *
<span id="line18845" class="line"></span>             * @event blur
<span id="line18846" class="line"></span>             * @memberof OpenSeadragon.Button
<span id="line18847" class="line"></span>             * @type {object}
<span id="line18848" class="line"></span>             * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
<span id="line18849" class="line"></span>             * @property {Object} originalEvent - The original DOM event.
<span id="line18850" class="line"></span>             * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line18851" class="line"></span>             */
<span id="line18852" class="line"></span>            _this.raiseEvent( "blur", { originalEvent: event.originalEvent } );
<span id="line18853" class="line"></span>        },
<span id="line18854" class="line"></span>
<span id="line18855" class="line"></span>        pressHandler: function ( event ) {
<span id="line18856" class="line"></span>            inTo( _this, $.ButtonState.DOWN );
<span id="line18857" class="line"></span>            /**
<span id="line18858" class="line"></span>             * Raised when a mouse button is pressed or touch occurs in the Button element.
<span id="line18859" class="line"></span>             *
<span id="line18860" class="line"></span>             * @event press
<span id="line18861" class="line"></span>             * @memberof OpenSeadragon.Button
<span id="line18862" class="line"></span>             * @type {object}
<span id="line18863" class="line"></span>             * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
<span id="line18864" class="line"></span>             * @property {Object} originalEvent - The original DOM event.
<span id="line18865" class="line"></span>             * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line18866" class="line"></span>             */
<span id="line18867" class="line"></span>            _this.raiseEvent( "press", { originalEvent: event.originalEvent } );
<span id="line18868" class="line"></span>        },
<span id="line18869" class="line"></span>
<span id="line18870" class="line"></span>        releaseHandler: function( event ) {
<span id="line18871" class="line"></span>            if ( event.insideElementPressed &amp;&amp; event.insideElementReleased ) {
<span id="line18872" class="line"></span>                outTo( _this, $.ButtonState.HOVER );
<span id="line18873" class="line"></span>                /**
<span id="line18874" class="line"></span>                 * Raised when the mouse button is released or touch ends in the Button element.
<span id="line18875" class="line"></span>                 *
<span id="line18876" class="line"></span>                 * @event release
<span id="line18877" class="line"></span>                 * @memberof OpenSeadragon.Button
<span id="line18878" class="line"></span>                 * @type {object}
<span id="line18879" class="line"></span>                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
<span id="line18880" class="line"></span>                 * @property {Object} originalEvent - The original DOM event.
<span id="line18881" class="line"></span>                 * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line18882" class="line"></span>                 */
<span id="line18883" class="line"></span>                _this.raiseEvent( "release", { originalEvent: event.originalEvent } );
<span id="line18884" class="line"></span>            } else if ( event.insideElementPressed ) {
<span id="line18885" class="line"></span>                outTo( _this, $.ButtonState.GROUP );
<span id="line18886" class="line"></span>            } else {
<span id="line18887" class="line"></span>                inTo( _this, $.ButtonState.HOVER );
<span id="line18888" class="line"></span>            }
<span id="line18889" class="line"></span>        },
<span id="line18890" class="line"></span>
<span id="line18891" class="line"></span>        clickHandler: function( event ) {
<span id="line18892" class="line"></span>            if ( event.quick ) {
<span id="line18893" class="line"></span>                /**
<span id="line18894" class="line"></span>                 * Raised when a mouse button is pressed and released or touch is initiated and ended in the Button element within the time and distance threshold.
<span id="line18895" class="line"></span>                 *
<span id="line18896" class="line"></span>                 * @event click
<span id="line18897" class="line"></span>                 * @memberof OpenSeadragon.Button
<span id="line18898" class="line"></span>                 * @type {object}
<span id="line18899" class="line"></span>                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
<span id="line18900" class="line"></span>                 * @property {Object} originalEvent - The original DOM event.
<span id="line18901" class="line"></span>                 * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line18902" class="line"></span>                 */
<span id="line18903" class="line"></span>                _this.raiseEvent("click", { originalEvent: event.originalEvent });
<span id="line18904" class="line"></span>            }
<span id="line18905" class="line"></span>        },
<span id="line18906" class="line"></span>
<span id="line18907" class="line"></span>        keyHandler: function( event ){
<span id="line18908" class="line"></span>            //console.log( "%s : handling key %s!", _this.tooltip, event.keyCode);
<span id="line18909" class="line"></span>            if( 13 === event.keyCode ){
<span id="line18910" class="line"></span>                /***
<span id="line18911" class="line"></span>                 * Raised when a mouse button is pressed and released or touch is initiated and ended in the Button element within the time and distance threshold.
<span id="line18912" class="line"></span>                 *
<span id="line18913" class="line"></span>                 * @event click
<span id="line18914" class="line"></span>                 * @memberof OpenSeadragon.Button
<span id="line18915" class="line"></span>                 * @type {object}
<span id="line18916" class="line"></span>                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
<span id="line18917" class="line"></span>                 * @property {Object} originalEvent - The original DOM event.
<span id="line18918" class="line"></span>                 * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line18919" class="line"></span>                 */
<span id="line18920" class="line"></span>                _this.raiseEvent( "click", { originalEvent: event.originalEvent } );
<span id="line18921" class="line"></span>                /***
<span id="line18922" class="line"></span>                 * Raised when the mouse button is released or touch ends in the Button element.
<span id="line18923" class="line"></span>                 *
<span id="line18924" class="line"></span>                 * @event release
<span id="line18925" class="line"></span>                 * @memberof OpenSeadragon.Button
<span id="line18926" class="line"></span>                 * @type {object}
<span id="line18927" class="line"></span>                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
<span id="line18928" class="line"></span>                 * @property {Object} originalEvent - The original DOM event.
<span id="line18929" class="line"></span>                 * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line18930" class="line"></span>                 */
<span id="line18931" class="line"></span>                _this.raiseEvent( "release", { originalEvent: event.originalEvent } );
<span id="line18932" class="line"></span>
<span id="line18933" class="line"></span>                event.preventDefault = true;
<span id="line18934" class="line"></span>            } else{
<span id="line18935" class="line"></span>                event.preventDefault = false;
<span id="line18936" class="line"></span>            }
<span id="line18937" class="line"></span>        }
<span id="line18938" class="line"></span>
<span id="line18939" class="line"></span>    });
<span id="line18940" class="line"></span>
<span id="line18941" class="line"></span>    outTo( this, $.ButtonState.REST );
<span id="line18942" class="line"></span>};
<span id="line18943" class="line"></span>
<span id="line18944" class="line"></span>$.extend( $.Button.prototype, $.EventSource.prototype, /** @lends OpenSeadragon.Button.prototype */{
<span id="line18945" class="line"></span>
<span id="line18946" class="line"></span>    /**
<span id="line18947" class="line"></span>     * Used by a button container element (e.g. a ButtonGroup) to transition the button state
<span id="line18948" class="line"></span>     * to ButtonState.GROUP.
<span id="line18949" class="line"></span>     * @function
<span id="line18950" class="line"></span>     */
<span id="line18951" class="line"></span>    notifyGroupEnter: function() {
<span id="line18952" class="line"></span>        inTo( this, $.ButtonState.GROUP );
<span id="line18953" class="line"></span>    },
<span id="line18954" class="line"></span>
<span id="line18955" class="line"></span>    /**
<span id="line18956" class="line"></span>     * Used by a button container element (e.g. a ButtonGroup) to transition the button state
<span id="line18957" class="line"></span>     * to ButtonState.REST.
<span id="line18958" class="line"></span>     * @function
<span id="line18959" class="line"></span>     */
<span id="line18960" class="line"></span>    notifyGroupExit: function() {
<span id="line18961" class="line"></span>        outTo( this, $.ButtonState.REST );
<span id="line18962" class="line"></span>    },
<span id="line18963" class="line"></span>
<span id="line18964" class="line"></span>    /**
<span id="line18965" class="line"></span>     * @function
<span id="line18966" class="line"></span>     */
<span id="line18967" class="line"></span>    disable: function(){
<span id="line18968" class="line"></span>        this.notifyGroupExit();
<span id="line18969" class="line"></span>        this.element.disabled = true;
<span id="line18970" class="line"></span>        this.tracker.setTracking(false);
<span id="line18971" class="line"></span>        $.setElementOpacity( this.element, 0.2, true );
<span id="line18972" class="line"></span>    },
<span id="line18973" class="line"></span>
<span id="line18974" class="line"></span>    /**
<span id="line18975" class="line"></span>     * @function
<span id="line18976" class="line"></span>     */
<span id="line18977" class="line"></span>    enable: function(){
<span id="line18978" class="line"></span>        this.element.disabled = false;
<span id="line18979" class="line"></span>        this.tracker.setTracking(true);
<span id="line18980" class="line"></span>        $.setElementOpacity( this.element, 1.0, true );
<span id="line18981" class="line"></span>        this.notifyGroupEnter();
<span id="line18982" class="line"></span>    },
<span id="line18983" class="line"></span>
<span id="line18984" class="line"></span>    destroy: function() {
<span id="line18985" class="line"></span>        if (this.imgRest) {
<span id="line18986" class="line"></span>            this.element.removeChild(this.imgRest);
<span id="line18987" class="line"></span>            this.imgRest = null;
<span id="line18988" class="line"></span>        }
<span id="line18989" class="line"></span>        if (this.imgGroup) {
<span id="line18990" class="line"></span>            this.element.removeChild(this.imgGroup);
<span id="line18991" class="line"></span>            this.imgGroup = null;
<span id="line18992" class="line"></span>        }
<span id="line18993" class="line"></span>        if (this.imgHover) {
<span id="line18994" class="line"></span>            this.element.removeChild(this.imgHover);
<span id="line18995" class="line"></span>            this.imgHover = null;
<span id="line18996" class="line"></span>        }
<span id="line18997" class="line"></span>        if (this.imgDown) {
<span id="line18998" class="line"></span>            this.element.removeChild(this.imgDown);
<span id="line18999" class="line"></span>            this.imgDown = null;
<span id="line19000" class="line"></span>        }
<span id="line19001" class="line"></span>        this.removeAllHandlers();
<span id="line19002" class="line"></span>        this.tracker.destroy();
<span id="line19003" class="line"></span>        this.element = null;
<span id="line19004" class="line"></span>    }
<span id="line19005" class="line"></span>
<span id="line19006" class="line"></span>});
<span id="line19007" class="line"></span>
<span id="line19008" class="line"></span>
<span id="line19009" class="line"></span>function scheduleFade( button ) {
<span id="line19010" class="line"></span>    $.requestAnimationFrame(function(){
<span id="line19011" class="line"></span>        updateFade( button );
<span id="line19012" class="line"></span>    });
<span id="line19013" class="line"></span>}
<span id="line19014" class="line"></span>
<span id="line19015" class="line"></span>function updateFade( button ) {
<span id="line19016" class="line"></span>    let currentTime,
<span id="line19017" class="line"></span>        deltaTime,
<span id="line19018" class="line"></span>        opacity;
<span id="line19019" class="line"></span>
<span id="line19020" class="line"></span>    if ( button.shouldFade ) {
<span id="line19021" class="line"></span>        currentTime = $.now();
<span id="line19022" class="line"></span>        deltaTime   = currentTime - button.fadeBeginTime;
<span id="line19023" class="line"></span>        opacity     = 1.0 - deltaTime / button.fadeLength;
<span id="line19024" class="line"></span>        opacity     = Math.min( 1.0, opacity );
<span id="line19025" class="line"></span>        opacity     = Math.max( 0.0, opacity );
<span id="line19026" class="line"></span>
<span id="line19027" class="line"></span>        if( button.imgGroup ){
<span id="line19028" class="line"></span>            $.setElementOpacity( button.imgGroup, opacity, true );
<span id="line19029" class="line"></span>        }
<span id="line19030" class="line"></span>        if ( opacity &gt; 0 ) {
<span id="line19031" class="line"></span>            // fade again
<span id="line19032" class="line"></span>            scheduleFade( button );
<span id="line19033" class="line"></span>        }
<span id="line19034" class="line"></span>    }
<span id="line19035" class="line"></span>}
<span id="line19036" class="line"></span>
<span id="line19037" class="line"></span>function beginFading( button ) {
<span id="line19038" class="line"></span>    button.shouldFade = true;
<span id="line19039" class="line"></span>    button.fadeBeginTime = $.now() + button.fadeDelay;
<span id="line19040" class="line"></span>    window.setTimeout( function(){
<span id="line19041" class="line"></span>        scheduleFade( button );
<span id="line19042" class="line"></span>    }, button.fadeDelay );
<span id="line19043" class="line"></span>}
<span id="line19044" class="line"></span>
<span id="line19045" class="line"></span>function stopFading( button ) {
<span id="line19046" class="line"></span>    button.shouldFade = false;
<span id="line19047" class="line"></span>    if( button.imgGroup ){
<span id="line19048" class="line"></span>        $.setElementOpacity( button.imgGroup, 1.0, true );
<span id="line19049" class="line"></span>    }
<span id="line19050" class="line"></span>}
<span id="line19051" class="line"></span>
<span id="line19052" class="line"></span>function inTo( button, newState ) {
<span id="line19053" class="line"></span>
<span id="line19054" class="line"></span>    if( button.element.disabled ){
<span id="line19055" class="line"></span>        return;
<span id="line19056" class="line"></span>    }
<span id="line19057" class="line"></span>
<span id="line19058" class="line"></span>    if ( newState &gt;= $.ButtonState.GROUP &amp;&amp;
<span id="line19059" class="line"></span>         button.currentState === $.ButtonState.REST ) {
<span id="line19060" class="line"></span>        stopFading( button );
<span id="line19061" class="line"></span>        button.currentState = $.ButtonState.GROUP;
<span id="line19062" class="line"></span>    }
<span id="line19063" class="line"></span>
<span id="line19064" class="line"></span>    if ( newState &gt;= $.ButtonState.HOVER &amp;&amp;
<span id="line19065" class="line"></span>         button.currentState === $.ButtonState.GROUP ) {
<span id="line19066" class="line"></span>        if( button.imgHover ){
<span id="line19067" class="line"></span>            button.imgHover.style.visibility = "";
<span id="line19068" class="line"></span>        }
<span id="line19069" class="line"></span>        button.currentState = $.ButtonState.HOVER;
<span id="line19070" class="line"></span>    }
<span id="line19071" class="line"></span>
<span id="line19072" class="line"></span>    if ( newState &gt;= $.ButtonState.DOWN &amp;&amp;
<span id="line19073" class="line"></span>         button.currentState === $.ButtonState.HOVER ) {
<span id="line19074" class="line"></span>        if( button.imgDown ){
<span id="line19075" class="line"></span>            button.imgDown.style.visibility = "";
<span id="line19076" class="line"></span>        }
<span id="line19077" class="line"></span>        button.currentState = $.ButtonState.DOWN;
<span id="line19078" class="line"></span>    }
<span id="line19079" class="line"></span>}
<span id="line19080" class="line"></span>
<span id="line19081" class="line"></span>
<span id="line19082" class="line"></span>function outTo( button, newState ) {
<span id="line19083" class="line"></span>
<span id="line19084" class="line"></span>    if( button.element.disabled ){
<span id="line19085" class="line"></span>        return;
<span id="line19086" class="line"></span>    }
<span id="line19087" class="line"></span>
<span id="line19088" class="line"></span>    if ( newState &lt;= $.ButtonState.HOVER &amp;&amp;
<span id="line19089" class="line"></span>         button.currentState === $.ButtonState.DOWN ) {
<span id="line19090" class="line"></span>        if( button.imgDown ){
<span id="line19091" class="line"></span>            button.imgDown.style.visibility = "hidden";
<span id="line19092" class="line"></span>        }
<span id="line19093" class="line"></span>        button.currentState = $.ButtonState.HOVER;
<span id="line19094" class="line"></span>    }
<span id="line19095" class="line"></span>
<span id="line19096" class="line"></span>    if ( newState &lt;= $.ButtonState.GROUP &amp;&amp;
<span id="line19097" class="line"></span>         button.currentState === $.ButtonState.HOVER ) {
<span id="line19098" class="line"></span>        if( button.imgHover ){
<span id="line19099" class="line"></span>            button.imgHover.style.visibility = "hidden";
<span id="line19100" class="line"></span>        }
<span id="line19101" class="line"></span>        button.currentState = $.ButtonState.GROUP;
<span id="line19102" class="line"></span>    }
<span id="line19103" class="line"></span>
<span id="line19104" class="line"></span>    if ( newState &lt;= $.ButtonState.REST &amp;&amp;
<span id="line19105" class="line"></span>         button.currentState === $.ButtonState.GROUP ) {
<span id="line19106" class="line"></span>        beginFading( button );
<span id="line19107" class="line"></span>        button.currentState = $.ButtonState.REST;
<span id="line19108" class="line"></span>    }
<span id="line19109" class="line"></span>}
<span id="line19110" class="line"></span>
<span id="line19111" class="line"></span>
<span id="line19112" class="line"></span>
<span id="line19113" class="line"></span>}( OpenSeadragon ));
<span id="line19114" class="line"></span>
<span id="line19115" class="line"></span>/*
<span id="line19116" class="line"></span> * OpenSeadragon - ButtonGroup
<span id="line19117" class="line"></span> *
<span id="line19118" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line19119" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line19120" class="line"></span> *
<span id="line19121" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line19122" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line19123" class="line"></span> * met:
<span id="line19124" class="line"></span> *
<span id="line19125" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line19126" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line19127" class="line"></span> *
<span id="line19128" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line19129" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line19130" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line19131" class="line"></span> *
<span id="line19132" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line19133" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line19134" class="line"></span> *   this software without specific prior written permission.
<span id="line19135" class="line"></span> *
<span id="line19136" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line19137" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line19138" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line19139" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line19140" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line19141" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line19142" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line19143" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line19144" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line19145" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line19146" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line19147" class="line"></span> */
<span id="line19148" class="line"></span>
<span id="line19149" class="line"></span>(function( $ ){
<span id="line19150" class="line"></span>/**
<span id="line19151" class="line"></span> * @class ButtonGroup
<span id="line19152" class="line"></span> * @classdesc Manages events on groups of buttons.
<span id="line19153" class="line"></span> *
<span id="line19154" class="line"></span> * @memberof OpenSeadragon
<span id="line19155" class="line"></span> * @param {Object} options - A dictionary of settings applied against the entire group of buttons.
<span id="line19156" class="line"></span> * @param {Array} options.buttons Array of buttons
<span id="line19157" class="line"></span> * @param {Element} [options.element] Element to use as the container
<span id="line19158" class="line"></span> **/
<span id="line19159" class="line"></span>$.ButtonGroup = function( options ) {
<span id="line19160" class="line"></span>
<span id="line19161" class="line"></span>    $.extend( true, this, {
<span id="line19162" class="line"></span>        /**
<span id="line19163" class="line"></span>         * An array containing the buttons themselves.
<span id="line19164" class="line"></span>         * @member {Array} buttons
<span id="line19165" class="line"></span>         * @memberof OpenSeadragon.ButtonGroup#
<span id="line19166" class="line"></span>         */
<span id="line19167" class="line"></span>        buttons:            [],
<span id="line19168" class="line"></span>        clickTimeThreshold: $.DEFAULT_SETTINGS.clickTimeThreshold,
<span id="line19169" class="line"></span>        clickDistThreshold: $.DEFAULT_SETTINGS.clickDistThreshold,
<span id="line19170" class="line"></span>        labelText:          ""
<span id="line19171" class="line"></span>    }, options );
<span id="line19172" class="line"></span>
<span id="line19173" class="line"></span>    // copy the button elements  TODO: Why?
<span id="line19174" class="line"></span>    let buttons = this.buttons.concat([]),
<span id="line19175" class="line"></span>        _this = this,
<span id="line19176" class="line"></span>        i;
<span id="line19177" class="line"></span>
<span id="line19178" class="line"></span>    /**
<span id="line19179" class="line"></span>     * The shared container for the buttons.
<span id="line19180" class="line"></span>     * @member {Element} element
<span id="line19181" class="line"></span>     * @memberof OpenSeadragon.ButtonGroup#
<span id="line19182" class="line"></span>     */
<span id="line19183" class="line"></span>    this.element = options.element || $.makeNeutralElement( "div" );
<span id="line19184" class="line"></span>
<span id="line19185" class="line"></span>    // TODO What if there IS an options.group specified?
<span id="line19186" class="line"></span>    if( !options.group ){
<span id="line19187" class="line"></span>        this.element.style.display = "inline-block";
<span id="line19188" class="line"></span>        //this.label   = $.makeNeutralElement( "label" );
<span id="line19189" class="line"></span>        //TODO: support labels for ButtonGroups
<span id="line19190" class="line"></span>        //this.label.innerHTML = this.labelText;
<span id="line19191" class="line"></span>        //this.element.appendChild( this.label );
<span id="line19192" class="line"></span>        for ( i = 0; i &lt; buttons.length; i++ ) {
<span id="line19193" class="line"></span>            this.element.appendChild( buttons[ i ].element );
<span id="line19194" class="line"></span>        }
<span id="line19195" class="line"></span>    }
<span id="line19196" class="line"></span>
<span id="line19197" class="line"></span>    $.setElementTouchActionNone( this.element );
<span id="line19198" class="line"></span>
<span id="line19199" class="line"></span>    /**
<span id="line19200" class="line"></span>     * Tracks mouse/touch/key events across the group of buttons.
<span id="line19201" class="line"></span>     * @member {OpenSeadragon.MouseTracker} tracker
<span id="line19202" class="line"></span>     * @memberof OpenSeadragon.ButtonGroup#
<span id="line19203" class="line"></span>     */
<span id="line19204" class="line"></span>    this.tracker = new $.MouseTracker({
<span id="line19205" class="line"></span>        userData:           'ButtonGroup.tracker',
<span id="line19206" class="line"></span>        element:            this.element,
<span id="line19207" class="line"></span>        clickTimeThreshold: this.clickTimeThreshold,
<span id="line19208" class="line"></span>        clickDistThreshold: this.clickDistThreshold,
<span id="line19209" class="line"></span>        enterHandler: function ( event ) {
<span id="line19210" class="line"></span>            let i;
<span id="line19211" class="line"></span>            for ( i = 0; i &lt; _this.buttons.length; i++ ) {
<span id="line19212" class="line"></span>                _this.buttons[ i ].notifyGroupEnter();
<span id="line19213" class="line"></span>            }
<span id="line19214" class="line"></span>        },
<span id="line19215" class="line"></span>        leaveHandler: function ( event ) {
<span id="line19216" class="line"></span>            let i;
<span id="line19217" class="line"></span>            if ( !event.insideElementPressed ) {
<span id="line19218" class="line"></span>                for ( i = 0; i &lt; _this.buttons.length; i++ ) {
<span id="line19219" class="line"></span>                    _this.buttons[ i ].notifyGroupExit();
<span id="line19220" class="line"></span>                }
<span id="line19221" class="line"></span>            }
<span id="line19222" class="line"></span>        },
<span id="line19223" class="line"></span>    });
<span id="line19224" class="line"></span>};
<span id="line19225" class="line"></span>
<span id="line19226" class="line"></span>/** @lends OpenSeadragon.ButtonGroup.prototype */
<span id="line19227" class="line"></span>$.ButtonGroup.prototype = {
<span id="line19228" class="line"></span>
<span id="line19229" class="line"></span>    /**
<span id="line19230" class="line"></span>     * Adds the given button to this button group.
<span id="line19231" class="line"></span>     *
<span id="line19232" class="line"></span>     * @function
<span id="line19233" class="line"></span>     * @param {OpenSeadragon.Button} button
<span id="line19234" class="line"></span>     */
<span id="line19235" class="line"></span>    addButton: function( button ){
<span id="line19236" class="line"></span>        this.buttons.push(button);
<span id="line19237" class="line"></span>        this.element.appendChild(button.element);
<span id="line19238" class="line"></span>    },
<span id="line19239" class="line"></span>
<span id="line19240" class="line"></span>    /**
<span id="line19241" class="line"></span>     * TODO: Figure out why this is used on the public API and if a more useful
<span id="line19242" class="line"></span>     * api can be created.
<span id="line19243" class="line"></span>     * @function
<span id="line19244" class="line"></span>     * @private
<span id="line19245" class="line"></span>     */
<span id="line19246" class="line"></span>    emulateEnter: function() {
<span id="line19247" class="line"></span>        this.tracker.enterHandler( { eventSource: this.tracker } );
<span id="line19248" class="line"></span>    },
<span id="line19249" class="line"></span>
<span id="line19250" class="line"></span>    /**
<span id="line19251" class="line"></span>     * TODO: Figure out why this is used on the public API and if a more useful
<span id="line19252" class="line"></span>     * api can be created.
<span id="line19253" class="line"></span>     * @function
<span id="line19254" class="line"></span>     * @private
<span id="line19255" class="line"></span>     */
<span id="line19256" class="line"></span>    emulateLeave: function() {
<span id="line19257" class="line"></span>        this.tracker.leaveHandler( { eventSource: this.tracker } );
<span id="line19258" class="line"></span>    },
<span id="line19259" class="line"></span>
<span id="line19260" class="line"></span>    destroy: function() {
<span id="line19261" class="line"></span>        while (this.buttons.length) {
<span id="line19262" class="line"></span>            const button = this.buttons.pop();
<span id="line19263" class="line"></span>            this.element.removeChild(button.element);
<span id="line19264" class="line"></span>            button.destroy();
<span id="line19265" class="line"></span>        }
<span id="line19266" class="line"></span>        this.tracker.destroy();
<span id="line19267" class="line"></span>        this.element = null;
<span id="line19268" class="line"></span>    }
<span id="line19269" class="line"></span>};
<span id="line19270" class="line"></span>
<span id="line19271" class="line"></span>
<span id="line19272" class="line"></span>}( OpenSeadragon ));
<span id="line19273" class="line"></span>
<span id="line19274" class="line"></span>/*
<span id="line19275" class="line"></span> * OpenSeadragon - Rect
<span id="line19276" class="line"></span> *
<span id="line19277" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line19278" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line19279" class="line"></span> *
<span id="line19280" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line19281" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line19282" class="line"></span> * met:
<span id="line19283" class="line"></span> *
<span id="line19284" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line19285" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line19286" class="line"></span> *
<span id="line19287" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line19288" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line19289" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line19290" class="line"></span> *
<span id="line19291" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line19292" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line19293" class="line"></span> *   this software without specific prior written permission.
<span id="line19294" class="line"></span> *
<span id="line19295" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line19296" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line19297" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line19298" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line19299" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line19300" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line19301" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line19302" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line19303" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line19304" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line19305" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line19306" class="line"></span> */
<span id="line19307" class="line"></span>
<span id="line19308" class="line"></span>(function($) {
<span id="line19309" class="line"></span>
<span id="line19310" class="line"></span>/**
<span id="line19311" class="line"></span> * @class Rect
<span id="line19312" class="line"></span> * @classdesc A Rectangle is described by it top left coordinates (x, y), width,
<span id="line19313" class="line"></span> * height and degrees of rotation around (x, y).
<span id="line19314" class="line"></span> * Note that the coordinate system used is the one commonly used with images:
<span id="line19315" class="line"></span> * x increases when going to the right
<span id="line19316" class="line"></span> * y increases when going to the bottom
<span id="line19317" class="line"></span> * degrees increases clockwise with 0 being the horizontal
<span id="line19318" class="line"></span> *
<span id="line19319" class="line"></span> * The constructor normalizes the rectangle to always have 0 &lt;= degrees &lt; 90
<span id="line19320" class="line"></span> *
<span id="line19321" class="line"></span> * @memberof OpenSeadragon
<span id="line19322" class="line"></span> * @param {Number} [x=0] The vector component 'x'.
<span id="line19323" class="line"></span> * @param {Number} [y=0] The vector component 'y'.
<span id="line19324" class="line"></span> * @param {Number} [width=0] The vector component 'width'.
<span id="line19325" class="line"></span> * @param {Number} [height=0] The vector component 'height'.
<span id="line19326" class="line"></span> * @param {Number} [degrees=0] Rotation of the rectangle around (x,y) in degrees.
<span id="line19327" class="line"></span> */
<span id="line19328" class="line"></span>$.Rect = function(x, y, width, height, degrees) {
<span id="line19329" class="line"></span>    /**
<span id="line19330" class="line"></span>     * The vector component 'x'.
<span id="line19331" class="line"></span>     * @member {Number} x
<span id="line19332" class="line"></span>     * @memberof OpenSeadragon.Rect#
<span id="line19333" class="line"></span>     */
<span id="line19334" class="line"></span>    this.x = typeof (x) === "number" ? x : 0;
<span id="line19335" class="line"></span>    /**
<span id="line19336" class="line"></span>     * The vector component 'y'.
<span id="line19337" class="line"></span>     * @member {Number} y
<span id="line19338" class="line"></span>     * @memberof OpenSeadragon.Rect#
<span id="line19339" class="line"></span>     */
<span id="line19340" class="line"></span>    this.y = typeof (y) === "number" ? y : 0;
<span id="line19341" class="line"></span>    /**
<span id="line19342" class="line"></span>     * The vector component 'width'.
<span id="line19343" class="line"></span>     * @member {Number} width
<span id="line19344" class="line"></span>     * @memberof OpenSeadragon.Rect#
<span id="line19345" class="line"></span>     */
<span id="line19346" class="line"></span>    this.width  = typeof (width) === "number" ? width : 0;
<span id="line19347" class="line"></span>    /**
<span id="line19348" class="line"></span>     * The vector component 'height'.
<span id="line19349" class="line"></span>     * @member {Number} height
<span id="line19350" class="line"></span>     * @memberof OpenSeadragon.Rect#
<span id="line19351" class="line"></span>     */
<span id="line19352" class="line"></span>    this.height = typeof (height) === "number" ? height : 0;
<span id="line19353" class="line"></span>
<span id="line19354" class="line"></span>    /**
<span id="line19355" class="line"></span>     * The rotation of the rectangle, in degrees.
<span id="line19356" class="line"></span>     * @member {Number} degrees
<span id="line19357" class="line"></span>     * @memberof OpenSeadragon.Rect#
<span id="line19358" class="line"></span>     */
<span id="line19359" class="line"></span>    this.degrees = typeof (degrees) === "number" ? degrees : 0;
<span id="line19360" class="line"></span>
<span id="line19361" class="line"></span>    // Normalizes the rectangle.
<span id="line19362" class="line"></span>    this.degrees = $.positiveModulo(this.degrees, 360);
<span id="line19363" class="line"></span>    let newTopLeft, newWidth;
<span id="line19364" class="line"></span>    if (this.degrees &gt;= 270) {
<span id="line19365" class="line"></span>        newTopLeft = this.getTopRight();
<span id="line19366" class="line"></span>        this.x = newTopLeft.x;
<span id="line19367" class="line"></span>        this.y = newTopLeft.y;
<span id="line19368" class="line"></span>        newWidth = this.height;
<span id="line19369" class="line"></span>        this.height = this.width;
<span id="line19370" class="line"></span>        this.width = newWidth;
<span id="line19371" class="line"></span>        this.degrees -= 270;
<span id="line19372" class="line"></span>    } else if (this.degrees &gt;= 180) {
<span id="line19373" class="line"></span>        newTopLeft = this.getBottomRight();
<span id="line19374" class="line"></span>        this.x = newTopLeft.x;
<span id="line19375" class="line"></span>        this.y = newTopLeft.y;
<span id="line19376" class="line"></span>        this.degrees -= 180;
<span id="line19377" class="line"></span>    } else if (this.degrees &gt;= 90) {
<span id="line19378" class="line"></span>        newTopLeft = this.getBottomLeft();
<span id="line19379" class="line"></span>        this.x = newTopLeft.x;
<span id="line19380" class="line"></span>        this.y = newTopLeft.y;
<span id="line19381" class="line"></span>        newWidth = this.height;
<span id="line19382" class="line"></span>        this.height = this.width;
<span id="line19383" class="line"></span>        this.width = newWidth;
<span id="line19384" class="line"></span>        this.degrees -= 90;
<span id="line19385" class="line"></span>    }
<span id="line19386" class="line"></span>};
<span id="line19387" class="line"></span>
<span id="line19388" class="line"></span>/**
<span id="line19389" class="line"></span> * Builds a rectangle having the 3 specified points as summits.
<span id="line19390" class="line"></span> * @static
<span id="line19391" class="line"></span> * @memberof OpenSeadragon.Rect
<span id="line19392" class="line"></span> * @param {OpenSeadragon.Point} topLeft
<span id="line19393" class="line"></span> * @param {OpenSeadragon.Point} topRight
<span id="line19394" class="line"></span> * @param {OpenSeadragon.Point} bottomLeft
<span id="line19395" class="line"></span> * @returns {OpenSeadragon.Rect}
<span id="line19396" class="line"></span> */
<span id="line19397" class="line"></span>$.Rect.fromSummits = function(topLeft, topRight, bottomLeft) {
<span id="line19398" class="line"></span>    const width = topLeft.distanceTo(topRight);
<span id="line19399" class="line"></span>    const height = topLeft.distanceTo(bottomLeft);
<span id="line19400" class="line"></span>    const diff = topRight.minus(topLeft);
<span id="line19401" class="line"></span>    let radians = Math.atan(diff.y / diff.x);
<span id="line19402" class="line"></span>    if (diff.x &lt; 0) {
<span id="line19403" class="line"></span>        radians += Math.PI;
<span id="line19404" class="line"></span>    } else if (diff.y &lt; 0) {
<span id="line19405" class="line"></span>        radians += 2 * Math.PI;
<span id="line19406" class="line"></span>    }
<span id="line19407" class="line"></span>    return new $.Rect(
<span id="line19408" class="line"></span>        topLeft.x,
<span id="line19409" class="line"></span>        topLeft.y,
<span id="line19410" class="line"></span>        width,
<span id="line19411" class="line"></span>        height,
<span id="line19412" class="line"></span>        radians / Math.PI * 180);
<span id="line19413" class="line"></span>};
<span id="line19414" class="line"></span>
<span id="line19415" class="line"></span>/** @lends OpenSeadragon.Rect.prototype */
<span id="line19416" class="line"></span>$.Rect.prototype = {
<span id="line19417" class="line"></span>    /**
<span id="line19418" class="line"></span>     * @function
<span id="line19419" class="line"></span>     * @returns {OpenSeadragon.Rect} a duplicate of this Rect
<span id="line19420" class="line"></span>     */
<span id="line19421" class="line"></span>    clone: function() {
<span id="line19422" class="line"></span>        return new $.Rect(
<span id="line19423" class="line"></span>            this.x,
<span id="line19424" class="line"></span>            this.y,
<span id="line19425" class="line"></span>            this.width,
<span id="line19426" class="line"></span>            this.height,
<span id="line19427" class="line"></span>            this.degrees);
<span id="line19428" class="line"></span>    },
<span id="line19429" class="line"></span>
<span id="line19430" class="line"></span>    /**
<span id="line19431" class="line"></span>     * The aspect ratio is simply the ratio of width to height.
<span id="line19432" class="line"></span>     * @function
<span id="line19433" class="line"></span>     * @returns {Number} The ratio of width to height.
<span id="line19434" class="line"></span>     */
<span id="line19435" class="line"></span>    getAspectRatio: function() {
<span id="line19436" class="line"></span>        return this.width / this.height;
<span id="line19437" class="line"></span>    },
<span id="line19438" class="line"></span>
<span id="line19439" class="line"></span>    /**
<span id="line19440" class="line"></span>     * Provides the coordinates of the upper-left corner of the rectangle as a
<span id="line19441" class="line"></span>     * point.
<span id="line19442" class="line"></span>     * @function
<span id="line19443" class="line"></span>     * @returns {OpenSeadragon.Point} The coordinate of the upper-left corner of
<span id="line19444" class="line"></span>     *  the rectangle.
<span id="line19445" class="line"></span>     */
<span id="line19446" class="line"></span>    getTopLeft: function() {
<span id="line19447" class="line"></span>        return new $.Point(
<span id="line19448" class="line"></span>            this.x,
<span id="line19449" class="line"></span>            this.y
<span id="line19450" class="line"></span>        );
<span id="line19451" class="line"></span>    },
<span id="line19452" class="line"></span>
<span id="line19453" class="line"></span>    /**
<span id="line19454" class="line"></span>     * Provides the coordinates of the bottom-right corner of the rectangle as a
<span id="line19455" class="line"></span>     * point.
<span id="line19456" class="line"></span>     * @function
<span id="line19457" class="line"></span>     * @returns {OpenSeadragon.Point} The coordinate of the bottom-right corner of
<span id="line19458" class="line"></span>     *  the rectangle.
<span id="line19459" class="line"></span>     */
<span id="line19460" class="line"></span>    getBottomRight: function() {
<span id="line19461" class="line"></span>        return new $.Point(this.x + this.width, this.y + this.height)
<span id="line19462" class="line"></span>            .rotate(this.degrees, this.getTopLeft());
<span id="line19463" class="line"></span>    },
<span id="line19464" class="line"></span>
<span id="line19465" class="line"></span>    /**
<span id="line19466" class="line"></span>     * Provides the coordinates of the top-right corner of the rectangle as a
<span id="line19467" class="line"></span>     * point.
<span id="line19468" class="line"></span>     * @function
<span id="line19469" class="line"></span>     * @returns {OpenSeadragon.Point} The coordinate of the top-right corner of
<span id="line19470" class="line"></span>     *  the rectangle.
<span id="line19471" class="line"></span>     */
<span id="line19472" class="line"></span>    getTopRight: function() {
<span id="line19473" class="line"></span>        return new $.Point(this.x + this.width, this.y)
<span id="line19474" class="line"></span>            .rotate(this.degrees, this.getTopLeft());
<span id="line19475" class="line"></span>    },
<span id="line19476" class="line"></span>
<span id="line19477" class="line"></span>    /**
<span id="line19478" class="line"></span>     * Provides the coordinates of the bottom-left corner of the rectangle as a
<span id="line19479" class="line"></span>     * point.
<span id="line19480" class="line"></span>     * @function
<span id="line19481" class="line"></span>     * @returns {OpenSeadragon.Point} The coordinate of the bottom-left corner of
<span id="line19482" class="line"></span>     *  the rectangle.
<span id="line19483" class="line"></span>     */
<span id="line19484" class="line"></span>    getBottomLeft: function() {
<span id="line19485" class="line"></span>        return new $.Point(this.x, this.y + this.height)
<span id="line19486" class="line"></span>            .rotate(this.degrees, this.getTopLeft());
<span id="line19487" class="line"></span>    },
<span id="line19488" class="line"></span>
<span id="line19489" class="line"></span>    /**
<span id="line19490" class="line"></span>     * Computes the center of the rectangle.
<span id="line19491" class="line"></span>     * @function
<span id="line19492" class="line"></span>     * @returns {OpenSeadragon.Point} The center of the rectangle as represented
<span id="line19493" class="line"></span>     *  as represented by a 2-dimensional vector (x,y)
<span id="line19494" class="line"></span>     */
<span id="line19495" class="line"></span>    getCenter: function() {
<span id="line19496" class="line"></span>        return new $.Point(
<span id="line19497" class="line"></span>            this.x + this.width / 2.0,
<span id="line19498" class="line"></span>            this.y + this.height / 2.0
<span id="line19499" class="line"></span>        ).rotate(this.degrees, this.getTopLeft());
<span id="line19500" class="line"></span>    },
<span id="line19501" class="line"></span>
<span id="line19502" class="line"></span>    /**
<span id="line19503" class="line"></span>     * Returns the width and height component as a vector OpenSeadragon.Point
<span id="line19504" class="line"></span>     * @function
<span id="line19505" class="line"></span>     * @returns {OpenSeadragon.Point} The 2 dimensional vector representing the
<span id="line19506" class="line"></span>     *  width and height of the rectangle.
<span id="line19507" class="line"></span>     */
<span id="line19508" class="line"></span>    getSize: function() {
<span id="line19509" class="line"></span>        return new $.Point(this.width, this.height);
<span id="line19510" class="line"></span>    },
<span id="line19511" class="line"></span>
<span id="line19512" class="line"></span>    /**
<span id="line19513" class="line"></span>     * Determines if two Rectangles have equivalent components.
<span id="line19514" class="line"></span>     * @function
<span id="line19515" class="line"></span>     * @param {OpenSeadragon.Rect} rectangle The Rectangle to compare to.
<span id="line19516" class="line"></span>     * @returns {Boolean} 'true' if all components are equal, otherwise 'false'.
<span id="line19517" class="line"></span>     */
<span id="line19518" class="line"></span>    equals: function(other) {
<span id="line19519" class="line"></span>        return (other instanceof $.Rect) &amp;&amp;
<span id="line19520" class="line"></span>            this.x === other.x &amp;&amp;
<span id="line19521" class="line"></span>            this.y === other.y &amp;&amp;
<span id="line19522" class="line"></span>            this.width === other.width &amp;&amp;
<span id="line19523" class="line"></span>            this.height === other.height &amp;&amp;
<span id="line19524" class="line"></span>            this.degrees === other.degrees;
<span id="line19525" class="line"></span>    },
<span id="line19526" class="line"></span>
<span id="line19527" class="line"></span>    /**
<span id="line19528" class="line"></span>    * Multiply all dimensions (except degrees) in this Rect by a factor and
<span id="line19529" class="line"></span>    * return a new Rect.
<span id="line19530" class="line"></span>    * @function
<span id="line19531" class="line"></span>    * @param {Number} factor The factor to multiply vector components.
<span id="line19532" class="line"></span>    * @returns {OpenSeadragon.Rect} A new rect representing the multiplication
<span id="line19533" class="line"></span>    *  of the vector components by the factor
<span id="line19534" class="line"></span>    */
<span id="line19535" class="line"></span>    times: function(factor) {
<span id="line19536" class="line"></span>        return new $.Rect(
<span id="line19537" class="line"></span>            this.x * factor,
<span id="line19538" class="line"></span>            this.y * factor,
<span id="line19539" class="line"></span>            this.width * factor,
<span id="line19540" class="line"></span>            this.height * factor,
<span id="line19541" class="line"></span>            this.degrees);
<span id="line19542" class="line"></span>    },
<span id="line19543" class="line"></span>
<span id="line19544" class="line"></span>    /**
<span id="line19545" class="line"></span>    * Translate/move this Rect by a vector and return new Rect.
<span id="line19546" class="line"></span>    * @function
<span id="line19547" class="line"></span>    * @param {OpenSeadragon.Point} delta The translation vector.
<span id="line19548" class="line"></span>    * @returns {OpenSeadragon.Rect} A new rect with altered position
<span id="line19549" class="line"></span>    */
<span id="line19550" class="line"></span>    translate: function(delta) {
<span id="line19551" class="line"></span>        return new $.Rect(
<span id="line19552" class="line"></span>            this.x + delta.x,
<span id="line19553" class="line"></span>            this.y + delta.y,
<span id="line19554" class="line"></span>            this.width,
<span id="line19555" class="line"></span>            this.height,
<span id="line19556" class="line"></span>            this.degrees);
<span id="line19557" class="line"></span>    },
<span id="line19558" class="line"></span>
<span id="line19559" class="line"></span>    /**
<span id="line19560" class="line"></span>     * Returns the smallest rectangle that will contain this and the given
<span id="line19561" class="line"></span>     * rectangle bounding boxes.
<span id="line19562" class="line"></span>     * @param {OpenSeadragon.Rect} rect
<span id="line19563" class="line"></span>     * @returns {OpenSeadragon.Rect} The new rectangle.
<span id="line19564" class="line"></span>     */
<span id="line19565" class="line"></span>    union: function(rect) {
<span id="line19566" class="line"></span>        const thisBoundingBox = this.getBoundingBox();
<span id="line19567" class="line"></span>        const otherBoundingBox = rect.getBoundingBox();
<span id="line19568" class="line"></span>
<span id="line19569" class="line"></span>        const left = Math.min(thisBoundingBox.x, otherBoundingBox.x);
<span id="line19570" class="line"></span>        const top = Math.min(thisBoundingBox.y, otherBoundingBox.y);
<span id="line19571" class="line"></span>        const right = Math.max(
<span id="line19572" class="line"></span>            thisBoundingBox.x + thisBoundingBox.width,
<span id="line19573" class="line"></span>            otherBoundingBox.x + otherBoundingBox.width);
<span id="line19574" class="line"></span>        const bottom = Math.max(
<span id="line19575" class="line"></span>            thisBoundingBox.y + thisBoundingBox.height,
<span id="line19576" class="line"></span>            otherBoundingBox.y + otherBoundingBox.height);
<span id="line19577" class="line"></span>
<span id="line19578" class="line"></span>        return new $.Rect(
<span id="line19579" class="line"></span>            left,
<span id="line19580" class="line"></span>            top,
<span id="line19581" class="line"></span>            right - left,
<span id="line19582" class="line"></span>            bottom - top);
<span id="line19583" class="line"></span>    },
<span id="line19584" class="line"></span>
<span id="line19585" class="line"></span>    /**
<span id="line19586" class="line"></span>     * Returns the bounding box of the intersection of this rectangle with the
<span id="line19587" class="line"></span>     * given rectangle.
<span id="line19588" class="line"></span>     * @param {OpenSeadragon.Rect} rect
<span id="line19589" class="line"></span>     * @returns {OpenSeadragon.Rect} the bounding box of the intersection
<span id="line19590" class="line"></span>     * or null if the rectangles don't intersect.
<span id="line19591" class="line"></span>     */
<span id="line19592" class="line"></span>    intersection: function(rect) {
<span id="line19593" class="line"></span>        // Simplified version of Weiler Atherton clipping algorithm
<span id="line19594" class="line"></span>        // https://en.wikipedia.org/wiki/Weiler%E2%80%93Atherton_clipping_algorithm
<span id="line19595" class="line"></span>        // Because we just want the bounding box of the intersection,
<span id="line19596" class="line"></span>        // we can just compute the bounding box of:
<span id="line19597" class="line"></span>        // 1. all the summits of this which are inside rect
<span id="line19598" class="line"></span>        // 2. all the summits of rect which are inside this
<span id="line19599" class="line"></span>        // 3. all the intersections of rect and this
<span id="line19600" class="line"></span>        const EPSILON = 0.0000000001;
<span id="line19601" class="line"></span>
<span id="line19602" class="line"></span>        const intersectionPoints = [];
<span id="line19603" class="line"></span>
<span id="line19604" class="line"></span>        const thisTopLeft = this.getTopLeft();
<span id="line19605" class="line"></span>        if (rect.containsPoint(thisTopLeft, EPSILON)) {
<span id="line19606" class="line"></span>            intersectionPoints.push(thisTopLeft);
<span id="line19607" class="line"></span>        }
<span id="line19608" class="line"></span>        const thisTopRight = this.getTopRight();
<span id="line19609" class="line"></span>        if (rect.containsPoint(thisTopRight, EPSILON)) {
<span id="line19610" class="line"></span>            intersectionPoints.push(thisTopRight);
<span id="line19611" class="line"></span>        }
<span id="line19612" class="line"></span>        const thisBottomLeft = this.getBottomLeft();
<span id="line19613" class="line"></span>        if (rect.containsPoint(thisBottomLeft, EPSILON)) {
<span id="line19614" class="line"></span>            intersectionPoints.push(thisBottomLeft);
<span id="line19615" class="line"></span>        }
<span id="line19616" class="line"></span>        const thisBottomRight = this.getBottomRight();
<span id="line19617" class="line"></span>        if (rect.containsPoint(thisBottomRight, EPSILON)) {
<span id="line19618" class="line"></span>            intersectionPoints.push(thisBottomRight);
<span id="line19619" class="line"></span>        }
<span id="line19620" class="line"></span>
<span id="line19621" class="line"></span>        const rectTopLeft = rect.getTopLeft();
<span id="line19622" class="line"></span>        if (this.containsPoint(rectTopLeft, EPSILON)) {
<span id="line19623" class="line"></span>            intersectionPoints.push(rectTopLeft);
<span id="line19624" class="line"></span>        }
<span id="line19625" class="line"></span>        const rectTopRight = rect.getTopRight();
<span id="line19626" class="line"></span>        if (this.containsPoint(rectTopRight, EPSILON)) {
<span id="line19627" class="line"></span>            intersectionPoints.push(rectTopRight);
<span id="line19628" class="line"></span>        }
<span id="line19629" class="line"></span>        const rectBottomLeft = rect.getBottomLeft();
<span id="line19630" class="line"></span>        if (this.containsPoint(rectBottomLeft, EPSILON)) {
<span id="line19631" class="line"></span>            intersectionPoints.push(rectBottomLeft);
<span id="line19632" class="line"></span>        }
<span id="line19633" class="line"></span>        const rectBottomRight = rect.getBottomRight();
<span id="line19634" class="line"></span>        if (this.containsPoint(rectBottomRight, EPSILON)) {
<span id="line19635" class="line"></span>            intersectionPoints.push(rectBottomRight);
<span id="line19636" class="line"></span>        }
<span id="line19637" class="line"></span>
<span id="line19638" class="line"></span>        const thisSegments = this._getSegments();
<span id="line19639" class="line"></span>        const rectSegments = rect._getSegments();
<span id="line19640" class="line"></span>        for (let i = 0; i &lt; thisSegments.length; i++) {
<span id="line19641" class="line"></span>            const thisSegment = thisSegments[i];
<span id="line19642" class="line"></span>            for (let j = 0; j &lt; rectSegments.length; j++) {
<span id="line19643" class="line"></span>                const rectSegment = rectSegments[j];
<span id="line19644" class="line"></span>                const intersect = getIntersection(thisSegment[0], thisSegment[1],
<span id="line19645" class="line"></span>                    rectSegment[0], rectSegment[1]);
<span id="line19646" class="line"></span>                if (intersect) {
<span id="line19647" class="line"></span>                    intersectionPoints.push(intersect);
<span id="line19648" class="line"></span>                }
<span id="line19649" class="line"></span>            }
<span id="line19650" class="line"></span>        }
<span id="line19651" class="line"></span>
<span id="line19652" class="line"></span>        // Get intersection point of segments [a,b] and [c,d]
<span id="line19653" class="line"></span>        function getIntersection(a, b, c, d) {
<span id="line19654" class="line"></span>            // http://stackoverflow.com/a/1968345/1440403
<span id="line19655" class="line"></span>            const abVector = b.minus(a);
<span id="line19656" class="line"></span>            const cdVector = d.minus(c);
<span id="line19657" class="line"></span>
<span id="line19658" class="line"></span>            const denom = -cdVector.x * abVector.y + abVector.x * cdVector.y;
<span id="line19659" class="line"></span>            if (denom === 0) {
<span id="line19660" class="line"></span>                return null;
<span id="line19661" class="line"></span>            }
<span id="line19662" class="line"></span>
<span id="line19663" class="line"></span>            const s = (abVector.x * (a.y - c.y) - abVector.y * (a.x - c.x)) / denom;
<span id="line19664" class="line"></span>            const t = (cdVector.x * (a.y - c.y) - cdVector.y * (a.x - c.x)) / denom;
<span id="line19665" class="line"></span>
<span id="line19666" class="line"></span>            if (-EPSILON &lt;= s &amp;&amp; s &lt;= 1 - EPSILON &amp;&amp;
<span id="line19667" class="line"></span>                -EPSILON &lt;= t &amp;&amp; t &lt;= 1 - EPSILON) {
<span id="line19668" class="line"></span>                return new $.Point(a.x + t * abVector.x, a.y + t * abVector.y);
<span id="line19669" class="line"></span>            }
<span id="line19670" class="line"></span>            return null;
<span id="line19671" class="line"></span>        }
<span id="line19672" class="line"></span>
<span id="line19673" class="line"></span>        if (intersectionPoints.length === 0) {
<span id="line19674" class="line"></span>            return null;
<span id="line19675" class="line"></span>        }
<span id="line19676" class="line"></span>
<span id="line19677" class="line"></span>        let minX = intersectionPoints[0].x;
<span id="line19678" class="line"></span>        let maxX = intersectionPoints[0].x;
<span id="line19679" class="line"></span>        let minY = intersectionPoints[0].y;
<span id="line19680" class="line"></span>        let maxY = intersectionPoints[0].y;
<span id="line19681" class="line"></span>        for (let k = 1; k &lt; intersectionPoints.length; k++) {
<span id="line19682" class="line"></span>            const point = intersectionPoints[k];
<span id="line19683" class="line"></span>            if (point.x &lt; minX) {
<span id="line19684" class="line"></span>                minX = point.x;
<span id="line19685" class="line"></span>            }
<span id="line19686" class="line"></span>            if (point.x &gt; maxX) {
<span id="line19687" class="line"></span>                maxX = point.x;
<span id="line19688" class="line"></span>            }
<span id="line19689" class="line"></span>            if (point.y &lt; minY) {
<span id="line19690" class="line"></span>                minY = point.y;
<span id="line19691" class="line"></span>            }
<span id="line19692" class="line"></span>            if (point.y &gt; maxY) {
<span id="line19693" class="line"></span>                maxY = point.y;
<span id="line19694" class="line"></span>            }
<span id="line19695" class="line"></span>        }
<span id="line19696" class="line"></span>        return new $.Rect(minX, minY, maxX - minX, maxY - minY);
<span id="line19697" class="line"></span>    },
<span id="line19698" class="line"></span>
<span id="line19699" class="line"></span>    // private
<span id="line19700" class="line"></span>    _getSegments: function() {
<span id="line19701" class="line"></span>        const topLeft = this.getTopLeft();
<span id="line19702" class="line"></span>        const topRight = this.getTopRight();
<span id="line19703" class="line"></span>        const bottomLeft = this.getBottomLeft();
<span id="line19704" class="line"></span>        const bottomRight = this.getBottomRight();
<span id="line19705" class="line"></span>        return [[topLeft, topRight],
<span id="line19706" class="line"></span>            [topRight, bottomRight],
<span id="line19707" class="line"></span>            [bottomRight, bottomLeft],
<span id="line19708" class="line"></span>            [bottomLeft, topLeft]];
<span id="line19709" class="line"></span>    },
<span id="line19710" class="line"></span>
<span id="line19711" class="line"></span>    /**
<span id="line19712" class="line"></span>     * Rotates a rectangle around a point.
<span id="line19713" class="line"></span>     * @function
<span id="line19714" class="line"></span>     * @param {Number} degrees The angle in degrees to rotate.
<span id="line19715" class="line"></span>     * @param {OpenSeadragon.Point} [pivot] The point about which to rotate.
<span id="line19716" class="line"></span>     * Defaults to the center of the rectangle.
<span id="line19717" class="line"></span>     * @returns {OpenSeadragon.Rect}
<span id="line19718" class="line"></span>     */
<span id="line19719" class="line"></span>    rotate: function(degrees, pivot) {
<span id="line19720" class="line"></span>        degrees = $.positiveModulo(degrees, 360);
<span id="line19721" class="line"></span>        if (degrees === 0) {
<span id="line19722" class="line"></span>            return this.clone();
<span id="line19723" class="line"></span>        }
<span id="line19724" class="line"></span>
<span id="line19725" class="line"></span>        pivot = pivot || this.getCenter();
<span id="line19726" class="line"></span>        const newTopLeft = this.getTopLeft().rotate(degrees, pivot);
<span id="line19727" class="line"></span>        const newTopRight = this.getTopRight().rotate(degrees, pivot);
<span id="line19728" class="line"></span>
<span id="line19729" class="line"></span>        let diff = newTopRight.minus(newTopLeft);
<span id="line19730" class="line"></span>        // Handle floating point error
<span id="line19731" class="line"></span>        diff = diff.apply(function(x) {
<span id="line19732" class="line"></span>            const EPSILON = 1e-15;
<span id="line19733" class="line"></span>            return Math.abs(x) &lt; EPSILON ? 0 : x;
<span id="line19734" class="line"></span>        });
<span id="line19735" class="line"></span>        let radians = Math.atan(diff.y / diff.x);
<span id="line19736" class="line"></span>        if (diff.x &lt; 0) {
<span id="line19737" class="line"></span>            radians += Math.PI;
<span id="line19738" class="line"></span>        } else if (diff.y &lt; 0) {
<span id="line19739" class="line"></span>            radians += 2 * Math.PI;
<span id="line19740" class="line"></span>        }
<span id="line19741" class="line"></span>        return new $.Rect(
<span id="line19742" class="line"></span>            newTopLeft.x,
<span id="line19743" class="line"></span>            newTopLeft.y,
<span id="line19744" class="line"></span>            this.width,
<span id="line19745" class="line"></span>            this.height,
<span id="line19746" class="line"></span>            radians / Math.PI * 180);
<span id="line19747" class="line"></span>    },
<span id="line19748" class="line"></span>
<span id="line19749" class="line"></span>    /**
<span id="line19750" class="line"></span>     * Retrieves the smallest horizontal (degrees=0) rectangle which contains
<span id="line19751" class="line"></span>     * this rectangle.
<span id="line19752" class="line"></span>     * @returns {OpenSeadragon.Rect}
<span id="line19753" class="line"></span>     */
<span id="line19754" class="line"></span>    getBoundingBox: function() {
<span id="line19755" class="line"></span>        if (this.degrees === 0) {
<span id="line19756" class="line"></span>            return this.clone();
<span id="line19757" class="line"></span>        }
<span id="line19758" class="line"></span>        const topLeft = this.getTopLeft();
<span id="line19759" class="line"></span>        const topRight = this.getTopRight();
<span id="line19760" class="line"></span>        const bottomLeft = this.getBottomLeft();
<span id="line19761" class="line"></span>        const bottomRight = this.getBottomRight();
<span id="line19762" class="line"></span>        const minX = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
<span id="line19763" class="line"></span>        const maxX = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
<span id="line19764" class="line"></span>        const minY = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
<span id="line19765" class="line"></span>        const maxY = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
<span id="line19766" class="line"></span>        return new $.Rect(
<span id="line19767" class="line"></span>            minX,
<span id="line19768" class="line"></span>            minY,
<span id="line19769" class="line"></span>            maxX - minX,
<span id="line19770" class="line"></span>            maxY - minY);
<span id="line19771" class="line"></span>    },
<span id="line19772" class="line"></span>
<span id="line19773" class="line"></span>    /**
<span id="line19774" class="line"></span>     * Retrieves the smallest horizontal (degrees=0) rectangle which contains
<span id="line19775" class="line"></span>     * this rectangle and has integers x, y, width and height
<span id="line19776" class="line"></span>     * @returns {OpenSeadragon.Rect}
<span id="line19777" class="line"></span>     */
<span id="line19778" class="line"></span>    getIntegerBoundingBox: function() {
<span id="line19779" class="line"></span>        const boundingBox = this.getBoundingBox();
<span id="line19780" class="line"></span>        const x = Math.floor(boundingBox.x);
<span id="line19781" class="line"></span>        const y = Math.floor(boundingBox.y);
<span id="line19782" class="line"></span>        const width = Math.ceil(boundingBox.width + boundingBox.x - x);
<span id="line19783" class="line"></span>        const height = Math.ceil(boundingBox.height + boundingBox.y - y);
<span id="line19784" class="line"></span>        return new $.Rect(x, y, width, height);
<span id="line19785" class="line"></span>    },
<span id="line19786" class="line"></span>
<span id="line19787" class="line"></span>    /**
<span id="line19788" class="line"></span>     * Determines whether a point is inside this rectangle (edge included).
<span id="line19789" class="line"></span>     * @function
<span id="line19790" class="line"></span>     * @param {OpenSeadragon.Point} point
<span id="line19791" class="line"></span>     * @param {Number} [epsilon=0] the margin of error allowed
<span id="line19792" class="line"></span>     * @returns {Boolean} true if the point is inside this rectangle, false
<span id="line19793" class="line"></span>     * otherwise.
<span id="line19794" class="line"></span>     */
<span id="line19795" class="line"></span>    containsPoint: function(point, epsilon) {
<span id="line19796" class="line"></span>        epsilon = epsilon || 0;
<span id="line19797" class="line"></span>
<span id="line19798" class="line"></span>        // See http://stackoverflow.com/a/2752754/1440403 for explanation
<span id="line19799" class="line"></span>        const topLeft = this.getTopLeft();
<span id="line19800" class="line"></span>        const topRight = this.getTopRight();
<span id="line19801" class="line"></span>        const bottomLeft = this.getBottomLeft();
<span id="line19802" class="line"></span>        const topDiff = topRight.minus(topLeft);
<span id="line19803" class="line"></span>        const leftDiff = bottomLeft.minus(topLeft);
<span id="line19804" class="line"></span>
<span id="line19805" class="line"></span>        return ((point.x - topLeft.x) * topDiff.x +
<span id="line19806" class="line"></span>            (point.y - topLeft.y) * topDiff.y &gt;= -epsilon) &amp;&amp;
<span id="line19807" class="line"></span>
<span id="line19808" class="line"></span>            ((point.x - topRight.x) * topDiff.x +
<span id="line19809" class="line"></span>            (point.y - topRight.y) * topDiff.y &lt;= epsilon) &amp;&amp;
<span id="line19810" class="line"></span>
<span id="line19811" class="line"></span>            ((point.x - topLeft.x) * leftDiff.x +
<span id="line19812" class="line"></span>            (point.y - topLeft.y) * leftDiff.y &gt;= -epsilon) &amp;&amp;
<span id="line19813" class="line"></span>
<span id="line19814" class="line"></span>            ((point.x - bottomLeft.x) * leftDiff.x +
<span id="line19815" class="line"></span>            (point.y - bottomLeft.y) * leftDiff.y &lt;= epsilon);
<span id="line19816" class="line"></span>    },
<span id="line19817" class="line"></span>
<span id="line19818" class="line"></span>    /**
<span id="line19819" class="line"></span>     * Provides a string representation of the rectangle which is useful for
<span id="line19820" class="line"></span>     * debugging.
<span id="line19821" class="line"></span>     * @function
<span id="line19822" class="line"></span>     * @returns {String} A string representation of the rectangle.
<span id="line19823" class="line"></span>     */
<span id="line19824" class="line"></span>    toString: function() {
<span id="line19825" class="line"></span>        return "[" +
<span id="line19826" class="line"></span>            (Math.round(this.x * 100) / 100) + ", " +
<span id="line19827" class="line"></span>            (Math.round(this.y * 100) / 100) + ", " +
<span id="line19828" class="line"></span>            (Math.round(this.width * 100) / 100) + "x" +
<span id="line19829" class="line"></span>            (Math.round(this.height * 100) / 100) + ", " +
<span id="line19830" class="line"></span>            (Math.round(this.degrees * 100) / 100) + "deg" +
<span id="line19831" class="line"></span>            "]";
<span id="line19832" class="line"></span>    }
<span id="line19833" class="line"></span>};
<span id="line19834" class="line"></span>
<span id="line19835" class="line"></span>
<span id="line19836" class="line"></span>}(OpenSeadragon));
<span id="line19837" class="line"></span>
<span id="line19838" class="line"></span>/*
<span id="line19839" class="line"></span> * OpenSeadragon - ReferenceStrip
<span id="line19840" class="line"></span> *
<span id="line19841" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line19842" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line19843" class="line"></span> *
<span id="line19844" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line19845" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line19846" class="line"></span> * met:
<span id="line19847" class="line"></span> *
<span id="line19848" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line19849" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line19850" class="line"></span> *
<span id="line19851" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line19852" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line19853" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line19854" class="line"></span> *
<span id="line19855" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line19856" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line19857" class="line"></span> *   this software without specific prior written permission.
<span id="line19858" class="line"></span> *
<span id="line19859" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line19860" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line19861" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line19862" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line19863" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line19864" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line19865" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line19866" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line19867" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line19868" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line19869" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line19870" class="line"></span> */
<span id="line19871" class="line"></span>
<span id="line19872" class="line"></span>(function ( $ ) {
<span id="line19873" class="line"></span>
<span id="line19874" class="line"></span>// dictionary from id to private properties
<span id="line19875" class="line"></span>const THIS = {};
<span id="line19876" class="line"></span>
<span id="line19877" class="line"></span>/**
<span id="line19878" class="line"></span> *  The CollectionDrawer is a reimplementation if the Drawer API that
<span id="line19879" class="line"></span> *  focuses on allowing a viewport to be redefined as a collection
<span id="line19880" class="line"></span> *  of smaller viewports, defined by a clear number of rows and / or
<span id="line19881" class="line"></span> *  columns of which each item in the matrix of viewports has its own
<span id="line19882" class="line"></span> *  source.
<span id="line19883" class="line"></span> *
<span id="line19884" class="line"></span> *  This idea is a reexpression of the idea of dzi collections
<span id="line19885" class="line"></span> *  which allows a clearer algorithm to reuse the tile sources already
<span id="line19886" class="line"></span> *  supported by OpenSeadragon, in heterogeneous or homogeneous
<span id="line19887" class="line"></span> *  sequences just like mixed groups already supported by the viewer
<span id="line19888" class="line"></span> *  for the purpose of image sequnces.
<span id="line19889" class="line"></span> *
<span id="line19890" class="line"></span> *  TODO:   The difficult part of this feature is figuring out how to express
<span id="line19891" class="line"></span> *          this functionality as a combination of the functionality already
<span id="line19892" class="line"></span> *          provided by Drawer, Viewport, TileSource, and Navigator.  It may
<span id="line19893" class="line"></span> *          require better abstraction at those points in order to efficiently
<span id="line19894" class="line"></span> *          reuse those paradigms.
<span id="line19895" class="line"></span> */
<span id="line19896" class="line"></span>/**
<span id="line19897" class="line"></span> * @class ReferenceStrip
<span id="line19898" class="line"></span> * @memberof OpenSeadragon
<span id="line19899" class="line"></span> * @param {Object} options
<span id="line19900" class="line"></span> */
<span id="line19901" class="line"></span>$.ReferenceStrip = function ( options ) {
<span id="line19902" class="line"></span>
<span id="line19903" class="line"></span>    const _this       = this;
<span id="line19904" class="line"></span>    const viewer      = options.viewer;
<span id="line19905" class="line"></span>    const viewerSize  = $.getElementSize( viewer.element );
<span id="line19906" class="line"></span>    let element;
<span id="line19907" class="line"></span>    let i;
<span id="line19908" class="line"></span>
<span id="line19909" class="line"></span>    //We may need to create a new element and id if they did not
<span id="line19910" class="line"></span>    //provide the id for the existing element
<span id="line19911" class="line"></span>    if ( !options.id ) {
<span id="line19912" class="line"></span>        options.id              = 'referencestrip-' + $.now();
<span id="line19913" class="line"></span>        this.element            = $.makeNeutralElement( "div" );
<span id="line19914" class="line"></span>        this.element.id         = options.id;
<span id="line19915" class="line"></span>        this.element.className  = 'referencestrip';
<span id="line19916" class="line"></span>    }
<span id="line19917" class="line"></span>
<span id="line19918" class="line"></span>    options = $.extend( true, {
<span id="line19919" class="line"></span>        sizeRatio:  $.DEFAULT_SETTINGS.referenceStripSizeRatio,
<span id="line19920" class="line"></span>        position:   $.DEFAULT_SETTINGS.referenceStripPosition,
<span id="line19921" class="line"></span>        scroll:     $.DEFAULT_SETTINGS.referenceStripScroll,
<span id="line19922" class="line"></span>        clickTimeThreshold:  $.DEFAULT_SETTINGS.clickTimeThreshold
<span id="line19923" class="line"></span>    }, options, {
<span id="line19924" class="line"></span>        element:                this.element
<span id="line19925" class="line"></span>    } );
<span id="line19926" class="line"></span>
<span id="line19927" class="line"></span>    $.extend( this, options );
<span id="line19928" class="line"></span>    //Private state properties
<span id="line19929" class="line"></span>    THIS[this.id] = {
<span id="line19930" class="line"></span>        animating:           false
<span id="line19931" class="line"></span>    };
<span id="line19932" class="line"></span>
<span id="line19933" class="line"></span>    this.minPixelRatio = this.viewer.minPixelRatio;
<span id="line19934" class="line"></span>
<span id="line19935" class="line"></span>    this.element.tabIndex = 0;
<span id="line19936" class="line"></span>
<span id="line19937" class="line"></span>    const style = this.element.style;
<span id="line19938" class="line"></span>    style.marginTop     = '0px';
<span id="line19939" class="line"></span>    style.marginRight   = '0px';
<span id="line19940" class="line"></span>    style.marginBottom  = '0px';
<span id="line19941" class="line"></span>    style.marginLeft    = '0px';
<span id="line19942" class="line"></span>    style.left          = '0px';
<span id="line19943" class="line"></span>    style.bottom        = '0px';
<span id="line19944" class="line"></span>    style.border        = '0px';
<span id="line19945" class="line"></span>    style.background    = '#000';
<span id="line19946" class="line"></span>    style.position      = 'relative';
<span id="line19947" class="line"></span>
<span id="line19948" class="line"></span>    $.setElementTouchActionNone( this.element );
<span id="line19949" class="line"></span>
<span id="line19950" class="line"></span>    $.setElementOpacity( this.element, 0.8 );
<span id="line19951" class="line"></span>
<span id="line19952" class="line"></span>    this.viewer = viewer;
<span id="line19953" class="line"></span>    this.tracker = new $.MouseTracker( {
<span id="line19954" class="line"></span>        userData:       'ReferenceStrip.tracker',
<span id="line19955" class="line"></span>        element:        this.element,
<span id="line19956" class="line"></span>        clickHandler:   $.delegate( this, onStripClick ),
<span id="line19957" class="line"></span>        dragHandler:    $.delegate( this, onStripDrag ),
<span id="line19958" class="line"></span>        scrollHandler:  $.delegate( this, onStripScroll ),
<span id="line19959" class="line"></span>        enterHandler:   $.delegate( this, onStripEnter ),
<span id="line19960" class="line"></span>        leaveHandler:   $.delegate( this, onStripLeave ),
<span id="line19961" class="line"></span>        keyDownHandler: $.delegate( this, onKeyDown ),
<span id="line19962" class="line"></span>        keyHandler:     $.delegate( this, onKeyPress ),
<span id="line19963" class="line"></span>        preProcessEventHandler: function (eventInfo) {
<span id="line19964" class="line"></span>            if (eventInfo.eventType === 'wheel') {
<span id="line19965" class="line"></span>                eventInfo.preventDefault = true;
<span id="line19966" class="line"></span>            }
<span id="line19967" class="line"></span>        }
<span id="line19968" class="line"></span>    } );
<span id="line19969" class="line"></span>
<span id="line19970" class="line"></span>    //Controls the position and orientation of the reference strip and sets the
<span id="line19971" class="line"></span>    //appropriate width and height
<span id="line19972" class="line"></span>    if ( options.width &amp;&amp; options.height ) {
<span id="line19973" class="line"></span>        this.element.style.width  = options.width + 'px';
<span id="line19974" class="line"></span>        this.element.style.height = options.height + 'px';
<span id="line19975" class="line"></span>        viewer.addControl(
<span id="line19976" class="line"></span>            this.element,
<span id="line19977" class="line"></span>            { anchor: $.ControlAnchor.BOTTOM_LEFT }
<span id="line19978" class="line"></span>        );
<span id="line19979" class="line"></span>    } else {
<span id="line19980" class="line"></span>        if ( "horizontal" === options.scroll ) {
<span id="line19981" class="line"></span>            this.element.style.width = (
<span id="line19982" class="line"></span>                viewerSize.x *
<span id="line19983" class="line"></span>                options.sizeRatio *
<span id="line19984" class="line"></span>                viewer.tileSources.length
<span id="line19985" class="line"></span>            ) + ( 12 * viewer.tileSources.length ) + 'px';
<span id="line19986" class="line"></span>
<span id="line19987" class="line"></span>            this.element.style.height = (
<span id="line19988" class="line"></span>                viewerSize.y *
<span id="line19989" class="line"></span>                options.sizeRatio
<span id="line19990" class="line"></span>            ) + 'px';
<span id="line19991" class="line"></span>
<span id="line19992" class="line"></span>            viewer.addControl(
<span id="line19993" class="line"></span>                this.element,
<span id="line19994" class="line"></span>                { anchor: $.ControlAnchor.BOTTOM_LEFT }
<span id="line19995" class="line"></span>            );
<span id="line19996" class="line"></span>        } else {
<span id="line19997" class="line"></span>            this.element.style.height = (
<span id="line19998" class="line"></span>                viewerSize.y *
<span id="line19999" class="line"></span>                options.sizeRatio *
<span id="line20000" class="line"></span>                viewer.tileSources.length
<span id="line20001" class="line"></span>            ) + ( 12 * viewer.tileSources.length ) + 'px';
<span id="line20002" class="line"></span>
<span id="line20003" class="line"></span>            this.element.style.width = (
<span id="line20004" class="line"></span>                viewerSize.x *
<span id="line20005" class="line"></span>                options.sizeRatio
<span id="line20006" class="line"></span>            ) + 'px';
<span id="line20007" class="line"></span>
<span id="line20008" class="line"></span>            viewer.addControl(
<span id="line20009" class="line"></span>                this.element,
<span id="line20010" class="line"></span>                { anchor: $.ControlAnchor.TOP_LEFT }
<span id="line20011" class="line"></span>            );
<span id="line20012" class="line"></span>
<span id="line20013" class="line"></span>        }
<span id="line20014" class="line"></span>    }
<span id="line20015" class="line"></span>
<span id="line20016" class="line"></span>    this.panelWidth = ( viewerSize.x * this.sizeRatio ) + 8;
<span id="line20017" class="line"></span>    this.panelHeight = ( viewerSize.y * this.sizeRatio ) + 8;
<span id="line20018" class="line"></span>    this.panels = [];
<span id="line20019" class="line"></span>    this.miniViewers = {};
<span id="line20020" class="line"></span>
<span id="line20021" class="line"></span>    /*jshint loopfunc:true*/
<span id="line20022" class="line"></span>    for ( i = 0; i &lt; viewer.tileSources.length; i++ ) {
<span id="line20023" class="line"></span>
<span id="line20024" class="line"></span>        element = $.makeNeutralElement( 'div' );
<span id="line20025" class="line"></span>        element.id = this.element.id + "-" + i;
<span id="line20026" class="line"></span>
<span id="line20027" class="line"></span>        element.style.width         = _this.panelWidth + 'px';
<span id="line20028" class="line"></span>        element.style.height        = _this.panelHeight + 'px';
<span id="line20029" class="line"></span>        element.style.display       = 'inline';
<span id="line20030" class="line"></span>        element.style['float']      = 'left'; //Webkit
<span id="line20031" class="line"></span>        element.style.cssFloat      = 'left'; //Firefox
<span id="line20032" class="line"></span>        element.style.padding       = '2px';
<span id="line20033" class="line"></span>        $.setElementTouchActionNone( element );
<span id="line20034" class="line"></span>        $.setElementPointerEventsNone( element );
<span id="line20035" class="line"></span>
<span id="line20036" class="line"></span>        this.element.appendChild( element );
<span id="line20037" class="line"></span>
<span id="line20038" class="line"></span>        element.activePanel = false;
<span id="line20039" class="line"></span>
<span id="line20040" class="line"></span>        this.panels.push( element );
<span id="line20041" class="line"></span>
<span id="line20042" class="line"></span>    }
<span id="line20043" class="line"></span>    loadPanels( this, this.scroll === 'vertical' ? viewerSize.y : viewerSize.x, 0 );
<span id="line20044" class="line"></span>    this.setFocus( 0 );
<span id="line20045" class="line"></span>
<span id="line20046" class="line"></span>};
<span id="line20047" class="line"></span>
<span id="line20048" class="line"></span>/** @lends OpenSeadragon.ReferenceStrip.prototype */
<span id="line20049" class="line"></span>$.ReferenceStrip.prototype = {
<span id="line20050" class="line"></span>
<span id="line20051" class="line"></span>    /**
<span id="line20052" class="line"></span>     * @function
<span id="line20053" class="line"></span>     */
<span id="line20054" class="line"></span>    setFocus: function ( page ) {
<span id="line20055" class="line"></span>        const element      = this.element.querySelector('#' + this.element.id + '-' + page );
<span id="line20056" class="line"></span>        const viewerSize   = $.getElementSize( this.viewer.canvas );
<span id="line20057" class="line"></span>        const scrollWidth  = Number( this.element.style.width.replace( 'px', '' ) );
<span id="line20058" class="line"></span>        const scrollHeight = Number( this.element.style.height.replace( 'px', '' ) );
<span id="line20059" class="line"></span>        const offsetLeft   = -Number( this.element.style.marginLeft.replace( 'px', '' ) );
<span id="line20060" class="line"></span>        const offsetTop    = -Number( this.element.style.marginTop.replace( 'px', '' ) );
<span id="line20061" class="line"></span>        let offset;
<span id="line20062" class="line"></span>
<span id="line20063" class="line"></span>        if ( this.currentSelected !== element ) {
<span id="line20064" class="line"></span>            if ( this.currentSelected ) {
<span id="line20065" class="line"></span>                this.currentSelected.style.background = '#000';
<span id="line20066" class="line"></span>            }
<span id="line20067" class="line"></span>            this.currentSelected = element;
<span id="line20068" class="line"></span>            this.currentSelected.style.background = '#999';
<span id="line20069" class="line"></span>
<span id="line20070" class="line"></span>            if ( 'horizontal' === this.scroll ) {
<span id="line20071" class="line"></span>                //right left
<span id="line20072" class="line"></span>                offset = ( Number( page ) ) * ( this.panelWidth + 3 );
<span id="line20073" class="line"></span>                if ( offset &gt; offsetLeft + viewerSize.x - this.panelWidth ) {
<span id="line20074" class="line"></span>                    offset = Math.min( offset, ( scrollWidth - viewerSize.x ) );
<span id="line20075" class="line"></span>                    this.element.style.marginLeft = -offset + 'px';
<span id="line20076" class="line"></span>                    loadPanels( this, viewerSize.x, -offset );
<span id="line20077" class="line"></span>                } else if ( offset &lt; offsetLeft ) {
<span id="line20078" class="line"></span>                    offset = Math.max( 0, offset - viewerSize.x / 2 );
<span id="line20079" class="line"></span>                    this.element.style.marginLeft = -offset + 'px';
<span id="line20080" class="line"></span>                    loadPanels( this, viewerSize.x, -offset );
<span id="line20081" class="line"></span>                }
<span id="line20082" class="line"></span>            } else {
<span id="line20083" class="line"></span>                offset = ( Number( page ) ) * ( this.panelHeight + 3 );
<span id="line20084" class="line"></span>                if ( offset &gt; offsetTop + viewerSize.y - this.panelHeight ) {
<span id="line20085" class="line"></span>                    offset = Math.min( offset, ( scrollHeight - viewerSize.y ) );
<span id="line20086" class="line"></span>                    this.element.style.marginTop = -offset + 'px';
<span id="line20087" class="line"></span>                    loadPanels( this, viewerSize.y, -offset );
<span id="line20088" class="line"></span>                } else if ( offset &lt; offsetTop ) {
<span id="line20089" class="line"></span>                    offset = Math.max( 0, offset - viewerSize.y / 2 );
<span id="line20090" class="line"></span>                    this.element.style.marginTop = -offset + 'px';
<span id="line20091" class="line"></span>                    loadPanels( this, viewerSize.y, -offset );
<span id="line20092" class="line"></span>                }
<span id="line20093" class="line"></span>            }
<span id="line20094" class="line"></span>
<span id="line20095" class="line"></span>            this.currentPage = page;
<span id="line20096" class="line"></span>            onStripEnter.call( this, { eventSource: this.tracker } );
<span id="line20097" class="line"></span>        }
<span id="line20098" class="line"></span>    },
<span id="line20099" class="line"></span>
<span id="line20100" class="line"></span>    /**
<span id="line20101" class="line"></span>     * @function
<span id="line20102" class="line"></span>     */
<span id="line20103" class="line"></span>    update: function () {
<span id="line20104" class="line"></span>        if ( THIS[this.id].animating ) {
<span id="line20105" class="line"></span>            // $.console.log( 'image reference strip update' );
<span id="line20106" class="line"></span>            return true;
<span id="line20107" class="line"></span>        }
<span id="line20108" class="line"></span>        return false;
<span id="line20109" class="line"></span>    },
<span id="line20110" class="line"></span>
<span id="line20111" class="line"></span>    destroy: function() {
<span id="line20112" class="line"></span>        if (this.miniViewers) {
<span id="line20113" class="line"></span>          for (const key in this.miniViewers) {
<span id="line20114" class="line"></span>            this.miniViewers[key].destroy();
<span id="line20115" class="line"></span>          }
<span id="line20116" class="line"></span>        }
<span id="line20117" class="line"></span>
<span id="line20118" class="line"></span>        this.tracker.destroy();
<span id="line20119" class="line"></span>
<span id="line20120" class="line"></span>        if (this.element) {
<span id="line20121" class="line"></span>            this.viewer.removeControl( this.element );
<span id="line20122" class="line"></span>        }
<span id="line20123" class="line"></span>    }
<span id="line20124" class="line"></span>
<span id="line20125" class="line"></span>};
<span id="line20126" class="line"></span>
<span id="line20127" class="line"></span>
<span id="line20128" class="line"></span>/**
<span id="line20129" class="line"></span> * @private
<span id="line20130" class="line"></span> * @inner
<span id="line20131" class="line"></span> * @function
<span id="line20132" class="line"></span> */
<span id="line20133" class="line"></span>function onStripClick( event ) {
<span id="line20134" class="line"></span>    if ( event.quick ) {
<span id="line20135" class="line"></span>        let page;
<span id="line20136" class="line"></span>
<span id="line20137" class="line"></span>        if ( 'horizontal' === this.scroll ) {
<span id="line20138" class="line"></span>            // +4px fix to solve problem with precision on thumbnail selection if there is a lot of them
<span id="line20139" class="line"></span>            page = Math.floor(event.position.x / (this.panelWidth + 4));
<span id="line20140" class="line"></span>        } else {
<span id="line20141" class="line"></span>            page = Math.floor(event.position.y / this.panelHeight);
<span id="line20142" class="line"></span>        }
<span id="line20143" class="line"></span>
<span id="line20144" class="line"></span>        this.viewer.goToPage( page );
<span id="line20145" class="line"></span>    }
<span id="line20146" class="line"></span>
<span id="line20147" class="line"></span>    this.element.focus();
<span id="line20148" class="line"></span>}
<span id="line20149" class="line"></span>
<span id="line20150" class="line"></span>
<span id="line20151" class="line"></span>/**
<span id="line20152" class="line"></span> * @private
<span id="line20153" class="line"></span> * @inner
<span id="line20154" class="line"></span> * @function
<span id="line20155" class="line"></span> */
<span id="line20156" class="line"></span>function onStripDrag( event ) {
<span id="line20157" class="line"></span>
<span id="line20158" class="line"></span>    this.dragging = true;
<span id="line20159" class="line"></span>    if ( this.element ) {
<span id="line20160" class="line"></span>        const offsetLeft   = Number( this.element.style.marginLeft.replace( 'px', '' ) );
<span id="line20161" class="line"></span>        const offsetTop    = Number( this.element.style.marginTop.replace( 'px', '' ) );
<span id="line20162" class="line"></span>        const scrollWidth  = Number( this.element.style.width.replace( 'px', '' ) );
<span id="line20163" class="line"></span>        const scrollHeight = Number( this.element.style.height.replace( 'px', '' ) );
<span id="line20164" class="line"></span>        const viewerSize   = $.getElementSize( this.viewer.canvas );
<span id="line20165" class="line"></span>
<span id="line20166" class="line"></span>        if ( 'horizontal' === this.scroll ) {
<span id="line20167" class="line"></span>            if ( -event.delta.x &gt; 0 ) {
<span id="line20168" class="line"></span>                //forward
<span id="line20169" class="line"></span>                if ( offsetLeft &gt; -( scrollWidth - viewerSize.x ) ) {
<span id="line20170" class="line"></span>                    this.element.style.marginLeft = ( offsetLeft + ( event.delta.x * 2 ) ) + 'px';
<span id="line20171" class="line"></span>                    loadPanels( this, viewerSize.x, offsetLeft + ( event.delta.x * 2 ) );
<span id="line20172" class="line"></span>                }
<span id="line20173" class="line"></span>            } else if ( -event.delta.x &lt; 0 ) {
<span id="line20174" class="line"></span>                //reverse
<span id="line20175" class="line"></span>                if ( offsetLeft &lt; 0 ) {
<span id="line20176" class="line"></span>                    this.element.style.marginLeft = ( offsetLeft + ( event.delta.x * 2 ) ) + 'px';
<span id="line20177" class="line"></span>                    loadPanels( this, viewerSize.x, offsetLeft + ( event.delta.x * 2 ) );
<span id="line20178" class="line"></span>                }
<span id="line20179" class="line"></span>            }
<span id="line20180" class="line"></span>        } else {
<span id="line20181" class="line"></span>            if ( -event.delta.y &gt; 0 ) {
<span id="line20182" class="line"></span>                //forward
<span id="line20183" class="line"></span>                if ( offsetTop &gt; -( scrollHeight - viewerSize.y ) ) {
<span id="line20184" class="line"></span>                    this.element.style.marginTop = ( offsetTop + ( event.delta.y * 2 ) ) + 'px';
<span id="line20185" class="line"></span>                    loadPanels( this, viewerSize.y, offsetTop + ( event.delta.y * 2 ) );
<span id="line20186" class="line"></span>                }
<span id="line20187" class="line"></span>            } else if ( -event.delta.y &lt; 0 ) {
<span id="line20188" class="line"></span>                //reverse
<span id="line20189" class="line"></span>                if ( offsetTop &lt; 0 ) {
<span id="line20190" class="line"></span>                    this.element.style.marginTop = ( offsetTop + ( event.delta.y * 2 ) ) + 'px';
<span id="line20191" class="line"></span>                    loadPanels( this, viewerSize.y, offsetTop + ( event.delta.y * 2 ) );
<span id="line20192" class="line"></span>                }
<span id="line20193" class="line"></span>            }
<span id="line20194" class="line"></span>        }
<span id="line20195" class="line"></span>    }
<span id="line20196" class="line"></span>
<span id="line20197" class="line"></span>}
<span id="line20198" class="line"></span>
<span id="line20199" class="line"></span>
<span id="line20200" class="line"></span>
<span id="line20201" class="line"></span>/**
<span id="line20202" class="line"></span> * @private
<span id="line20203" class="line"></span> * @inner
<span id="line20204" class="line"></span> * @function
<span id="line20205" class="line"></span> */
<span id="line20206" class="line"></span>function onStripScroll( event ) {
<span id="line20207" class="line"></span>    if ( this.element ) {
<span id="line20208" class="line"></span>        const offsetLeft   = Number( this.element.style.marginLeft.replace( 'px', '' ) );
<span id="line20209" class="line"></span>        const offsetTop    = Number( this.element.style.marginTop.replace( 'px', '' ) );
<span id="line20210" class="line"></span>        const scrollWidth  = Number( this.element.style.width.replace( 'px', '' ) );
<span id="line20211" class="line"></span>        const scrollHeight = Number( this.element.style.height.replace( 'px', '' ) );
<span id="line20212" class="line"></span>        const viewerSize   = $.getElementSize( this.viewer.canvas );
<span id="line20213" class="line"></span>
<span id="line20214" class="line"></span>        if ( 'horizontal' === this.scroll ) {
<span id="line20215" class="line"></span>            if ( event.scroll &gt; 0 ) {
<span id="line20216" class="line"></span>                //forward
<span id="line20217" class="line"></span>                if ( offsetLeft &gt; -( scrollWidth - viewerSize.x ) ) {
<span id="line20218" class="line"></span>                    this.element.style.marginLeft = ( offsetLeft - ( event.scroll * 60 ) ) + 'px';
<span id="line20219" class="line"></span>                    loadPanels( this, viewerSize.x, offsetLeft - ( event.scroll * 60 ) );
<span id="line20220" class="line"></span>                }
<span id="line20221" class="line"></span>            } else if ( event.scroll &lt; 0 ) {
<span id="line20222" class="line"></span>                //reverse
<span id="line20223" class="line"></span>                if ( offsetLeft &lt; 0 ) {
<span id="line20224" class="line"></span>                    this.element.style.marginLeft = ( offsetLeft - ( event.scroll * 60 ) ) + 'px';
<span id="line20225" class="line"></span>                    loadPanels( this, viewerSize.x, offsetLeft - ( event.scroll * 60 ) );
<span id="line20226" class="line"></span>                }
<span id="line20227" class="line"></span>            }
<span id="line20228" class="line"></span>        } else {
<span id="line20229" class="line"></span>            if ( event.scroll &lt; 0 ) {
<span id="line20230" class="line"></span>                //scroll up
<span id="line20231" class="line"></span>                if ( offsetTop &gt; viewerSize.y - scrollHeight ) {
<span id="line20232" class="line"></span>                    this.element.style.marginTop = ( offsetTop + ( event.scroll * 60 ) ) + 'px';
<span id="line20233" class="line"></span>                    loadPanels( this, viewerSize.y, offsetTop + ( event.scroll * 60 ) );
<span id="line20234" class="line"></span>                }
<span id="line20235" class="line"></span>            } else if ( event.scroll &gt; 0 ) {
<span id="line20236" class="line"></span>                //scroll dowm
<span id="line20237" class="line"></span>                if ( offsetTop &lt; 0 ) {
<span id="line20238" class="line"></span>                    this.element.style.marginTop = ( offsetTop + ( event.scroll * 60 ) ) + 'px';
<span id="line20239" class="line"></span>                    loadPanels( this, viewerSize.y, offsetTop + ( event.scroll * 60 ) );
<span id="line20240" class="line"></span>                }
<span id="line20241" class="line"></span>            }
<span id="line20242" class="line"></span>        }
<span id="line20243" class="line"></span>
<span id="line20244" class="line"></span>        event.preventDefault = true;
<span id="line20245" class="line"></span>    }
<span id="line20246" class="line"></span>}
<span id="line20247" class="line"></span>
<span id="line20248" class="line"></span>
<span id="line20249" class="line"></span>function loadPanels( strip, viewerSize, scroll ) {
<span id="line20250" class="line"></span>    let panelSize;
<span id="line20251" class="line"></span>    let activePanelsStart;
<span id="line20252" class="line"></span>    let activePanelsEnd;
<span id="line20253" class="line"></span>    let miniViewer;
<span id="line20254" class="line"></span>    let i;
<span id="line20255" class="line"></span>    let element;
<span id="line20256" class="line"></span>
<span id="line20257" class="line"></span>    if ( 'horizontal' === strip.scroll ) {
<span id="line20258" class="line"></span>        panelSize = strip.panelWidth;
<span id="line20259" class="line"></span>    } else {
<span id="line20260" class="line"></span>        panelSize = strip.panelHeight;
<span id="line20261" class="line"></span>    }
<span id="line20262" class="line"></span>    activePanelsStart = Math.ceil( viewerSize / panelSize ) + 5;
<span id="line20263" class="line"></span>    activePanelsEnd = Math.ceil( ( Math.abs( scroll ) + viewerSize ) / panelSize ) + 1;
<span id="line20264" class="line"></span>    activePanelsStart = activePanelsEnd - activePanelsStart;
<span id="line20265" class="line"></span>    activePanelsStart = activePanelsStart &lt; 0 ? 0 : activePanelsStart;
<span id="line20266" class="line"></span>
<span id="line20267" class="line"></span>    for ( i = activePanelsStart; i &lt; activePanelsEnd &amp;&amp; i &lt; strip.panels.length; i++ ) {
<span id="line20268" class="line"></span>        element = strip.panels[i];
<span id="line20269" class="line"></span>        if ( !element.activePanel ) {
<span id="line20270" class="line"></span>            let miniTileSource;
<span id="line20271" class="line"></span>            const originalTileSource = strip.viewer.tileSources[i];
<span id="line20272" class="line"></span>            if (originalTileSource.referenceStripThumbnailUrl) {
<span id="line20273" class="line"></span>                miniTileSource = {
<span id="line20274" class="line"></span>                    type: 'image',
<span id="line20275" class="line"></span>                    url: originalTileSource.referenceStripThumbnailUrl
<span id="line20276" class="line"></span>                };
<span id="line20277" class="line"></span>            } else {
<span id="line20278" class="line"></span>                miniTileSource = originalTileSource;
<span id="line20279" class="line"></span>            }
<span id="line20280" class="line"></span>            miniViewer = new $.Viewer( {
<span id="line20281" class="line"></span>                id:                     element.id,
<span id="line20282" class="line"></span>                tileSources:            [miniTileSource],
<span id="line20283" class="line"></span>                element:                element,
<span id="line20284" class="line"></span>                navigatorSizeRatio:     strip.sizeRatio,
<span id="line20285" class="line"></span>                showNavigator:          false,
<span id="line20286" class="line"></span>                mouseNavEnabled:        false,
<span id="line20287" class="line"></span>                showNavigationControl:  false,
<span id="line20288" class="line"></span>                showSequenceControl:    false,
<span id="line20289" class="line"></span>                immediateRender:        true,
<span id="line20290" class="line"></span>                blendTime:              0,
<span id="line20291" class="line"></span>                animationTime:          0,
<span id="line20292" class="line"></span>                loadTilesWithAjax:      strip.viewer.loadTilesWithAjax,
<span id="line20293" class="line"></span>                ajaxHeaders:            strip.viewer.ajaxHeaders,
<span id="line20294" class="line"></span>                viewer:                 strip.viewer,
<span id="line20295" class="line"></span>                // TODO: make possible for users to ensure the sub-drawer is the same type as the base parent drawer
<span id="line20296" class="line"></span>                drawer:                 'canvas', //always use canvas for the reference strip
<span id="line20297" class="line"></span>            } );
<span id="line20298" class="line"></span>            // Allow pointer events to pass through miniViewer's canvas/container
<span id="line20299" class="line"></span>            //   elements so implicit pointer capture works on touch devices
<span id="line20300" class="line"></span>            $.setElementPointerEventsNone( miniViewer.canvas );
<span id="line20301" class="line"></span>            $.setElementPointerEventsNone( miniViewer.container );
<span id="line20302" class="line"></span>            // We'll use event delegation from the reference strip element instead of
<span id="line20303" class="line"></span>            //   handling events on every miniViewer
<span id="line20304" class="line"></span>            miniViewer.innerTracker.setTracking( false );
<span id="line20305" class="line"></span>            miniViewer.outerTracker.setTracking( false );
<span id="line20306" class="line"></span>
<span id="line20307" class="line"></span>            strip.miniViewers[element.id] = miniViewer;
<span id="line20308" class="line"></span>
<span id="line20309" class="line"></span>            element.activePanel = true;
<span id="line20310" class="line"></span>        }
<span id="line20311" class="line"></span>    }
<span id="line20312" class="line"></span>}
<span id="line20313" class="line"></span>
<span id="line20314" class="line"></span>
<span id="line20315" class="line"></span>/**
<span id="line20316" class="line"></span> * @private
<span id="line20317" class="line"></span> * @inner
<span id="line20318" class="line"></span> * @function
<span id="line20319" class="line"></span> */
<span id="line20320" class="line"></span>function onStripEnter( event ) {
<span id="line20321" class="line"></span>    const element = event.eventSource.element;
<span id="line20322" class="line"></span>
<span id="line20323" class="line"></span>    //$.setElementOpacity(element, 0.8);
<span id="line20324" class="line"></span>
<span id="line20325" class="line"></span>    //element.style.border = '1px solid #555';
<span id="line20326" class="line"></span>    //element.style.background = '#000';
<span id="line20327" class="line"></span>
<span id="line20328" class="line"></span>    if ( 'horizontal' === this.scroll ) {
<span id="line20329" class="line"></span>
<span id="line20330" class="line"></span>        //element.style.paddingTop = "0px";
<span id="line20331" class="line"></span>        element.style.marginBottom = "0px";
<span id="line20332" class="line"></span>
<span id="line20333" class="line"></span>    } else {
<span id="line20334" class="line"></span>
<span id="line20335" class="line"></span>        //element.style.paddingRight = "0px";
<span id="line20336" class="line"></span>        element.style.marginLeft = "0px";
<span id="line20337" class="line"></span>
<span id="line20338" class="line"></span>    }
<span id="line20339" class="line"></span>}
<span id="line20340" class="line"></span>
<span id="line20341" class="line"></span>
<span id="line20342" class="line"></span>/**
<span id="line20343" class="line"></span> * @private
<span id="line20344" class="line"></span> * @inner
<span id="line20345" class="line"></span> * @function
<span id="line20346" class="line"></span> */
<span id="line20347" class="line"></span>function onStripLeave( event ) {
<span id="line20348" class="line"></span>    const element = event.eventSource.element;
<span id="line20349" class="line"></span>
<span id="line20350" class="line"></span>    if ( 'horizontal' === this.scroll ) {
<span id="line20351" class="line"></span>
<span id="line20352" class="line"></span>        //element.style.paddingTop = "10px";
<span id="line20353" class="line"></span>        element.style.marginBottom = "-" + ( $.getElementSize( element ).y / 2 ) + "px";
<span id="line20354" class="line"></span>
<span id="line20355" class="line"></span>    } else {
<span id="line20356" class="line"></span>
<span id="line20357" class="line"></span>        //element.style.paddingRight = "10px";
<span id="line20358" class="line"></span>        element.style.marginLeft = "-" + ( $.getElementSize( element ).x / 2 ) + "px";
<span id="line20359" class="line"></span>
<span id="line20360" class="line"></span>    }
<span id="line20361" class="line"></span>}
<span id="line20362" class="line"></span>
<span id="line20363" class="line"></span>
<span id="line20364" class="line"></span>/**
<span id="line20365" class="line"></span> * @private
<span id="line20366" class="line"></span> * @inner
<span id="line20367" class="line"></span> * @function
<span id="line20368" class="line"></span> */
<span id="line20369" class="line"></span>function onKeyDown( event ) {
<span id="line20370" class="line"></span>    //console.log( event.keyCode );
<span id="line20371" class="line"></span>
<span id="line20372" class="line"></span>    if ( !event.ctrl &amp;&amp; !event.alt &amp;&amp; !event.meta ) {
<span id="line20373" class="line"></span>        switch ( event.keyCode ) {
<span id="line20374" class="line"></span>            case 38: //up arrow
<span id="line20375" class="line"></span>                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );
<span id="line20376" class="line"></span>                event.preventDefault = true;
<span id="line20377" class="line"></span>                break;
<span id="line20378" class="line"></span>            case 40: //down arrow
<span id="line20379" class="line"></span>                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );
<span id="line20380" class="line"></span>                event.preventDefault = true;
<span id="line20381" class="line"></span>                break;
<span id="line20382" class="line"></span>            case 37: //left arrow
<span id="line20383" class="line"></span>                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );
<span id="line20384" class="line"></span>                event.preventDefault = true;
<span id="line20385" class="line"></span>                break;
<span id="line20386" class="line"></span>            case 39: //right arrow
<span id="line20387" class="line"></span>                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );
<span id="line20388" class="line"></span>                event.preventDefault = true;
<span id="line20389" class="line"></span>                break;
<span id="line20390" class="line"></span>            default:
<span id="line20391" class="line"></span>                //console.log( 'navigator keycode %s', event.keyCode );
<span id="line20392" class="line"></span>                event.preventDefault = false;
<span id="line20393" class="line"></span>                break;
<span id="line20394" class="line"></span>        }
<span id="line20395" class="line"></span>    } else {
<span id="line20396" class="line"></span>        event.preventDefault = false;
<span id="line20397" class="line"></span>    }
<span id="line20398" class="line"></span>}
<span id="line20399" class="line"></span>
<span id="line20400" class="line"></span>
<span id="line20401" class="line"></span>/**
<span id="line20402" class="line"></span> * @private
<span id="line20403" class="line"></span> * @inner
<span id="line20404" class="line"></span> * @function
<span id="line20405" class="line"></span> */
<span id="line20406" class="line"></span>function onKeyPress( event ) {
<span id="line20407" class="line"></span>    //console.log( event.keyCode );
<span id="line20408" class="line"></span>
<span id="line20409" class="line"></span>    if ( !event.ctrl &amp;&amp; !event.alt &amp;&amp; !event.meta ) {
<span id="line20410" class="line"></span>        switch ( event.keyCode ) {
<span id="line20411" class="line"></span>            case 61: //=|+
<span id="line20412" class="line"></span>                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );
<span id="line20413" class="line"></span>                event.preventDefault = true;
<span id="line20414" class="line"></span>                break;
<span id="line20415" class="line"></span>            case 45: //-|_
<span id="line20416" class="line"></span>                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );
<span id="line20417" class="line"></span>                event.preventDefault = true;
<span id="line20418" class="line"></span>                break;
<span id="line20419" class="line"></span>            case 48: //0|)
<span id="line20420" class="line"></span>            case 119: //w
<span id="line20421" class="line"></span>            case 87: //W
<span id="line20422" class="line"></span>                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );
<span id="line20423" class="line"></span>                event.preventDefault = true;
<span id="line20424" class="line"></span>                break;
<span id="line20425" class="line"></span>            case 115: //s
<span id="line20426" class="line"></span>            case 83: //S
<span id="line20427" class="line"></span>                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );
<span id="line20428" class="line"></span>                event.preventDefault = true;
<span id="line20429" class="line"></span>                break;
<span id="line20430" class="line"></span>            case 97: //a
<span id="line20431" class="line"></span>                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );
<span id="line20432" class="line"></span>                event.preventDefault = true;
<span id="line20433" class="line"></span>                break;
<span id="line20434" class="line"></span>            case 100: //d
<span id="line20435" class="line"></span>                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );
<span id="line20436" class="line"></span>                event.preventDefault = true;
<span id="line20437" class="line"></span>                break;
<span id="line20438" class="line"></span>            default:
<span id="line20439" class="line"></span>                //console.log( 'navigator keycode %s', event.keyCode );
<span id="line20440" class="line"></span>                event.preventDefault = false;
<span id="line20441" class="line"></span>                break;
<span id="line20442" class="line"></span>        }
<span id="line20443" class="line"></span>    } else {
<span id="line20444" class="line"></span>        event.preventDefault = false;
<span id="line20445" class="line"></span>    }
<span id="line20446" class="line"></span>}
<span id="line20447" class="line"></span>
<span id="line20448" class="line"></span>}(OpenSeadragon));
<span id="line20449" class="line"></span>
<span id="line20450" class="line"></span>/*
<span id="line20451" class="line"></span> * OpenSeadragon - DisplayRect
<span id="line20452" class="line"></span> *
<span id="line20453" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line20454" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line20455" class="line"></span> *
<span id="line20456" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line20457" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line20458" class="line"></span> * met:
<span id="line20459" class="line"></span> *
<span id="line20460" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line20461" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line20462" class="line"></span> *
<span id="line20463" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line20464" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line20465" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line20466" class="line"></span> *
<span id="line20467" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line20468" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line20469" class="line"></span> *   this software without specific prior written permission.
<span id="line20470" class="line"></span> *
<span id="line20471" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line20472" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line20473" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line20474" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line20475" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line20476" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line20477" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line20478" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line20479" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line20480" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line20481" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line20482" class="line"></span> */
<span id="line20483" class="line"></span>
<span id="line20484" class="line"></span>(function( $ ){
<span id="line20485" class="line"></span>
<span id="line20486" class="line"></span>/**
<span id="line20487" class="line"></span> * @class DisplayRect
<span id="line20488" class="line"></span> * @classdesc A display rectangle is very similar to {@link OpenSeadragon.Rect} but adds two
<span id="line20489" class="line"></span> * fields, 'minLevel' and 'maxLevel' which denote the supported zoom levels
<span id="line20490" class="line"></span> * for this rectangle.
<span id="line20491" class="line"></span> *
<span id="line20492" class="line"></span> * @memberof OpenSeadragon
<span id="line20493" class="line"></span> * @extends OpenSeadragon.Rect
<span id="line20494" class="line"></span> * @param {Number} x The vector component 'x'.
<span id="line20495" class="line"></span> * @param {Number} y The vector component 'y'.
<span id="line20496" class="line"></span> * @param {Number} width The vector component 'height'.
<span id="line20497" class="line"></span> * @param {Number} height The vector component 'width'.
<span id="line20498" class="line"></span> * @param {Number} minLevel The lowest zoom level supported.
<span id="line20499" class="line"></span> * @param {Number} maxLevel The highest zoom level supported.
<span id="line20500" class="line"></span> */
<span id="line20501" class="line"></span>$.DisplayRect = function( x, y, width, height, minLevel, maxLevel ) {
<span id="line20502" class="line"></span>    $.Rect.apply( this, [ x, y, width, height ] );
<span id="line20503" class="line"></span>
<span id="line20504" class="line"></span>    /**
<span id="line20505" class="line"></span>     * The lowest zoom level supported.
<span id="line20506" class="line"></span>     * @member {Number} minLevel
<span id="line20507" class="line"></span>     * @memberof OpenSeadragon.DisplayRect#
<span id="line20508" class="line"></span>     */
<span id="line20509" class="line"></span>    this.minLevel = minLevel;
<span id="line20510" class="line"></span>    /**
<span id="line20511" class="line"></span>     * The highest zoom level supported.
<span id="line20512" class="line"></span>     * @member {Number} maxLevel
<span id="line20513" class="line"></span>     * @memberof OpenSeadragon.DisplayRect#
<span id="line20514" class="line"></span>     */
<span id="line20515" class="line"></span>    this.maxLevel = maxLevel;
<span id="line20516" class="line"></span>};
<span id="line20517" class="line"></span>
<span id="line20518" class="line"></span>$.extend( $.DisplayRect.prototype, $.Rect.prototype );
<span id="line20519" class="line"></span>
<span id="line20520" class="line"></span>}( OpenSeadragon ));
<span id="line20521" class="line"></span>
<span id="line20522" class="line"></span>/*
<span id="line20523" class="line"></span> * OpenSeadragon - Spring
<span id="line20524" class="line"></span> *
<span id="line20525" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line20526" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line20527" class="line"></span> *
<span id="line20528" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line20529" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line20530" class="line"></span> * met:
<span id="line20531" class="line"></span> *
<span id="line20532" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line20533" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line20534" class="line"></span> *
<span id="line20535" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line20536" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line20537" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line20538" class="line"></span> *
<span id="line20539" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line20540" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line20541" class="line"></span> *   this software without specific prior written permission.
<span id="line20542" class="line"></span> *
<span id="line20543" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line20544" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line20545" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line20546" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line20547" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line20548" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line20549" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line20550" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line20551" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line20552" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line20553" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line20554" class="line"></span> */
<span id="line20555" class="line"></span>
<span id="line20556" class="line"></span>(function( $ ){
<span id="line20557" class="line"></span>
<span id="line20558" class="line"></span>/**
<span id="line20559" class="line"></span> * @class Spring
<span id="line20560" class="line"></span> * @memberof OpenSeadragon
<span id="line20561" class="line"></span> * @param {Object} options - Spring configuration settings.
<span id="line20562" class="line"></span> * @param {Number} options.springStiffness - Spring stiffness. Must be greater than zero.
<span id="line20563" class="line"></span> * The closer to zero, the closer to linear animation.
<span id="line20564" class="line"></span> * @param {Number} options.animationTime - Animation duration per spring, in seconds.
<span id="line20565" class="line"></span> * Must be zero or greater.
<span id="line20566" class="line"></span> * @param {Number} [options.initial=0] - Initial value of spring.
<span id="line20567" class="line"></span> * @param {Boolean} [options.exponential=false] - Whether this spring represents
<span id="line20568" class="line"></span> * an exponential scale (such as zoom) and should be animated accordingly. Note that
<span id="line20569" class="line"></span> * exponential springs must have non-zero values.
<span id="line20570" class="line"></span> */
<span id="line20571" class="line"></span>$.Spring = function( options ) {
<span id="line20572" class="line"></span>    const args = arguments;
<span id="line20573" class="line"></span>
<span id="line20574" class="line"></span>    if( typeof ( options ) !== 'object' ){
<span id="line20575" class="line"></span>        //allows backward compatible use of ( initialValue, config ) as
<span id="line20576" class="line"></span>        //constructor parameters
<span id="line20577" class="line"></span>        options = {
<span id="line20578" class="line"></span>            initial: args.length &amp;&amp; typeof ( args[ 0 ] ) === "number" ?
<span id="line20579" class="line"></span>                args[ 0 ] :
<span id="line20580" class="line"></span>                undefined,
<span id="line20581" class="line"></span>            /**
<span id="line20582" class="line"></span>             * Spring stiffness.
<span id="line20583" class="line"></span>             * @member {Number} springStiffness
<span id="line20584" class="line"></span>             * @memberof OpenSeadragon.Spring#
<span id="line20585" class="line"></span>             */
<span id="line20586" class="line"></span>            springStiffness: args.length &gt; 1 ?
<span id="line20587" class="line"></span>                args[ 1 ].springStiffness :
<span id="line20588" class="line"></span>                5.0,
<span id="line20589" class="line"></span>            /**
<span id="line20590" class="line"></span>             * Animation duration per spring.
<span id="line20591" class="line"></span>             * @member {Number} animationTime
<span id="line20592" class="line"></span>             * @memberof OpenSeadragon.Spring#
<span id="line20593" class="line"></span>             */
<span id="line20594" class="line"></span>            animationTime: args.length &gt; 1 ?
<span id="line20595" class="line"></span>                args[ 1 ].animationTime :
<span id="line20596" class="line"></span>                1.5
<span id="line20597" class="line"></span>        };
<span id="line20598" class="line"></span>    }
<span id="line20599" class="line"></span>
<span id="line20600" class="line"></span>    $.console.assert(typeof options.springStiffness === "number" &amp;&amp; options.springStiffness !== 0,
<span id="line20601" class="line"></span>        "[OpenSeadragon.Spring] options.springStiffness must be a non-zero number");
<span id="line20602" class="line"></span>
<span id="line20603" class="line"></span>    $.console.assert(typeof options.animationTime === "number" &amp;&amp; options.animationTime &gt;= 0,
<span id="line20604" class="line"></span>        "[OpenSeadragon.Spring] options.animationTime must be a number greater than or equal to 0");
<span id="line20605" class="line"></span>
<span id="line20606" class="line"></span>    if (options.exponential) {
<span id="line20607" class="line"></span>        this._exponential = true;
<span id="line20608" class="line"></span>        delete options.exponential;
<span id="line20609" class="line"></span>    }
<span id="line20610" class="line"></span>
<span id="line20611" class="line"></span>    $.extend( true, this, options);
<span id="line20612" class="line"></span>
<span id="line20613" class="line"></span>    /**
<span id="line20614" class="line"></span>     * @member {Object} current
<span id="line20615" class="line"></span>     * @memberof OpenSeadragon.Spring#
<span id="line20616" class="line"></span>     * @property {Number} value
<span id="line20617" class="line"></span>     * @property {Number} time
<span id="line20618" class="line"></span>     */
<span id="line20619" class="line"></span>    this.current = {
<span id="line20620" class="line"></span>        value: typeof ( this.initial ) === "number" ?
<span id="line20621" class="line"></span>            this.initial :
<span id="line20622" class="line"></span>            (this._exponential ? 0 : 1),
<span id="line20623" class="line"></span>        time:  $.now() // always work in milliseconds
<span id="line20624" class="line"></span>    };
<span id="line20625" class="line"></span>
<span id="line20626" class="line"></span>    $.console.assert(!this._exponential || this.current.value !== 0,
<span id="line20627" class="line"></span>        "[OpenSeadragon.Spring] value must be non-zero for exponential springs");
<span id="line20628" class="line"></span>
<span id="line20629" class="line"></span>    /**
<span id="line20630" class="line"></span>     * @member {Object} start
<span id="line20631" class="line"></span>     * @memberof OpenSeadragon.Spring#
<span id="line20632" class="line"></span>     * @property {Number} value
<span id="line20633" class="line"></span>     * @property {Number} time
<span id="line20634" class="line"></span>     */
<span id="line20635" class="line"></span>    this.start = {
<span id="line20636" class="line"></span>        value: this.current.value,
<span id="line20637" class="line"></span>        time:  this.current.time
<span id="line20638" class="line"></span>    };
<span id="line20639" class="line"></span>
<span id="line20640" class="line"></span>    /**
<span id="line20641" class="line"></span>     * @member {Object} target
<span id="line20642" class="line"></span>     * @memberof OpenSeadragon.Spring#
<span id="line20643" class="line"></span>     * @property {Number} value
<span id="line20644" class="line"></span>     * @property {Number} time
<span id="line20645" class="line"></span>     */
<span id="line20646" class="line"></span>    this.target = {
<span id="line20647" class="line"></span>        value: this.current.value,
<span id="line20648" class="line"></span>        time:  this.current.time
<span id="line20649" class="line"></span>    };
<span id="line20650" class="line"></span>
<span id="line20651" class="line"></span>    if (this._exponential) {
<span id="line20652" class="line"></span>        this.start._logValue = Math.log(this.start.value);
<span id="line20653" class="line"></span>        this.target._logValue = Math.log(this.target.value);
<span id="line20654" class="line"></span>        this.current._logValue = Math.log(this.current.value);
<span id="line20655" class="line"></span>    }
<span id="line20656" class="line"></span>};
<span id="line20657" class="line"></span>
<span id="line20658" class="line"></span>/** @lends OpenSeadragon.Spring.prototype */
<span id="line20659" class="line"></span>$.Spring.prototype = {
<span id="line20660" class="line"></span>
<span id="line20661" class="line"></span>    /**
<span id="line20662" class="line"></span>     * @function
<span id="line20663" class="line"></span>     * @param {Number} target
<span id="line20664" class="line"></span>     */
<span id="line20665" class="line"></span>    resetTo: function( target ) {
<span id="line20666" class="line"></span>        $.console.assert(!this._exponential || target !== 0,
<span id="line20667" class="line"></span>            "[OpenSeadragon.Spring.resetTo] target must be non-zero for exponential springs");
<span id="line20668" class="line"></span>
<span id="line20669" class="line"></span>        this.start.value = this.target.value = this.current.value = target;
<span id="line20670" class="line"></span>        this.start.time = this.target.time = this.current.time = $.now();
<span id="line20671" class="line"></span>
<span id="line20672" class="line"></span>        if (this._exponential) {
<span id="line20673" class="line"></span>            this.start._logValue = Math.log(this.start.value);
<span id="line20674" class="line"></span>            this.target._logValue = Math.log(this.target.value);
<span id="line20675" class="line"></span>            this.current._logValue = Math.log(this.current.value);
<span id="line20676" class="line"></span>        }
<span id="line20677" class="line"></span>    },
<span id="line20678" class="line"></span>
<span id="line20679" class="line"></span>    /**
<span id="line20680" class="line"></span>     * @function
<span id="line20681" class="line"></span>     * @param {Number} target
<span id="line20682" class="line"></span>     */
<span id="line20683" class="line"></span>    springTo: function( target ) {
<span id="line20684" class="line"></span>        $.console.assert(!this._exponential || target !== 0,
<span id="line20685" class="line"></span>            "[OpenSeadragon.Spring.springTo] target must be non-zero for exponential springs");
<span id="line20686" class="line"></span>
<span id="line20687" class="line"></span>        this.start.value  = this.current.value;
<span id="line20688" class="line"></span>        this.start.time   = this.current.time;
<span id="line20689" class="line"></span>        this.target.value = target;
<span id="line20690" class="line"></span>        this.target.time  = this.start.time + 1000 * this.animationTime;
<span id="line20691" class="line"></span>
<span id="line20692" class="line"></span>        if (this._exponential) {
<span id="line20693" class="line"></span>            this.start._logValue = Math.log(this.start.value);
<span id="line20694" class="line"></span>            this.target._logValue = Math.log(this.target.value);
<span id="line20695" class="line"></span>        }
<span id="line20696" class="line"></span>    },
<span id="line20697" class="line"></span>
<span id="line20698" class="line"></span>    /**
<span id="line20699" class="line"></span>     * @function
<span id="line20700" class="line"></span>     * @param {Number} delta
<span id="line20701" class="line"></span>     */
<span id="line20702" class="line"></span>    shiftBy: function( delta ) {
<span id="line20703" class="line"></span>        this.start.value  += delta;
<span id="line20704" class="line"></span>        this.target.value += delta;
<span id="line20705" class="line"></span>
<span id="line20706" class="line"></span>        if (this._exponential) {
<span id="line20707" class="line"></span>            $.console.assert(this.target.value !== 0 &amp;&amp; this.start.value !== 0,
<span id="line20708" class="line"></span>                "[OpenSeadragon.Spring.shiftBy] spring value must be non-zero for exponential springs");
<span id="line20709" class="line"></span>
<span id="line20710" class="line"></span>            this.start._logValue = Math.log(this.start.value);
<span id="line20711" class="line"></span>            this.target._logValue = Math.log(this.target.value);
<span id="line20712" class="line"></span>        }
<span id="line20713" class="line"></span>    },
<span id="line20714" class="line"></span>
<span id="line20715" class="line"></span>    setExponential: function(value) {
<span id="line20716" class="line"></span>        this._exponential = value;
<span id="line20717" class="line"></span>
<span id="line20718" class="line"></span>        if (this._exponential) {
<span id="line20719" class="line"></span>            $.console.assert(this.current.value !== 0 &amp;&amp; this.target.value !== 0 &amp;&amp; this.start.value !== 0,
<span id="line20720" class="line"></span>                "[OpenSeadragon.Spring.setExponential] spring value must be non-zero for exponential springs");
<span id="line20721" class="line"></span>
<span id="line20722" class="line"></span>            this.start._logValue = Math.log(this.start.value);
<span id="line20723" class="line"></span>            this.target._logValue = Math.log(this.target.value);
<span id="line20724" class="line"></span>            this.current._logValue = Math.log(this.current.value);
<span id="line20725" class="line"></span>        }
<span id="line20726" class="line"></span>    },
<span id="line20727" class="line"></span>
<span id="line20728" class="line"></span>    /**
<span id="line20729" class="line"></span>     * @function
<span id="line20730" class="line"></span>     * @returns true if the spring is still updating its value, false if it is
<span id="line20731" class="line"></span>     * already at the target value.
<span id="line20732" class="line"></span>     */
<span id="line20733" class="line"></span>    update: function() {
<span id="line20734" class="line"></span>        this.current.time  = $.now();
<span id="line20735" class="line"></span>
<span id="line20736" class="line"></span>        let startValue, targetValue;
<span id="line20737" class="line"></span>        if (this._exponential) {
<span id="line20738" class="line"></span>            startValue = this.start._logValue;
<span id="line20739" class="line"></span>            targetValue = this.target._logValue;
<span id="line20740" class="line"></span>        } else {
<span id="line20741" class="line"></span>            startValue = this.start.value;
<span id="line20742" class="line"></span>            targetValue = this.target.value;
<span id="line20743" class="line"></span>        }
<span id="line20744" class="line"></span>
<span id="line20745" class="line"></span>        if(this.current.time &gt;= this.target.time){
<span id="line20746" class="line"></span>            this.current.value = this.target.value;
<span id="line20747" class="line"></span>        } else {
<span id="line20748" class="line"></span>            let currentValue = startValue +
<span id="line20749" class="line"></span>                    ( targetValue - startValue ) *
<span id="line20750" class="line"></span>                    transform(
<span id="line20751" class="line"></span>                        this.springStiffness,
<span id="line20752" class="line"></span>                        ( this.current.time - this.start.time ) /
<span id="line20753" class="line"></span>                        ( this.target.time - this.start.time )
<span id="line20754" class="line"></span>                    );
<span id="line20755" class="line"></span>
<span id="line20756" class="line"></span>            if (this._exponential) {
<span id="line20757" class="line"></span>                this.current.value = Math.exp(currentValue);
<span id="line20758" class="line"></span>            } else {
<span id="line20759" class="line"></span>                this.current.value = currentValue;
<span id="line20760" class="line"></span>            }
<span id="line20761" class="line"></span>        }
<span id="line20762" class="line"></span>
<span id="line20763" class="line"></span>        return this.current.value !== this.target.value;
<span id="line20764" class="line"></span>    },
<span id="line20765" class="line"></span>
<span id="line20766" class="line"></span>    /**
<span id="line20767" class="line"></span>     * Returns whether the spring is at the target value
<span id="line20768" class="line"></span>     * @function
<span id="line20769" class="line"></span>     * @returns {Boolean} True if at target value, false otherwise
<span id="line20770" class="line"></span>     */
<span id="line20771" class="line"></span>    isAtTargetValue: function() {
<span id="line20772" class="line"></span>        return this.current.value === this.target.value;
<span id="line20773" class="line"></span>    }
<span id="line20774" class="line"></span>};
<span id="line20775" class="line"></span>
<span id="line20776" class="line"></span>/**
<span id="line20777" class="line"></span> * @private
<span id="line20778" class="line"></span> */
<span id="line20779" class="line"></span>function transform( stiffness, x ) {
<span id="line20780" class="line"></span>    return ( 1.0 - Math.exp( stiffness * -x ) ) /
<span id="line20781" class="line"></span>        ( 1.0 - Math.exp( -stiffness ) );
<span id="line20782" class="line"></span>}
<span id="line20783" class="line"></span>
<span id="line20784" class="line"></span>}( OpenSeadragon ));
<span id="line20785" class="line"></span>
<span id="line20786" class="line"></span>/*
<span id="line20787" class="line"></span> * OpenSeadragon - ImageLoader
<span id="line20788" class="line"></span> *
<span id="line20789" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line20790" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line20791" class="line"></span>
<span id="line20792" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line20793" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line20794" class="line"></span> * met:
<span id="line20795" class="line"></span> *
<span id="line20796" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line20797" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line20798" class="line"></span> *
<span id="line20799" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line20800" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line20801" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line20802" class="line"></span> *
<span id="line20803" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line20804" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line20805" class="line"></span> *   this software without specific prior written permission.
<span id="line20806" class="line"></span> *
<span id="line20807" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line20808" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line20809" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line20810" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line20811" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line20812" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line20813" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line20814" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line20815" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line20816" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line20817" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line20818" class="line"></span> */
<span id="line20819" class="line"></span>
<span id="line20820" class="line"></span>(function($){
<span id="line20821" class="line"></span>
<span id="line20822" class="line"></span>/**
<span id="line20823" class="line"></span> * @class ImageJob
<span id="line20824" class="line"></span> * @classdesc Handles downloading of a single image.
<span id="line20825" class="line"></span> *
<span id="line20826" class="line"></span> * @memberof OpenSeadragon
<span id="line20827" class="line"></span> * @param {Object} options - Options for this ImageJob.
<span id="line20828" class="line"></span> * @param {String} [options.src] - URL of image to download.
<span id="line20829" class="line"></span> * @param {Tile} [options.tile] - Tile that belongs the data to.
<span id="line20830" class="line"></span> * @param {TileSource} [options.source] - Image loading strategy
<span id="line20831" class="line"></span> * @param {String} [options.loadWithAjax] - Whether to load this image with AJAX.
<span id="line20832" class="line"></span> * @param {String} [options.ajaxHeaders] - Headers to add to the image request if using AJAX.
<span id="line20833" class="line"></span> * @param {Boolean} [options.ajaxWithCredentials] - Whether to set withCredentials on AJAX requests.
<span id="line20834" class="line"></span> * @param {String} [options.crossOriginPolicy] - CORS policy to use for downloads
<span id="line20835" class="line"></span> * @param {String} [options.postData] - HTTP POST data (usually but not necessarily in k=v&amp;k2=v2... form,
<span id="line20836" class="line"></span> *      see TileSource::getTilePostData) or null
<span id="line20837" class="line"></span> * @param {Function} [options.callback] - Called once image has been downloaded.
<span id="line20838" class="line"></span> * @param {Function} [options.abort] - Called when this image job is aborted.
<span id="line20839" class="line"></span> * @param {Number} [options.timeout] - The max number of milliseconds that this image job may take to complete.
<span id="line20840" class="line"></span> * @param {Number} [options.tries] - Actual number of the current try.
<span id="line20841" class="line"></span> */
<span id="line20842" class="line"></span>$.ImageJob = function(options) {
<span id="line20843" class="line"></span>
<span id="line20844" class="line"></span>    /**
<span id="line20845" class="line"></span>     * Private parameter. Called automatically once image has been downloaded
<span id="line20846" class="line"></span>     *   (triggered by finish).
<span id="line20847" class="line"></span>     * @member {function} callback
<span id="line20848" class="line"></span>     * @memberof OpenSeadragon.ImageJob#
<span id="line20849" class="line"></span>     * @private
<span id="line20850" class="line"></span>     */
<span id="line20851" class="line"></span>
<span id="line20852" class="line"></span>    /**
<span id="line20853" class="line"></span>     * URL of image (or other data item that will be rendered) to download.
<span id="line20854" class="line"></span>     * @member {string} src
<span id="line20855" class="line"></span>     * @memberof OpenSeadragon.ImageJob#
<span id="line20856" class="line"></span>     */
<span id="line20857" class="line"></span>
<span id="line20858" class="line"></span>    /**
<span id="line20859" class="line"></span>     * Tile that owns the load. Note the data might be shared between tiles.
<span id="line20860" class="line"></span>     * @member {OpenSeadragon.Tile} tile
<span id="line20861" class="line"></span>     * @memberof OpenSeadragon.ImageJob#
<span id="line20862" class="line"></span>     */
<span id="line20863" class="line"></span>
<span id="line20864" class="line"></span>    /**
<span id="line20865" class="line"></span>     * TileSource that initiated the load and owns the tile. Note the data might be shared between tiles and tile sources.
<span id="line20866" class="line"></span>     * @member {OpenSeadragon.TileSource} source
<span id="line20867" class="line"></span>     * @memberof OpenSeadragon.ImageJob#
<span id="line20868" class="line"></span>     */
<span id="line20869" class="line"></span>
<span id="line20870" class="line"></span>    /**
<span id="line20871" class="line"></span>     * Whether to load this image with AJAX.
<span id="line20872" class="line"></span>     * @member {boolean} loadWithAjax
<span id="line20873" class="line"></span>     * @memberof OpenSeadragon.ImageJob#
<span id="line20874" class="line"></span>     */
<span id="line20875" class="line"></span>
<span id="line20876" class="line"></span>    /**
<span id="line20877" class="line"></span>     * Headers to add to the image request if using AJAX.
<span id="line20878" class="line"></span>     * @member {Object.&lt;string, string&gt;} ajaxHeaders
<span id="line20879" class="line"></span>     * @memberof OpenSeadragon.ImageJob#
<span id="line20880" class="line"></span>     */
<span id="line20881" class="line"></span>
<span id="line20882" class="line"></span>    /**
<span id="line20883" class="line"></span>     * Whether to set withCredentials on AJAX requests.
<span id="line20884" class="line"></span>     * @member {boolean} ajaxWithCredentials
<span id="line20885" class="line"></span>     * @memberof OpenSeadragon.ImageJob#
<span id="line20886" class="line"></span>     */
<span id="line20887" class="line"></span>
<span id="line20888" class="line"></span>    /**
<span id="line20889" class="line"></span>     * CORS policy to use for downloads
<span id="line20890" class="line"></span>     * @member {String} crossOriginPolicy
<span id="line20891" class="line"></span>     * @memberof OpenSeadragon.ImageJob#
<span id="line20892" class="line"></span>     */
<span id="line20893" class="line"></span>
<span id="line20894" class="line"></span>    /**
<span id="line20895" class="line"></span>     * HTTP POST data to send with the request
<span id="line20896" class="line"></span>     * @member {(String|Object)} [postData] - HTTP POST data (usually but not necessarily
<span id="line20897" class="line"></span>     *   in k=v&amp;k2=v2... form, see TileSource::getTilePostData) or null
<span id="line20898" class="line"></span>     * @memberof OpenSeadragon.ImageJob#
<span id="line20899" class="line"></span>     */
<span id="line20900" class="line"></span>
<span id="line20901" class="line"></span>    /**
<span id="line20902" class="line"></span>     * Data object which will contain downloaded image data.
<span id="line20903" class="line"></span>     * @member {Image|*} data data object, by default an Image object (depends on TileSource)
<span id="line20904" class="line"></span>     * @memberof OpenSeadragon.ImageJob#
<span id="line20905" class="line"></span>     */
<span id="line20906" class="line"></span>    this.data = null;
<span id="line20907" class="line"></span>
<span id="line20908" class="line"></span>    /**
<span id="line20909" class="line"></span>     * User workspace to populate with helper variables
<span id="line20910" class="line"></span>     * @member {*} userData to append custom data and avoid namespace collision
<span id="line20911" class="line"></span>     * @memberof OpenSeadragon.ImageJob#
<span id="line20912" class="line"></span>     */
<span id="line20913" class="line"></span>    this.userData = {};
<span id="line20914" class="line"></span>
<span id="line20915" class="line"></span>    /**
<span id="line20916" class="line"></span>     * Error message holder. The final error message, default null (set by finish).
<span id="line20917" class="line"></span>     * @member {string} error message
<span id="line20918" class="line"></span>     * @memberof OpenSeadragon.ImageJob#
<span id="line20919" class="line"></span>     * @private
<span id="line20920" class="line"></span>     */
<span id="line20921" class="line"></span>    this.errorMsg = null;
<span id="line20922" class="line"></span>
<span id="line20923" class="line"></span>    /**
<span id="line20924" class="line"></span>     * Private parameter. The max number of milliseconds that
<span id="line20925" class="line"></span>     *   this image job may take to complete.
<span id="line20926" class="line"></span>     * @member {number} timeout
<span id="line20927" class="line"></span>     * @memberof OpenSeadragon.ImageJob#
<span id="line20928" class="line"></span>     * @private
<span id="line20929" class="line"></span>     */
<span id="line20930" class="line"></span>    this.timeout = $.DEFAULT_SETTINGS.timeout;
<span id="line20931" class="line"></span>
<span id="line20932" class="line"></span>    /**
<span id="line20933" class="line"></span>     * Flag if part of batch query.
<span id="line20934" class="line"></span>     * @member {boolean} isBatched
<span id="line20935" class="line"></span>     * @memberof OpenSeadragon.ImageJob#
<span id="line20936" class="line"></span>     * @private
<span id="line20937" class="line"></span>     */
<span id="line20938" class="line"></span>    this.isBatched = false;
<span id="line20939" class="line"></span>
<span id="line20940" class="line"></span>
<span id="line20941" class="line"></span>    $.extend(true, this, {
<span id="line20942" class="line"></span>        jobId: null,
<span id="line20943" class="line"></span>        tries: 0,
<span id="line20944" class="line"></span>    }, options);
<span id="line20945" class="line"></span>};
<span id="line20946" class="line"></span>
<span id="line20947" class="line"></span>$.ImageJob.prototype = {
<span id="line20948" class="line"></span>    /**
<span id="line20949" class="line"></span>     * Starts the image job.
<span id="line20950" class="line"></span>     * @method
<span id="line20951" class="line"></span>     * @private
<span id="line20952" class="line"></span>     * @memberof OpenSeadragon.ImageJob#
<span id="line20953" class="line"></span>     */
<span id="line20954" class="line"></span>    start: function() {
<span id="line20955" class="line"></span>        this.tries++;
<span id="line20956" class="line"></span>
<span id="line20957" class="line"></span>        const self = this;
<span id="line20958" class="line"></span>        const selfAbort = this.abort;
<span id="line20959" class="line"></span>
<span id="line20960" class="line"></span>        this.jobId = window.setTimeout(function () {
<span id="line20961" class="line"></span>            self.fail("Image load exceeded timeout (" + self.timeout + " ms)", null);
<span id="line20962" class="line"></span>        }, this.timeout);
<span id="line20963" class="line"></span>
<span id="line20964" class="line"></span>        /**
<span id="line20965" class="line"></span>         * Called automatically when the job times out.
<span id="line20966" class="line"></span>         *   Usage: if you decide to abort the request (no fail/finish will be called), call context.abort().
<span id="line20967" class="line"></span>         * @member {function} abort
<span id="line20968" class="line"></span>         * @memberof OpenSeadragon.ImageJob#
<span id="line20969" class="line"></span>         */
<span id="line20970" class="line"></span>        this.abort = function() {
<span id="line20971" class="line"></span>            // this should call finish or fail
<span id="line20972" class="line"></span>            self.source.downloadTileAbort(self);
<span id="line20973" class="line"></span>            if (typeof selfAbort === "function") {
<span id="line20974" class="line"></span>                selfAbort();
<span id="line20975" class="line"></span>            }
<span id="line20976" class="line"></span>            self.fail("Image load aborted.", null);
<span id="line20977" class="line"></span>        };
<span id="line20978" class="line"></span>
<span id="line20979" class="line"></span>        this.source.downloadTileStart(this);
<span id="line20980" class="line"></span>    },
<span id="line20981" class="line"></span>
<span id="line20982" class="line"></span>    /**
<span id="line20983" class="line"></span>     * Prepares the image job to be part of batched mode. It does not override abort
<span id="line20984" class="line"></span>     * callback and does not set timeout, nor call any tile source APIs. Managed by parent batch.
<span id="line20985" class="line"></span>     * @method
<span id="line20986" class="line"></span>     * @private
<span id="line20987" class="line"></span>     * @memberof OpenSeadragon.ImageJob#
<span id="line20988" class="line"></span>     */
<span id="line20989" class="line"></span>    prepareForBatch: function() {
<span id="line20990" class="line"></span>        this.tries++;
<span id="line20991" class="line"></span>        this.jobId = -1;  // ensures methods above work, calling clearTimeout is noop
<span id="line20992" class="line"></span>    },
<span id="line20993" class="line"></span>
<span id="line20994" class="line"></span>    /**
<span id="line20995" class="line"></span>     * Finish this job. Should be called unless abort() was executed upon successful data retrieval.
<span id="line20996" class="line"></span>     *   Usage: context.finish(data, request, dataType=undefined). Pass the downloaded data object
<span id="line20997" class="line"></span>     *   add also reference to an ajax request if used. Optionally, specify what data type the data is.
<span id="line20998" class="line"></span>     * @param {*} data data that has been downloaded
<span id="line20999" class="line"></span>     * @param {XMLHttpRequest} request reference to the request if used
<span id="line21000" class="line"></span>     * @param {string} dataType data type identifier
<span id="line21001" class="line"></span>     *   fallback compatibility behavior: dataType treated as errorMessage if data is falsey value
<span id="line21002" class="line"></span>     * @memberof OpenSeadragon.ImageJob#
<span id="line21003" class="line"></span>     */
<span id="line21004" class="line"></span>    finish: function(data, request, dataType) {
<span id="line21005" class="line"></span>        if (!this.jobId) {
<span id="line21006" class="line"></span>            return;
<span id="line21007" class="line"></span>        }
<span id="line21008" class="line"></span>        // old behavior, no deprecation due to possible finish calls with invalid data item (e.g. different error)
<span id="line21009" class="line"></span>        if (isInvalidData(data)) {
<span id="line21010" class="line"></span>            this.fail(dataType || "[downloadTileStart-&gt;finish()] Retrieved data is invalid!", request);
<span id="line21011" class="line"></span>            return;
<span id="line21012" class="line"></span>        }
<span id="line21013" class="line"></span>
<span id="line21014" class="line"></span>        this.data = data;
<span id="line21015" class="line"></span>        this.request = request;
<span id="line21016" class="line"></span>        this.errorMsg = null;
<span id="line21017" class="line"></span>        this.dataType = dataType;
<span id="line21018" class="line"></span>
<span id="line21019" class="line"></span>        window.clearTimeout(this.jobId);
<span id="line21020" class="line"></span>        this.jobId = null;
<span id="line21021" class="line"></span>
<span id="line21022" class="line"></span>        this.callback(this);
<span id="line21023" class="line"></span>    },
<span id="line21024" class="line"></span>
<span id="line21025" class="line"></span>    /**
<span id="line21026" class="line"></span>     * Finish this job as a failure. Should be called unless abort() was executed upon unsuccessful request.
<span id="line21027" class="line"></span>     *   Usage: context.fail(errMessage, request). Provide error message in case of failure,
<span id="line21028" class="line"></span>     *   add also reference to an ajax request if used.
<span id="line21029" class="line"></span>     * @param {string} errorMessage description upon failure
<span id="line21030" class="line"></span>     * @param {XMLHttpRequest} request reference to the request if used
<span id="line21031" class="line"></span>     */
<span id="line21032" class="line"></span>    fail: function(errorMessage, request) {
<span id="line21033" class="line"></span>        this.data = null;
<span id="line21034" class="line"></span>        this.request = request;
<span id="line21035" class="line"></span>        this.errorMsg = errorMessage;
<span id="line21036" class="line"></span>        this.dataType = null;
<span id="line21037" class="line"></span>
<span id="line21038" class="line"></span>        if (this.jobId) {
<span id="line21039" class="line"></span>            window.clearTimeout(this.jobId);
<span id="line21040" class="line"></span>            this.jobId = null;
<span id="line21041" class="line"></span>        }
<span id="line21042" class="line"></span>
<span id="line21043" class="line"></span>        this.callback(this);
<span id="line21044" class="line"></span>    }
<span id="line21045" class="line"></span>};
<span id="line21046" class="line"></span>
<span id="line21047" class="line"></span>/**
<span id="line21048" class="line"></span> * @class BatchImageJob
<span id="line21049" class="line"></span> * @memberof OpenSeadragon
<span id="line21050" class="line"></span> * @classdesc Wraps a group of ImageJobs as a single unit of work for the ImageLoader queue.
<span id="line21051" class="line"></span> * It mimics the ImageJob API so it can be managed in a similar way.
<span id="line21052" class="line"></span> * @param {Object} options
<span id="line21053" class="line"></span> * @param {TileSource} options.source
<span id="line21054" class="line"></span> * @param {Array&lt;OpenSeadragon.ImageJob&gt;} options.jobs
<span id="line21055" class="line"></span> * @param {Function} [options.callback]
<span id="line21056" class="line"></span> * @param {Function} [options.abort]
<span id="line21057" class="line"></span> */
<span id="line21058" class="line"></span>$.BatchImageJob = function(options) {
<span id="line21059" class="line"></span>    $.extend(true, this, {
<span id="line21060" class="line"></span>        timeout: $.DEFAULT_SETTINGS.timeout,
<span id="line21061" class="line"></span>        jobId: null,
<span id="line21062" class="line"></span>        data: null,
<span id="line21063" class="line"></span>        dataType: null,
<span id="line21064" class="line"></span>        errorMsg: null
<span id="line21065" class="line"></span>    }, options);
<span id="line21066" class="line"></span>
<span id="line21067" class="line"></span>    this.jobs = options.jobs || [];
<span id="line21068" class="line"></span>    this.source = options.source;
<span id="line21069" class="line"></span>};
<span id="line21070" class="line"></span>
<span id="line21071" class="line"></span>$.BatchImageJob.prototype = {
<span id="line21072" class="line"></span>    /**
<span id="line21073" class="line"></span>     * Starts the batch job.
<span id="line21074" class="line"></span>     */
<span id="line21075" class="line"></span>    start: function() {
<span id="line21076" class="line"></span>        this._finishedJobs = 0;
<span id="line21077" class="line"></span>        const self = this;
<span id="line21078" class="line"></span>
<span id="line21079" class="line"></span>        // Set timeout for the whole batch
<span id="line21080" class="line"></span>        this.jobId = window.setTimeout(function () {
<span id="line21081" class="line"></span>            self.fail("Batch image load exceeded timeout (" + self.timeout + " ms)", null);
<span id="line21082" class="line"></span>        }, this.timeout);
<span id="line21083" class="line"></span>
<span id="line21084" class="line"></span>        this.abort = function() {
<span id="line21085" class="line"></span>            // we don't call job.start() for each job, so abort is callable here
<span id="line21086" class="line"></span>            self.source.downloadTileBatchAbort(self);
<span id="line21087" class="line"></span>            for (let j of this.jobs) {
<span id="line21088" class="line"></span>                // Abort only running jobs by checking jobId. In theory, all should finish at once,
<span id="line21089" class="line"></span>                // but we cannot enforce the logic executed by each batch job.
<span id="line21090" class="line"></span>                if (j.jobId &amp;&amp; j.abort) {
<span id="line21091" class="line"></span>                    j.abort();
<span id="line21092" class="line"></span>                }
<span id="line21093" class="line"></span>            }
<span id="line21094" class="line"></span>        };
<span id="line21095" class="line"></span>
<span id="line21096" class="line"></span>        const wrap = (fn, job) =&gt; {
<span id="line21097" class="line"></span>            return (...args) =&gt; {
<span id="line21098" class="line"></span>                if (!this.jobId) {
<span id="line21099" class="line"></span>                    return;
<span id="line21100" class="line"></span>                }
<span id="line21101" class="line"></span>                this._finishedJobs++;
<span id="line21102" class="line"></span>                fn.call(job, ...args);
<span id="line21103" class="line"></span>                if (this._finishedJobs === this.jobs.length) {
<span id="line21104" class="line"></span>                    window.clearTimeout(this.jobId);
<span id="line21105" class="line"></span>                    this.jobId = null;
<span id="line21106" class="line"></span>                    if (this.callback) {
<span id="line21107" class="line"></span>                        this.callback(this);
<span id="line21108" class="line"></span>                    }
<span id="line21109" class="line"></span>                }
<span id="line21110" class="line"></span>            };
<span id="line21111" class="line"></span>        };
<span id="line21112" class="line"></span>
<span id="line21113" class="line"></span>        for (let j of this.jobs) {
<span id="line21114" class="line"></span>            // Handle timeout securely
<span id="line21115" class="line"></span>            j.finish = wrap(j.finish, j);
<span id="line21116" class="line"></span>            j.fail = wrap(j.fail, j);
<span id="line21117" class="line"></span>            j.prepareForBatch();
<span id="line21118" class="line"></span>        }
<span id="line21119" class="line"></span>
<span id="line21120" class="line"></span>        this.source.downloadTileBatchStart(this);
<span id="line21121" class="line"></span>    },
<span id="line21122" class="line"></span>
<span id="line21123" class="line"></span>    /**
<span id="line21124" class="line"></span>     * Finish is defined as not to throw when accidentally used, but should not be called.
<span id="line21125" class="line"></span>     */
<span id="line21126" class="line"></span>    finish: function(data, request, dataType) {
<span id="line21127" class="line"></span>        $.console.error('Finish call on batch job is not desirable: call finish on individual child jobs!', data, request);
<span id="line21128" class="line"></span>    },
<span id="line21129" class="line"></span>
<span id="line21130" class="line"></span>    /**
<span id="line21131" class="line"></span>     * Finish all batched jobs as a failure. This is available mainly for ImageLoader class logics,
<span id="line21132" class="line"></span>     * implementations should fail/finish/abort individual jobs directly.
<span id="line21133" class="line"></span>     * @param {string} errorMessage description upon failure
<span id="line21134" class="line"></span>     * @param {XMLHttpRequest} request reference to the request if used
<span id="line21135" class="line"></span>     */
<span id="line21136" class="line"></span>    fail: function(errorMessage, request) {
<span id="line21137" class="line"></span>        this.data = null;
<span id="line21138" class="line"></span>        this.request = request;
<span id="line21139" class="line"></span>        this.errorMsg = errorMessage;
<span id="line21140" class="line"></span>        this.dataType = null;
<span id="line21141" class="line"></span>
<span id="line21142" class="line"></span>        // Fail before setting jobId to null, which is checked for in wrapped fail call.
<span id="line21143" class="line"></span>        for (let i = 0; i &lt; this.jobs.length; i++) {
<span id="line21144" class="line"></span>            if (this.jobs[i].jobId) { // If still running
<span id="line21145" class="line"></span>                this.jobs[i].fail(errorMessage || "Batch failed", request);
<span id="line21146" class="line"></span>            }
<span id="line21147" class="line"></span>        }
<span id="line21148" class="line"></span>
<span id="line21149" class="line"></span>        if (this.jobId) {
<span id="line21150" class="line"></span>            window.clearTimeout(this.jobId);
<span id="line21151" class="line"></span>            this.jobId = null;
<span id="line21152" class="line"></span>        }
<span id="line21153" class="line"></span>
<span id="line21154" class="line"></span>        if (this.callback) {
<span id="line21155" class="line"></span>            this.callback(this);
<span id="line21156" class="line"></span>        }
<span id="line21157" class="line"></span>    }
<span id="line21158" class="line"></span>};
<span id="line21159" class="line"></span>
<span id="line21160" class="line"></span>/**
<span id="line21161" class="line"></span> * @class ImageLoader
<span id="line21162" class="line"></span> * @memberof OpenSeadragon
<span id="line21163" class="line"></span> * @classdesc Handles downloading of a set of images using asynchronous queue pattern.
<span id="line21164" class="line"></span> * You generally won't have to interact with the ImageLoader directly.
<span id="line21165" class="line"></span> * @param {Object} options - Options for this ImageLoader.
<span id="line21166" class="line"></span> * @param {Number} [options.jobLimit] - The number of concurrent image requests. See imageLoaderLimit in {@link OpenSeadragon.Options} for details.
<span id="line21167" class="line"></span> * @param {Number} [options.timeout] - The max number of milliseconds that an image job may take to complete.
<span id="line21168" class="line"></span> */
<span id="line21169" class="line"></span>$.ImageLoader = function(options) {
<span id="line21170" class="line"></span>
<span id="line21171" class="line"></span>    $.extend(true, this, {
<span id="line21172" class="line"></span>        jobLimit:       $.DEFAULT_SETTINGS.imageLoaderLimit,
<span id="line21173" class="line"></span>        timeout:        $.DEFAULT_SETTINGS.timeout,
<span id="line21174" class="line"></span>        jobQueue:       [],
<span id="line21175" class="line"></span>        failedTiles:    [],
<span id="line21176" class="line"></span>        jobsInProgress: 0
<span id="line21177" class="line"></span>    }, options);
<span id="line21178" class="line"></span>
<span id="line21179" class="line"></span>    this._batchBuckets = [];
<span id="line21180" class="line"></span>};
<span id="line21181" class="line"></span>
<span id="line21182" class="line"></span>/** @lends OpenSeadragon.ImageLoader.prototype */
<span id="line21183" class="line"></span>$.ImageLoader.prototype = {
<span id="line21184" class="line"></span>
<span id="line21185" class="line"></span>    /**
<span id="line21186" class="line"></span>     * Add an unloaded image to the loader queue.
<span id="line21187" class="line"></span>     * @method
<span id="line21188" class="line"></span>     * @param {Object} options - Options for this job.
<span id="line21189" class="line"></span>     * @param {TileSource} options.source - Image loading strategy definition
<span id="line21190" class="line"></span>     * @param {String} [options.src] - URL of image to download.
<span id="line21191" class="line"></span>     * @param {Tile} [options.tile] - Tile that belongs the data to. The tile instance
<span id="line21192" class="line"></span>     *      is not internally used and serves for custom TileSources implementations.
<span id="line21193" class="line"></span>     * @param {String} [options.loadWithAjax] - Whether to load this image with AJAX.
<span id="line21194" class="line"></span>     * @param {String} [options.ajaxHeaders] - Headers to add to the image request if using AJAX.
<span id="line21195" class="line"></span>     * @param {String|Boolean} [options.crossOriginPolicy] - CORS policy to use for downloads
<span id="line21196" class="line"></span>     * @param {String} [options.postData] - POST parameters (usually but not necessarily in k=v&amp;k2=v2... form,
<span id="line21197" class="line"></span>     *      see TileSource::getTilePostData) or null
<span id="line21198" class="line"></span>     * @param {Boolean} [options.ajaxWithCredentials] - Whether to set withCredentials on AJAX
<span id="line21199" class="line"></span>     *      requests.
<span id="line21200" class="line"></span>     * @param {Function} [options.callback] - Called once image has been downloaded.
<span id="line21201" class="line"></span>     * @param {Function} [options.abort] - Called when this image job is aborted.
<span id="line21202" class="line"></span>     * @returns {boolean} true if job was immediatelly started, false if queued
<span id="line21203" class="line"></span>     */
<span id="line21204" class="line"></span>    addJob: function(options) {
<span id="line21205" class="line"></span>        if (!options.source) {
<span id="line21206" class="line"></span>            $.console.error('ImageLoader.prototype.addJob() requires [options.source]...');
<span id="line21207" class="line"></span>            options.source = $.TileSource.prototype;
<span id="line21208" class="line"></span>        }
<span id="line21209" class="line"></span>
<span id="line21210" class="line"></span>        const _this = this,
<span id="line21211" class="line"></span>            jobOptions = {
<span id="line21212" class="line"></span>                src: options.src,
<span id="line21213" class="line"></span>                tile: options.tile || {},
<span id="line21214" class="line"></span>                source: options.source,
<span id="line21215" class="line"></span>                loadWithAjax: options.loadWithAjax,
<span id="line21216" class="line"></span>                ajaxHeaders: options.loadWithAjax ? options.ajaxHeaders : null,
<span id="line21217" class="line"></span>                crossOriginPolicy: options.crossOriginPolicy,
<span id="line21218" class="line"></span>                ajaxWithCredentials: options.ajaxWithCredentials,
<span id="line21219" class="line"></span>                postData: options.postData,
<span id="line21220" class="line"></span>                callback: (job) =&gt; completeJob(_this, job, options.callback),
<span id="line21221" class="line"></span>                abort: options.abort,
<span id="line21222" class="line"></span>                timeout: this.timeout
<span id="line21223" class="line"></span>            },
<span id="line21224" class="line"></span>            newJob = new $.ImageJob(jobOptions);
<span id="line21225" class="line"></span>
<span id="line21226" class="line"></span>        const sourceWantsBatching = options.source &amp;&amp; options.source.batchEnabled();
<span id="line21227" class="line"></span>        if (sourceWantsBatching) {
<span id="line21228" class="line"></span>            // Mark job as batched so completeJob knows not to decrement global counters
<span id="line21229" class="line"></span>            newJob.isBatched = true;
<span id="line21230" class="line"></span>            this._stageJobForBatching(newJob, options.source);
<span id="line21231" class="line"></span>            return false;
<span id="line21232" class="line"></span>        }
<span id="line21233" class="line"></span>
<span id="line21234" class="line"></span>        if ( !this.jobLimit || this.jobsInProgress &lt; this.jobLimit ) {
<span id="line21235" class="line"></span>            newJob.start();
<span id="line21236" class="line"></span>            this.jobsInProgress++;
<span id="line21237" class="line"></span>            return true;
<span id="line21238" class="line"></span>        }
<span id="line21239" class="line"></span>        this.jobQueue.push( newJob );
<span id="line21240" class="line"></span>        return false;
<span id="line21241" class="line"></span>    },
<span id="line21242" class="line"></span>
<span id="line21243" class="line"></span>    /**
<span id="line21244" class="line"></span>     * Internal method to group jobs.
<span id="line21245" class="line"></span>     * @private
<span id="line21246" class="line"></span>     */
<span id="line21247" class="line"></span>    _stageJobForBatching: function(newJob, source) {
<span id="line21248" class="line"></span>        let bucket = null;
<span id="line21249" class="line"></span>        for (let i = 0; i &lt; this._batchBuckets.length; i++) {
<span id="line21250" class="line"></span>            if (this._batchBuckets[i].source.batchCompatible(source)) {
<span id="line21251" class="line"></span>                bucket = this._batchBuckets[i];
<span id="line21252" class="line"></span>                break;
<span id="line21253" class="line"></span>            }
<span id="line21254" class="line"></span>        }
<span id="line21255" class="line"></span>
<span id="line21256" class="line"></span>        if (bucket &amp;&amp; !bucket.timer) {
<span id="line21257" class="line"></span>            $.console.error(
<span id="line21258" class="line"></span>                'Attempted to add a new job to a batch bucket that has already been flushed. ' +
<span id="line21259" class="line"></span>                'Creating a new batch bucket for this source. ' +
<span id="line21260" class="line"></span>                'Check batch logic and timing if this happens frequently. ' +
<span id="line21261" class="line"></span>                'Bucket source:', source, 'Job ID:', newJob &amp;&amp; newJob.jobId
<span id="line21262" class="line"></span>            );
<span id="line21263" class="line"></span>            bucket = null;
<span id="line21264" class="line"></span>        }
<span id="line21265" class="line"></span>
<span id="line21266" class="line"></span>        if (!bucket) {
<span id="line21267" class="line"></span>            bucket = {
<span id="line21268" class="line"></span>                source: source,
<span id="line21269" class="line"></span>                jobs: [],
<span id="line21270" class="line"></span>                timer: null,
<span id="line21271" class="line"></span>                waitTimeout: source.batchTimeout(),
<span id="line21272" class="line"></span>                maxJobs: source.batchMaxJobs()
<span id="line21273" class="line"></span>            };
<span id="line21274" class="line"></span>            bucket.timer = setTimeout(() =&gt; this._flushBatchBucket(bucket), bucket.waitTimeout);
<span id="line21275" class="line"></span>            this._batchBuckets.push(bucket);
<span id="line21276" class="line"></span>        }
<span id="line21277" class="line"></span>
<span id="line21278" class="line"></span>        bucket.jobs.push(newJob);
<span id="line21279" class="line"></span>
<span id="line21280" class="line"></span>        if (bucket.maxJobs &gt;= 1 &amp;&amp; bucket.jobs.length &gt;= bucket.maxJobs) {
<span id="line21281" class="line"></span>            clearTimeout(bucket.timer);
<span id="line21282" class="line"></span>            this._flushBatchBucket(bucket);
<span id="line21283" class="line"></span>        }
<span id="line21284" class="line"></span>    },
<span id="line21285" class="line"></span>
<span id="line21286" class="line"></span>    /**
<span id="line21287" class="line"></span>     * Flushes a specific bucket, creating a BatchJob and submitting it to the main queue logic.
<span id="line21288" class="line"></span>     * @private
<span id="line21289" class="line"></span>     */
<span id="line21290" class="line"></span>    _flushBatchBucket: function(bucket) {
<span id="line21291" class="line"></span>        bucket.timer = null;
<span id="line21292" class="line"></span>        const index = this._batchBuckets.indexOf(bucket);
<span id="line21293" class="line"></span>        if (index &gt; -1) {
<span id="line21294" class="line"></span>            this._batchBuckets.splice(index, 1);
<span id="line21295" class="line"></span>        }
<span id="line21296" class="line"></span>
<span id="line21297" class="line"></span>        if (bucket.jobs.length === 0) {
<span id="line21298" class="line"></span>            return;
<span id="line21299" class="line"></span>        }
<span id="line21300" class="line"></span>
<span id="line21301" class="line"></span>        const _this = this;
<span id="line21302" class="line"></span>        const batchJob = new $.BatchImageJob({
<span id="line21303" class="line"></span>            source: bucket.source,
<span id="line21304" class="line"></span>            jobs: bucket.jobs,
<span id="line21305" class="line"></span>            timeout: this.timeout,
<span id="line21306" class="line"></span>            callback: (job) =&gt; completeBatchJob(_this, job),
<span id="line21307" class="line"></span>            // no abort here
<span id="line21308" class="line"></span>        });
<span id="line21309" class="line"></span>
<span id="line21310" class="line"></span>        if ( !this.jobLimit || this.jobsInProgress &lt; this.jobLimit ) {
<span id="line21311" class="line"></span>            batchJob.start();
<span id="line21312" class="line"></span>            this.jobsInProgress++;
<span id="line21313" class="line"></span>        } else {
<span id="line21314" class="line"></span>            this.jobQueue.push(batchJob);
<span id="line21315" class="line"></span>        }
<span id="line21316" class="line"></span>    },
<span id="line21317" class="line"></span>
<span id="line21318" class="line"></span>    /**
<span id="line21319" class="line"></span>     * @returns {boolean} true if a job can be submitted
<span id="line21320" class="line"></span>     */
<span id="line21321" class="line"></span>    canAcceptNewJob() {
<span id="line21322" class="line"></span>        return !this.jobLimit || this.jobsInProgress &lt; this.jobLimit;
<span id="line21323" class="line"></span>    },
<span id="line21324" class="line"></span>
<span id="line21325" class="line"></span>    /**
<span id="line21326" class="line"></span>     * Clear any unstarted image loading jobs from the queue.
<span id="line21327" class="line"></span>     * @method
<span id="line21328" class="line"></span>     */
<span id="line21329" class="line"></span>    clear: function() {
<span id="line21330" class="line"></span>        for( let i = 0; i &lt; this.jobQueue.length; i++ ) {
<span id="line21331" class="line"></span>            const job = this.jobQueue[i];
<span id="line21332" class="line"></span>            if ( typeof job.abort === "function" ) {
<span id="line21333" class="line"></span>                job.abort();
<span id="line21334" class="line"></span>            }
<span id="line21335" class="line"></span>        }
<span id="line21336" class="line"></span>        this.jobQueue = [];
<span id="line21337" class="line"></span>
<span id="line21338" class="line"></span>        if (this._batchBuckets) {
<span id="line21339" class="line"></span>            for (let i = 0; i &lt; this._batchBuckets.length; i++) {
<span id="line21340" class="line"></span>                const bucket = this._batchBuckets[i];
<span id="line21341" class="line"></span>                clearTimeout(bucket.timer);
<span id="line21342" class="line"></span>                bucket.timer = null;
<span id="line21343" class="line"></span>                // Jobs in buckets haven't started, no abort needed typically, just drop refs
<span id="line21344" class="line"></span>            }
<span id="line21345" class="line"></span>            this._batchBuckets = [];
<span id="line21346" class="line"></span>        }
<span id="line21347" class="line"></span>    }
<span id="line21348" class="line"></span>};
<span id="line21349" class="line"></span>
<span id="line21350" class="line"></span>/**
<span id="line21351" class="line"></span> * Cleans up ImageJob once completed. Restarts job after tileRetryDelay seconds if failed
<span id="line21352" class="line"></span> * but max tileRetryMax times
<span id="line21353" class="line"></span> * @method
<span id="line21354" class="line"></span> * @private
<span id="line21355" class="line"></span> * @param loader - ImageLoader used to start job.
<span id="line21356" class="line"></span> * @param {OpenSeadragon.ImageJob} job - The ImageJob that has completed.
<span id="line21357" class="line"></span> * @param callback - Called once cleanup is finished.
<span id="line21358" class="line"></span> */
<span id="line21359" class="line"></span>function completeJob(loader, job, callback) {
<span id="line21360" class="line"></span>    if (job.errorMsg &amp;&amp; job.data === null &amp;&amp; job.tries &lt; 1 + loader.tileRetryMax) {
<span id="line21361" class="line"></span>        // Retries are ran separately.
<span id="line21362" class="line"></span>        job.isBatched = false;
<span id="line21363" class="line"></span>        loader.failedTiles.push(job);
<span id="line21364" class="line"></span>    }
<span id="line21365" class="line"></span>
<span id="line21366" class="line"></span>    // CRITICAL: Child batch job items are marked as batched - do NOT decrement.
<span id="line21367" class="line"></span>    if (!job.isBatched) {
<span id="line21368" class="line"></span>        loader.jobsInProgress--;
<span id="line21369" class="line"></span>    }
<span id="line21370" class="line"></span>
<span id="line21371" class="line"></span>    if (loader.canAcceptNewJob() &amp;&amp; loader.jobQueue.length &gt; 0) {
<span id="line21372" class="line"></span>        let nextJob = loader.jobQueue.shift();
<span id="line21373" class="line"></span>        nextJob.start();
<span id="line21374" class="line"></span>        loader.jobsInProgress++;
<span id="line21375" class="line"></span>    }
<span id="line21376" class="line"></span>
<span id="line21377" class="line"></span>    if (loader.tileRetryMax &gt; 0 &amp;&amp; loader.jobQueue.length === 0) {
<span id="line21378" class="line"></span>        if (loader.canAcceptNewJob() &amp;&amp; loader.failedTiles.length &gt; 0) {
<span id="line21379" class="line"></span>            let nextJob = loader.failedTiles.shift();
<span id="line21380" class="line"></span>            setTimeout(function () {
<span id="line21381" class="line"></span>                nextJob.start();
<span id="line21382" class="line"></span>            }, loader.tileRetryDelay);
<span id="line21383" class="line"></span>            loader.jobsInProgress++;
<span id="line21384" class="line"></span>        }
<span id="line21385" class="line"></span>    }
<span id="line21386" class="line"></span>
<span id="line21387" class="line"></span>    if (callback) {
<span id="line21388" class="line"></span>        callback(job.data, job.errorMsg, job.request, job.dataType, job.tries);
<span id="line21389" class="line"></span>    }
<span id="line21390" class="line"></span>}
<span id="line21391" class="line"></span>
<span id="line21392" class="line"></span>/**
<span id="line21393" class="line"></span> * Cleans up BatchImageJob once completed. Explicit here so it's easier to debug,
<span id="line21394" class="line"></span> * In fact batch job does not need to do anything except decrementing counter.
<span id="line21395" class="line"></span> * @method
<span id="line21396" class="line"></span> * @private
<span id="line21397" class="line"></span> * @param loader - ImageLoader used to start job.
<span id="line21398" class="line"></span> * @param {BatchImageJob} job - The ImageJob that has completed.
<span id="line21399" class="line"></span> */
<span id="line21400" class="line"></span>function completeBatchJob(loader, job) {
<span id="line21401" class="line"></span>    loader.jobsInProgress--;
<span id="line21402" class="line"></span>    job.jobs.length = 0; // make sure items are detached
<span id="line21403" class="line"></span>}
<span id="line21404" class="line"></span>
<span id="line21405" class="line"></span>// Consistent data validity checker
<span id="line21406" class="line"></span>function isInvalidData(dataItem) {
<span id="line21407" class="line"></span>    return dataItem === null || dataItem === undefined || dataItem === false;
<span id="line21408" class="line"></span>}
<span id="line21409" class="line"></span>
<span id="line21410" class="line"></span>}(OpenSeadragon));
<span id="line21411" class="line"></span>
<span id="line21412" class="line"></span>/*
<span id="line21413" class="line"></span> * OpenSeadragon - Tile
<span id="line21414" class="line"></span> *
<span id="line21415" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line21416" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line21417" class="line"></span> *
<span id="line21418" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line21419" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line21420" class="line"></span> * met:
<span id="line21421" class="line"></span> *
<span id="line21422" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line21423" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line21424" class="line"></span> *
<span id="line21425" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line21426" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line21427" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line21428" class="line"></span> *
<span id="line21429" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line21430" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line21431" class="line"></span> *   this software without specific prior written permission.
<span id="line21432" class="line"></span> *
<span id="line21433" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line21434" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line21435" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line21436" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line21437" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line21438" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line21439" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line21440" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line21441" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line21442" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line21443" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line21444" class="line"></span> */
<span id="line21445" class="line"></span>
<span id="line21446" class="line"></span>(function( $ ){
<span id="line21447" class="line"></span>
<span id="line21448" class="line"></span>/**
<span id="line21449" class="line"></span> * @class Tile
<span id="line21450" class="line"></span> * @memberof OpenSeadragon
<span id="line21451" class="line"></span> * @param {Number} level The zoom level this tile belongs to.
<span id="line21452" class="line"></span> * @param {Number} x The vector component 'x'.
<span id="line21453" class="line"></span> * @param {Number} y The vector component 'y'.
<span id="line21454" class="line"></span> * @param {OpenSeadragon.Rect} bounds Where this tile fits, in normalized
<span id="line21455" class="line"></span> *      coordinates.
<span id="line21456" class="line"></span> * @param {Boolean} exists Is this tile a part of a sparse image? ( Also has
<span id="line21457" class="line"></span> *      this tile failed to load? )
<span id="line21458" class="line"></span> * @param {String|Function} url The URL of this tile's image or a function that returns a url.
<span id="line21459" class="line"></span> * @param {CanvasRenderingContext2D} [context2D=undefined] The context2D of this tile if it
<span id="line21460" class="line"></span> *  *      is provided directly by the tile source. Deprecated: use Tile::addCache(...) instead.
<span id="line21461" class="line"></span> * @param {Boolean} loadWithAjax Whether this tile image should be loaded with an AJAX request .
<span id="line21462" class="line"></span> * @param {Object} ajaxHeaders The headers to send with this tile's AJAX request (if applicable).
<span id="line21463" class="line"></span> * @param {OpenSeadragon.Rect} sourceBounds The portion of the tile to use as the source of the
<span id="line21464" class="line"></span> *      drawing operation, in pixels. Note that this only works when drawing with canvas; when drawing
<span id="line21465" class="line"></span> *      with HTML the entire tile is always used.
<span id="line21466" class="line"></span> * @param {String} postData HTTP POST data (usually but not necessarily in k=v&amp;k2=v2... form,
<span id="line21467" class="line"></span> *      see TileSource::getTilePostData) or null
<span id="line21468" class="line"></span> * @param {String} cacheKey key to act as a tile cache, must be unique for tiles with unique image data
<span id="line21469" class="line"></span> */
<span id="line21470" class="line"></span>$.Tile = function(level, x, y, bounds, exists, url, context2D, loadWithAjax, ajaxHeaders, sourceBounds, postData, cacheKey) {
<span id="line21471" class="line"></span>    /**
<span id="line21472" class="line"></span>     * The zoom level this tile belongs to.
<span id="line21473" class="line"></span>     * @member {Number} level
<span id="line21474" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21475" class="line"></span>     */
<span id="line21476" class="line"></span>    this.level   = level;
<span id="line21477" class="line"></span>    /**
<span id="line21478" class="line"></span>     * The vector component 'x'.
<span id="line21479" class="line"></span>     * @member {Number} x
<span id="line21480" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21481" class="line"></span>     */
<span id="line21482" class="line"></span>    this.x       = x;
<span id="line21483" class="line"></span>    /**
<span id="line21484" class="line"></span>     * The vector component 'y'.
<span id="line21485" class="line"></span>     * @member {Number} y
<span id="line21486" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21487" class="line"></span>     */
<span id="line21488" class="line"></span>    this.y       = y;
<span id="line21489" class="line"></span>    /**
<span id="line21490" class="line"></span>     * Where this tile fits, in normalized coordinates
<span id="line21491" class="line"></span>     * @member {OpenSeadragon.Rect} bounds
<span id="line21492" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21493" class="line"></span>     */
<span id="line21494" class="line"></span>    this.bounds  = bounds;
<span id="line21495" class="line"></span>    /**
<span id="line21496" class="line"></span>     * Where this tile fits, in normalized coordinates, after positioning
<span id="line21497" class="line"></span>     * @member {OpenSeadragon.Rect} positionedBounds
<span id="line21498" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21499" class="line"></span>     */
<span id="line21500" class="line"></span>    this.positionedBounds  = new OpenSeadragon.Rect(bounds.x, bounds.y, bounds.width, bounds.height);
<span id="line21501" class="line"></span>    /**
<span id="line21502" class="line"></span>     * The portion of the tile to use as the source of the drawing operation, in pixels. Note that
<span id="line21503" class="line"></span>     * this property is ignored with HTML drawer where the whole tile is always drawn.
<span id="line21504" class="line"></span>     * @member {OpenSeadragon.Rect} sourceBounds
<span id="line21505" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21506" class="line"></span>     */
<span id="line21507" class="line"></span>    this.sourceBounds = sourceBounds;
<span id="line21508" class="line"></span>    /**
<span id="line21509" class="line"></span>     * Is this tile a part of a sparse image? Also has this tile failed to load?
<span id="line21510" class="line"></span>     * @member {Boolean} exists
<span id="line21511" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21512" class="line"></span>     */
<span id="line21513" class="line"></span>    this.exists  = exists;
<span id="line21514" class="line"></span>    /**
<span id="line21515" class="line"></span>     * Private property to hold string url or url retriever function.
<span id="line21516" class="line"></span>     * Consumers should access via Tile.getUrl()
<span id="line21517" class="line"></span>     * @member {String|Function} url
<span id="line21518" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21519" class="line"></span>     * @private
<span id="line21520" class="line"></span>     */
<span id="line21521" class="line"></span>    this._url     = url;
<span id="line21522" class="line"></span>    /**
<span id="line21523" class="line"></span>     * Post parameters for this tile. For example, it can be an URL-encoded string
<span id="line21524" class="line"></span>     * in k1=v1&amp;k2=v2... format, or a JSON, or a FormData instance... or null if no POST request used
<span id="line21525" class="line"></span>     * @member {String} postData HTTP POST data (usually but not necessarily in k=v&amp;k2=v2... form,
<span id="line21526" class="line"></span>     *      see TileSource::getTilePostData) or null
<span id="line21527" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21528" class="line"></span>     */
<span id="line21529" class="line"></span>    this.postData  = postData;
<span id="line21530" class="line"></span>    /**
<span id="line21531" class="line"></span>     * The context2D of this tile if it is provided directly by the tile source.
<span id="line21532" class="line"></span>     * @member {CanvasRenderingContext2D} context2D
<span id="line21533" class="line"></span>     * @memberOf OpenSeadragon.Tile#
<span id="line21534" class="line"></span>     */
<span id="line21535" class="line"></span>    if (context2D) {
<span id="line21536" class="line"></span>        this.context2D = context2D;
<span id="line21537" class="line"></span>    }
<span id="line21538" class="line"></span>    /**
<span id="line21539" class="line"></span>     * Whether to load this tile's image with an AJAX request.
<span id="line21540" class="line"></span>     * @member {Boolean} loadWithAjax
<span id="line21541" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21542" class="line"></span>     */
<span id="line21543" class="line"></span>    this.loadWithAjax = loadWithAjax;
<span id="line21544" class="line"></span>    /**
<span id="line21545" class="line"></span>     * The headers to be used in requesting this tile's image.
<span id="line21546" class="line"></span>     * Only used if loadWithAjax is set to true.
<span id="line21547" class="line"></span>     * @member {Object} ajaxHeaders
<span id="line21548" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21549" class="line"></span>     */
<span id="line21550" class="line"></span>    this.ajaxHeaders = ajaxHeaders;
<span id="line21551" class="line"></span>
<span id="line21552" class="line"></span>    if (cacheKey === undefined) {
<span id="line21553" class="line"></span>        $.console.warn("Tile constructor needs 'cacheKey' variable: creation tile cache" +
<span id="line21554" class="line"></span>            " in Tile class is deprecated. TileSource.prototype.getTileHashKey will be used.");
<span id="line21555" class="line"></span>        cacheKey = $.TileSource.prototype.getTileHashKey(level, x, y, url, ajaxHeaders, postData);
<span id="line21556" class="line"></span>    }
<span id="line21557" class="line"></span>
<span id="line21558" class="line"></span>    this._cKey = cacheKey || "";
<span id="line21559" class="line"></span>    this._ocKey = cacheKey || "";
<span id="line21560" class="line"></span>
<span id="line21561" class="line"></span>    /**
<span id="line21562" class="line"></span>     * Is this tile loaded?
<span id="line21563" class="line"></span>     * @member {Boolean} loaded
<span id="line21564" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21565" class="line"></span>     */
<span id="line21566" class="line"></span>    this.loaded  = false;
<span id="line21567" class="line"></span>    /**
<span id="line21568" class="line"></span>     * Is this tile loading?
<span id="line21569" class="line"></span>     * @member {Boolean} loading
<span id="line21570" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21571" class="line"></span>     */
<span id="line21572" class="line"></span>    this.loading = false;
<span id="line21573" class="line"></span>    /**
<span id="line21574" class="line"></span>     * This tile's position on screen, in pixels.
<span id="line21575" class="line"></span>     * @member {OpenSeadragon.Point} position
<span id="line21576" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21577" class="line"></span>     */
<span id="line21578" class="line"></span>    this.position   = null;
<span id="line21579" class="line"></span>    /**
<span id="line21580" class="line"></span>     * This tile's size on screen, in pixels.
<span id="line21581" class="line"></span>     * @member {OpenSeadragon.Point} size
<span id="line21582" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21583" class="line"></span>     */
<span id="line21584" class="line"></span>    this.size       = null;
<span id="line21585" class="line"></span>    /**
<span id="line21586" class="line"></span>     * Whether to flip the tile when rendering.
<span id="line21587" class="line"></span>     * @member {Boolean} flipped
<span id="line21588" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21589" class="line"></span>     */
<span id="line21590" class="line"></span>    this.flipped    = false;
<span id="line21591" class="line"></span>    /**
<span id="line21592" class="line"></span>     * The start time of this tile's blending.
<span id="line21593" class="line"></span>     * @member {Number} blendStart
<span id="line21594" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21595" class="line"></span>     */
<span id="line21596" class="line"></span>    this.blendStart = null;
<span id="line21597" class="line"></span>    /**
<span id="line21598" class="line"></span>     * The current opacity this tile should be.
<span id="line21599" class="line"></span>     * @member {Number} opacity
<span id="line21600" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21601" class="line"></span>     */
<span id="line21602" class="line"></span>    this.opacity    = null;
<span id="line21603" class="line"></span>    /**
<span id="line21604" class="line"></span>     * The squared distance of this tile to the viewport center.
<span id="line21605" class="line"></span>     * Use for comparing tiles.
<span id="line21606" class="line"></span>     * @member {Number} squaredDistance
<span id="line21607" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21608" class="line"></span>     * @private
<span id="line21609" class="line"></span>     */
<span id="line21610" class="line"></span>    this.squaredDistance   = null;
<span id="line21611" class="line"></span>    /**
<span id="line21612" class="line"></span>     * The visibility score of this tile.
<span id="line21613" class="line"></span>     * @member {Number} visibility
<span id="line21614" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21615" class="line"></span>     */
<span id="line21616" class="line"></span>    this.visibility = null;
<span id="line21617" class="line"></span>
<span id="line21618" class="line"></span>    /**
<span id="line21619" class="line"></span>     * The transparency indicator of this tile.
<span id="line21620" class="line"></span>     * @member {Boolean} hasTransparency true if tile contains transparency for correct rendering
<span id="line21621" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21622" class="line"></span>     */
<span id="line21623" class="line"></span>    this.hasTransparency = false;
<span id="line21624" class="line"></span>
<span id="line21625" class="line"></span>    /**
<span id="line21626" class="line"></span>     * Whether this tile is currently being drawn.
<span id="line21627" class="line"></span>     * @member {Boolean} beingDrawn
<span id="line21628" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21629" class="line"></span>     */
<span id="line21630" class="line"></span>    this.beingDrawn     = false;
<span id="line21631" class="line"></span>
<span id="line21632" class="line"></span>    /**
<span id="line21633" class="line"></span>     * Timestamp the tile was last touched.
<span id="line21634" class="line"></span>     * @member {Number} lastTouchTime
<span id="line21635" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21636" class="line"></span>     */
<span id="line21637" class="line"></span>    this.lastTouchTime  = 0;
<span id="line21638" class="line"></span>
<span id="line21639" class="line"></span>    /**
<span id="line21640" class="line"></span>     * Whether this tile is in the right-most column for its level.
<span id="line21641" class="line"></span>     * @member {Boolean} isRightMost
<span id="line21642" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21643" class="line"></span>     */
<span id="line21644" class="line"></span>    this.isRightMost = false;
<span id="line21645" class="line"></span>
<span id="line21646" class="line"></span>    /**
<span id="line21647" class="line"></span>     * Whether this tile is in the bottom-most row for its level.
<span id="line21648" class="line"></span>     * @member {Boolean} isBottomMost
<span id="line21649" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21650" class="line"></span>     */
<span id="line21651" class="line"></span>    this.isBottomMost = false;
<span id="line21652" class="line"></span>
<span id="line21653" class="line"></span>    /**
<span id="line21654" class="line"></span>     * Owner of this tile. Do not change this property manually.
<span id="line21655" class="line"></span>     * @member {OpenSeadragon.TiledImage}
<span id="line21656" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21657" class="line"></span>     */
<span id="line21658" class="line"></span>    this.tiledImage = null;
<span id="line21659" class="line"></span>    /**
<span id="line21660" class="line"></span>     * Array of cached tile data associated with the tile.
<span id="line21661" class="line"></span>     * @member {Object}
<span id="line21662" class="line"></span>     * @private
<span id="line21663" class="line"></span>     */
<span id="line21664" class="line"></span>    this._caches = {};
<span id="line21665" class="line"></span>    /**
<span id="line21666" class="line"></span>     * Processing flag, exempt the tile from removal when there are ongoing updates
<span id="line21667" class="line"></span>     * @member {Boolean|Number}
<span id="line21668" class="line"></span>     * @private
<span id="line21669" class="line"></span>     */
<span id="line21670" class="line"></span>    this.processing = false;
<span id="line21671" class="line"></span>    /**
<span id="line21672" class="line"></span>     * Processing promise, resolves when the tile exits processing, or
<span id="line21673" class="line"></span>     * resolves immediatelly if not in the processing state.
<span id="line21674" class="line"></span>     * @member {OpenSeadragon.Promise&lt;OpenSeadragon.Tile&gt;}
<span id="line21675" class="line"></span>     * @private
<span id="line21676" class="line"></span>     */
<span id="line21677" class="line"></span>    this.processingPromise = $.Promise.resolve(this);
<span id="line21678" class="line"></span>};
<span id="line21679" class="line"></span>
<span id="line21680" class="line"></span>/** @lends OpenSeadragon.Tile.prototype */
<span id="line21681" class="line"></span>$.Tile.prototype = {
<span id="line21682" class="line"></span>
<span id="line21683" class="line"></span>    /**
<span id="line21684" class="line"></span>     * Provides a string representation of this tiles level and (x,y)
<span id="line21685" class="line"></span>     * components.
<span id="line21686" class="line"></span>     * @function
<span id="line21687" class="line"></span>     * @returns {String}
<span id="line21688" class="line"></span>     */
<span id="line21689" class="line"></span>    toString: function() {
<span id="line21690" class="line"></span>        return this.level + "/" + this.x + "_" + this.y;
<span id="line21691" class="line"></span>    },
<span id="line21692" class="line"></span>
<span id="line21693" class="line"></span>    /**
<span id="line21694" class="line"></span>     * The unique main cache key for this tile. Created automatically
<span id="line21695" class="line"></span>     *  from the given tiledImage.source.getTileHashKey(...) implementation.
<span id="line21696" class="line"></span>     * @member {String} cacheKey
<span id="line21697" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21698" class="line"></span>     * @private
<span id="line21699" class="line"></span>     */
<span id="line21700" class="line"></span>    get cacheKey() {
<span id="line21701" class="line"></span>        return this._cKey;
<span id="line21702" class="line"></span>    },
<span id="line21703" class="line"></span>    set cacheKey(value) {
<span id="line21704" class="line"></span>        if (value === this.cacheKey) {
<span id="line21705" class="line"></span>            return;
<span id="line21706" class="line"></span>        }
<span id="line21707" class="line"></span>        const cache = this.getCache(value);
<span id="line21708" class="line"></span>        if (!cache) {
<span id="line21709" class="line"></span>            // It's better to first set cache, then change the key to existing one. Warn if otherwise.
<span id="line21710" class="line"></span>            $.console.warn("[Tile.cacheKey] should not be set manually. Use addCache() with setAsMain=true.");
<span id="line21711" class="line"></span>        }
<span id="line21712" class="line"></span>        this._updateMainCacheKey(value);
<span id="line21713" class="line"></span>    },
<span id="line21714" class="line"></span>
<span id="line21715" class="line"></span>    /**
<span id="line21716" class="line"></span>     * By default equal to tile.cacheKey, marks a cache associated with this tile
<span id="line21717" class="line"></span>     * that holds the cache original data (it was loaded with). In case you
<span id="line21718" class="line"></span>     * change the tile data, the tile original data should be left with the cache
<span id="line21719" class="line"></span>     * 'originalCacheKey' and the new, modified data should be stored in cache 'cacheKey'.
<span id="line21720" class="line"></span>     * This key is used in cache resolution: in case new tile data is requested, if
<span id="line21721" class="line"></span>     * this cache key exists in the cache it is loaded.
<span id="line21722" class="line"></span>     * @member {String} originalCacheKey
<span id="line21723" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21724" class="line"></span>     * @private
<span id="line21725" class="line"></span>     */
<span id="line21726" class="line"></span>    set originalCacheKey(value) {
<span id="line21727" class="line"></span>        throw "Original Cache Key cannot be managed manually!";
<span id="line21728" class="line"></span>    },
<span id="line21729" class="line"></span>    get originalCacheKey() {
<span id="line21730" class="line"></span>        return this._ocKey;
<span id="line21731" class="line"></span>    },
<span id="line21732" class="line"></span>
<span id="line21733" class="line"></span>    /**
<span id="line21734" class="line"></span>     * The Image object for this tile.
<span id="line21735" class="line"></span>     * @member {Object} image
<span id="line21736" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21737" class="line"></span>     * @deprecated
<span id="line21738" class="line"></span>     * @returns {Image}
<span id="line21739" class="line"></span>     */
<span id="line21740" class="line"></span>    get image() {
<span id="line21741" class="line"></span>        $.console.error("[Tile.image] property has been deprecated. Use [Tile.getData] instead.");
<span id="line21742" class="line"></span>        return this.getImage();
<span id="line21743" class="line"></span>    },
<span id="line21744" class="line"></span>
<span id="line21745" class="line"></span>    /**
<span id="line21746" class="line"></span>     * The URL of this tile's image.
<span id="line21747" class="line"></span>     * @member {String} url
<span id="line21748" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21749" class="line"></span>     * @deprecated
<span id="line21750" class="line"></span>     * @returns {String}
<span id="line21751" class="line"></span>     */
<span id="line21752" class="line"></span>    get url() {
<span id="line21753" class="line"></span>        $.console.error("[Tile.url] property has been deprecated. Use [Tile.getUrl] instead.");
<span id="line21754" class="line"></span>        return this.getUrl();
<span id="line21755" class="line"></span>    },
<span id="line21756" class="line"></span>
<span id="line21757" class="line"></span>    /**
<span id="line21758" class="line"></span>     * The HTML div element for this tile
<span id="line21759" class="line"></span>     * @member {Element} element
<span id="line21760" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21761" class="line"></span>     * @deprecated
<span id="line21762" class="line"></span>     */
<span id="line21763" class="line"></span>    get element() {
<span id="line21764" class="line"></span>        $.console.error("Tile::element property is deprecated. Use cache API instead. Moreover, this property might be unstable.");
<span id="line21765" class="line"></span>        const cache = this.getCache();
<span id="line21766" class="line"></span>        if (!cache || !cache.loaded) {
<span id="line21767" class="line"></span>            return null;
<span id="line21768" class="line"></span>        }
<span id="line21769" class="line"></span>        if (cache.type !== OpenSeadragon.HTMLDrawer.canvasCacheType || cache.type !== OpenSeadragon.HTMLDrawer.imageCacheType) {
<span id="line21770" class="line"></span>            $.console.error("Access to HtmlDrawer property via Tile instance: HTMLDrawer must be used!");
<span id="line21771" class="line"></span>            return null;
<span id="line21772" class="line"></span>        }
<span id="line21773" class="line"></span>        return cache.data.element;
<span id="line21774" class="line"></span>    },
<span id="line21775" class="line"></span>
<span id="line21776" class="line"></span>    /**
<span id="line21777" class="line"></span>     * The HTML img element for this tile.
<span id="line21778" class="line"></span>     * @member {Element} imgElement
<span id="line21779" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21780" class="line"></span>     * @deprecated
<span id="line21781" class="line"></span>     */
<span id="line21782" class="line"></span>    get imgElement() {
<span id="line21783" class="line"></span>        $.console.error("Tile::imgElement property is deprecated. Use cache API instead. Moreover, this property might be unstable.");
<span id="line21784" class="line"></span>        const cache = this.getCache();
<span id="line21785" class="line"></span>        if (!cache || !cache.loaded) {
<span id="line21786" class="line"></span>            return null;
<span id="line21787" class="line"></span>        }
<span id="line21788" class="line"></span>        if (cache.type !== OpenSeadragon.HTMLDrawer.canvasCacheType || cache.type !== OpenSeadragon.HTMLDrawer.imageCacheType) {
<span id="line21789" class="line"></span>            $.console.error("Access to HtmlDrawer property via Tile instance: HTMLDrawer must be used!");
<span id="line21790" class="line"></span>            return null;
<span id="line21791" class="line"></span>        }
<span id="line21792" class="line"></span>        return cache.data.imgElement;
<span id="line21793" class="line"></span>    },
<span id="line21794" class="line"></span>
<span id="line21795" class="line"></span>    /**
<span id="line21796" class="line"></span>     * The alias of this.element.style.
<span id="line21797" class="line"></span>     * @member {String} style
<span id="line21798" class="line"></span>     * @memberof OpenSeadragon.Tile#
<span id="line21799" class="line"></span>     * @deprecated
<span id="line21800" class="line"></span>     */
<span id="line21801" class="line"></span>    get style() {
<span id="line21802" class="line"></span>        $.console.error("Tile::style property is deprecated. Use cache API instead. Moreover, this property might be unstable.");
<span id="line21803" class="line"></span>        const cache = this.getCache();
<span id="line21804" class="line"></span>        if (!cache || !cache.loaded) {
<span id="line21805" class="line"></span>            return null;
<span id="line21806" class="line"></span>        }
<span id="line21807" class="line"></span>        if (cache.type !== OpenSeadragon.HTMLDrawer.canvasCacheType || cache.type !== OpenSeadragon.HTMLDrawer.imageCacheType) {
<span id="line21808" class="line"></span>            $.console.error("Access to HtmlDrawer property via Tile instance: HTMLDrawer must be used!");
<span id="line21809" class="line"></span>            return null;
<span id="line21810" class="line"></span>        }
<span id="line21811" class="line"></span>        return cache.data.style;
<span id="line21812" class="line"></span>    },
<span id="line21813" class="line"></span>
<span id="line21814" class="line"></span>    /**
<span id="line21815" class="line"></span>     * Get the Image object for this tile.
<span id="line21816" class="line"></span>     * @returns {?Image}
<span id="line21817" class="line"></span>     * @deprecated
<span id="line21818" class="line"></span>     */
<span id="line21819" class="line"></span>    getImage: function() {
<span id="line21820" class="line"></span>        $.console.error("[Tile.getImage] property has been deprecated. Use 'tile-invalidated' routine event instead.");
<span id="line21821" class="line"></span>        //this method used to ensure the underlying data model conformed to given type - convert instead of getData()
<span id="line21822" class="line"></span>        const cache = this.getCache(this.cacheKey);
<span id="line21823" class="line"></span>        if (!cache) {
<span id="line21824" class="line"></span>            return undefined;
<span id="line21825" class="line"></span>        }
<span id="line21826" class="line"></span>        cache.transformTo("image");
<span id="line21827" class="line"></span>        return cache.data;
<span id="line21828" class="line"></span>    },
<span id="line21829" class="line"></span>
<span id="line21830" class="line"></span>    /**
<span id="line21831" class="line"></span>     * Get the url string for this tile.
<span id="line21832" class="line"></span>     * @returns {String}
<span id="line21833" class="line"></span>     */
<span id="line21834" class="line"></span>    getUrl: function() {
<span id="line21835" class="line"></span>        if (typeof this._url === 'function') {
<span id="line21836" class="line"></span>            return this._url();
<span id="line21837" class="line"></span>        }
<span id="line21838" class="line"></span>
<span id="line21839" class="line"></span>        return this._url;
<span id="line21840" class="line"></span>    },
<span id="line21841" class="line"></span>
<span id="line21842" class="line"></span>    /**
<span id="line21843" class="line"></span>     * Get the CanvasRenderingContext2D instance for tile image data drawn
<span id="line21844" class="line"></span>     * onto Canvas if enabled and available
<span id="line21845" class="line"></span>     * @deprecated
<span id="line21846" class="line"></span>     * @returns {CanvasRenderingContext2D|undefined}
<span id="line21847" class="line"></span>     */
<span id="line21848" class="line"></span>    getCanvasContext: function() {
<span id="line21849" class="line"></span>        $.console.error("[Tile.getCanvasContext] property has been deprecated. Use 'tile-invalidated' routine event instead.");
<span id="line21850" class="line"></span>        //this method used to ensure the underlying data model conformed to given type - convert instead of getData()
<span id="line21851" class="line"></span>        const cache = this.getCache(this.cacheKey);
<span id="line21852" class="line"></span>        if (!cache) {
<span id="line21853" class="line"></span>            return undefined;
<span id="line21854" class="line"></span>        }
<span id="line21855" class="line"></span>        cache.transformTo("context2d");
<span id="line21856" class="line"></span>        return cache.data;
<span id="line21857" class="line"></span>    },
<span id="line21858" class="line"></span>
<span id="line21859" class="line"></span>    /**
<span id="line21860" class="line"></span>     * The context2D of this tile if it is provided directly by the tile source.
<span id="line21861" class="line"></span>     * @deprecated
<span id="line21862" class="line"></span>     * @type {CanvasRenderingContext2D}
<span id="line21863" class="line"></span>     */
<span id="line21864" class="line"></span>    get context2D() {
<span id="line21865" class="line"></span>        $.console.error("[Tile.context2D] property has been deprecated. Use 'tile-invalidated' routine event instead.");
<span id="line21866" class="line"></span>        return this.getCanvasContext();
<span id="line21867" class="line"></span>    },
<span id="line21868" class="line"></span>
<span id="line21869" class="line"></span>    /**
<span id="line21870" class="line"></span>     * The context2D of this tile if it is provided directly by the tile source.
<span id="line21871" class="line"></span>     * @deprecated
<span id="line21872" class="line"></span>     */
<span id="line21873" class="line"></span>    set context2D(value) {
<span id="line21874" class="line"></span>        $.console.error("[Tile.context2D] property has been deprecated. Use 'tile-invalidated' routine event instead.");
<span id="line21875" class="line"></span>        const cache = this._caches[this.cacheKey];
<span id="line21876" class="line"></span>        if (cache) {
<span id="line21877" class="line"></span>            this.removeCache(this.cacheKey);
<span id="line21878" class="line"></span>        }
<span id="line21879" class="line"></span>        this.addCache(this.cacheKey, value, 'context2d', true, false);
<span id="line21880" class="line"></span>    },
<span id="line21881" class="line"></span>
<span id="line21882" class="line"></span>    /**
<span id="line21883" class="line"></span>     * The default cache for this tile.
<span id="line21884" class="line"></span>     * @deprecated
<span id="line21885" class="line"></span>     * @type OpenSeadragon.CacheRecord
<span id="line21886" class="line"></span>     */
<span id="line21887" class="line"></span>    get cacheImageRecord() {
<span id="line21888" class="line"></span>        $.console.error("[Tile.cacheImageRecord] property has been deprecated. Use Tile::getCache.");
<span id="line21889" class="line"></span>        return this.getCache(this.cacheKey);
<span id="line21890" class="line"></span>    },
<span id="line21891" class="line"></span>
<span id="line21892" class="line"></span>    /**
<span id="line21893" class="line"></span>     * The default cache for this tile.
<span id="line21894" class="line"></span>     * @deprecated
<span id="line21895" class="line"></span>     */
<span id="line21896" class="line"></span>    set cacheImageRecord(value) {
<span id="line21897" class="line"></span>        $.console.error("[Tile.cacheImageRecord] property has been deprecated. Use Tile::addCache.");
<span id="line21898" class="line"></span>        const cache = this._caches[this.cacheKey];
<span id="line21899" class="line"></span>
<span id="line21900" class="line"></span>        if (cache) {
<span id="line21901" class="line"></span>            this.removeCache(this.cacheKey);
<span id="line21902" class="line"></span>        }
<span id="line21903" class="line"></span>
<span id="line21904" class="line"></span>        if (value) {
<span id="line21905" class="line"></span>            if (value.loaded) {
<span id="line21906" class="line"></span>                this.addCache(this.cacheKey, value.data, value.type, true, false);
<span id="line21907" class="line"></span>            } else {
<span id="line21908" class="line"></span>                value.await().then(x =&gt; this.addCache(this.cacheKey, x, value.type, true, false));
<span id="line21909" class="line"></span>            }
<span id="line21910" class="line"></span>        }
<span id="line21911" class="line"></span>    },
<span id="line21912" class="line"></span>
<span id="line21913" class="line"></span>    /**
<span id="line21914" class="line"></span>     * Cache key for main cache that is 'cache-equal', but different from original cache key
<span id="line21915" class="line"></span>     * @return {string}
<span id="line21916" class="line"></span>     * @private
<span id="line21917" class="line"></span>     */
<span id="line21918" class="line"></span>    buildDistinctMainCacheKey: function () {
<span id="line21919" class="line"></span>        return this.cacheKey === this.originalCacheKey ? "mod://" + this.originalCacheKey : this.cacheKey;
<span id="line21920" class="line"></span>    },
<span id="line21921" class="line"></span>
<span id="line21922" class="line"></span>    /**
<span id="line21923" class="line"></span>     * Read tile cache data object (CacheRecord)
<span id="line21924" class="line"></span>     * @param {string} [key=this.cacheKey] cache key to read that belongs to this tile
<span id="line21925" class="line"></span>     * @return {OpenSeadragon.CacheRecord}
<span id="line21926" class="line"></span>     * @private
<span id="line21927" class="line"></span>     */
<span id="line21928" class="line"></span>    getCache: function(key = this._cKey) {
<span id="line21929" class="line"></span>        const cache = this._caches[key];
<span id="line21930" class="line"></span>        if (cache) {
<span id="line21931" class="line"></span>            cache.withTileReference(this);
<span id="line21932" class="line"></span>        }
<span id="line21933" class="line"></span>        return cache;
<span id="line21934" class="line"></span>    },
<span id="line21935" class="line"></span>
<span id="line21936" class="line"></span>    /**
<span id="line21937" class="line"></span>     * Create tile cache for given data object.
<span id="line21938" class="line"></span>     *
<span id="line21939" class="line"></span>     * Using `setAsMain` updates also main tile cache key - the main cache key used to draw this tile.
<span id="line21940" class="line"></span>     * In that case, the cache should be ready to be rendered immediatelly (converted to one of the supported formats
<span id="line21941" class="line"></span>     * of the currently employed drawer).
<span id="line21942" class="line"></span>     *
<span id="line21943" class="line"></span>     * NOTE: if the existing cache already exists,
<span id="line21944" class="line"></span>     * data parameter is ignored and inherited from the existing cache object.
<span id="line21945" class="line"></span>     * WARNING: if you override main tile cache key to point to a different cache, the invalidation routine
<span id="line21946" class="line"></span>     * will no longer work. If you need to modify tile main data, prefer to use invalidation routine instead.
<span id="line21947" class="line"></span>     *
<span id="line21948" class="line"></span>     * @param {string} key cache key, if unique, new cache object is created, else existing cache attached
<span id="line21949" class="line"></span>     * @param {*} data this data will be IGNORED if cache already exists; therefore if
<span id="line21950" class="line"></span>     *   `typeof data === 'function'` holds (both async and normal functions), the data is called to obtain
<span id="line21951" class="line"></span>     *   the data item: this is an optimization to load data only when necessary.
<span id="line21952" class="line"></span>     * @param {string} [type=undefined] data type, will be guessed if not provided (not recommended),
<span id="line21953" class="line"></span>     *   if data is a callback the type is a mandatory field, not setting it results in undefined behaviour
<span id="line21954" class="line"></span>     * @param {boolean} [setAsMain=false] if true, the key will be set as the tile.cacheKey,
<span id="line21955" class="line"></span>     *   no effect if key === this.cacheKey
<span id="line21956" class="line"></span>     * @param [_safely=true] private
<span id="line21957" class="line"></span>     * @returns {OpenSeadragon.CacheRecord|null} - The cache record the tile was attached to.
<span id="line21958" class="line"></span>     * @private
<span id="line21959" class="line"></span>     */
<span id="line21960" class="line"></span>    addCache: function(key, data, type = undefined, setAsMain = false, _safely = true) {
<span id="line21961" class="line"></span>        const tiledImage = this.tiledImage;
<span id="line21962" class="line"></span>        if (!tiledImage) {
<span id="line21963" class="line"></span>            return null; //async can access outside its lifetime
<span id="line21964" class="line"></span>        }
<span id="line21965" class="line"></span>
<span id="line21966" class="line"></span>        if (!type) {
<span id="line21967" class="line"></span>            if (!this.__typeWarningReported) {
<span id="line21968" class="line"></span>                $.console.warn(this, "[Tile.addCache] called without type specification. " +
<span id="line21969" class="line"></span>                    "Automated deduction is potentially unsafe: prefer specification of data type explicitly.");
<span id="line21970" class="line"></span>                this.__typeWarningReported = true;
<span id="line21971" class="line"></span>            }
<span id="line21972" class="line"></span>            if (typeof data === 'function') {
<span id="line21973" class="line"></span>                $.console.error("[TileCache.cacheTile] options.data as a callback requires type argument! Current is " + type);
<span id="line21974" class="line"></span>            }
<span id="line21975" class="line"></span>            type = $.converter.guessType(data);
<span id="line21976" class="line"></span>        }
<span id="line21977" class="line"></span>
<span id="line21978" class="line"></span>        const overwritesMainCache = key === this.cacheKey;
<span id="line21979" class="line"></span>        if (_safely &amp;&amp; (overwritesMainCache || setAsMain)) {
<span id="line21980" class="line"></span>            // Need to get the supported type for rendering out of the active drawer.
<span id="line21981" class="line"></span>            const supportedTypes = tiledImage.getDrawer().getSupportedDataFormats();
<span id="line21982" class="line"></span>            const conversion = $.converter.getConversionPath(type, supportedTypes);
<span id="line21983" class="line"></span>            $.console.assert(conversion, "[Tile.addCache] data was set for the default tile cache we are unable" +
<span id="line21984" class="line"></span>                `to render. Make sure OpenSeadragon.converter was taught to convert ${type} to (one of): ${conversion.toString()}`);
<span id="line21985" class="line"></span>        }
<span id="line21986" class="line"></span>
<span id="line21987" class="line"></span>        const cachedItem = tiledImage._tileCache.cacheTile({
<span id="line21988" class="line"></span>            data: data,
<span id="line21989" class="line"></span>            dataType: type,
<span id="line21990" class="line"></span>            tile: this,
<span id="line21991" class="line"></span>            cacheKey: key,
<span id="line21992" class="line"></span>            cutoff: tiledImage.source.getClosestLevel(),
<span id="line21993" class="line"></span>        });
<span id="line21994" class="line"></span>        const havingRecord = this._caches[key];
<span id="line21995" class="line"></span>        if (havingRecord !== cachedItem) {
<span id="line21996" class="line"></span>            this._caches[key] = cachedItem;
<span id="line21997" class="line"></span>            if (havingRecord) {
<span id="line21998" class="line"></span>                havingRecord.removeTile(this);
<span id="line21999" class="line"></span>                tiledImage._tileCache.safeUnloadCache(havingRecord);
<span id="line22000" class="line"></span>            }
<span id="line22001" class="line"></span>        }
<span id="line22002" class="line"></span>
<span id="line22003" class="line"></span>        // Update cache key if differs and main requested
<span id="line22004" class="line"></span>        if (!overwritesMainCache &amp;&amp; setAsMain) {
<span id="line22005" class="line"></span>            this._updateMainCacheKey(key);
<span id="line22006" class="line"></span>        }
<span id="line22007" class="line"></span>        return cachedItem;
<span id="line22008" class="line"></span>    },
<span id="line22009" class="line"></span>
<span id="line22010" class="line"></span>
<span id="line22011" class="line"></span>    /**
<span id="line22012" class="line"></span>     * Add cache object to the tile
<span id="line22013" class="line"></span>     *
<span id="line22014" class="line"></span>     * @param {string} key cache key, if unique, new cache object is created, else existing cache attached
<span id="line22015" class="line"></span>     * @param {OpenSeadragon.CacheRecord} cache the cache object to attach to this tile
<span id="line22016" class="line"></span>     * @param {boolean} [setAsMain=false] if true, the key will be set as the tile.cacheKey,
<span id="line22017" class="line"></span>     *   no effect if key === this.cacheKey
<span id="line22018" class="line"></span>     * @param [_safely=true] private
<span id="line22019" class="line"></span>     * @returns {OpenSeadragon.CacheRecord|null} - Returns cache parameter reference if attached.
<span id="line22020" class="line"></span>     * @private
<span id="line22021" class="line"></span>     */
<span id="line22022" class="line"></span>    setCache(key, cache, setAsMain = false, _safely = true) {
<span id="line22023" class="line"></span>        const tiledImage = this.tiledImage;
<span id="line22024" class="line"></span>        if (!tiledImage) {
<span id="line22025" class="line"></span>            return null; //async can access outside its lifetime
<span id="line22026" class="line"></span>        }
<span id="line22027" class="line"></span>
<span id="line22028" class="line"></span>        const overwritesMainCache = key === this.cacheKey;
<span id="line22029" class="line"></span>        if (_safely) {
<span id="line22030" class="line"></span>            $.console.assert(cache instanceof $.CacheRecord, "[Tile.setCache] cache must be a CacheRecord object!");
<span id="line22031" class="line"></span>            if (overwritesMainCache || setAsMain) {
<span id="line22032" class="line"></span>                // Need to get the supported type for rendering out of the active drawer.
<span id="line22033" class="line"></span>                const supportedTypes = tiledImage.getDrawer().getSupportedDataFormats();
<span id="line22034" class="line"></span>                const conversion = $.converter.getConversionPath(cache.type, supportedTypes);
<span id="line22035" class="line"></span>                $.console.assert(conversion, "[Tile.setCache] data was set for the default tile cache we are unable" +
<span id="line22036" class="line"></span>                    `to render. Make sure OpenSeadragon.converter was taught to convert ${cache.type} to (one of): ${conversion.toString()}`);
<span id="line22037" class="line"></span>            }
<span id="line22038" class="line"></span>        }
<span id="line22039" class="line"></span>
<span id="line22040" class="line"></span>        const havingRecord = this._caches[key];
<span id="line22041" class="line"></span>        if (havingRecord !== cache) {
<span id="line22042" class="line"></span>            this._caches[key] = cache;
<span id="line22043" class="line"></span>            cache.addTile(this);  // keep reference bidirectional
<span id="line22044" class="line"></span>            if (havingRecord) {
<span id="line22045" class="line"></span>                havingRecord.removeTile(this);
<span id="line22046" class="line"></span>                tiledImage._tileCache.safeUnloadCache(havingRecord);
<span id="line22047" class="line"></span>            }
<span id="line22048" class="line"></span>        }
<span id="line22049" class="line"></span>
<span id="line22050" class="line"></span>        // Update cache key if differs and main requested
<span id="line22051" class="line"></span>        if (!overwritesMainCache &amp;&amp; setAsMain) {
<span id="line22052" class="line"></span>            this._updateMainCacheKey(key);
<span id="line22053" class="line"></span>        }
<span id="line22054" class="line"></span>        return cache;
<span id="line22055" class="line"></span>    },
<span id="line22056" class="line"></span>
<span id="line22057" class="line"></span>    /**
<span id="line22058" class="line"></span>     * Sets the main cache key for this tile and
<span id="line22059" class="line"></span>     * performs necessary updates
<span id="line22060" class="line"></span>     * @param value
<span id="line22061" class="line"></span>     * @private
<span id="line22062" class="line"></span>     */
<span id="line22063" class="line"></span>    _updateMainCacheKey: function(value) {
<span id="line22064" class="line"></span>        let ref = this._caches[this._cKey];
<span id="line22065" class="line"></span>        if (ref) {
<span id="line22066" class="line"></span>            // make sure we free drawer internal cache if people change cache key externally
<span id="line22067" class="line"></span>            ref.destroyInternalCache();
<span id="line22068" class="line"></span>        }
<span id="line22069" class="line"></span>        this._cKey = value;
<span id="line22070" class="line"></span>    },
<span id="line22071" class="line"></span>
<span id="line22072" class="line"></span>    /**
<span id="line22073" class="line"></span>     * Get the number of caches available to this tile
<span id="line22074" class="line"></span>     * @returns {number} number of caches
<span id="line22075" class="line"></span>     */
<span id="line22076" class="line"></span>    getCacheSize: function() {
<span id="line22077" class="line"></span>        return Object.keys(this._caches).length;
<span id="line22078" class="line"></span>    },
<span id="line22079" class="line"></span>
<span id="line22080" class="line"></span>    /**
<span id="line22081" class="line"></span>     * Free tile cache. Removes by default the cache record if no other tile uses it.
<span id="line22082" class="line"></span>     * @param {string} key cache key, required
<span id="line22083" class="line"></span>     * @param {boolean} [freeIfUnused=true] set to false if zombie should be created
<span id="line22084" class="line"></span>     * @return {OpenSeadragon.CacheRecord|undefined} reference to the cache record if it was removed,
<span id="line22085" class="line"></span>     *   undefined if removal was refused to perform (e.g. does not exist, it is an original data target etc.)
<span id="line22086" class="line"></span>     * @private
<span id="line22087" class="line"></span>     */
<span id="line22088" class="line"></span>    removeCache: function(key, freeIfUnused = true) {
<span id="line22089" class="line"></span>        const deleteTarget = this._caches[key];
<span id="line22090" class="line"></span>        if (!deleteTarget) {
<span id="line22091" class="line"></span>            // try to erase anyway in case the cache got stuck in memory
<span id="line22092" class="line"></span>            this.tiledImage._tileCache.unloadCacheForTile(this, key, freeIfUnused, true);
<span id="line22093" class="line"></span>            return undefined;
<span id="line22094" class="line"></span>        }
<span id="line22095" class="line"></span>
<span id="line22096" class="line"></span>        const currentMainKey = this.cacheKey,
<span id="line22097" class="line"></span>            originalDataKey = this.originalCacheKey,
<span id="line22098" class="line"></span>            sameBuiltinKeys = currentMainKey === originalDataKey;
<span id="line22099" class="line"></span>
<span id="line22100" class="line"></span>        if (!sameBuiltinKeys &amp;&amp; originalDataKey === key) {
<span id="line22101" class="line"></span>            $.console.warn("[Tile.removeCache] original data must not be manually deleted: other parts of the code might rely on it!",
<span id="line22102" class="line"></span>                "If you want the tile not to preserve the original data, toggle of data perseverance in tile.setData().");
<span id="line22103" class="line"></span>            return undefined;
<span id="line22104" class="line"></span>        }
<span id="line22105" class="line"></span>
<span id="line22106" class="line"></span>        if (currentMainKey === key) {
<span id="line22107" class="line"></span>            if (!sameBuiltinKeys &amp;&amp; this._caches[originalDataKey]) {
<span id="line22108" class="line"></span>                // if we have original data let's revert back
<span id="line22109" class="line"></span>                this._updateMainCacheKey(originalDataKey);
<span id="line22110" class="line"></span>            } else {
<span id="line22111" class="line"></span>                $.console.warn("[Tile.removeCache] trying to remove the only cache that can be used to draw the tile!",
<span id="line22112" class="line"></span>                    "If you want to remove the main cache, first set different cache as main with tile.addCache()");
<span id="line22113" class="line"></span>                return undefined;
<span id="line22114" class="line"></span>            }
<span id="line22115" class="line"></span>        }
<span id="line22116" class="line"></span>        if (this.tiledImage._tileCache.unloadCacheForTile(this, key, freeIfUnused, false)) {
<span id="line22117" class="line"></span>            //if we managed to free tile from record, we are sure we decreased cache count
<span id="line22118" class="line"></span>            delete this._caches[key];
<span id="line22119" class="line"></span>        }
<span id="line22120" class="line"></span>        return deleteTarget;
<span id="line22121" class="line"></span>    },
<span id="line22122" class="line"></span>
<span id="line22123" class="line"></span>    /**
<span id="line22124" class="line"></span>     * Get the ratio between current and original size.
<span id="line22125" class="line"></span>     * @function
<span id="line22126" class="line"></span>     * @deprecated
<span id="line22127" class="line"></span>     * @returns {number}
<span id="line22128" class="line"></span>     */
<span id="line22129" class="line"></span>    getScaleForEdgeSmoothing: function() {
<span id="line22130" class="line"></span>        // getCanvasContext is deprecated and so should be this method.
<span id="line22131" class="line"></span>        $.console.warn("[Tile.getScaleForEdgeSmoothing] is deprecated, the following error is the consequence:");
<span id="line22132" class="line"></span>        const context = this.getCanvasContext();
<span id="line22133" class="line"></span>        if (!context) {
<span id="line22134" class="line"></span>            $.console.warn(
<span id="line22135" class="line"></span>                '[Tile.drawCanvas] attempting to get tile scale %s when tile\'s not cached',
<span id="line22136" class="line"></span>                this.toString());
<span id="line22137" class="line"></span>            return 1;
<span id="line22138" class="line"></span>        }
<span id="line22139" class="line"></span>        return context.canvas.width / (this.size.x * $.pixelDensityRatio);
<span id="line22140" class="line"></span>    },
<span id="line22141" class="line"></span>
<span id="line22142" class="line"></span>    /**
<span id="line22143" class="line"></span>     * Get a translation vector that when applied to the tile position produces integer coordinates.
<span id="line22144" class="line"></span>     * Needed to avoid swimming and twitching.
<span id="line22145" class="line"></span>     * @function
<span id="line22146" class="line"></span>     * @param {Number} [scale=1] - Scale to be applied to position.
<span id="line22147" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line22148" class="line"></span>     */
<span id="line22149" class="line"></span>    getTranslationForEdgeSmoothing: function(scale, canvasSize, sketchCanvasSize) {
<span id="line22150" class="line"></span>        // The translation vector must have positive values, otherwise the image goes a bit off
<span id="line22151" class="line"></span>        // the sketch canvas to the top and left and we must use negative coordinates to repaint it
<span id="line22152" class="line"></span>        // to the main canvas. In that case, some browsers throw:
<span id="line22153" class="line"></span>        // INDEX_SIZE_ERR: DOM Exception 1: Index or size was negative, or greater than the allowed value.
<span id="line22154" class="line"></span>        const x = Math.max(1, Math.ceil((sketchCanvasSize.x - canvasSize.x) / 2));
<span id="line22155" class="line"></span>        const y = Math.max(1, Math.ceil((sketchCanvasSize.y - canvasSize.y) / 2));
<span id="line22156" class="line"></span>        return new $.Point(x, y).minus(
<span id="line22157" class="line"></span>            this.position
<span id="line22158" class="line"></span>                .times($.pixelDensityRatio)
<span id="line22159" class="line"></span>                .times(scale || 1)
<span id="line22160" class="line"></span>                .apply(function(x) {
<span id="line22161" class="line"></span>                    return x % 1;
<span id="line22162" class="line"></span>                })
<span id="line22163" class="line"></span>        );
<span id="line22164" class="line"></span>    },
<span id="line22165" class="line"></span>
<span id="line22166" class="line"></span>    /**
<span id="line22167" class="line"></span>     * Reflect that a cache object was renamed. Called internally from TileCache.
<span id="line22168" class="line"></span>     * Do NOT call manually.
<span id="line22169" class="line"></span>     * @function
<span id="line22170" class="line"></span>     * @private
<span id="line22171" class="line"></span>     */
<span id="line22172" class="line"></span>    reflectCacheRenamed: function (oldKey, newKey) {
<span id="line22173" class="line"></span>        let cache = this._caches[oldKey];
<span id="line22174" class="line"></span>        if (!cache) {
<span id="line22175" class="line"></span>            return;  // nothing to fix
<span id="line22176" class="line"></span>        }
<span id="line22177" class="line"></span>        // Do update via private refs, old key no longer exists in cache
<span id="line22178" class="line"></span>        if (oldKey === this._ocKey) {
<span id="line22179" class="line"></span>            this._ocKey = newKey;
<span id="line22180" class="line"></span>        }
<span id="line22181" class="line"></span>        if (oldKey === this._cKey) {
<span id="line22182" class="line"></span>            this._cKey = newKey;
<span id="line22183" class="line"></span>        }
<span id="line22184" class="line"></span>        // Working key is never updated, it will be invalidated (but do not dereference cache, just fix the pointers)
<span id="line22185" class="line"></span>        this._caches[newKey] = cache;
<span id="line22186" class="line"></span>        delete this._caches[oldKey];
<span id="line22187" class="line"></span>    },
<span id="line22188" class="line"></span>
<span id="line22189" class="line"></span>    /**
<span id="line22190" class="line"></span>     * Check if two tiles are data-equal
<span id="line22191" class="line"></span>     * @param {OpenSeadragon.Tile} tile
<span id="line22192" class="line"></span>     */
<span id="line22193" class="line"></span>    equals(tile) {
<span id="line22194" class="line"></span>         return this._ocKey === tile._ocKey;
<span id="line22195" class="line"></span>    },
<span id="line22196" class="line"></span>
<span id="line22197" class="line"></span>    /**
<span id="line22198" class="line"></span>     * Removes tile from the system: it will still be present in the
<span id="line22199" class="line"></span>     * OSD memory, but marked as loaded=false, and its data will be erased if erase set to true.
<span id="line22200" class="line"></span>     * @param {boolean} [erase=false]
<span id="line22201" class="line"></span>     */
<span id="line22202" class="line"></span>    unload: function(erase = false) {
<span id="line22203" class="line"></span>        if (!this.loaded) {
<span id="line22204" class="line"></span>            return;
<span id="line22205" class="line"></span>        }
<span id="line22206" class="line"></span>        this.tiledImage._tileCache.unloadTile(this, erase);
<span id="line22207" class="line"></span>    },
<span id="line22208" class="line"></span>
<span id="line22209" class="line"></span>    /**
<span id="line22210" class="line"></span>     * this method shall be called only by cache system when the tile is already empty of data
<span id="line22211" class="line"></span>     * @private
<span id="line22212" class="line"></span>     */
<span id="line22213" class="line"></span>    _unload: function () {
<span id="line22214" class="line"></span>        this.tiledImage = null;
<span id="line22215" class="line"></span>        this._caches    = {};
<span id="line22216" class="line"></span>        this.loaded     = false;
<span id="line22217" class="line"></span>        this.loading    = false;
<span id="line22218" class="line"></span>        this._cKey      = this._ocKey;
<span id="line22219" class="line"></span>    }
<span id="line22220" class="line"></span>};
<span id="line22221" class="line"></span>
<span id="line22222" class="line"></span>}( OpenSeadragon ));
<span id="line22223" class="line"></span>
<span id="line22224" class="line"></span>/*
<span id="line22225" class="line"></span> * OpenSeadragon - Overlay
<span id="line22226" class="line"></span> *
<span id="line22227" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line22228" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line22229" class="line"></span> *
<span id="line22230" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line22231" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line22232" class="line"></span> * met:
<span id="line22233" class="line"></span> *
<span id="line22234" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line22235" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line22236" class="line"></span> *
<span id="line22237" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line22238" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line22239" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line22240" class="line"></span> *
<span id="line22241" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line22242" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line22243" class="line"></span> *   this software without specific prior written permission.
<span id="line22244" class="line"></span> *
<span id="line22245" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line22246" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line22247" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line22248" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line22249" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line22250" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line22251" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line22252" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line22253" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line22254" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line22255" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line22256" class="line"></span> */
<span id="line22257" class="line"></span>
<span id="line22258" class="line"></span>(function($) {
<span id="line22259" class="line"></span>
<span id="line22260" class="line"></span>    /**
<span id="line22261" class="line"></span>     * An enumeration of positions that an overlay may be assigned relative to
<span id="line22262" class="line"></span>     * the viewport.
<span id="line22263" class="line"></span>     * It is identical to OpenSeadragon.Placement but is kept for backward
<span id="line22264" class="line"></span>     * compatibility.
<span id="line22265" class="line"></span>     * @member OverlayPlacement
<span id="line22266" class="line"></span>     * @memberof OpenSeadragon
<span id="line22267" class="line"></span>     * @see OpenSeadragon.Placement
<span id="line22268" class="line"></span>     * @static
<span id="line22269" class="line"></span>     * @readonly
<span id="line22270" class="line"></span>     * @type {Object}
<span id="line22271" class="line"></span>     * @property {Number} CENTER
<span id="line22272" class="line"></span>     * @property {Number} TOP_LEFT
<span id="line22273" class="line"></span>     * @property {Number} TOP
<span id="line22274" class="line"></span>     * @property {Number} TOP_RIGHT
<span id="line22275" class="line"></span>     * @property {Number} RIGHT
<span id="line22276" class="line"></span>     * @property {Number} BOTTOM_RIGHT
<span id="line22277" class="line"></span>     * @property {Number} BOTTOM
<span id="line22278" class="line"></span>     * @property {Number} BOTTOM_LEFT
<span id="line22279" class="line"></span>     * @property {Number} LEFT
<span id="line22280" class="line"></span>     */
<span id="line22281" class="line"></span>    $.OverlayPlacement = $.Placement;
<span id="line22282" class="line"></span>
<span id="line22283" class="line"></span>    /**
<span id="line22284" class="line"></span>     * An enumeration of possible ways to handle overlays rotation
<span id="line22285" class="line"></span>     * @member OverlayRotationMode
<span id="line22286" class="line"></span>     * @memberOf OpenSeadragon
<span id="line22287" class="line"></span>     * @static
<span id="line22288" class="line"></span>     * @readonly
<span id="line22289" class="line"></span>     * @property {Number} NO_ROTATION The overlay ignore the viewport rotation.
<span id="line22290" class="line"></span>     * @property {Number} EXACT The overlay use CSS 3 transforms to rotate with
<span id="line22291" class="line"></span>     * the viewport. If the overlay contains text, it will get rotated as well.
<span id="line22292" class="line"></span>     * @property {Number} BOUNDING_BOX The overlay adjusts for rotation by
<span id="line22293" class="line"></span>     * taking the size of the bounding box of the rotated bounds.
<span id="line22294" class="line"></span>     * Only valid for overlays with Rect location and scalable in both directions.
<span id="line22295" class="line"></span>     */
<span id="line22296" class="line"></span>    $.OverlayRotationMode = $.freezeObject({
<span id="line22297" class="line"></span>        NO_ROTATION: 1,
<span id="line22298" class="line"></span>        EXACT: 2,
<span id="line22299" class="line"></span>        BOUNDING_BOX: 3
<span id="line22300" class="line"></span>    });
<span id="line22301" class="line"></span>
<span id="line22302" class="line"></span>    /**
<span id="line22303" class="line"></span>     * @class Overlay
<span id="line22304" class="line"></span>     * @classdesc Provides a way to float an HTML element on top of the viewer element.
<span id="line22305" class="line"></span>     *
<span id="line22306" class="line"></span>     * @memberof OpenSeadragon
<span id="line22307" class="line"></span>     * @param {Object} options
<span id="line22308" class="line"></span>     * @param {Element} options.element
<span id="line22309" class="line"></span>     * @param {OpenSeadragon.Point|OpenSeadragon.Rect} options.location - The
<span id="line22310" class="line"></span>     * location of the overlay on the image. If a {@link OpenSeadragon.Point}
<span id="line22311" class="line"></span>     * is specified, the overlay will be located at this location with respect
<span id="line22312" class="line"></span>     * to the placement option. If a {@link OpenSeadragon.Rect} is specified,
<span id="line22313" class="line"></span>     * the overlay will be placed at this location with the corresponding width
<span id="line22314" class="line"></span>     * and height and placement TOP_LEFT.
<span id="line22315" class="line"></span>     * @param {OpenSeadragon.Placement} [options.placement=OpenSeadragon.Placement.TOP_LEFT]
<span id="line22316" class="line"></span>     * Defines what part of the overlay should be at the specified options.location
<span id="line22317" class="line"></span>     * @param {OpenSeadragon.Overlay.OnDrawCallback} [options.onDraw]
<span id="line22318" class="line"></span>     * @param {Boolean} [options.checkResize=true] Set to false to avoid to
<span id="line22319" class="line"></span>     * check the size of the overlay every time it is drawn in the directions
<span id="line22320" class="line"></span>     * which are not scaled. It will improve performances but will cause a
<span id="line22321" class="line"></span>     * misalignment if the overlay size changes.
<span id="line22322" class="line"></span>     * @param {Number} [options.width] The width of the overlay in viewport
<span id="line22323" class="line"></span>     * coordinates. If specified, the width of the overlay will be adjusted when
<span id="line22324" class="line"></span>     * the zoom changes.
<span id="line22325" class="line"></span>     * @param {Number} [options.height] The height of the overlay in viewport
<span id="line22326" class="line"></span>     * coordinates. If specified, the height of the overlay will be adjusted when
<span id="line22327" class="line"></span>     * the zoom changes.
<span id="line22328" class="line"></span>     * @param {Boolean} [options.rotationMode=OpenSeadragon.OverlayRotationMode.EXACT]
<span id="line22329" class="line"></span>     * How to handle the rotation of the viewport.
<span id="line22330" class="line"></span>     */
<span id="line22331" class="line"></span>    $.Overlay = function(element, location, placement) {
<span id="line22332" class="line"></span>
<span id="line22333" class="line"></span>        /**
<span id="line22334" class="line"></span>         * onDraw callback signature used by {@link OpenSeadragon.Overlay}.
<span id="line22335" class="line"></span>         *
<span id="line22336" class="line"></span>         * @callback OnDrawCallback
<span id="line22337" class="line"></span>         * @memberof OpenSeadragon.Overlay
<span id="line22338" class="line"></span>         * @param {OpenSeadragon.Point} position
<span id="line22339" class="line"></span>         * @param {OpenSeadragon.Point} size
<span id="line22340" class="line"></span>         * @param {Element} element
<span id="line22341" class="line"></span>         */
<span id="line22342" class="line"></span>
<span id="line22343" class="line"></span>        let options;
<span id="line22344" class="line"></span>        if ($.isPlainObject(element)) {
<span id="line22345" class="line"></span>            options = element;
<span id="line22346" class="line"></span>        } else {
<span id="line22347" class="line"></span>            options = {
<span id="line22348" class="line"></span>                element: element,
<span id="line22349" class="line"></span>                location: location,
<span id="line22350" class="line"></span>                placement: placement
<span id="line22351" class="line"></span>            };
<span id="line22352" class="line"></span>        }
<span id="line22353" class="line"></span>
<span id="line22354" class="line"></span>        this.elementWrapper = document.createElement('div');
<span id="line22355" class="line"></span>        this.element = options.element;
<span id="line22356" class="line"></span>        this.elementWrapper.appendChild(this.element);
<span id="line22357" class="line"></span>
<span id="line22358" class="line"></span>        if (this.element.id) {
<span id="line22359" class="line"></span>            this.elementWrapper.id = "overlay-wrapper-" + this.element.id; // Unique ID if element has one
<span id="line22360" class="line"></span>        }
<span id="line22361" class="line"></span>
<span id="line22362" class="line"></span>        // Always add a class for styling &amp; selection
<span id="line22363" class="line"></span>        this.elementWrapper.classList.add("openseadragon-overlay-wrapper");
<span id="line22364" class="line"></span>
<span id="line22365" class="line"></span>        this.style = this.elementWrapper.style;
<span id="line22366" class="line"></span>        this._init(options);
<span id="line22367" class="line"></span>    };
<span id="line22368" class="line"></span>
<span id="line22369" class="line"></span>    /** @lends OpenSeadragon.Overlay.prototype */
<span id="line22370" class="line"></span>    $.Overlay.prototype = {
<span id="line22371" class="line"></span>
<span id="line22372" class="line"></span>        // private
<span id="line22373" class="line"></span>        _init: function(options) {
<span id="line22374" class="line"></span>            this.location = options.location;
<span id="line22375" class="line"></span>            this.placement = options.placement === undefined ?
<span id="line22376" class="line"></span>                $.Placement.TOP_LEFT : options.placement;
<span id="line22377" class="line"></span>            this.onDraw = options.onDraw;
<span id="line22378" class="line"></span>            this.checkResize = options.checkResize === undefined ?
<span id="line22379" class="line"></span>                true : options.checkResize;
<span id="line22380" class="line"></span>
<span id="line22381" class="line"></span>            // When this.width is not null, the overlay get scaled horizontally
<span id="line22382" class="line"></span>            this.width = options.width === undefined ? null : options.width;
<span id="line22383" class="line"></span>
<span id="line22384" class="line"></span>            // When this.height is not null, the overlay get scaled vertically
<span id="line22385" class="line"></span>            this.height = options.height === undefined ? null : options.height;
<span id="line22386" class="line"></span>
<span id="line22387" class="line"></span>            this.rotationMode = options.rotationMode || $.OverlayRotationMode.EXACT;
<span id="line22388" class="line"></span>
<span id="line22389" class="line"></span>            // Having a rect as location is a syntactic sugar
<span id="line22390" class="line"></span>            if (this.location instanceof $.Rect) {
<span id="line22391" class="line"></span>                this.width = this.location.width;
<span id="line22392" class="line"></span>                this.height = this.location.height;
<span id="line22393" class="line"></span>                this.location = this.location.getTopLeft();
<span id="line22394" class="line"></span>                this.placement = $.Placement.TOP_LEFT;
<span id="line22395" class="line"></span>            }
<span id="line22396" class="line"></span>
<span id="line22397" class="line"></span>            // Deprecated properties kept for backward compatibility.
<span id="line22398" class="line"></span>            this.scales = this.width !== null &amp;&amp; this.height !== null;
<span id="line22399" class="line"></span>            this.bounds = new $.Rect(
<span id="line22400" class="line"></span>                this.location.x, this.location.y, this.width, this.height);
<span id="line22401" class="line"></span>            this.position = this.location;
<span id="line22402" class="line"></span>        },
<span id="line22403" class="line"></span>
<span id="line22404" class="line"></span>        /**
<span id="line22405" class="line"></span>         * Internal function to adjust the position of an overlay
<span id="line22406" class="line"></span>         * depending on it size and placement.
<span id="line22407" class="line"></span>         * @function
<span id="line22408" class="line"></span>         * @param {OpenSeadragon.Point} position
<span id="line22409" class="line"></span>         * @param {OpenSeadragon.Point} size
<span id="line22410" class="line"></span>         */
<span id="line22411" class="line"></span>        adjust: function(position, size) {
<span id="line22412" class="line"></span>            const properties = $.Placement.properties[this.placement];
<span id="line22413" class="line"></span>            if (!properties) {
<span id="line22414" class="line"></span>                return;
<span id="line22415" class="line"></span>            }
<span id="line22416" class="line"></span>            if (properties.isHorizontallyCentered) {
<span id="line22417" class="line"></span>                position.x -= size.x / 2;
<span id="line22418" class="line"></span>            } else if (properties.isRight) {
<span id="line22419" class="line"></span>                position.x -= size.x;
<span id="line22420" class="line"></span>            }
<span id="line22421" class="line"></span>            if (properties.isVerticallyCentered) {
<span id="line22422" class="line"></span>                position.y -= size.y / 2;
<span id="line22423" class="line"></span>            } else if (properties.isBottom) {
<span id="line22424" class="line"></span>                position.y -= size.y;
<span id="line22425" class="line"></span>            }
<span id="line22426" class="line"></span>        },
<span id="line22427" class="line"></span>
<span id="line22428" class="line"></span>        /**
<span id="line22429" class="line"></span>         * @function
<span id="line22430" class="line"></span>         */
<span id="line22431" class="line"></span>        destroy: function() {
<span id="line22432" class="line"></span>            const element = this.elementWrapper;
<span id="line22433" class="line"></span>            const style = this.style;
<span id="line22434" class="line"></span>
<span id="line22435" class="line"></span>            if (element.parentNode) {
<span id="line22436" class="line"></span>                element.parentNode.removeChild(element);
<span id="line22437" class="line"></span>                //this should allow us to preserve overlays when required between
<span id="line22438" class="line"></span>                //pages
<span id="line22439" class="line"></span>                if (element.prevElementParent) {
<span id="line22440" class="line"></span>                    style.display = 'none';
<span id="line22441" class="line"></span>                    //element.prevElementParent.insertBefore(
<span id="line22442" class="line"></span>                    //    element,
<span id="line22443" class="line"></span>                    //    element.prevNextSibling
<span id="line22444" class="line"></span>                    //);
<span id="line22445" class="line"></span>                    document.body.appendChild(element);
<span id="line22446" class="line"></span>                }
<span id="line22447" class="line"></span>            }
<span id="line22448" class="line"></span>
<span id="line22449" class="line"></span>            // clear the onDraw callback
<span id="line22450" class="line"></span>            this.onDraw = null;
<span id="line22451" class="line"></span>
<span id="line22452" class="line"></span>            style.top = "";
<span id="line22453" class="line"></span>            style.left = "";
<span id="line22454" class="line"></span>            style.position = "";
<span id="line22455" class="line"></span>
<span id="line22456" class="line"></span>            if (this.width !== null) {
<span id="line22457" class="line"></span>                style.width = "";
<span id="line22458" class="line"></span>            }
<span id="line22459" class="line"></span>            if (this.height !== null) {
<span id="line22460" class="line"></span>                style.height = "";
<span id="line22461" class="line"></span>            }
<span id="line22462" class="line"></span>            const transformOriginProp = $.getCssPropertyWithVendorPrefix(
<span id="line22463" class="line"></span>                'transformOrigin');
<span id="line22464" class="line"></span>            const transformProp = $.getCssPropertyWithVendorPrefix(
<span id="line22465" class="line"></span>                'transform');
<span id="line22466" class="line"></span>            if (transformOriginProp &amp;&amp; transformProp) {
<span id="line22467" class="line"></span>                style[transformOriginProp] = "";
<span id="line22468" class="line"></span>                style[transformProp] = "";
<span id="line22469" class="line"></span>            }
<span id="line22470" class="line"></span>        },
<span id="line22471" class="line"></span>
<span id="line22472" class="line"></span>        /**
<span id="line22473" class="line"></span>         * @function
<span id="line22474" class="line"></span>         * @param {Element} container
<span id="line22475" class="line"></span>         */
<span id="line22476" class="line"></span>        drawHTML: function(container, viewport) {
<span id="line22477" class="line"></span>            const element = this.elementWrapper;
<span id="line22478" class="line"></span>            if (element.parentNode !== container) {
<span id="line22479" class="line"></span>                //save the source parent for later if we need it
<span id="line22480" class="line"></span>                element.prevElementParent = element.parentNode;
<span id="line22481" class="line"></span>                element.prevNextSibling = element.nextSibling;
<span id="line22482" class="line"></span>                container.appendChild(element);
<span id="line22483" class="line"></span>
<span id="line22484" class="line"></span>                // have to set position before calculating size, fix #1116
<span id="line22485" class="line"></span>                this.style.position = "absolute";
<span id="line22486" class="line"></span>                // this.size is used by overlays which don't get scaled in at
<span id="line22487" class="line"></span>                // least one direction when this.checkResize is set to false.
<span id="line22488" class="line"></span>                this.size = $.getElementSize(this.elementWrapper);
<span id="line22489" class="line"></span>            }
<span id="line22490" class="line"></span>            const positionAndSize = this._getOverlayPositionAndSize(viewport);
<span id="line22491" class="line"></span>            const position = positionAndSize.position;
<span id="line22492" class="line"></span>            const size = this.size = positionAndSize.size;
<span id="line22493" class="line"></span>            let outerScale = "";
<span id="line22494" class="line"></span>            if (viewport.overlayPreserveContentDirection) {
<span id="line22495" class="line"></span>                outerScale = viewport.flipped ? " scaleX(-1)" : " scaleX(1)";
<span id="line22496" class="line"></span>            }
<span id="line22497" class="line"></span>            const rotate = viewport.flipped ? -positionAndSize.rotate : positionAndSize.rotate;
<span id="line22498" class="line"></span>            const scale = viewport.flipped ? " scaleX(-1)" : "";
<span id="line22499" class="line"></span>            // call the onDraw callback if it exists to allow one to overwrite
<span id="line22500" class="line"></span>            // the drawing/positioning/sizing of the overlay
<span id="line22501" class="line"></span>            if (this.onDraw) {
<span id="line22502" class="line"></span>                this.onDraw(position, size, this.element);
<span id="line22503" class="line"></span>            } else {
<span id="line22504" class="line"></span>                const style = this.style;
<span id="line22505" class="line"></span>                const innerStyle = this.element.style;
<span id="line22506" class="line"></span>                innerStyle.display = "block";
<span id="line22507" class="line"></span>                style.left = position.x + "px";
<span id="line22508" class="line"></span>                style.top = position.y + "px";
<span id="line22509" class="line"></span>                if (this.width !== null) {
<span id="line22510" class="line"></span>                    innerStyle.width = size.x + "px";
<span id="line22511" class="line"></span>                }
<span id="line22512" class="line"></span>                if (this.height !== null) {
<span id="line22513" class="line"></span>                    innerStyle.height = size.y + "px";
<span id="line22514" class="line"></span>                }
<span id="line22515" class="line"></span>                const transformOriginProp = $.getCssPropertyWithVendorPrefix(
<span id="line22516" class="line"></span>                    'transformOrigin');
<span id="line22517" class="line"></span>                const transformProp = $.getCssPropertyWithVendorPrefix(
<span id="line22518" class="line"></span>                    'transform');
<span id="line22519" class="line"></span>                if (transformOriginProp &amp;&amp; transformProp) {
<span id="line22520" class="line"></span>                    if (rotate &amp;&amp; !viewport.flipped) {
<span id="line22521" class="line"></span>                        innerStyle[transformProp] = "";
<span id="line22522" class="line"></span>                        style[transformOriginProp] = this._getTransformOrigin();
<span id="line22523" class="line"></span>                        style[transformProp] = "rotate(" + rotate + "deg)";
<span id="line22524" class="line"></span>                    } else if (!rotate &amp;&amp; viewport.flipped) {
<span id="line22525" class="line"></span>                        innerStyle[transformProp] = outerScale;
<span id="line22526" class="line"></span>                        style[transformOriginProp] = this._getTransformOrigin();
<span id="line22527" class="line"></span>                        style[transformProp] = scale;
<span id="line22528" class="line"></span>                    } else if (rotate &amp;&amp; viewport.flipped){
<span id="line22529" class="line"></span>                        innerStyle[transformProp] = outerScale;
<span id="line22530" class="line"></span>                        style[transformOriginProp] = this._getTransformOrigin();
<span id="line22531" class="line"></span>                        style[transformProp] = "rotate(" + rotate + "deg)" + scale;
<span id="line22532" class="line"></span>                    } else {
<span id="line22533" class="line"></span>                        innerStyle[transformProp] = "";
<span id="line22534" class="line"></span>                        style[transformOriginProp] = "";
<span id="line22535" class="line"></span>                        style[transformProp] = "";
<span id="line22536" class="line"></span>                    }
<span id="line22537" class="line"></span>                }
<span id="line22538" class="line"></span>                style.display = 'flex';
<span id="line22539" class="line"></span>            }
<span id="line22540" class="line"></span>        },
<span id="line22541" class="line"></span>
<span id="line22542" class="line"></span>        // private
<span id="line22543" class="line"></span>        _getOverlayPositionAndSize: function(viewport) {
<span id="line22544" class="line"></span>            let position = viewport.pixelFromPoint(this.location, true);
<span id="line22545" class="line"></span>            let size = this._getSizeInPixels(viewport);
<span id="line22546" class="line"></span>            this.adjust(position, size);
<span id="line22547" class="line"></span>
<span id="line22548" class="line"></span>            let rotate = 0;
<span id="line22549" class="line"></span>            if (viewport.getRotation(true) &amp;&amp;
<span id="line22550" class="line"></span>                this.rotationMode !== $.OverlayRotationMode.NO_ROTATION) {
<span id="line22551" class="line"></span>                // BOUNDING_BOX is only valid if both directions get scaled.
<span id="line22552" class="line"></span>                // Get replaced by EXACT otherwise.
<span id="line22553" class="line"></span>                if (this.rotationMode === $.OverlayRotationMode.BOUNDING_BOX &amp;&amp;
<span id="line22554" class="line"></span>                    this.width !== null &amp;&amp; this.height !== null) {
<span id="line22555" class="line"></span>                    const rect = new $.Rect(position.x, position.y, size.x, size.y);
<span id="line22556" class="line"></span>                    const boundingBox = this._getBoundingBox(rect, viewport.getRotation(true));
<span id="line22557" class="line"></span>                    position = boundingBox.getTopLeft();
<span id="line22558" class="line"></span>                    size = boundingBox.getSize();
<span id="line22559" class="line"></span>                } else {
<span id="line22560" class="line"></span>                    rotate = viewport.getRotation(true);
<span id="line22561" class="line"></span>                }
<span id="line22562" class="line"></span>            }
<span id="line22563" class="line"></span>
<span id="line22564" class="line"></span>            if (viewport.flipped) {
<span id="line22565" class="line"></span>                position.x = (viewport.getContainerSize().x - position.x);
<span id="line22566" class="line"></span>            }
<span id="line22567" class="line"></span>            return {
<span id="line22568" class="line"></span>                position: position,
<span id="line22569" class="line"></span>                size: size,
<span id="line22570" class="line"></span>                rotate: rotate
<span id="line22571" class="line"></span>            };
<span id="line22572" class="line"></span>        },
<span id="line22573" class="line"></span>
<span id="line22574" class="line"></span>        // private
<span id="line22575" class="line"></span>        _getSizeInPixels: function(viewport) {
<span id="line22576" class="line"></span>            let width = this.size.x;
<span id="line22577" class="line"></span>            let height = this.size.y;
<span id="line22578" class="line"></span>            if (this.width !== null || this.height !== null) {
<span id="line22579" class="line"></span>                const scaledSize = viewport.deltaPixelsFromPointsNoRotate(
<span id="line22580" class="line"></span>                    new $.Point(this.width || 0, this.height || 0), true);
<span id="line22581" class="line"></span>                if (this.width !== null) {
<span id="line22582" class="line"></span>                    width = scaledSize.x;
<span id="line22583" class="line"></span>                }
<span id="line22584" class="line"></span>                if (this.height !== null) {
<span id="line22585" class="line"></span>                    height = scaledSize.y;
<span id="line22586" class="line"></span>                }
<span id="line22587" class="line"></span>            }
<span id="line22588" class="line"></span>            if (this.checkResize &amp;&amp;
<span id="line22589" class="line"></span>                (this.width === null || this.height === null)) {
<span id="line22590" class="line"></span>                const eltSize = this.size = $.getElementSize(this.elementWrapper);
<span id="line22591" class="line"></span>                if (this.width === null) {
<span id="line22592" class="line"></span>                    width = eltSize.x;
<span id="line22593" class="line"></span>                }
<span id="line22594" class="line"></span>                if (this.height === null) {
<span id="line22595" class="line"></span>                    height = eltSize.y;
<span id="line22596" class="line"></span>                }
<span id="line22597" class="line"></span>            }
<span id="line22598" class="line"></span>            return new $.Point(width, height);
<span id="line22599" class="line"></span>        },
<span id="line22600" class="line"></span>
<span id="line22601" class="line"></span>        // private
<span id="line22602" class="line"></span>        _getBoundingBox: function(rect, degrees) {
<span id="line22603" class="line"></span>            const refPoint = this._getPlacementPoint(rect);
<span id="line22604" class="line"></span>            return rect.rotate(degrees, refPoint).getBoundingBox();
<span id="line22605" class="line"></span>        },
<span id="line22606" class="line"></span>
<span id="line22607" class="line"></span>        // private
<span id="line22608" class="line"></span>        _getPlacementPoint: function(rect) {
<span id="line22609" class="line"></span>            const result = new $.Point(rect.x, rect.y);
<span id="line22610" class="line"></span>            const properties = $.Placement.properties[this.placement];
<span id="line22611" class="line"></span>            if (properties) {
<span id="line22612" class="line"></span>                if (properties.isHorizontallyCentered) {
<span id="line22613" class="line"></span>                    result.x += rect.width / 2;
<span id="line22614" class="line"></span>                } else if (properties.isRight) {
<span id="line22615" class="line"></span>                    result.x += rect.width;
<span id="line22616" class="line"></span>                }
<span id="line22617" class="line"></span>                if (properties.isVerticallyCentered) {
<span id="line22618" class="line"></span>                    result.y += rect.height / 2;
<span id="line22619" class="line"></span>                } else if (properties.isBottom) {
<span id="line22620" class="line"></span>                    result.y += rect.height;
<span id="line22621" class="line"></span>                }
<span id="line22622" class="line"></span>            }
<span id="line22623" class="line"></span>            return result;
<span id="line22624" class="line"></span>        },
<span id="line22625" class="line"></span>
<span id="line22626" class="line"></span>        // private
<span id="line22627" class="line"></span>        _getTransformOrigin: function() {
<span id="line22628" class="line"></span>            let result = "";
<span id="line22629" class="line"></span>            const properties = $.Placement.properties[this.placement];
<span id="line22630" class="line"></span>            if (!properties) {
<span id="line22631" class="line"></span>                return result;
<span id="line22632" class="line"></span>            }
<span id="line22633" class="line"></span>            if (properties.isLeft) {
<span id="line22634" class="line"></span>                result = "left";
<span id="line22635" class="line"></span>            } else if (properties.isRight) {
<span id="line22636" class="line"></span>                result = "right";
<span id="line22637" class="line"></span>            }
<span id="line22638" class="line"></span>            if (properties.isTop) {
<span id="line22639" class="line"></span>                result += " top";
<span id="line22640" class="line"></span>            } else if (properties.isBottom) {
<span id="line22641" class="line"></span>                result += " bottom";
<span id="line22642" class="line"></span>            }
<span id="line22643" class="line"></span>            return result;
<span id="line22644" class="line"></span>        },
<span id="line22645" class="line"></span>
<span id="line22646" class="line"></span>        /**
<span id="line22647" class="line"></span>         * Changes the overlay settings.
<span id="line22648" class="line"></span>         * @function
<span id="line22649" class="line"></span>         * @param {OpenSeadragon.Point|OpenSeadragon.Rect|Object} location
<span id="line22650" class="line"></span>         * If an object is specified, the options are the same than the constructor
<span id="line22651" class="line"></span>         * except for the element which can not be changed.
<span id="line22652" class="line"></span>         * @param {OpenSeadragon.Placement} placement
<span id="line22653" class="line"></span>         */
<span id="line22654" class="line"></span>        update: function(location, placement) {
<span id="line22655" class="line"></span>            const options = $.isPlainObject(location) ? location : {
<span id="line22656" class="line"></span>                location: location,
<span id="line22657" class="line"></span>                placement: placement
<span id="line22658" class="line"></span>            };
<span id="line22659" class="line"></span>            this._init({
<span id="line22660" class="line"></span>                location: options.location || this.location,
<span id="line22661" class="line"></span>                placement: options.placement !== undefined ?
<span id="line22662" class="line"></span>                    options.placement : this.placement,
<span id="line22663" class="line"></span>                onDraw: options.onDraw || this.onDraw,
<span id="line22664" class="line"></span>                checkResize: options.checkResize || this.checkResize,
<span id="line22665" class="line"></span>                width: options.width !== undefined ? options.width : this.width,
<span id="line22666" class="line"></span>                height: options.height !== undefined ? options.height : this.height,
<span id="line22667" class="line"></span>                rotationMode: options.rotationMode || this.rotationMode
<span id="line22668" class="line"></span>            });
<span id="line22669" class="line"></span>        },
<span id="line22670" class="line"></span>
<span id="line22671" class="line"></span>        /**
<span id="line22672" class="line"></span>         * Returns the current bounds of the overlay in viewport coordinates
<span id="line22673" class="line"></span>         * @function
<span id="line22674" class="line"></span>         * @param {OpenSeadragon.Viewport} viewport the viewport
<span id="line22675" class="line"></span>         * @returns {OpenSeadragon.Rect} overlay bounds
<span id="line22676" class="line"></span>         */
<span id="line22677" class="line"></span>        getBounds: function(viewport) {
<span id="line22678" class="line"></span>            $.console.assert(viewport,
<span id="line22679" class="line"></span>                'A viewport must now be passed to Overlay.getBounds.');
<span id="line22680" class="line"></span>            let width = this.width;
<span id="line22681" class="line"></span>            let height = this.height;
<span id="line22682" class="line"></span>            if (width === null || height === null) {
<span id="line22683" class="line"></span>                const size = viewport.deltaPointsFromPixelsNoRotate(this.size, true);
<span id="line22684" class="line"></span>                if (width === null) {
<span id="line22685" class="line"></span>                    width = size.x;
<span id="line22686" class="line"></span>                }
<span id="line22687" class="line"></span>                if (height === null) {
<span id="line22688" class="line"></span>                    height = size.y;
<span id="line22689" class="line"></span>                }
<span id="line22690" class="line"></span>            }
<span id="line22691" class="line"></span>            const location = this.location.clone();
<span id="line22692" class="line"></span>            this.adjust(location, new $.Point(width, height));
<span id="line22693" class="line"></span>            return this._adjustBoundsForRotation(
<span id="line22694" class="line"></span>                viewport, new $.Rect(location.x, location.y, width, height));
<span id="line22695" class="line"></span>        },
<span id="line22696" class="line"></span>
<span id="line22697" class="line"></span>        // private
<span id="line22698" class="line"></span>        _adjustBoundsForRotation: function(viewport, bounds) {
<span id="line22699" class="line"></span>            if (!viewport ||
<span id="line22700" class="line"></span>                viewport.getRotation(true) === 0 ||
<span id="line22701" class="line"></span>                this.rotationMode === $.OverlayRotationMode.EXACT) {
<span id="line22702" class="line"></span>                return bounds;
<span id="line22703" class="line"></span>            }
<span id="line22704" class="line"></span>            if (this.rotationMode === $.OverlayRotationMode.BOUNDING_BOX) {
<span id="line22705" class="line"></span>                // If overlay not fully scalable, BOUNDING_BOX falls back to EXACT
<span id="line22706" class="line"></span>                if (this.width === null || this.height === null) {
<span id="line22707" class="line"></span>                    return bounds;
<span id="line22708" class="line"></span>                }
<span id="line22709" class="line"></span>                // It is easier to just compute the position and size and
<span id="line22710" class="line"></span>                // convert to viewport coordinates.
<span id="line22711" class="line"></span>                const positionAndSize = this._getOverlayPositionAndSize(viewport);
<span id="line22712" class="line"></span>                return viewport.viewerElementToViewportRectangle(new $.Rect(
<span id="line22713" class="line"></span>                    positionAndSize.position.x,
<span id="line22714" class="line"></span>                    positionAndSize.position.y,
<span id="line22715" class="line"></span>                    positionAndSize.size.x,
<span id="line22716" class="line"></span>                    positionAndSize.size.y));
<span id="line22717" class="line"></span>            }
<span id="line22718" class="line"></span>
<span id="line22719" class="line"></span>            // NO_ROTATION case
<span id="line22720" class="line"></span>            return bounds.rotate(-viewport.getRotation(true),
<span id="line22721" class="line"></span>                this._getPlacementPoint(bounds));
<span id="line22722" class="line"></span>        }
<span id="line22723" class="line"></span>    };
<span id="line22724" class="line"></span>
<span id="line22725" class="line"></span>}(OpenSeadragon));
<span id="line22726" class="line"></span>
<span id="line22727" class="line"></span>/*
<span id="line22728" class="line"></span> * OpenSeadragon - DrawerBase
<span id="line22729" class="line"></span> *
<span id="line22730" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line22731" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line22732" class="line"></span> *
<span id="line22733" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line22734" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line22735" class="line"></span> * met:
<span id="line22736" class="line"></span> *
<span id="line22737" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line22738" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line22739" class="line"></span> *
<span id="line22740" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line22741" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line22742" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line22743" class="line"></span> *
<span id="line22744" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line22745" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line22746" class="line"></span> *   this software without specific prior written permission.
<span id="line22747" class="line"></span> *
<span id="line22748" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line22749" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line22750" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line22751" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line22752" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line22753" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line22754" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line22755" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line22756" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line22757" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line22758" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line22759" class="line"></span> */
<span id="line22760" class="line"></span>
<span id="line22761" class="line"></span>(function( $ ){
<span id="line22762" class="line"></span>
<span id="line22763" class="line"></span>/**
<span id="line22764" class="line"></span> * @typedef OpenSeadragon.BaseDrawerOptions
<span id="line22765" class="line"></span> * @memberOf OpenSeadragon
<span id="line22766" class="line"></span> * @property {boolean} [usePrivateCache=false] specify whether the drawer should use
<span id="line22767" class="line"></span> *   detached (=internal) cache object in case it has to perform custom type conversion atop
<span id="line22768" class="line"></span> *   what cache performs. In that case, drawer must implement internalCacheCreate() which gets data in one
<span id="line22769" class="line"></span> *   of formats the drawer declares as supported. This method must return object to be used during drawing.
<span id="line22770" class="line"></span> *   You should probably implement also internalCacheFree() to provide cleanup logics.
<span id="line22771" class="line"></span> *
<span id="line22772" class="line"></span> * @property {boolean} [preloadCache=true] When internalCacheCreate is used, it can be applied offline
<span id="line22773" class="line"></span> *   (asynchronously) during data processing = preloading, or just in time before rendering (if necessary).
<span id="line22774" class="line"></span> *   Preloading supports async handlers, and can use promises. If preloadCache=false, no async (e.g. cache conversion)
<span id="line22775" class="line"></span> *   logics can be used!
<span id="line22776" class="line"></span> *
<span id="line22777" class="line"></span> * @property {boolean} [offScreen=false] When true, the drawer is not attached to DOM. This must be false
<span id="line22778" class="line"></span> *   for all drawers created and used for rendering, particularly the main viewer drawer. However,
<span id="line22779" class="line"></span> *   if you need to use particular viewer API for rendering an offscreen images for further processing,
<span id="line22780" class="line"></span> *   you can set this to true.
<span id="line22781" class="line"></span> *
<span id="line22782" class="line"></span> * @property {boolean} [broadCastTileInvalidation=true] When true, the drawer will reflect changes done to the viewer's
<span id="line22783" class="line"></span> *   base drawer instance. For example, navigator will reflect data updates of the main viewport.
<span id="line22784" class="line"></span> */
<span id="line22785" class="line"></span>
<span id="line22786" class="line"></span>const OpenSeadragon = $; // (re)alias back to OpenSeadragon for JSDoc
<span id="line22787" class="line"></span>/**
<span id="line22788" class="line"></span> * @class OpenSeadragon.DrawerBase
<span id="line22789" class="line"></span> * @classdesc Base class for Drawers that handle rendering of tiles for an {@link OpenSeadragon.Viewer}.
<span id="line22790" class="line"></span> *   More viewers can be implemented even as plugins if they are attached to the OpenSeadragon namespace.
<span id="line22791" class="line"></span> *   Then you can employ the newly defined type as you would do with built-in drawers.
<span id="line22792" class="line"></span> * @param {Object} options - Options for this Drawer.
<span id="line22793" class="line"></span> * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this Drawer.
<span id="line22794" class="line"></span> * @param {OpenSeadragon.Viewport} options.viewport - Reference to Viewer viewport.
<span id="line22795" class="line"></span> * @param {HTMLElement} options.element - Parent element.
<span id="line22796" class="line"></span> * @abstract
<span id="line22797" class="line"></span> */
<span id="line22798" class="line"></span>
<span id="line22799" class="line"></span>OpenSeadragon.DrawerBase = class DrawerBase {
<span id="line22800" class="line"></span>    constructor(options){
<span id="line22801" class="line"></span>        $.console.assert( options.viewer, "[Drawer] options.viewer is required" );
<span id="line22802" class="line"></span>        $.console.assert( options.viewport, "[Drawer] options.viewport is required" );
<span id="line22803" class="line"></span>        $.console.assert( options.element, "[Drawer] options.element is required" );
<span id="line22804" class="line"></span>
<span id="line22805" class="line"></span>        this._id = this.getType() + $.now();
<span id="line22806" class="line"></span>        this.viewer = options.viewer;
<span id="line22807" class="line"></span>        this.viewport = options.viewport;
<span id="line22808" class="line"></span>        this.debugGridColor = typeof options.debugGridColor === 'string' ? [options.debugGridColor] : options.debugGridColor || $.DEFAULT_SETTINGS.debugGridColor;
<span id="line22809" class="line"></span>
<span id="line22810" class="line"></span>        /**
<span id="line22811" class="line"></span>         * @memberof OpenSeadragon.DrawerBase#
<span id="line22812" class="line"></span>         * @type OpenSeadragon.BaseDrawerOptions
<span id="line22813" class="line"></span>         */
<span id="line22814" class="line"></span>        this.options = $.extend({
<span id="line22815" class="line"></span>            usePrivateCache: false,
<span id="line22816" class="line"></span>            preloadCache: true,
<span id="line22817" class="line"></span>            offScreen: false,
<span id="line22818" class="line"></span>            broadCastTileInvalidation: true,
<span id="line22819" class="line"></span>        }, this.defaultOptions, options.options);
<span id="line22820" class="line"></span>
<span id="line22821" class="line"></span>        this.container  = $.getElement( options.element );
<span id="line22822" class="line"></span>
<span id="line22823" class="line"></span>        this._renderingTarget = this._createDrawingElement();
<span id="line22824" class="line"></span>
<span id="line22825" class="line"></span>        if (!this.options.offScreen) {
<span id="line22826" class="line"></span>            this.canvas.style.width     = "100%";
<span id="line22827" class="line"></span>            this.canvas.style.height    = "100%";
<span id="line22828" class="line"></span>            this.canvas.style.position  = "absolute";
<span id="line22829" class="line"></span>            // set canvas.style.left = 0 so the canvas is positioned properly in ltr and rtl html
<span id="line22830" class="line"></span>            this.canvas.style.left = "0";
<span id="line22831" class="line"></span>            $.setElementOpacity( this.canvas, this.viewer.opacity, true );
<span id="line22832" class="line"></span>
<span id="line22833" class="line"></span>            // Allow pointer events to pass through the canvas element so implicit
<span id="line22834" class="line"></span>            //   pointer capture works on touch devices
<span id="line22835" class="line"></span>            $.setElementPointerEventsNone( this.canvas );
<span id="line22836" class="line"></span>            $.setElementTouchActionNone( this.canvas );
<span id="line22837" class="line"></span>
<span id="line22838" class="line"></span>            // explicit left-align
<span id="line22839" class="line"></span>            this.container.style.textAlign = "left";
<span id="line22840" class="line"></span>            this.container.appendChild( this.canvas );
<span id="line22841" class="line"></span>
<span id="line22842" class="line"></span>            if (this.options.broadCastTileInvalidation) {
<span id="line22843" class="line"></span>                let parentViewer = this.viewer;
<span id="line22844" class="line"></span>                while (parentViewer.viewer) {
<span id="line22845" class="line"></span>                    parentViewer = parentViewer.viewer;
<span id="line22846" class="line"></span>                }
<span id="line22847" class="line"></span>                this._parentViewer = parentViewer;
<span id="line22848" class="line"></span>                parentViewer._registerDrawer(this);
<span id="line22849" class="line"></span>            } else {
<span id="line22850" class="line"></span>                this.viewer._registerDrawer(this);
<span id="line22851" class="line"></span>                this._parentViewer = this.viewer;
<span id="line22852" class="line"></span>            }
<span id="line22853" class="line"></span>        }
<span id="line22854" class="line"></span>
<span id="line22855" class="line"></span>        this._checkInterfaceImplementation();
<span id="line22856" class="line"></span>        this.setInternalCacheNeedsRefresh();  // initializes timestamp
<span id="line22857" class="line"></span>    }
<span id="line22858" class="line"></span>
<span id="line22859" class="line"></span>    /**
<span id="line22860" class="line"></span>     * Retrieve default options for the current drawer.
<span id="line22861" class="line"></span>     * The base implementation provides default shared options.
<span id="line22862" class="line"></span>     * Overrides should enumerate all defaults or extend from this implementation.
<span id="line22863" class="line"></span>     *   return $.extend({}, super.options, { ... custom drawer instance options ... });
<span id="line22864" class="line"></span>     * @memberof {OpenSeadragon.DrawerBase}
<span id="line22865" class="line"></span>     * @returns {OpenSeadragon.BaseDrawerOptions} common options
<span id="line22866" class="line"></span>     */
<span id="line22867" class="line"></span>    get defaultOptions() {
<span id="line22868" class="line"></span>        // defaults are defined in constructor to avoid overriding issues
<span id="line22869" class="line"></span>        return {};
<span id="line22870" class="line"></span>    }
<span id="line22871" class="line"></span>
<span id="line22872" class="line"></span>    /**
<span id="line22873" class="line"></span>     * @memberof {OpenSeadragon.DrawerBase}
<span id="line22874" class="line"></span>     * @return {Element}
<span id="line22875" class="line"></span>     */
<span id="line22876" class="line"></span>    get canvas(){
<span id="line22877" class="line"></span>        return this._renderingTarget;
<span id="line22878" class="line"></span>    }
<span id="line22879" class="line"></span>
<span id="line22880" class="line"></span>    get element(){
<span id="line22881" class="line"></span>        $.console.error('Drawer.element is deprecated. Use Drawer.container instead.');
<span id="line22882" class="line"></span>        return this.container;
<span id="line22883" class="line"></span>    }
<span id="line22884" class="line"></span>
<span id="line22885" class="line"></span>    /**
<span id="line22886" class="line"></span>     * Get unique drawer ID
<span id="line22887" class="line"></span>     * @return {string}
<span id="line22888" class="line"></span>     */
<span id="line22889" class="line"></span>    getId() {
<span id="line22890" class="line"></span>        return this._id;
<span id="line22891" class="line"></span>    }
<span id="line22892" class="line"></span>
<span id="line22893" class="line"></span>    /**
<span id="line22894" class="line"></span>     * @abstract
<span id="line22895" class="line"></span>     * @memberof {OpenSeadragon.DrawerBase}
<span id="line22896" class="line"></span>     * @returns {String | undefined} What type of drawer this is. Must be overridden by extending classes.
<span id="line22897" class="line"></span>     */
<span id="line22898" class="line"></span>    getType(){
<span id="line22899" class="line"></span>        $.console.error('Drawer.getType must be implemented by child class');
<span id="line22900" class="line"></span>        return undefined;
<span id="line22901" class="line"></span>    }
<span id="line22902" class="line"></span>
<span id="line22903" class="line"></span>    /**
<span id="line22904" class="line"></span>     * Retrieve required data formats the data must be converted to.
<span id="line22905" class="line"></span>     * This list MUST BE A VALID SUBSET OF getSupportedDataFormats()
<span id="line22906" class="line"></span>     * @memberof {OpenSeadragon.DrawerBase}
<span id="line22907" class="line"></span>     * @return {string[]}
<span id="line22908" class="line"></span>     */
<span id="line22909" class="line"></span>    getRequiredDataFormats() {
<span id="line22910" class="line"></span>        return this.getSupportedDataFormats();
<span id="line22911" class="line"></span>    }
<span id="line22912" class="line"></span>
<span id="line22913" class="line"></span>    /**
<span id="line22914" class="line"></span>     * Retrieve data types
<span id="line22915" class="line"></span>     * @abstract
<span id="line22916" class="line"></span>     * @memberof {OpenSeadragon.DrawerBase}
<span id="line22917" class="line"></span>     * @return {string[]}
<span id="line22918" class="line"></span>     */
<span id="line22919" class="line"></span>    getSupportedDataFormats() {
<span id="line22920" class="line"></span>        throw "Drawer.getSupportedDataFormats must define its supported rendering data types!";
<span id="line22921" class="line"></span>    }
<span id="line22922" class="line"></span>
<span id="line22923" class="line"></span>    /**
<span id="line22924" class="line"></span>     * Check a particular cache record is compatible.
<span id="line22925" class="line"></span>     * This function _MUST_ be called: if it returns a falsey
<span id="line22926" class="line"></span>     * value, the rendering _MUST NOT_ proceed. It should
<span id="line22927" class="line"></span>     * await next animation frames and check again for availability.
<span id="line22928" class="line"></span>     * @param {OpenSeadragon.Tile} tile
<span id="line22929" class="line"></span>     * @memberof {OpenSeadragon.DrawerBase}
<span id="line22930" class="line"></span>     * @return {any|undefined} undefined if cache not available, compatible data otherwise.
<span id="line22931" class="line"></span>     */
<span id="line22932" class="line"></span>    getDataToDraw(tile) {
<span id="line22933" class="line"></span>        const cache = tile.getCache(tile.cacheKey);
<span id="line22934" class="line"></span>        if (!cache) {
<span id="line22935" class="line"></span>            $.console.warn("Attempt to draw tile %s when not cached!", tile);
<span id="line22936" class="line"></span>            return undefined;
<span id="line22937" class="line"></span>        }
<span id="line22938" class="line"></span>        const dataCache = cache.getDataForRendering(this, tile);
<span id="line22939" class="line"></span>        return dataCache &amp;&amp; dataCache.data;
<span id="line22940" class="line"></span>    }
<span id="line22941" class="line"></span>
<span id="line22942" class="line"></span>    /**
<span id="line22943" class="line"></span>     * @abstract
<span id="line22944" class="line"></span>     * @returns {Boolean} Whether the drawer implementation is supported by the browser. Must be overridden by extending classes.
<span id="line22945" class="line"></span>     */
<span id="line22946" class="line"></span>    static isSupported() {
<span id="line22947" class="line"></span>        $.console.error('Drawer.isSupported must be implemented by child class');
<span id="line22948" class="line"></span>    }
<span id="line22949" class="line"></span>
<span id="line22950" class="line"></span>    /**
<span id="line22951" class="line"></span>     * @abstract
<span id="line22952" class="line"></span>     * @returns {Element} the element to draw into
<span id="line22953" class="line"></span>     * @private
<span id="line22954" class="line"></span>     */
<span id="line22955" class="line"></span>    _createDrawingElement() {
<span id="line22956" class="line"></span>        $.console.error('Drawer._createDrawingElement must be implemented by child class');
<span id="line22957" class="line"></span>        return null;
<span id="line22958" class="line"></span>    }
<span id="line22959" class="line"></span>
<span id="line22960" class="line"></span>    /**
<span id="line22961" class="line"></span>     * @abstract
<span id="line22962" class="line"></span>     * @param {Array} tiledImages - An array of TiledImages that are ready to be drawn.
<span id="line22963" class="line"></span>     * @private
<span id="line22964" class="line"></span>     */
<span id="line22965" class="line"></span>    draw(tiledImages) {
<span id="line22966" class="line"></span>        $.console.error('Drawer.draw must be implemented by child class');
<span id="line22967" class="line"></span>    }
<span id="line22968" class="line"></span>
<span id="line22969" class="line"></span>    /**
<span id="line22970" class="line"></span>     * @abstract
<span id="line22971" class="line"></span>     * @returns {Boolean} True if rotation is supported.
<span id="line22972" class="line"></span>     */
<span id="line22973" class="line"></span>    canRotate() {
<span id="line22974" class="line"></span>        $.console.error('Drawer.canRotate must be implemented by child class');
<span id="line22975" class="line"></span>    }
<span id="line22976" class="line"></span>
<span id="line22977" class="line"></span>    /**
<span id="line22978" class="line"></span>     * Destroy the drawer. Child classes must call this super class.
<span id="line22979" class="line"></span>     */
<span id="line22980" class="line"></span>    destroy() {
<span id="line22981" class="line"></span>        // how to force child classes to call this?
<span id="line22982" class="line"></span>        // we could force destroy methods to return some unique value that is obtainable only from this method...
<span id="line22983" class="line"></span>        this._parentViewer._unregisterDrawer(this);
<span id="line22984" class="line"></span>    }
<span id="line22985" class="line"></span>
<span id="line22986" class="line"></span>    /**
<span id="line22987" class="line"></span>     * Destroy internal cache. Should be called within destroy() when
<span id="line22988" class="line"></span>     * usePrivateCache is set to true. Ensures cleanup of anything created
<span id="line22989" class="line"></span>     * by internalCacheCreate(...).
<span id="line22990" class="line"></span>     */
<span id="line22991" class="line"></span>    destroyInternalCache() {
<span id="line22992" class="line"></span>        this.viewer.tileCache.clearDrawerInternalCache(this);
<span id="line22993" class="line"></span>    }
<span id="line22994" class="line"></span>
<span id="line22995" class="line"></span>    /**
<span id="line22996" class="line"></span>     * @param {TiledImage} tiledImage the tiled image that is calling the function
<span id="line22997" class="line"></span>     * @returns {Boolean} Whether this drawer requires enforcing minimum tile overlap to avoid showing seams.
<span id="line22998" class="line"></span>     * @private
<span id="line22999" class="line"></span>     */
<span id="line23000" class="line"></span>    minimumOverlapRequired(tiledImage) {
<span id="line23001" class="line"></span>        return false;
<span id="line23002" class="line"></span>    }
<span id="line23003" class="line"></span>
<span id="line23004" class="line"></span>    /**
<span id="line23005" class="line"></span>     * @abstract
<span id="line23006" class="line"></span>     * @param {Boolean} [imageSmoothingEnabled] - Whether or not the image is
<span id="line23007" class="line"></span>     * drawn smoothly on the canvas; see imageSmoothingEnabled in
<span id="line23008" class="line"></span>     * {@link OpenSeadragon.Options} for more explanation.
<span id="line23009" class="line"></span>     */
<span id="line23010" class="line"></span>    setImageSmoothingEnabled(imageSmoothingEnabled){
<span id="line23011" class="line"></span>        $.console.error('Drawer.setImageSmoothingEnabled must be implemented by child class');
<span id="line23012" class="line"></span>    }
<span id="line23013" class="line"></span>
<span id="line23014" class="line"></span>    /**
<span id="line23015" class="line"></span>     * Optional public API to draw a rectangle (e.g. for debugging purposes)
<span id="line23016" class="line"></span>     * Child classes can override this method if they wish to support this
<span id="line23017" class="line"></span>     * @param {OpenSeadragon.Rect} rect
<span id="line23018" class="line"></span>     */
<span id="line23019" class="line"></span>    drawDebuggingRect(rect) {
<span id="line23020" class="line"></span>        $.console.warn('[drawer].drawDebuggingRect is not implemented by this drawer');
<span id="line23021" class="line"></span>    }
<span id="line23022" class="line"></span>
<span id="line23023" class="line"></span>    // Deprecated functions
<span id="line23024" class="line"></span>    clear(){
<span id="line23025" class="line"></span>        $.console.warn('[drawer].clear() is deprecated. The drawer is responsible for clearing itself as needed before drawing tiles.');
<span id="line23026" class="line"></span>    }
<span id="line23027" class="line"></span>
<span id="line23028" class="line"></span>    /**
<span id="line23029" class="line"></span>     * If options.usePrivateCache is true, this method MUST RETURN the private cache content
<span id="line23030" class="line"></span>     * @param {OpenSeadragon.CacheRecord} cache
<span id="line23031" class="line"></span>     * @param {OpenSeadragon.Tile} tile
<span id="line23032" class="line"></span>     * @return any
<span id="line23033" class="line"></span>     */
<span id="line23034" class="line"></span>    internalCacheCreate(cache, tile) {}
<span id="line23035" class="line"></span>
<span id="line23036" class="line"></span>    /**
<span id="line23037" class="line"></span>     * It is possible to perform any necessary cleanup on internal cache, necessary if you
<span id="line23038" class="line"></span>     * need to clean up some memory (e.g. destroy canvas by setting with &amp; height to 0).
<span id="line23039" class="line"></span>     * @param {*} data object returned by internalCacheCreate(...)
<span id="line23040" class="line"></span>     */
<span id="line23041" class="line"></span>    internalCacheFree(data) {}
<span id="line23042" class="line"></span>
<span id="line23043" class="line"></span>    /**
<span id="line23044" class="line"></span>     * Call to invalidate internal cache. It will be rebuilt. With synchronous converions,
<span id="line23045" class="line"></span>     * it will be rebuilt immediatelly. With asynchronous, it will be rebuilt once invalidation
<span id="line23046" class="line"></span>     * routine happens, e.g. you should call also requestInvalidate() if you need to happen
<span id="line23047" class="line"></span>     * it as soon as possible.
<span id="line23048" class="line"></span>     */
<span id="line23049" class="line"></span>    setInternalCacheNeedsRefresh() {
<span id="line23050" class="line"></span>        this._dataNeedsRefresh = $.now();
<span id="line23051" class="line"></span>    }
<span id="line23052" class="line"></span>
<span id="line23053" class="line"></span>    /**
<span id="line23054" class="line"></span>     * When a Tiled Image is initialized and ready, this method is called.
<span id="line23055" class="line"></span>     * Unlike with events, here it is guaranteed that all external code has finished
<span id="line23056" class="line"></span>     * processing (under normal circumstances) and the tiled image should not change.
<span id="line23057" class="line"></span>     * @param {OpenSeadragon.TiledImage} tiledImage target image that has been created
<span id="line23058" class="line"></span>     */
<span id="line23059" class="line"></span>    tiledImageCreated(tiledImage) {
<span id="line23060" class="line"></span>        // pass
<span id="line23061" class="line"></span>    }
<span id="line23062" class="line"></span>
<span id="line23063" class="line"></span>    // Private functions
<span id="line23064" class="line"></span>
<span id="line23065" class="line"></span>    /**
<span id="line23066" class="line"></span>     * Ensures that child classes have provided implementations for public API methods
<span id="line23067" class="line"></span>     * draw, canRotate, destroy, and setImageSmoothinEnabled. Throws an exception if the original
<span id="line23068" class="line"></span>     * placeholder methods are still in place.
<span id="line23069" class="line"></span>     * @private
<span id="line23070" class="line"></span>     *
<span id="line23071" class="line"></span>     */
<span id="line23072" class="line"></span>    _checkInterfaceImplementation(){
<span id="line23073" class="line"></span>        if (this._createDrawingElement === $.DrawerBase.prototype._createDrawingElement) {
<span id="line23074" class="line"></span>            throw(new Error("[drawer]._createDrawingElement must be implemented by child class"));
<span id="line23075" class="line"></span>        }
<span id="line23076" class="line"></span>        if (this.draw === $.DrawerBase.prototype.draw) {
<span id="line23077" class="line"></span>            throw(new Error("[drawer].draw must be implemented by child class"));
<span id="line23078" class="line"></span>        }
<span id="line23079" class="line"></span>        if (this.canRotate === $.DrawerBase.prototype.canRotate) {
<span id="line23080" class="line"></span>            throw(new Error("[drawer].canRotate must be implemented by child class"));
<span id="line23081" class="line"></span>        }
<span id="line23082" class="line"></span>        if (this.destroy === $.DrawerBase.prototype.destroy) {
<span id="line23083" class="line"></span>            throw(new Error("[drawer].destroy must be implemented by child class"));
<span id="line23084" class="line"></span>        }
<span id="line23085" class="line"></span>        if (this.setImageSmoothingEnabled === $.DrawerBase.prototype.setImageSmoothingEnabled) {
<span id="line23086" class="line"></span>            throw(new Error("[drawer].setImageSmoothingEnabled must be implemented by child class"));
<span id="line23087" class="line"></span>        }
<span id="line23088" class="line"></span>    }
<span id="line23089" class="line"></span>
<span id="line23090" class="line"></span>
<span id="line23091" class="line"></span>    // Utility functions
<span id="line23092" class="line"></span>
<span id="line23093" class="line"></span>    /**
<span id="line23094" class="line"></span>     * Scale from OpenSeadragon viewer rectangle to drawer rectangle
<span id="line23095" class="line"></span>     * (ignoring rotation)
<span id="line23096" class="line"></span>     * @param {OpenSeadragon.Rect} rectangle - The rectangle in viewport coordinate system.
<span id="line23097" class="line"></span>     * @returns {OpenSeadragon.Rect} Rectangle in drawer coordinate system.
<span id="line23098" class="line"></span>     */
<span id="line23099" class="line"></span>    viewportToDrawerRectangle(rectangle) {
<span id="line23100" class="line"></span>        const topLeft = this.viewport.pixelFromPointNoRotate(rectangle.getTopLeft(), true);
<span id="line23101" class="line"></span>        const size = this.viewport.deltaPixelsFromPointsNoRotate(rectangle.getSize(), true);
<span id="line23102" class="line"></span>
<span id="line23103" class="line"></span>        return new $.Rect(
<span id="line23104" class="line"></span>            topLeft.x * $.pixelDensityRatio,
<span id="line23105" class="line"></span>            topLeft.y * $.pixelDensityRatio,
<span id="line23106" class="line"></span>            size.x * $.pixelDensityRatio,
<span id="line23107" class="line"></span>            size.y * $.pixelDensityRatio
<span id="line23108" class="line"></span>        );
<span id="line23109" class="line"></span>    }
<span id="line23110" class="line"></span>
<span id="line23111" class="line"></span>    /**
<span id="line23112" class="line"></span>     * This function converts the given point from to the drawer coordinate by
<span id="line23113" class="line"></span>     * multiplying it with the pixel density.
<span id="line23114" class="line"></span>     * This function does not take rotation into account, thus assuming provided
<span id="line23115" class="line"></span>     * point is at 0 degree.
<span id="line23116" class="line"></span>     * @param {OpenSeadragon.Point} point - the pixel point to convert
<span id="line23117" class="line"></span>     * @returns {OpenSeadragon.Point} Point in drawer coordinate system.
<span id="line23118" class="line"></span>     */
<span id="line23119" class="line"></span>    viewportCoordToDrawerCoord(point) {
<span id="line23120" class="line"></span>        const vpPoint = this.viewport.pixelFromPointNoRotate(point, true);
<span id="line23121" class="line"></span>        return new $.Point(
<span id="line23122" class="line"></span>            vpPoint.x * $.pixelDensityRatio,
<span id="line23123" class="line"></span>            vpPoint.y * $.pixelDensityRatio
<span id="line23124" class="line"></span>        );
<span id="line23125" class="line"></span>    }
<span id="line23126" class="line"></span>
<span id="line23127" class="line"></span>
<span id="line23128" class="line"></span>    // Internal utility functions
<span id="line23129" class="line"></span>
<span id="line23130" class="line"></span>    /**
<span id="line23131" class="line"></span>     * Calculate width and height of the canvas based on viewport dimensions
<span id="line23132" class="line"></span>     * and pixelDensityRatio
<span id="line23133" class="line"></span>     * @private
<span id="line23134" class="line"></span>     * @returns {OpenSeadragon.Point} {x, y} size of the canvas
<span id="line23135" class="line"></span>     */
<span id="line23136" class="line"></span>    _calculateCanvasSize() {
<span id="line23137" class="line"></span>        const pixelDensityRatio = $.pixelDensityRatio;
<span id="line23138" class="line"></span>        const viewportSize = this.viewport.getContainerSize();
<span id="line23139" class="line"></span>        return new OpenSeadragon.Point( Math.round(viewportSize.x * pixelDensityRatio), Math.round(viewportSize.y * pixelDensityRatio));
<span id="line23140" class="line"></span>    }
<span id="line23141" class="line"></span>
<span id="line23142" class="line"></span>    /**
<span id="line23143" class="line"></span>     * Called by implementations to fire the tiled-image-drawn event (used by tests)
<span id="line23144" class="line"></span>     * @private
<span id="line23145" class="line"></span>     */
<span id="line23146" class="line"></span>    _raiseTiledImageDrawnEvent(tiledImage, tiles){
<span id="line23147" class="line"></span>        if(!this.viewer) {
<span id="line23148" class="line"></span>            return;
<span id="line23149" class="line"></span>        }
<span id="line23150" class="line"></span>
<span id="line23151" class="line"></span>        /**
<span id="line23152" class="line"></span>        *  Raised when a tiled image is drawn to the canvas. Used internally for testing.
<span id="line23153" class="line"></span>        *  The update-viewport event is preferred if you want to know when a frame has been drawn.
<span id="line23154" class="line"></span>        *
<span id="line23155" class="line"></span>        * @event tiled-image-drawn
<span id="line23156" class="line"></span>        * @memberof OpenSeadragon.Viewer
<span id="line23157" class="line"></span>        * @type {object}
<span id="line23158" class="line"></span>        * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line23159" class="line"></span>        * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
<span id="line23160" class="line"></span>        * @property {Array} tiles - An array of Tile objects that were drawn.
<span id="line23161" class="line"></span>        * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line23162" class="line"></span>        * @private
<span id="line23163" class="line"></span>        */
<span id="line23164" class="line"></span>        this.viewer.raiseEvent( 'tiled-image-drawn', {
<span id="line23165" class="line"></span>            tiledImage: tiledImage,
<span id="line23166" class="line"></span>            tiles: tiles,
<span id="line23167" class="line"></span>        });
<span id="line23168" class="line"></span>    }
<span id="line23169" class="line"></span>
<span id="line23170" class="line"></span>    /**
<span id="line23171" class="line"></span>     * Called by implementations to fire the drawer-error event
<span id="line23172" class="line"></span>     * @private
<span id="line23173" class="line"></span>     */
<span id="line23174" class="line"></span>    _raiseDrawerErrorEvent(tiledImage, errorMessage){
<span id="line23175" class="line"></span>        if(!this.viewer) {
<span id="line23176" class="line"></span>            return;
<span id="line23177" class="line"></span>        }
<span id="line23178" class="line"></span>
<span id="line23179" class="line"></span>        /**
<span id="line23180" class="line"></span>        *  Raised when a tiled image is drawn to the canvas. Used internally for testing.
<span id="line23181" class="line"></span>        *  The update-viewport event is preferred if you want to know when a frame has been drawn.
<span id="line23182" class="line"></span>        *
<span id="line23183" class="line"></span>        * @event drawer-error
<span id="line23184" class="line"></span>        * @memberof OpenSeadragon.Viewer
<span id="line23185" class="line"></span>        * @type {object}
<span id="line23186" class="line"></span>        * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line23187" class="line"></span>        * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
<span id="line23188" class="line"></span>        * @property {OpenSeadragon.DrawerBase} drawer - The drawer that raised the error.
<span id="line23189" class="line"></span>        * @property {String} error - A message describing the error.
<span id="line23190" class="line"></span>        * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line23191" class="line"></span>        * @protected
<span id="line23192" class="line"></span>        */
<span id="line23193" class="line"></span>        this.viewer.raiseEvent( 'drawer-error', {
<span id="line23194" class="line"></span>            tiledImage: tiledImage,
<span id="line23195" class="line"></span>            drawer: this,
<span id="line23196" class="line"></span>            error: errorMessage,
<span id="line23197" class="line"></span>        });
<span id="line23198" class="line"></span>    }
<span id="line23199" class="line"></span>
<span id="line23200" class="line"></span>
<span id="line23201" class="line"></span>};
<span id="line23202" class="line"></span>
<span id="line23203" class="line"></span>}( OpenSeadragon ));
<span id="line23204" class="line"></span>
<span id="line23205" class="line"></span>/*
<span id="line23206" class="line"></span> * OpenSeadragon - HTMLDrawer
<span id="line23207" class="line"></span> *
<span id="line23208" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line23209" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line23210" class="line"></span> *
<span id="line23211" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line23212" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line23213" class="line"></span> * met:
<span id="line23214" class="line"></span> *
<span id="line23215" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line23216" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line23217" class="line"></span> *
<span id="line23218" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line23219" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line23220" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line23221" class="line"></span> *
<span id="line23222" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line23223" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line23224" class="line"></span> *   this software without specific prior written permission.
<span id="line23225" class="line"></span> *
<span id="line23226" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line23227" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line23228" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line23229" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line23230" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line23231" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line23232" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line23233" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line23234" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line23235" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line23236" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line23237" class="line"></span> */
<span id="line23238" class="line"></span>
<span id="line23239" class="line"></span>(function( $ ){
<span id="line23240" class="line"></span>
<span id="line23241" class="line"></span>const OpenSeadragon = $; // alias back for JSDoc
<span id="line23242" class="line"></span>
<span id="line23243" class="line"></span>/**
<span id="line23244" class="line"></span> * @class OpenSeadragon.HTMLDrawer
<span id="line23245" class="line"></span> * @extends OpenSeadragon.DrawerBase
<span id="line23246" class="line"></span> * @classdesc HTML-based implementation of DrawerBase for an {@link OpenSeadragon.Viewer}.
<span id="line23247" class="line"></span> * @param {Object} options - Options for this Drawer.
<span id="line23248" class="line"></span> * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this Drawer.
<span id="line23249" class="line"></span> * @param {OpenSeadragon.Viewport} options.viewport - Reference to Viewer viewport.
<span id="line23250" class="line"></span> * @param {Element} options.element - Parent element.
<span id="line23251" class="line"></span> * @param {Number} [options.debugGridColor] - See debugGridColor in {@link OpenSeadragon.Options} for details.
<span id="line23252" class="line"></span> */
<span id="line23253" class="line"></span>
<span id="line23254" class="line"></span>class HTMLDrawer extends OpenSeadragon.DrawerBase{
<span id="line23255" class="line"></span>    constructor(options){
<span id="line23256" class="line"></span>        super(options);
<span id="line23257" class="line"></span>
<span id="line23258" class="line"></span>        /**
<span id="line23259" class="line"></span>         * The HTML element (div) that this drawer uses for drawing
<span id="line23260" class="line"></span>         * @member {Element} canvas
<span id="line23261" class="line"></span>         * @memberof OpenSeadragon.HTMLDrawer#
<span id="line23262" class="line"></span>         */
<span id="line23263" class="line"></span>
<span id="line23264" class="line"></span>        /**
<span id="line23265" class="line"></span>         * The parent element of this Drawer instance, passed in when the Drawer was created.
<span id="line23266" class="line"></span>         * The parent of {@link OpenSeadragon.WebGLDrawer#canvas}.
<span id="line23267" class="line"></span>         * @member {Element} container
<span id="line23268" class="line"></span>         * @memberof OpenSeadragon.HTMLDrawer#
<span id="line23269" class="line"></span>         */
<span id="line23270" class="line"></span>
<span id="line23271" class="line"></span>        // Reject listening for the tile-drawing event, which this drawer does not fire
<span id="line23272" class="line"></span>        this.viewer.rejectEventHandler("tile-drawing", "The HTMLDrawer does not raise the tile-drawing event");
<span id="line23273" class="line"></span>        // Since the tile-drawn event is fired by this drawer, make sure handlers can be added for it
<span id="line23274" class="line"></span>        this.viewer.allowEventHandler("tile-drawn");
<span id="line23275" class="line"></span>
<span id="line23276" class="line"></span>        // works with canvas &amp; image objects
<span id="line23277" class="line"></span>        function _prepareTile(tile, data) {
<span id="line23278" class="line"></span>            const element = $.makeNeutralElement( "div" );
<span id="line23279" class="line"></span>            const imgElement = data.cloneNode();
<span id="line23280" class="line"></span>            imgElement.style.msInterpolationMode = "nearest-neighbor";
<span id="line23281" class="line"></span>            imgElement.style.width = "100%";
<span id="line23282" class="line"></span>            imgElement.style.height = "100%";
<span id="line23283" class="line"></span>
<span id="line23284" class="line"></span>            const style = element.style;
<span id="line23285" class="line"></span>            style.position = "absolute";
<span id="line23286" class="line"></span>
<span id="line23287" class="line"></span>            return {
<span id="line23288" class="line"></span>                element, imgElement, style, data
<span id="line23289" class="line"></span>            };
<span id="line23290" class="line"></span>        }
<span id="line23291" class="line"></span>
<span id="line23292" class="line"></span>        // In theory, HTML drawer should cope well with canvas node type too,
<span id="line23293" class="line"></span>        // but tests fail - if this conversion is used, it outputs uninitialized zeroed data
<span id="line23294" class="line"></span>        // (data manipulation test module).
<span id="line23295" class="line"></span>
<span id="line23296" class="line"></span>        // The actual placing logics will not happen at draw event, but when the cache is created:
<span id="line23297" class="line"></span>        // $.converter.learn("context2d", HTMLDrawer.canvasCacheType, (t, d) =&gt; _prepareTile(t, d.canvas), 1, 1);
<span id="line23298" class="line"></span>        $.converter.learn("image", HTMLDrawer.imageCacheType, _prepareTile, 1, 1);
<span id="line23299" class="line"></span>        // Also learn how to move back, since these elements can be just used as-is
<span id="line23300" class="line"></span>        // $.converter.learn(HTMLDrawer.canvasCacheType, "context2d", (t, d) =&gt; d.data.getContext('2d'), 1, 3);
<span id="line23301" class="line"></span>        $.converter.learn(HTMLDrawer.imageCacheType, "image", (t, d) =&gt; d.data, 1, 3);
<span id="line23302" class="line"></span>
<span id="line23303" class="line"></span>        function _freeTile(data) {
<span id="line23304" class="line"></span>            if ( data.imgElement &amp;&amp; data.imgElement.parentNode ) {
<span id="line23305" class="line"></span>                data.imgElement.parentNode.removeChild( data.imgElement );
<span id="line23306" class="line"></span>            }
<span id="line23307" class="line"></span>            if ( data.element &amp;&amp; data.element.parentNode ) {
<span id="line23308" class="line"></span>                data.element.parentNode.removeChild( data.element );
<span id="line23309" class="line"></span>            }
<span id="line23310" class="line"></span>        }
<span id="line23311" class="line"></span>
<span id="line23312" class="line"></span>        // $.converter.learnDestroy(HTMLDrawer.canvasCacheType, _freeTile);
<span id="line23313" class="line"></span>        $.converter.learnDestroy(HTMLDrawer.imageCacheType, _freeTile);
<span id="line23314" class="line"></span>    }
<span id="line23315" class="line"></span>
<span id="line23316" class="line"></span>    static get imageCacheType() {
<span id="line23317" class="line"></span>        return 'htmlDrawer[image]';
<span id="line23318" class="line"></span>    }
<span id="line23319" class="line"></span>
<span id="line23320" class="line"></span>    static get canvasCacheType() {
<span id="line23321" class="line"></span>        return 'htmlDrawer[canvas]';
<span id="line23322" class="line"></span>    }
<span id="line23323" class="line"></span>
<span id="line23324" class="line"></span>    /**
<span id="line23325" class="line"></span>     * @returns {Boolean} always true
<span id="line23326" class="line"></span>     */
<span id="line23327" class="line"></span>    static isSupported() {
<span id="line23328" class="line"></span>        return true;
<span id="line23329" class="line"></span>    }
<span id="line23330" class="line"></span>
<span id="line23331" class="line"></span>    /**
<span id="line23332" class="line"></span>     *
<span id="line23333" class="line"></span>     * @returns 'html'
<span id="line23334" class="line"></span>     */
<span id="line23335" class="line"></span>    getType(){
<span id="line23336" class="line"></span>        return 'html';
<span id="line23337" class="line"></span>    }
<span id="line23338" class="line"></span>
<span id="line23339" class="line"></span>    getSupportedDataFormats() {
<span id="line23340" class="line"></span>        return [HTMLDrawer.imageCacheType, HTMLDrawer.canvasCacheType];
<span id="line23341" class="line"></span>    }
<span id="line23342" class="line"></span>
<span id="line23343" class="line"></span>    /**
<span id="line23344" class="line"></span>     * @param {TiledImage} tiledImage the tiled image that is calling the function
<span id="line23345" class="line"></span>     * @returns {Boolean} Whether this drawer requires enforcing minimum tile overlap to avoid showing seams.
<span id="line23346" class="line"></span>     * @private
<span id="line23347" class="line"></span>     */
<span id="line23348" class="line"></span>    minimumOverlapRequired(tiledImage) {
<span id="line23349" class="line"></span>        return true;
<span id="line23350" class="line"></span>    }
<span id="line23351" class="line"></span>
<span id="line23352" class="line"></span>    /**
<span id="line23353" class="line"></span>     * create the HTML element (e.g. canvas, div) that the image will be drawn into
<span id="line23354" class="line"></span>     * @returns {Element} the div to draw into
<span id="line23355" class="line"></span>     */
<span id="line23356" class="line"></span>    _createDrawingElement(){
<span id="line23357" class="line"></span>        return $.makeNeutralElement("div");
<span id="line23358" class="line"></span>    }
<span id="line23359" class="line"></span>
<span id="line23360" class="line"></span>    /**
<span id="line23361" class="line"></span>     * Draws the TiledImages
<span id="line23362" class="line"></span>     */
<span id="line23363" class="line"></span>    draw(tiledImages) {
<span id="line23364" class="line"></span>        const _this = this;
<span id="line23365" class="line"></span>        this._prepareNewFrame(); // prepare to draw a new frame
<span id="line23366" class="line"></span>        tiledImages.forEach(function(tiledImage){
<span id="line23367" class="line"></span>            if (tiledImage.opacity !== 0) {
<span id="line23368" class="line"></span>                _this._drawTiles(tiledImage);
<span id="line23369" class="line"></span>            }
<span id="line23370" class="line"></span>        });
<span id="line23371" class="line"></span>
<span id="line23372" class="line"></span>    }
<span id="line23373" class="line"></span>
<span id="line23374" class="line"></span>    /**
<span id="line23375" class="line"></span>     * @returns {Boolean} False - rotation is not supported.
<span id="line23376" class="line"></span>     */
<span id="line23377" class="line"></span>    canRotate() {
<span id="line23378" class="line"></span>        return false;
<span id="line23379" class="line"></span>    }
<span id="line23380" class="line"></span>
<span id="line23381" class="line"></span>    /**
<span id="line23382" class="line"></span>     * Destroy the drawer (unload current loaded tiles)
<span id="line23383" class="line"></span>     */
<span id="line23384" class="line"></span>    destroy() {
<span id="line23385" class="line"></span>        super.destroy();
<span id="line23386" class="line"></span>        this.container.removeChild(this.canvas);
<span id="line23387" class="line"></span>    }
<span id="line23388" class="line"></span>
<span id="line23389" class="line"></span>    /**
<span id="line23390" class="line"></span>     * This function is ignored by the HTML Drawer. Implementing it is required by DrawerBase.
<span id="line23391" class="line"></span>     * @param {Boolean} [imageSmoothingEnabled] - Whether or not the image is
<span id="line23392" class="line"></span>     * drawn smoothly on the canvas; see imageSmoothingEnabled in
<span id="line23393" class="line"></span>     * {@link OpenSeadragon.Options} for more explanation.
<span id="line23394" class="line"></span>     */
<span id="line23395" class="line"></span>    setImageSmoothingEnabled(){
<span id="line23396" class="line"></span>        // noop - HTML Drawer does not deal with this property
<span id="line23397" class="line"></span>    }
<span id="line23398" class="line"></span>
<span id="line23399" class="line"></span>    /**
<span id="line23400" class="line"></span>     * Clears the Drawer so it's ready to draw another frame.
<span id="line23401" class="line"></span>     * @private
<span id="line23402" class="line"></span>     *
<span id="line23403" class="line"></span>     */
<span id="line23404" class="line"></span>    _prepareNewFrame() {
<span id="line23405" class="line"></span>        this.canvas.innerHTML = "";
<span id="line23406" class="line"></span>    }
<span id="line23407" class="line"></span>
<span id="line23408" class="line"></span>    /**
<span id="line23409" class="line"></span>     * Draws a TiledImage.
<span id="line23410" class="line"></span>     * @private
<span id="line23411" class="line"></span>     *
<span id="line23412" class="line"></span>     */
<span id="line23413" class="line"></span>    _drawTiles( tiledImage ) {
<span id="line23414" class="line"></span>        const lastDrawn = tiledImage.getTilesToDraw().map(info =&gt; info.tile);
<span id="line23415" class="line"></span>        if (tiledImage.opacity === 0 || (lastDrawn.length === 0 &amp;&amp; !tiledImage.placeholderFillStyle)) {
<span id="line23416" class="line"></span>            return;
<span id="line23417" class="line"></span>        }
<span id="line23418" class="line"></span>
<span id="line23419" class="line"></span>        // Iterate over the tiles to draw, and draw them
<span id="line23420" class="line"></span>        for (let i = lastDrawn.length - 1; i &gt;= 0; i--) {
<span id="line23421" class="line"></span>            const tile = lastDrawn[ i ];
<span id="line23422" class="line"></span>            this._drawTile( tile );
<span id="line23423" class="line"></span>
<span id="line23424" class="line"></span>            if( this.viewer ){
<span id="line23425" class="line"></span>                /**
<span id="line23426" class="line"></span>                 * Raised when a tile is drawn to the canvas. Only valid for
<span id="line23427" class="line"></span>                 * context2d and html drawers.
<span id="line23428" class="line"></span>                 *
<span id="line23429" class="line"></span>                 * @event tile-drawn
<span id="line23430" class="line"></span>                 * @memberof OpenSeadragon.Viewer
<span id="line23431" class="line"></span>                 * @type {object}
<span id="line23432" class="line"></span>                 * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line23433" class="line"></span>                 * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
<span id="line23434" class="line"></span>                 * @property {OpenSeadragon.Tile} tile
<span id="line23435" class="line"></span>                 * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line23436" class="line"></span>                 */
<span id="line23437" class="line"></span>                this.viewer.raiseEvent( 'tile-drawn', {
<span id="line23438" class="line"></span>                    tiledImage: tiledImage,
<span id="line23439" class="line"></span>                    tile: tile
<span id="line23440" class="line"></span>                });
<span id="line23441" class="line"></span>            }
<span id="line23442" class="line"></span>        }
<span id="line23443" class="line"></span>
<span id="line23444" class="line"></span>    }
<span id="line23445" class="line"></span>
<span id="line23446" class="line"></span>    /**
<span id="line23447" class="line"></span>     * Draws the given tile.
<span id="line23448" class="line"></span>     * @private
<span id="line23449" class="line"></span>     * @param {OpenSeadragon.Tile} tile - The tile to draw.
<span id="line23450" class="line"></span>     * @param {Function} drawingHandler - Method for firing the drawing event if using canvas.
<span id="line23451" class="line"></span>     * drawingHandler({context, tile, rendered})
<span id="line23452" class="line"></span>     */
<span id="line23453" class="line"></span>    _drawTile( tile ) {
<span id="line23454" class="line"></span>        $.console.assert(tile, '[Drawer._drawTile] tile is required');
<span id="line23455" class="line"></span>
<span id="line23456" class="line"></span>        let container = this.canvas;
<span id="line23457" class="line"></span>
<span id="line23458" class="line"></span>        if ( !tile.loaded ) {
<span id="line23459" class="line"></span>            $.console.warn(
<span id="line23460" class="line"></span>                "Attempting to draw tile %s when it's not yet loaded.",
<span id="line23461" class="line"></span>                tile.toString()
<span id="line23462" class="line"></span>            );
<span id="line23463" class="line"></span>            return;
<span id="line23464" class="line"></span>        }
<span id="line23465" class="line"></span>
<span id="line23466" class="line"></span>        //EXPERIMENTAL - trying to figure out how to scale the container
<span id="line23467" class="line"></span>        //               content during animation of the container size.
<span id="line23468" class="line"></span>
<span id="line23469" class="line"></span>        const dataObject = this.getDataToDraw(tile);
<span id="line23470" class="line"></span>        if (!dataObject) {
<span id="line23471" class="line"></span>            return;
<span id="line23472" class="line"></span>        }
<span id="line23473" class="line"></span>
<span id="line23474" class="line"></span>        if ( dataObject.element.parentNode !== container ) {
<span id="line23475" class="line"></span>            container.appendChild( dataObject.element );
<span id="line23476" class="line"></span>        }
<span id="line23477" class="line"></span>        if ( dataObject.imgElement.parentNode !== dataObject.element ) {
<span id="line23478" class="line"></span>            dataObject.element.appendChild( dataObject.imgElement );
<span id="line23479" class="line"></span>        }
<span id="line23480" class="line"></span>
<span id="line23481" class="line"></span>        dataObject.style.top     = tile.position.y + "px";
<span id="line23482" class="line"></span>        dataObject.style.left    = tile.position.x + "px";
<span id="line23483" class="line"></span>        dataObject.style.height  = tile.size.y + "px";
<span id="line23484" class="line"></span>        dataObject.style.width   = tile.size.x + "px";
<span id="line23485" class="line"></span>
<span id="line23486" class="line"></span>        if (tile.flipped) {
<span id="line23487" class="line"></span>            dataObject.style.transform = "scaleX(-1)";
<span id="line23488" class="line"></span>        }
<span id="line23489" class="line"></span>
<span id="line23490" class="line"></span>        $.setElementOpacity( dataObject.element, tile.opacity );
<span id="line23491" class="line"></span>    }
<span id="line23492" class="line"></span>}
<span id="line23493" class="line"></span>
<span id="line23494" class="line"></span>$.HTMLDrawer = HTMLDrawer;
<span id="line23495" class="line"></span>
<span id="line23496" class="line"></span>
<span id="line23497" class="line"></span>}( OpenSeadragon ));
<span id="line23498" class="line"></span>
<span id="line23499" class="line"></span>/*
<span id="line23500" class="line"></span> * OpenSeadragon - CanvasDrawer
<span id="line23501" class="line"></span> *
<span id="line23502" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line23503" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line23504" class="line"></span> *
<span id="line23505" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line23506" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line23507" class="line"></span> * met:
<span id="line23508" class="line"></span> *
<span id="line23509" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line23510" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line23511" class="line"></span> *
<span id="line23512" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line23513" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line23514" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line23515" class="line"></span> *
<span id="line23516" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line23517" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line23518" class="line"></span> *   this software without specific prior written permission.
<span id="line23519" class="line"></span> *
<span id="line23520" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line23521" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line23522" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line23523" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line23524" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line23525" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line23526" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line23527" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line23528" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line23529" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line23530" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line23531" class="line"></span> */
<span id="line23532" class="line"></span>
<span id="line23533" class="line"></span>(function( $ ){
<span id="line23534" class="line"></span>
<span id="line23535" class="line"></span>    const OpenSeadragon = $; // (re)alias back to OpenSeadragon for JSDoc
<span id="line23536" class="line"></span>/**
<span id="line23537" class="line"></span> * @class OpenSeadragon.CanvasDrawer
<span id="line23538" class="line"></span> * @extends OpenSeadragon.DrawerBase
<span id="line23539" class="line"></span> * @classdesc Default implementation of CanvasDrawer for an {@link OpenSeadragon.Viewer}.
<span id="line23540" class="line"></span> * @param {Object} options - Options for this Drawer.
<span id="line23541" class="line"></span> * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this Drawer.
<span id="line23542" class="line"></span> * @param {OpenSeadragon.Viewport} options.viewport - Reference to Viewer viewport.
<span id="line23543" class="line"></span> * @param {Element} options.element - Parent element.
<span id="line23544" class="line"></span> * @param {Number} [options.debugGridColor] - See debugGridColor in {@link OpenSeadragon.Options} for details.
<span id="line23545" class="line"></span> */
<span id="line23546" class="line"></span>
<span id="line23547" class="line"></span>class CanvasDrawer extends OpenSeadragon.DrawerBase{
<span id="line23548" class="line"></span>    constructor(options) {
<span id="line23549" class="line"></span>        super(options);
<span id="line23550" class="line"></span>
<span id="line23551" class="line"></span>        /**
<span id="line23552" class="line"></span>         * The HTML element (canvas) that this drawer uses for drawing
<span id="line23553" class="line"></span>         * @member {Element} canvas
<span id="line23554" class="line"></span>         * @memberof OpenSeadragon.CanvasDrawer#
<span id="line23555" class="line"></span>         */
<span id="line23556" class="line"></span>
<span id="line23557" class="line"></span>        /**
<span id="line23558" class="line"></span>         * The parent element of this Drawer instance, passed in when the Drawer was created.
<span id="line23559" class="line"></span>         * The parent of {@link OpenSeadragon.WebGLDrawer#canvas}.
<span id="line23560" class="line"></span>         * @member {Element} container
<span id="line23561" class="line"></span>         * @memberof OpenSeadragon.CanvasDrawer#
<span id="line23562" class="line"></span>         */
<span id="line23563" class="line"></span>
<span id="line23564" class="line"></span>        /**
<span id="line23565" class="line"></span>         * 2d drawing context for {@link OpenSeadragon.CanvasDrawer#canvas}.
<span id="line23566" class="line"></span>         * @member {Object} context
<span id="line23567" class="line"></span>         * @memberof OpenSeadragon.CanvasDrawer#
<span id="line23568" class="line"></span>         * @private
<span id="line23569" class="line"></span>         */
<span id="line23570" class="line"></span>        this.context = this.canvas.getContext('2d');
<span id="line23571" class="line"></span>
<span id="line23572" class="line"></span>        // Sketch canvas used to temporarily draw tiles which cannot be drawn directly
<span id="line23573" class="line"></span>        // to the main canvas due to opacity. Lazily initialized.
<span id="line23574" class="line"></span>        this.sketchCanvas = null;
<span id="line23575" class="line"></span>        this.sketchContext = null;
<span id="line23576" class="line"></span>
<span id="line23577" class="line"></span>        // Image smoothing for canvas rendering (only if canvas is used).
<span id="line23578" class="line"></span>        // Canvas default is "true", so this will only be changed if user specifies "false" in the options or via setImageSmoothinEnabled.
<span id="line23579" class="line"></span>        this._imageSmoothingEnabled = true;
<span id="line23580" class="line"></span>
<span id="line23581" class="line"></span>        // Since the tile-drawn and tile-drawing events are fired by this drawer, make sure handlers can be added for them
<span id="line23582" class="line"></span>        this.viewer.allowEventHandler("tile-drawn");
<span id="line23583" class="line"></span>        this.viewer.allowEventHandler("tile-drawing");
<span id="line23584" class="line"></span>
<span id="line23585" class="line"></span>    }
<span id="line23586" class="line"></span>
<span id="line23587" class="line"></span>    /**
<span id="line23588" class="line"></span>     * @returns {Boolean} true if canvas is supported by the browser, otherwise false
<span id="line23589" class="line"></span>     */
<span id="line23590" class="line"></span>    static isSupported(){
<span id="line23591" class="line"></span>        return $.supportsCanvas;
<span id="line23592" class="line"></span>    }
<span id="line23593" class="line"></span>
<span id="line23594" class="line"></span>    getType(){
<span id="line23595" class="line"></span>        return 'canvas';
<span id="line23596" class="line"></span>    }
<span id="line23597" class="line"></span>
<span id="line23598" class="line"></span>    getSupportedDataFormats() {
<span id="line23599" class="line"></span>        return ["context2d"];
<span id="line23600" class="line"></span>    }
<span id="line23601" class="line"></span>
<span id="line23602" class="line"></span>    /**
<span id="line23603" class="line"></span>     * create the HTML element (e.g. canvas, div) that the image will be drawn into
<span id="line23604" class="line"></span>     * @returns {Element} the canvas to draw into
<span id="line23605" class="line"></span>     */
<span id="line23606" class="line"></span>    _createDrawingElement(){
<span id="line23607" class="line"></span>        const canvas = $.makeNeutralElement("canvas");
<span id="line23608" class="line"></span>        const viewportSize = this._calculateCanvasSize();
<span id="line23609" class="line"></span>        canvas.width = viewportSize.x;
<span id="line23610" class="line"></span>        canvas.height = viewportSize.y;
<span id="line23611" class="line"></span>        return canvas;
<span id="line23612" class="line"></span>    }
<span id="line23613" class="line"></span>
<span id="line23614" class="line"></span>    /**
<span id="line23615" class="line"></span>     * Draws the TiledImages
<span id="line23616" class="line"></span>     */
<span id="line23617" class="line"></span>    draw(tiledImages) {
<span id="line23618" class="line"></span>        this._prepareNewFrame(); // prepare to draw a new frame
<span id="line23619" class="line"></span>        if(this.viewer.viewport.getFlip() !== this._viewportFlipped){
<span id="line23620" class="line"></span>            this._flip();
<span id="line23621" class="line"></span>        }
<span id="line23622" class="line"></span>        for(const tiledImage of tiledImages){
<span id="line23623" class="line"></span>            if (tiledImage.opacity !== 0) {
<span id="line23624" class="line"></span>                this._drawTiles(tiledImage);
<span id="line23625" class="line"></span>            }
<span id="line23626" class="line"></span>        }
<span id="line23627" class="line"></span>    }
<span id="line23628" class="line"></span>
<span id="line23629" class="line"></span>    /**
<span id="line23630" class="line"></span>     * @returns {Boolean} True - rotation is supported.
<span id="line23631" class="line"></span>     */
<span id="line23632" class="line"></span>    canRotate() {
<span id="line23633" class="line"></span>        return true;
<span id="line23634" class="line"></span>    }
<span id="line23635" class="line"></span>
<span id="line23636" class="line"></span>    /**
<span id="line23637" class="line"></span>     * Destroy the drawer (unload current loaded tiles)
<span id="line23638" class="line"></span>     */
<span id="line23639" class="line"></span>    destroy() {
<span id="line23640" class="line"></span>        super.destroy();
<span id="line23641" class="line"></span>        //force unloading of current canvas (1x1 will be gc later, trick not necessarily needed)
<span id="line23642" class="line"></span>        this.canvas.width  = 1;
<span id="line23643" class="line"></span>        this.canvas.height = 1;
<span id="line23644" class="line"></span>        this.sketchCanvas = null;
<span id="line23645" class="line"></span>        this.sketchContext = null;
<span id="line23646" class="line"></span>        this.container.removeChild(this.canvas);
<span id="line23647" class="line"></span>    }
<span id="line23648" class="line"></span>
<span id="line23649" class="line"></span>    /**
<span id="line23650" class="line"></span>     * @param {TiledImage} tiledImage the tiled image that is calling the function
<span id="line23651" class="line"></span>     * @returns {Boolean} Whether this drawer requires enforcing minimum tile overlap to avoid showing seams.
<span id="line23652" class="line"></span>     * @private
<span id="line23653" class="line"></span>     */
<span id="line23654" class="line"></span>    minimumOverlapRequired(tiledImage) {
<span id="line23655" class="line"></span>        return true;
<span id="line23656" class="line"></span>    }
<span id="line23657" class="line"></span>
<span id="line23658" class="line"></span>
<span id="line23659" class="line"></span>    /**
<span id="line23660" class="line"></span>     * Turns image smoothing on or off for this viewer. Note: Ignored in some (especially older) browsers that do not support this property.
<span id="line23661" class="line"></span>     *
<span id="line23662" class="line"></span>     * @function
<span id="line23663" class="line"></span>     * @param {Boolean} [imageSmoothingEnabled] - Whether or not the image is
<span id="line23664" class="line"></span>     * drawn smoothly on the canvas; see imageSmoothingEnabled in
<span id="line23665" class="line"></span>     * {@link OpenSeadragon.Options} for more explanation.
<span id="line23666" class="line"></span>     */
<span id="line23667" class="line"></span>    setImageSmoothingEnabled(imageSmoothingEnabled){
<span id="line23668" class="line"></span>        this._imageSmoothingEnabled = !!imageSmoothingEnabled;
<span id="line23669" class="line"></span>        this._updateImageSmoothingEnabled(this.context);
<span id="line23670" class="line"></span>        this.viewer.forceRedraw();
<span id="line23671" class="line"></span>    }
<span id="line23672" class="line"></span>
<span id="line23673" class="line"></span>    /**
<span id="line23674" class="line"></span>     * Draw a rectangle onto the canvas
<span id="line23675" class="line"></span>     * @param {OpenSeadragon.Rect} rect
<span id="line23676" class="line"></span>     */
<span id="line23677" class="line"></span>    drawDebuggingRect(rect) {
<span id="line23678" class="line"></span>        const context = this.context;
<span id="line23679" class="line"></span>        context.save();
<span id="line23680" class="line"></span>        context.lineWidth = 2 * $.pixelDensityRatio;
<span id="line23681" class="line"></span>        context.strokeStyle = this.debugGridColor[0];
<span id="line23682" class="line"></span>        context.fillStyle = this.debugGridColor[0];
<span id="line23683" class="line"></span>
<span id="line23684" class="line"></span>        context.strokeRect(
<span id="line23685" class="line"></span>            rect.x * $.pixelDensityRatio,
<span id="line23686" class="line"></span>            rect.y * $.pixelDensityRatio,
<span id="line23687" class="line"></span>            rect.width * $.pixelDensityRatio,
<span id="line23688" class="line"></span>            rect.height * $.pixelDensityRatio
<span id="line23689" class="line"></span>        );
<span id="line23690" class="line"></span>
<span id="line23691" class="line"></span>        context.restore();
<span id="line23692" class="line"></span>    }
<span id="line23693" class="line"></span>
<span id="line23694" class="line"></span>    /**
<span id="line23695" class="line"></span>     * Test whether the current context is flipped or not
<span id="line23696" class="line"></span>     * @private
<span id="line23697" class="line"></span>     */
<span id="line23698" class="line"></span>    get _viewportFlipped(){
<span id="line23699" class="line"></span>        return this.context.getTransform().a &lt; 0;
<span id="line23700" class="line"></span>    }
<span id="line23701" class="line"></span>
<span id="line23702" class="line"></span>    /**
<span id="line23703" class="line"></span>     * Fires the tile-drawing event.
<span id="line23704" class="line"></span>     * @private
<span id="line23705" class="line"></span>     */
<span id="line23706" class="line"></span>    _raiseTileDrawingEvent(tiledImage, context, tile, rendered){
<span id="line23707" class="line"></span>        /**
<span id="line23708" class="line"></span>         * This event is fired just before the tile is drawn giving the application a chance to alter the image.
<span id="line23709" class="line"></span>         *
<span id="line23710" class="line"></span>         * NOTE: This event is only fired when the 'canvas' drawer is being used
<span id="line23711" class="line"></span>         *
<span id="line23712" class="line"></span>         * @event tile-drawing
<span id="line23713" class="line"></span>         * @memberof OpenSeadragon.Viewer
<span id="line23714" class="line"></span>         * @type {object}
<span id="line23715" class="line"></span>         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line23716" class="line"></span>         * @property {OpenSeadragon.Tile} tile - The Tile being drawn.
<span id="line23717" class="line"></span>         * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
<span id="line23718" class="line"></span>         * @property {CanvasRenderingContext2D} context - The HTML canvas context being drawn into.
<span id="line23719" class="line"></span>         * @property {CanvasRenderingContext2D} rendered - The HTML canvas context containing the tile imagery.
<span id="line23720" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line23721" class="line"></span>         */
<span id="line23722" class="line"></span>        this.viewer.raiseEvent('tile-drawing', {
<span id="line23723" class="line"></span>            tiledImage: tiledImage,
<span id="line23724" class="line"></span>            context: context,
<span id="line23725" class="line"></span>            tile: tile,
<span id="line23726" class="line"></span>            rendered: rendered
<span id="line23727" class="line"></span>        });
<span id="line23728" class="line"></span>    }
<span id="line23729" class="line"></span>
<span id="line23730" class="line"></span>    /**
<span id="line23731" class="line"></span>     * Clears the Drawer so it's ready to draw another frame.
<span id="line23732" class="line"></span>     * @private
<span id="line23733" class="line"></span>     *
<span id="line23734" class="line"></span>     */
<span id="line23735" class="line"></span>    _prepareNewFrame() {
<span id="line23736" class="line"></span>        const viewportSize = this._calculateCanvasSize();
<span id="line23737" class="line"></span>        if( this.canvas.width !== viewportSize.x ||
<span id="line23738" class="line"></span>            this.canvas.height !== viewportSize.y ) {
<span id="line23739" class="line"></span>            this.canvas.width = viewportSize.x;
<span id="line23740" class="line"></span>            this.canvas.height = viewportSize.y;
<span id="line23741" class="line"></span>            this._updateImageSmoothingEnabled(this.context);
<span id="line23742" class="line"></span>            if ( this.sketchCanvas !== null ) {
<span id="line23743" class="line"></span>                const sketchCanvasSize = this._calculateSketchCanvasSize();
<span id="line23744" class="line"></span>                this.sketchCanvas.width = sketchCanvasSize.x;
<span id="line23745" class="line"></span>                this.sketchCanvas.height = sketchCanvasSize.y;
<span id="line23746" class="line"></span>                this._updateImageSmoothingEnabled(this.sketchContext);
<span id="line23747" class="line"></span>            }
<span id="line23748" class="line"></span>        }
<span id="line23749" class="line"></span>        this._clear();
<span id="line23750" class="line"></span>    }
<span id="line23751" class="line"></span>
<span id="line23752" class="line"></span>    /**
<span id="line23753" class="line"></span>     * @private
<span id="line23754" class="line"></span>     * @param {Boolean} useSketch Whether to clear sketch canvas or main canvas
<span id="line23755" class="line"></span>     * @param {OpenSeadragon.Rect} [bounds] The rectangle to clear
<span id="line23756" class="line"></span>     */
<span id="line23757" class="line"></span>    _clear(useSketch, bounds){
<span id="line23758" class="line"></span>        const context = this._getContext(useSketch);
<span id="line23759" class="line"></span>        if (bounds) {
<span id="line23760" class="line"></span>            context.clearRect(bounds.x, bounds.y, bounds.width, bounds.height);
<span id="line23761" class="line"></span>        } else {
<span id="line23762" class="line"></span>            const canvas = context.canvas;
<span id="line23763" class="line"></span>            context.clearRect(0, 0, canvas.width, canvas.height);
<span id="line23764" class="line"></span>        }
<span id="line23765" class="line"></span>    }
<span id="line23766" class="line"></span>
<span id="line23767" class="line"></span>    /**
<span id="line23768" class="line"></span>     * Draws a TiledImage.
<span id="line23769" class="line"></span>     * @private
<span id="line23770" class="line"></span>     *
<span id="line23771" class="line"></span>     */
<span id="line23772" class="line"></span>    _drawTiles( tiledImage ) {
<span id="line23773" class="line"></span>        const lastDrawn =  tiledImage.getTilesToDraw().map(info =&gt; info.tile);
<span id="line23774" class="line"></span>        if (tiledImage.opacity === 0 || (lastDrawn.length === 0 &amp;&amp; !tiledImage.placeholderFillStyle)) {
<span id="line23775" class="line"></span>            return;
<span id="line23776" class="line"></span>        }
<span id="line23777" class="line"></span>
<span id="line23778" class="line"></span>        let tile = lastDrawn[0];
<span id="line23779" class="line"></span>        let useSketch;
<span id="line23780" class="line"></span>
<span id="line23781" class="line"></span>        if (tile) {
<span id="line23782" class="line"></span>            useSketch = tiledImage.opacity &lt; 1 ||
<span id="line23783" class="line"></span>                (tiledImage.compositeOperation &amp;&amp; tiledImage.compositeOperation !== 'source-over') ||
<span id="line23784" class="line"></span>                (!tiledImage._isBottomItem() &amp;&amp;
<span id="line23785" class="line"></span>                tiledImage.source.hasTransparency(null, tile.getUrl(), tile.ajaxHeaders, tile.postData));
<span id="line23786" class="line"></span>        }
<span id="line23787" class="line"></span>
<span id="line23788" class="line"></span>        let sketchScale;
<span id="line23789" class="line"></span>        let sketchTranslate;
<span id="line23790" class="line"></span>
<span id="line23791" class="line"></span>        const zoom = this.viewport.getZoom(true);
<span id="line23792" class="line"></span>        const imageZoom = tiledImage.viewportToImageZoom(zoom);
<span id="line23793" class="line"></span>
<span id="line23794" class="line"></span>        if (lastDrawn.length &gt; 1 &amp;&amp;
<span id="line23795" class="line"></span>            imageZoom &gt; tiledImage.smoothTileEdgesMinZoom &amp;&amp;
<span id="line23796" class="line"></span>            !tiledImage.iOSDevice &amp;&amp;
<span id="line23797" class="line"></span>            tiledImage.getRotation(true) % 360 === 0 ){ // TODO: support tile edge smoothing with tiled image rotation.
<span id="line23798" class="line"></span>            // When zoomed in a lot (&gt;100%) the tile edges are visible.
<span id="line23799" class="line"></span>            // So we have to composite them at ~100% and scale them up together.
<span id="line23800" class="line"></span>            // Note: Disabled on iOS devices per default as it causes a native crash
<span id="line23801" class="line"></span>            useSketch = true;
<span id="line23802" class="line"></span>
<span id="line23803" class="line"></span>            const context = tile.length &amp;&amp; this.getDataToDraw(tile);
<span id="line23804" class="line"></span>            if (context) {
<span id="line23805" class="line"></span>                sketchScale = context.canvas.width / (tile.size.x * $.pixelDensityRatio);
<span id="line23806" class="line"></span>            } else {
<span id="line23807" class="line"></span>                sketchScale = 1;
<span id="line23808" class="line"></span>            }
<span id="line23809" class="line"></span>            sketchTranslate = tile.getTranslationForEdgeSmoothing(sketchScale,
<span id="line23810" class="line"></span>                this._getCanvasSize(false),
<span id="line23811" class="line"></span>                this._getCanvasSize(true));
<span id="line23812" class="line"></span>        }
<span id="line23813" class="line"></span>
<span id="line23814" class="line"></span>        let bounds;
<span id="line23815" class="line"></span>        if (useSketch) {
<span id="line23816" class="line"></span>            if (!sketchScale) {
<span id="line23817" class="line"></span>                // Except when edge smoothing, we only clean the part of the
<span id="line23818" class="line"></span>                // sketch canvas we are going to use for performance reasons.
<span id="line23819" class="line"></span>                bounds = this.viewport.viewportToViewerElementRectangle(
<span id="line23820" class="line"></span>                    tiledImage.getClippedBounds(true))
<span id="line23821" class="line"></span>                    .getIntegerBoundingBox();
<span id="line23822" class="line"></span>
<span id="line23823" class="line"></span>                bounds = bounds.times($.pixelDensityRatio);
<span id="line23824" class="line"></span>            }
<span id="line23825" class="line"></span>            this._clear(true, bounds);
<span id="line23826" class="line"></span>        }
<span id="line23827" class="line"></span>
<span id="line23828" class="line"></span>        // When scaling, we must rotate only when blending the sketch canvas to
<span id="line23829" class="line"></span>        // avoid interpolation
<span id="line23830" class="line"></span>        if (!sketchScale) {
<span id="line23831" class="line"></span>            this._setRotations(tiledImage, useSketch);
<span id="line23832" class="line"></span>        }
<span id="line23833" class="line"></span>
<span id="line23834" class="line"></span>        let usedClip = false;
<span id="line23835" class="line"></span>        if ( tiledImage._clip ) {
<span id="line23836" class="line"></span>            this._saveContext(useSketch);
<span id="line23837" class="line"></span>
<span id="line23838" class="line"></span>            let box = tiledImage.imageToViewportRectangle(tiledImage._clip, true);
<span id="line23839" class="line"></span>            box = box.rotate(-tiledImage.getRotation(true), tiledImage._getRotationPoint(true));
<span id="line23840" class="line"></span>            let clipRect = this.viewportToDrawerRectangle(box);
<span id="line23841" class="line"></span>            if (sketchScale) {
<span id="line23842" class="line"></span>                clipRect = clipRect.times(sketchScale);
<span id="line23843" class="line"></span>            }
<span id="line23844" class="line"></span>            if (sketchTranslate) {
<span id="line23845" class="line"></span>                clipRect = clipRect.translate(sketchTranslate);
<span id="line23846" class="line"></span>            }
<span id="line23847" class="line"></span>            this._setClip(clipRect, useSketch);
<span id="line23848" class="line"></span>
<span id="line23849" class="line"></span>            usedClip = true;
<span id="line23850" class="line"></span>        }
<span id="line23851" class="line"></span>
<span id="line23852" class="line"></span>        if (tiledImage._croppingPolygons) {
<span id="line23853" class="line"></span>            const self = this;
<span id="line23854" class="line"></span>            if(!usedClip){
<span id="line23855" class="line"></span>                this._saveContext(useSketch);
<span id="line23856" class="line"></span>            }
<span id="line23857" class="line"></span>            try {
<span id="line23858" class="line"></span>                const polygons = tiledImage._croppingPolygons.map(function (polygon) {
<span id="line23859" class="line"></span>                    return polygon.map(function (coord) {
<span id="line23860" class="line"></span>                        const point = tiledImage
<span id="line23861" class="line"></span>                            .imageToViewportCoordinates(coord.x, coord.y, true)
<span id="line23862" class="line"></span>                            .rotate(-tiledImage.getRotation(true), tiledImage._getRotationPoint(true));
<span id="line23863" class="line"></span>                        let clipPoint = self.viewportCoordToDrawerCoord(point);
<span id="line23864" class="line"></span>                        if (sketchScale) {
<span id="line23865" class="line"></span>                            clipPoint = clipPoint.times(sketchScale);
<span id="line23866" class="line"></span>                        }
<span id="line23867" class="line"></span>                        if (sketchTranslate) { // mostly fixes #2312
<span id="line23868" class="line"></span>                            clipPoint = clipPoint.plus(sketchTranslate);
<span id="line23869" class="line"></span>                        }
<span id="line23870" class="line"></span>                        return clipPoint;
<span id="line23871" class="line"></span>                    });
<span id="line23872" class="line"></span>                });
<span id="line23873" class="line"></span>                this._clipWithPolygons(polygons, useSketch);
<span id="line23874" class="line"></span>            } catch (e) {
<span id="line23875" class="line"></span>                $.console.error(e);
<span id="line23876" class="line"></span>            }
<span id="line23877" class="line"></span>            usedClip = true;
<span id="line23878" class="line"></span>        }
<span id="line23879" class="line"></span>        tiledImage._hasOpaqueTile = false;
<span id="line23880" class="line"></span>        if ( tiledImage.placeholderFillStyle &amp;&amp; tiledImage._hasOpaqueTile === false ) {
<span id="line23881" class="line"></span>            let placeholderRect = this.viewportToDrawerRectangle(tiledImage.getBoundsNoRotate(true));
<span id="line23882" class="line"></span>            if (sketchScale) {
<span id="line23883" class="line"></span>                placeholderRect = placeholderRect.times(sketchScale);
<span id="line23884" class="line"></span>            }
<span id="line23885" class="line"></span>            if (sketchTranslate) {
<span id="line23886" class="line"></span>                placeholderRect = placeholderRect.translate(sketchTranslate);
<span id="line23887" class="line"></span>            }
<span id="line23888" class="line"></span>
<span id="line23889" class="line"></span>            let fillStyle = null;
<span id="line23890" class="line"></span>            if ( typeof tiledImage.placeholderFillStyle === "function" ) {
<span id="line23891" class="line"></span>                fillStyle = tiledImage.placeholderFillStyle(tiledImage, this.context);
<span id="line23892" class="line"></span>            }
<span id="line23893" class="line"></span>            else {
<span id="line23894" class="line"></span>                fillStyle = tiledImage.placeholderFillStyle;
<span id="line23895" class="line"></span>            }
<span id="line23896" class="line"></span>
<span id="line23897" class="line"></span>            this._drawRectangle(placeholderRect, fillStyle, useSketch);
<span id="line23898" class="line"></span>        }
<span id="line23899" class="line"></span>
<span id="line23900" class="line"></span>        const subPixelRoundingRule = determineSubPixelRoundingRule(tiledImage.subPixelRoundingForTransparency);
<span id="line23901" class="line"></span>
<span id="line23902" class="line"></span>        let shouldRoundPositionAndSize = false;
<span id="line23903" class="line"></span>
<span id="line23904" class="line"></span>        if (subPixelRoundingRule === $.SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS) {
<span id="line23905" class="line"></span>            shouldRoundPositionAndSize = true;
<span id="line23906" class="line"></span>        } else if (subPixelRoundingRule === $.SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST) {
<span id="line23907" class="line"></span>            shouldRoundPositionAndSize = !(this.viewer &amp;&amp; this.viewer.isAnimating());
<span id="line23908" class="line"></span>        }
<span id="line23909" class="line"></span>
<span id="line23910" class="line"></span>        // Iterate over the tiles to draw, and draw them
<span id="line23911" class="line"></span>        for (let i = 0; i &lt; lastDrawn.length; i++) {
<span id="line23912" class="line"></span>            tile = lastDrawn[ i ];
<span id="line23913" class="line"></span>            this._drawTile( tile, tiledImage, useSketch, sketchScale,
<span id="line23914" class="line"></span>                sketchTranslate, shouldRoundPositionAndSize, tiledImage.source );
<span id="line23915" class="line"></span>
<span id="line23916" class="line"></span>            if( this.viewer ){
<span id="line23917" class="line"></span>                /**
<span id="line23918" class="line"></span>                 * Raised when a tile is drawn to the canvas. Only valid for
<span id="line23919" class="line"></span>                 * context2d and html drawers.
<span id="line23920" class="line"></span>                 *
<span id="line23921" class="line"></span>                 * @event tile-drawn
<span id="line23922" class="line"></span>                 * @memberof OpenSeadragon.Viewer
<span id="line23923" class="line"></span>                 * @type {object}
<span id="line23924" class="line"></span>                 * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line23925" class="line"></span>                 * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
<span id="line23926" class="line"></span>                 * @property {OpenSeadragon.Tile} tile
<span id="line23927" class="line"></span>                 * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line23928" class="line"></span>                 */
<span id="line23929" class="line"></span>                this.viewer.raiseEvent( 'tile-drawn', {
<span id="line23930" class="line"></span>                    tiledImage: tiledImage,
<span id="line23931" class="line"></span>                    tile: tile
<span id="line23932" class="line"></span>                });
<span id="line23933" class="line"></span>            }
<span id="line23934" class="line"></span>        }
<span id="line23935" class="line"></span>
<span id="line23936" class="line"></span>        if ( usedClip ) {
<span id="line23937" class="line"></span>            this._restoreContext( useSketch );
<span id="line23938" class="line"></span>        }
<span id="line23939" class="line"></span>
<span id="line23940" class="line"></span>        if (!sketchScale) {
<span id="line23941" class="line"></span>            if (tiledImage.getRotation(true) % 360 !== 0) {
<span id="line23942" class="line"></span>                this._restoreRotationChanges(useSketch);
<span id="line23943" class="line"></span>            }
<span id="line23944" class="line"></span>            if (this.viewport.getRotation(true) % 360 !== 0) {
<span id="line23945" class="line"></span>                this._restoreRotationChanges(useSketch);
<span id="line23946" class="line"></span>            }
<span id="line23947" class="line"></span>        }
<span id="line23948" class="line"></span>
<span id="line23949" class="line"></span>        if (useSketch) {
<span id="line23950" class="line"></span>            if (sketchScale) {
<span id="line23951" class="line"></span>                this._setRotations(tiledImage);
<span id="line23952" class="line"></span>            }
<span id="line23953" class="line"></span>            this.blendSketch({
<span id="line23954" class="line"></span>                opacity: tiledImage.opacity,
<span id="line23955" class="line"></span>                scale: sketchScale,
<span id="line23956" class="line"></span>                translate: sketchTranslate,
<span id="line23957" class="line"></span>                compositeOperation: tiledImage.compositeOperation,
<span id="line23958" class="line"></span>                bounds: bounds
<span id="line23959" class="line"></span>            });
<span id="line23960" class="line"></span>            if (sketchScale) {
<span id="line23961" class="line"></span>                if (tiledImage.getRotation(true) % 360 !== 0) {
<span id="line23962" class="line"></span>                    this._restoreRotationChanges(false);
<span id="line23963" class="line"></span>                }
<span id="line23964" class="line"></span>                if (this.viewport.getRotation(true) % 360 !== 0) {
<span id="line23965" class="line"></span>                    this._restoreRotationChanges(false);
<span id="line23966" class="line"></span>                }
<span id="line23967" class="line"></span>            }
<span id="line23968" class="line"></span>        }
<span id="line23969" class="line"></span>
<span id="line23970" class="line"></span>        this._drawDebugInfo( tiledImage, lastDrawn );
<span id="line23971" class="line"></span>
<span id="line23972" class="line"></span>        // Fire tiled-image-drawn event.
<span id="line23973" class="line"></span>        this._raiseTiledImageDrawnEvent(tiledImage, lastDrawn);
<span id="line23974" class="line"></span>    }
<span id="line23975" class="line"></span>
<span id="line23976" class="line"></span>    /**
<span id="line23977" class="line"></span>     * Draws special debug information for a TiledImage if in debug mode.
<span id="line23978" class="line"></span>     * @private
<span id="line23979" class="line"></span>     * @param {OpenSeadragon.Tile[]} lastDrawn - An unordered list of Tiles drawn last frame.
<span id="line23980" class="line"></span>     */
<span id="line23981" class="line"></span>    _drawDebugInfo( tiledImage, lastDrawn ) {
<span id="line23982" class="line"></span>        if( tiledImage.debugMode ) {
<span id="line23983" class="line"></span>            for ( let i = lastDrawn.length - 1; i &gt;= 0; i-- ) {
<span id="line23984" class="line"></span>                const tile = lastDrawn[ i ];
<span id="line23985" class="line"></span>                try {
<span id="line23986" class="line"></span>                    this._drawDebugInfoOnTile(tile, lastDrawn.length, i, tiledImage);
<span id="line23987" class="line"></span>                } catch(e) {
<span id="line23988" class="line"></span>                    $.console.error(e);
<span id="line23989" class="line"></span>                }
<span id="line23990" class="line"></span>            }
<span id="line23991" class="line"></span>        }
<span id="line23992" class="line"></span>    }
<span id="line23993" class="line"></span>
<span id="line23994" class="line"></span>    /**
<span id="line23995" class="line"></span>     * This function will create multiple polygon paths on the drawing context by provided polygons,
<span id="line23996" class="line"></span>     * then clip the context to the paths.
<span id="line23997" class="line"></span>     * @private
<span id="line23998" class="line"></span>     * @param {OpenSeadragon.Point[][]} polygons - an array of polygons. A polygon is an array of OpenSeadragon.Point
<span id="line23999" class="line"></span>     * @param {Boolean} useSketch - Whether to use the sketch canvas or not.
<span id="line24000" class="line"></span>     */
<span id="line24001" class="line"></span>    _clipWithPolygons (polygons, useSketch) {
<span id="line24002" class="line"></span>        const context = this._getContext(useSketch);
<span id="line24003" class="line"></span>        context.beginPath();
<span id="line24004" class="line"></span>        for(const polygon of polygons){
<span id="line24005" class="line"></span>            for(const [i, coord] of polygon.entries() ){
<span id="line24006" class="line"></span>                context[i === 0 ? 'moveTo' : 'lineTo'](coord.x, coord.y);
<span id="line24007" class="line"></span>            }
<span id="line24008" class="line"></span>        }
<span id="line24009" class="line"></span>
<span id="line24010" class="line"></span>        context.clip();
<span id="line24011" class="line"></span>    }
<span id="line24012" class="line"></span>
<span id="line24013" class="line"></span>    /**
<span id="line24014" class="line"></span>     * Draws the given tile.
<span id="line24015" class="line"></span>     * @private
<span id="line24016" class="line"></span>     * @param {OpenSeadragon.Tile} tile - The tile to draw.
<span id="line24017" class="line"></span>     * @param {OpenSeadragon.TiledImage} tiledImage - The tiled image being drawn.
<span id="line24018" class="line"></span>     * @param {Boolean} useSketch - Whether to use the sketch canvas or not.
<span id="line24019" class="line"></span>     * where &lt;code&gt;rendered&lt;/code&gt; is the context with the pre-drawn image.
<span id="line24020" class="line"></span>     * @param {Float} [scale=1] - Apply a scale to tile position and size. Defaults to 1.
<span id="line24021" class="line"></span>     * @param {OpenSeadragon.Point} [translate] A translation vector to offset tile position
<span id="line24022" class="line"></span>     * @param {Boolean} [shouldRoundPositionAndSize] - Tells whether to round
<span id="line24023" class="line"></span>     * position and size of tiles supporting alpha channel in non-transparency
<span id="line24024" class="line"></span>     * context.
<span id="line24025" class="line"></span>     * @param {OpenSeadragon.TileSource} source - The source specification of the tile.
<span id="line24026" class="line"></span>     */
<span id="line24027" class="line"></span>    _drawTile( tile, tiledImage, useSketch, scale, translate, shouldRoundPositionAndSize, source) {
<span id="line24028" class="line"></span>        $.console.assert(tile, '[Drawer._drawTile] tile is required');
<span id="line24029" class="line"></span>        $.console.assert(tiledImage, '[Drawer._drawTile] drawingHandler is required');
<span id="line24030" class="line"></span>
<span id="line24031" class="line"></span>        if ( !tile.loaded ){
<span id="line24032" class="line"></span>            $.console.warn(
<span id="line24033" class="line"></span>                "Attempting to draw tile %s when it's not yet loaded.",
<span id="line24034" class="line"></span>                tile.toString()
<span id="line24035" class="line"></span>            );
<span id="line24036" class="line"></span>            return;
<span id="line24037" class="line"></span>        }
<span id="line24038" class="line"></span>
<span id="line24039" class="line"></span>        const rendered = this.getDataToDraw(tile);
<span id="line24040" class="line"></span>        if (!rendered) {
<span id="line24041" class="line"></span>            return;
<span id="line24042" class="line"></span>        }
<span id="line24043" class="line"></span>
<span id="line24044" class="line"></span>        const context = this._getContext(useSketch);
<span id="line24045" class="line"></span>        scale = scale || 1;
<span id="line24046" class="line"></span>
<span id="line24047" class="line"></span>        let position = tile.position.times($.pixelDensityRatio),
<span id="line24048" class="line"></span>            size     = tile.size.times($.pixelDensityRatio);
<span id="line24049" class="line"></span>
<span id="line24050" class="line"></span>        context.save();
<span id="line24051" class="line"></span>
<span id="line24052" class="line"></span>        if (typeof scale === 'number' &amp;&amp; scale !== 1) {
<span id="line24053" class="line"></span>            // draw tile at a different scale
<span id="line24054" class="line"></span>            position = position.times(scale);
<span id="line24055" class="line"></span>            size = size.times(scale);
<span id="line24056" class="line"></span>        }
<span id="line24057" class="line"></span>
<span id="line24058" class="line"></span>        if (translate instanceof $.Point) {
<span id="line24059" class="line"></span>            // shift tile position slightly
<span id="line24060" class="line"></span>            position = position.plus(translate);
<span id="line24061" class="line"></span>        }
<span id="line24062" class="line"></span>
<span id="line24063" class="line"></span>        //if we are supposed to be rendering fully opaque rectangle,
<span id="line24064" class="line"></span>        //ie its done fading or fading is turned off, and if we are drawing
<span id="line24065" class="line"></span>        //an image with an alpha channel, then the only way
<span id="line24066" class="line"></span>        //to avoid seeing the tile underneath is to clear the rectangle
<span id="line24067" class="line"></span>        if (context.globalAlpha === 1 &amp;&amp; tile.hasTransparency) {
<span id="line24068" class="line"></span>            if (shouldRoundPositionAndSize) {
<span id="line24069" class="line"></span>                // Round to the nearest whole pixel so we don't get seams from overlap.
<span id="line24070" class="line"></span>                position.x = Math.round(position.x);
<span id="line24071" class="line"></span>                position.y = Math.round(position.y);
<span id="line24072" class="line"></span>                size.x = Math.round(size.x);
<span id="line24073" class="line"></span>                size.y = Math.round(size.y);
<span id="line24074" class="line"></span>            }
<span id="line24075" class="line"></span>
<span id="line24076" class="line"></span>            //clearing only the inside of the rectangle occupied
<span id="line24077" class="line"></span>            //by the png prevents edge flikering
<span id="line24078" class="line"></span>            context.clearRect(
<span id="line24079" class="line"></span>                position.x,
<span id="line24080" class="line"></span>                position.y,
<span id="line24081" class="line"></span>                size.x,
<span id="line24082" class="line"></span>                size.y
<span id="line24083" class="line"></span>            );
<span id="line24084" class="line"></span>        }
<span id="line24085" class="line"></span>
<span id="line24086" class="line"></span>        this._raiseTileDrawingEvent(tiledImage, context, tile, rendered);
<span id="line24087" class="line"></span>
<span id="line24088" class="line"></span>        let sourceWidth, sourceHeight;
<span id="line24089" class="line"></span>        if (tile.sourceBounds) {
<span id="line24090" class="line"></span>            sourceWidth = Math.min(tile.sourceBounds.width, rendered.canvas.width);
<span id="line24091" class="line"></span>            sourceHeight = Math.min(tile.sourceBounds.height, rendered.canvas.height);
<span id="line24092" class="line"></span>        } else {
<span id="line24093" class="line"></span>            sourceWidth = rendered.canvas.width;
<span id="line24094" class="line"></span>            sourceHeight = rendered.canvas.height;
<span id="line24095" class="line"></span>        }
<span id="line24096" class="line"></span>
<span id="line24097" class="line"></span>        context.translate(position.x + size.x / 2, 0);
<span id="line24098" class="line"></span>        if (tile.flipped) {
<span id="line24099" class="line"></span>            context.scale(-1, 1);
<span id="line24100" class="line"></span>        }
<span id="line24101" class="line"></span>        context.drawImage(
<span id="line24102" class="line"></span>            rendered.canvas,
<span id="line24103" class="line"></span>            0,
<span id="line24104" class="line"></span>            0,
<span id="line24105" class="line"></span>            sourceWidth,
<span id="line24106" class="line"></span>            sourceHeight,
<span id="line24107" class="line"></span>            -size.x / 2,
<span id="line24108" class="line"></span>            position.y,
<span id="line24109" class="line"></span>            size.x,
<span id="line24110" class="line"></span>            size.y
<span id="line24111" class="line"></span>        );
<span id="line24112" class="line"></span>
<span id="line24113" class="line"></span>        context.restore();
<span id="line24114" class="line"></span>    }
<span id="line24115" class="line"></span>
<span id="line24116" class="line"></span>
<span id="line24117" class="line"></span>
<span id="line24118" class="line"></span>    /**
<span id="line24119" class="line"></span>     * Get the context of the main or sketch canvas
<span id="line24120" class="line"></span>     * @private
<span id="line24121" class="line"></span>     * @param {Boolean} useSketch
<span id="line24122" class="line"></span>     * @returns {CanvasRenderingContext2D}
<span id="line24123" class="line"></span>     */
<span id="line24124" class="line"></span>    _getContext( useSketch ) {
<span id="line24125" class="line"></span>        let context = this.context;
<span id="line24126" class="line"></span>        if ( useSketch ) {
<span id="line24127" class="line"></span>            if (this.sketchCanvas === null) {
<span id="line24128" class="line"></span>                this.sketchCanvas = document.createElement( "canvas" );
<span id="line24129" class="line"></span>                const sketchCanvasSize = this._calculateSketchCanvasSize();
<span id="line24130" class="line"></span>                this.sketchCanvas.width = sketchCanvasSize.x;
<span id="line24131" class="line"></span>                this.sketchCanvas.height = sketchCanvasSize.y;
<span id="line24132" class="line"></span>                this.sketchContext = this.sketchCanvas.getContext( "2d" );
<span id="line24133" class="line"></span>
<span id="line24134" class="line"></span>                // If the viewport is not currently rotated, the sketchCanvas
<span id="line24135" class="line"></span>                // will have the same size as the main canvas. However, if
<span id="line24136" class="line"></span>                // the viewport get rotated later on, we will need to resize it.
<span id="line24137" class="line"></span>                if (this.viewport.getRotation() === 0) {
<span id="line24138" class="line"></span>                    const self = this;
<span id="line24139" class="line"></span>                    this.viewer.addHandler('rotate', function resizeSketchCanvas() {
<span id="line24140" class="line"></span>                        if (self.viewport.getRotation() === 0) {
<span id="line24141" class="line"></span>                            return;
<span id="line24142" class="line"></span>                        }
<span id="line24143" class="line"></span>                        self.viewer.removeHandler('rotate', resizeSketchCanvas);
<span id="line24144" class="line"></span>                        const sketchCanvasSize = self._calculateSketchCanvasSize();
<span id="line24145" class="line"></span>                        self.sketchCanvas.width = sketchCanvasSize.x;
<span id="line24146" class="line"></span>                        self.sketchCanvas.height = sketchCanvasSize.y;
<span id="line24147" class="line"></span>                    });
<span id="line24148" class="line"></span>                }
<span id="line24149" class="line"></span>                this._updateImageSmoothingEnabled(this.sketchContext);
<span id="line24150" class="line"></span>            }
<span id="line24151" class="line"></span>            context = this.sketchContext;
<span id="line24152" class="line"></span>        }
<span id="line24153" class="line"></span>        return context;
<span id="line24154" class="line"></span>    }
<span id="line24155" class="line"></span>
<span id="line24156" class="line"></span>    /**
<span id="line24157" class="line"></span>     * Save the context of the main or sketch canvas
<span id="line24158" class="line"></span>     * @private
<span id="line24159" class="line"></span>     * @param {Boolean} useSketch
<span id="line24160" class="line"></span>     */
<span id="line24161" class="line"></span>    _saveContext( useSketch ) {
<span id="line24162" class="line"></span>        this._getContext( useSketch ).save();
<span id="line24163" class="line"></span>    }
<span id="line24164" class="line"></span>
<span id="line24165" class="line"></span>    /**
<span id="line24166" class="line"></span>     * Restore the context of the main or sketch canvas
<span id="line24167" class="line"></span>     * @private
<span id="line24168" class="line"></span>     * @param {Boolean} useSketch
<span id="line24169" class="line"></span>     */
<span id="line24170" class="line"></span>    _restoreContext( useSketch ) {
<span id="line24171" class="line"></span>        this._getContext( useSketch ).restore();
<span id="line24172" class="line"></span>    }
<span id="line24173" class="line"></span>
<span id="line24174" class="line"></span>    // private
<span id="line24175" class="line"></span>    _setClip(rect, useSketch) {
<span id="line24176" class="line"></span>        const context = this._getContext( useSketch );
<span id="line24177" class="line"></span>        context.beginPath();
<span id="line24178" class="line"></span>        context.rect(rect.x, rect.y, rect.width, rect.height);
<span id="line24179" class="line"></span>        context.clip();
<span id="line24180" class="line"></span>    }
<span id="line24181" class="line"></span>
<span id="line24182" class="line"></span>    // private
<span id="line24183" class="line"></span>    // used to draw a placeholder rectangle
<span id="line24184" class="line"></span>    _drawRectangle(rect, fillStyle, useSketch) {
<span id="line24185" class="line"></span>        const context = this._getContext( useSketch );
<span id="line24186" class="line"></span>        context.save();
<span id="line24187" class="line"></span>        context.fillStyle = fillStyle;
<span id="line24188" class="line"></span>        context.fillRect(rect.x, rect.y, rect.width, rect.height);
<span id="line24189" class="line"></span>        context.restore();
<span id="line24190" class="line"></span>    }
<span id="line24191" class="line"></span>
<span id="line24192" class="line"></span>    /**
<span id="line24193" class="line"></span>     * Blends the sketch canvas in the main canvas.
<span id="line24194" class="line"></span>     * @param {Object} options The options
<span id="line24195" class="line"></span>     * @param {Float} options.opacity The opacity of the blending.
<span id="line24196" class="line"></span>     * @param {Float} [options.scale=1] The scale at which tiles were drawn on
<span id="line24197" class="line"></span>     * the sketch. Default is 1.
<span id="line24198" class="line"></span>     * Use scale to draw at a lower scale and then enlarge onto the main canvas.
<span id="line24199" class="line"></span>     * @param {OpenSeadragon.Point} [options.translate] A translation vector
<span id="line24200" class="line"></span>     * that was used to draw the tiles
<span id="line24201" class="line"></span>     * @param {String} [options.compositeOperation] - How the image is
<span id="line24202" class="line"></span>     * composited onto other images; see compositeOperation in
<span id="line24203" class="line"></span>     * {@link OpenSeadragon.Options} for possible values.
<span id="line24204" class="line"></span>     * @param {OpenSeadragon.Rect} [options.bounds] The part of the sketch
<span id="line24205" class="line"></span>     * canvas to blend in the main canvas. If specified, options.scale and
<span id="line24206" class="line"></span>     * options.translate get ignored.
<span id="line24207" class="line"></span>     */
<span id="line24208" class="line"></span>    blendSketch(opacity, scale, translate, compositeOperation) {
<span id="line24209" class="line"></span>        let options = opacity;
<span id="line24210" class="line"></span>        if (!$.isPlainObject(options)) {
<span id="line24211" class="line"></span>            options = {
<span id="line24212" class="line"></span>                opacity: opacity,
<span id="line24213" class="line"></span>                scale: scale,
<span id="line24214" class="line"></span>                translate: translate,
<span id="line24215" class="line"></span>                compositeOperation: compositeOperation
<span id="line24216" class="line"></span>            };
<span id="line24217" class="line"></span>        }
<span id="line24218" class="line"></span>
<span id="line24219" class="line"></span>        opacity = options.opacity;
<span id="line24220" class="line"></span>        compositeOperation = options.compositeOperation;
<span id="line24221" class="line"></span>        const bounds = options.bounds;
<span id="line24222" class="line"></span>
<span id="line24223" class="line"></span>        this.context.save();
<span id="line24224" class="line"></span>        this.context.globalAlpha = opacity;
<span id="line24225" class="line"></span>        if (compositeOperation) {
<span id="line24226" class="line"></span>            this.context.globalCompositeOperation = compositeOperation;
<span id="line24227" class="line"></span>        }
<span id="line24228" class="line"></span>        if (bounds) {
<span id="line24229" class="line"></span>            // Internet Explorer, Microsoft Edge, and Safari have problems
<span id="line24230" class="line"></span>            // when you call context.drawImage with negative x or y
<span id="line24231" class="line"></span>            // or x + width or y + height greater than the canvas width or height respectively.
<span id="line24232" class="line"></span>            if (bounds.x &lt; 0) {
<span id="line24233" class="line"></span>                bounds.width += bounds.x;
<span id="line24234" class="line"></span>                bounds.x = 0;
<span id="line24235" class="line"></span>            }
<span id="line24236" class="line"></span>            if (bounds.x + bounds.width &gt; this.canvas.width) {
<span id="line24237" class="line"></span>                bounds.width = this.canvas.width - bounds.x;
<span id="line24238" class="line"></span>            }
<span id="line24239" class="line"></span>            if (bounds.y &lt; 0) {
<span id="line24240" class="line"></span>                bounds.height += bounds.y;
<span id="line24241" class="line"></span>                bounds.y = 0;
<span id="line24242" class="line"></span>            }
<span id="line24243" class="line"></span>            if (bounds.y + bounds.height &gt; this.canvas.height) {
<span id="line24244" class="line"></span>                bounds.height = this.canvas.height - bounds.y;
<span id="line24245" class="line"></span>            }
<span id="line24246" class="line"></span>
<span id="line24247" class="line"></span>            this.context.drawImage(
<span id="line24248" class="line"></span>                this.sketchCanvas,
<span id="line24249" class="line"></span>                bounds.x,
<span id="line24250" class="line"></span>                bounds.y,
<span id="line24251" class="line"></span>                bounds.width,
<span id="line24252" class="line"></span>                bounds.height,
<span id="line24253" class="line"></span>                bounds.x,
<span id="line24254" class="line"></span>                bounds.y,
<span id="line24255" class="line"></span>                bounds.width,
<span id="line24256" class="line"></span>                bounds.height
<span id="line24257" class="line"></span>            );
<span id="line24258" class="line"></span>        } else {
<span id="line24259" class="line"></span>            scale = options.scale || 1;
<span id="line24260" class="line"></span>            translate = options.translate;
<span id="line24261" class="line"></span>            const position = translate instanceof $.Point ?
<span id="line24262" class="line"></span>                translate : new $.Point(0, 0);
<span id="line24263" class="line"></span>
<span id="line24264" class="line"></span>            let widthExt = 0;
<span id="line24265" class="line"></span>            let heightExt = 0;
<span id="line24266" class="line"></span>            if (translate) {
<span id="line24267" class="line"></span>                const widthDiff = this.sketchCanvas.width - this.canvas.width;
<span id="line24268" class="line"></span>                const heightDiff = this.sketchCanvas.height - this.canvas.height;
<span id="line24269" class="line"></span>                widthExt = Math.round(widthDiff / 2);
<span id="line24270" class="line"></span>                heightExt = Math.round(heightDiff / 2);
<span id="line24271" class="line"></span>            }
<span id="line24272" class="line"></span>            this.context.drawImage(
<span id="line24273" class="line"></span>                this.sketchCanvas,
<span id="line24274" class="line"></span>                position.x - widthExt * scale,
<span id="line24275" class="line"></span>                position.y - heightExt * scale,
<span id="line24276" class="line"></span>                (this.canvas.width + 2 * widthExt) * scale,
<span id="line24277" class="line"></span>                (this.canvas.height + 2 * heightExt) * scale,
<span id="line24278" class="line"></span>                -widthExt,
<span id="line24279" class="line"></span>                -heightExt,
<span id="line24280" class="line"></span>                this.canvas.width + 2 * widthExt,
<span id="line24281" class="line"></span>                this.canvas.height + 2 * heightExt
<span id="line24282" class="line"></span>            );
<span id="line24283" class="line"></span>        }
<span id="line24284" class="line"></span>        this.context.restore();
<span id="line24285" class="line"></span>    }
<span id="line24286" class="line"></span>
<span id="line24287" class="line"></span>    // private
<span id="line24288" class="line"></span>    _drawDebugInfoOnTile(tile, count, i, tiledImage) {
<span id="line24289" class="line"></span>
<span id="line24290" class="line"></span>        const colorIndex = this.viewer.world.getIndexOfItem(tiledImage) % this.debugGridColor.length;
<span id="line24291" class="line"></span>        const context = this.context;
<span id="line24292" class="line"></span>        context.save();
<span id="line24293" class="line"></span>        context.lineWidth = 2 * $.pixelDensityRatio;
<span id="line24294" class="line"></span>        context.font = 'small-caps bold ' + (13 * $.pixelDensityRatio) + 'px arial';
<span id="line24295" class="line"></span>        context.strokeStyle = this.debugGridColor[colorIndex];
<span id="line24296" class="line"></span>        context.fillStyle = this.debugGridColor[colorIndex];
<span id="line24297" class="line"></span>
<span id="line24298" class="line"></span>        this._setRotations(tiledImage);
<span id="line24299" class="line"></span>
<span id="line24300" class="line"></span>        if(this._viewportFlipped){
<span id="line24301" class="line"></span>            this._flip({point: tile.position.plus(tile.size.divide(2))});
<span id="line24302" class="line"></span>        }
<span id="line24303" class="line"></span>
<span id="line24304" class="line"></span>        context.strokeRect(
<span id="line24305" class="line"></span>            tile.position.x * $.pixelDensityRatio,
<span id="line24306" class="line"></span>            tile.position.y * $.pixelDensityRatio,
<span id="line24307" class="line"></span>            tile.size.x * $.pixelDensityRatio,
<span id="line24308" class="line"></span>            tile.size.y * $.pixelDensityRatio
<span id="line24309" class="line"></span>        );
<span id="line24310" class="line"></span>
<span id="line24311" class="line"></span>        const tileCenterX = (tile.position.x + (tile.size.x / 2)) * $.pixelDensityRatio;
<span id="line24312" class="line"></span>        const tileCenterY = (tile.position.y + (tile.size.y / 2)) * $.pixelDensityRatio;
<span id="line24313" class="line"></span>
<span id="line24314" class="line"></span>        // Rotate the text the right way around.
<span id="line24315" class="line"></span>        context.translate( tileCenterX, tileCenterY );
<span id="line24316" class="line"></span>        const angleInDegrees = this.viewport.getRotation(true);
<span id="line24317" class="line"></span>        context.rotate( Math.PI / 180 * -angleInDegrees );
<span id="line24318" class="line"></span>        context.translate( -tileCenterX, -tileCenterY );
<span id="line24319" class="line"></span>
<span id="line24320" class="line"></span>        if( tile.x === 0 &amp;&amp; tile.y === 0 ){
<span id="line24321" class="line"></span>            context.fillText(
<span id="line24322" class="line"></span>                "Zoom: " + this.viewport.getZoom(),
<span id="line24323" class="line"></span>                tile.position.x * $.pixelDensityRatio,
<span id="line24324" class="line"></span>                (tile.position.y - 30) * $.pixelDensityRatio
<span id="line24325" class="line"></span>            );
<span id="line24326" class="line"></span>            context.fillText(
<span id="line24327" class="line"></span>                "Pan: " + this.viewport.getBounds().toString(),
<span id="line24328" class="line"></span>                tile.position.x * $.pixelDensityRatio,
<span id="line24329" class="line"></span>                (tile.position.y - 20) * $.pixelDensityRatio
<span id="line24330" class="line"></span>            );
<span id="line24331" class="line"></span>        }
<span id="line24332" class="line"></span>        context.fillText(
<span id="line24333" class="line"></span>            "Level: " + tile.level,
<span id="line24334" class="line"></span>            (tile.position.x + 10) * $.pixelDensityRatio,
<span id="line24335" class="line"></span>            (tile.position.y + 20) * $.pixelDensityRatio
<span id="line24336" class="line"></span>        );
<span id="line24337" class="line"></span>        context.fillText(
<span id="line24338" class="line"></span>            "Column: " + tile.x,
<span id="line24339" class="line"></span>            (tile.position.x + 10) * $.pixelDensityRatio,
<span id="line24340" class="line"></span>            (tile.position.y + 30) * $.pixelDensityRatio
<span id="line24341" class="line"></span>        );
<span id="line24342" class="line"></span>        context.fillText(
<span id="line24343" class="line"></span>            "Row: " + tile.y,
<span id="line24344" class="line"></span>            (tile.position.x + 10) * $.pixelDensityRatio,
<span id="line24345" class="line"></span>            (tile.position.y + 40) * $.pixelDensityRatio
<span id="line24346" class="line"></span>        );
<span id="line24347" class="line"></span>        context.fillText(
<span id="line24348" class="line"></span>            "Order: " + i + " of " + count,
<span id="line24349" class="line"></span>            (tile.position.x + 10) * $.pixelDensityRatio,
<span id="line24350" class="line"></span>            (tile.position.y + 50) * $.pixelDensityRatio
<span id="line24351" class="line"></span>        );
<span id="line24352" class="line"></span>        context.fillText(
<span id="line24353" class="line"></span>            "Size: " + tile.size.toString(),
<span id="line24354" class="line"></span>            (tile.position.x + 10) * $.pixelDensityRatio,
<span id="line24355" class="line"></span>            (tile.position.y + 60) * $.pixelDensityRatio
<span id="line24356" class="line"></span>        );
<span id="line24357" class="line"></span>        context.fillText(
<span id="line24358" class="line"></span>            "Position: " + tile.position.toString(),
<span id="line24359" class="line"></span>            (tile.position.x + 10) * $.pixelDensityRatio,
<span id="line24360" class="line"></span>            (tile.position.y + 70) * $.pixelDensityRatio
<span id="line24361" class="line"></span>        );
<span id="line24362" class="line"></span>
<span id="line24363" class="line"></span>        if (this.viewport.getRotation(true) % 360 !== 0 ) {
<span id="line24364" class="line"></span>            this._restoreRotationChanges();
<span id="line24365" class="line"></span>        }
<span id="line24366" class="line"></span>        if (tiledImage.getRotation(true) % 360 !== 0) {
<span id="line24367" class="line"></span>            this._restoreRotationChanges();
<span id="line24368" class="line"></span>        }
<span id="line24369" class="line"></span>
<span id="line24370" class="line"></span>        context.restore();
<span id="line24371" class="line"></span>    }
<span id="line24372" class="line"></span>
<span id="line24373" class="line"></span>    // private
<span id="line24374" class="line"></span>    _updateImageSmoothingEnabled(context){
<span id="line24375" class="line"></span>        context.msImageSmoothingEnabled = this._imageSmoothingEnabled;
<span id="line24376" class="line"></span>        context.imageSmoothingEnabled = this._imageSmoothingEnabled;
<span id="line24377" class="line"></span>    }
<span id="line24378" class="line"></span>
<span id="line24379" class="line"></span>    /**
<span id="line24380" class="line"></span>     * Get the canvas size
<span id="line24381" class="line"></span>     * @private
<span id="line24382" class="line"></span>     * @param {Boolean} sketch If set to true return the size of the sketch canvas
<span id="line24383" class="line"></span>     * @returns {OpenSeadragon.Point} The size of the canvas
<span id="line24384" class="line"></span>     */
<span id="line24385" class="line"></span>    _getCanvasSize(sketch) {
<span id="line24386" class="line"></span>        const canvas = this._getContext(sketch).canvas;
<span id="line24387" class="line"></span>        return new $.Point(canvas.width, canvas.height);
<span id="line24388" class="line"></span>    }
<span id="line24389" class="line"></span>
<span id="line24390" class="line"></span>    /**
<span id="line24391" class="line"></span>     * Get the canvas center
<span id="line24392" class="line"></span>     * @private
<span id="line24393" class="line"></span>     * @param {Boolean} sketch If set to true return the center point of the sketch canvas
<span id="line24394" class="line"></span>     * @returns {OpenSeadragon.Point} The center point of the canvas
<span id="line24395" class="line"></span>     */
<span id="line24396" class="line"></span>    _getCanvasCenter() {
<span id="line24397" class="line"></span>        return new $.Point(this.canvas.width / 2, this.canvas.height / 2);
<span id="line24398" class="line"></span>    }
<span id="line24399" class="line"></span>
<span id="line24400" class="line"></span>    /**
<span id="line24401" class="line"></span>     * Set rotations for viewport &amp; tiledImage
<span id="line24402" class="line"></span>     * @private
<span id="line24403" class="line"></span>     * @param {OpenSeadragon.TiledImage} tiledImage
<span id="line24404" class="line"></span>     * @param {Boolean} [useSketch=false]
<span id="line24405" class="line"></span>     */
<span id="line24406" class="line"></span>    _setRotations(tiledImage, useSketch = false) {
<span id="line24407" class="line"></span>        let saveContext = false;
<span id="line24408" class="line"></span>        if (this.viewport.getRotation(true) % 360 !== 0) {
<span id="line24409" class="line"></span>            this._offsetForRotation({
<span id="line24410" class="line"></span>                degrees: this.viewport.getRotation(true),
<span id="line24411" class="line"></span>                useSketch: useSketch,
<span id="line24412" class="line"></span>                saveContext: saveContext
<span id="line24413" class="line"></span>            });
<span id="line24414" class="line"></span>            saveContext = false;
<span id="line24415" class="line"></span>        }
<span id="line24416" class="line"></span>        if (tiledImage.getRotation(true) % 360 !== 0) {
<span id="line24417" class="line"></span>            this._offsetForRotation({
<span id="line24418" class="line"></span>                degrees: tiledImage.getRotation(true),
<span id="line24419" class="line"></span>                point: this.viewport.pixelFromPointNoRotate(
<span id="line24420" class="line"></span>                    tiledImage._getRotationPoint(true), true),
<span id="line24421" class="line"></span>                useSketch: useSketch,
<span id="line24422" class="line"></span>                saveContext: saveContext
<span id="line24423" class="line"></span>            });
<span id="line24424" class="line"></span>        }
<span id="line24425" class="line"></span>    }
<span id="line24426" class="line"></span>
<span id="line24427" class="line"></span>    // private
<span id="line24428" class="line"></span>    _offsetForRotation(options) {
<span id="line24429" class="line"></span>        const point = options.point ?
<span id="line24430" class="line"></span>            options.point.times($.pixelDensityRatio) :
<span id="line24431" class="line"></span>            this._getCanvasCenter();
<span id="line24432" class="line"></span>
<span id="line24433" class="line"></span>        const context = this._getContext(options.useSketch);
<span id="line24434" class="line"></span>        context.save();
<span id="line24435" class="line"></span>
<span id="line24436" class="line"></span>        context.translate(point.x, point.y);
<span id="line24437" class="line"></span>        context.rotate(Math.PI / 180 * options.degrees);
<span id="line24438" class="line"></span>        context.translate(-point.x, -point.y);
<span id="line24439" class="line"></span>    }
<span id="line24440" class="line"></span>
<span id="line24441" class="line"></span>    // private
<span id="line24442" class="line"></span>    _flip(options) {
<span id="line24443" class="line"></span>        options = options || {};
<span id="line24444" class="line"></span>        const point = options.point ?
<span id="line24445" class="line"></span>        options.point.times($.pixelDensityRatio) :
<span id="line24446" class="line"></span>        this._getCanvasCenter();
<span id="line24447" class="line"></span>        const context = this._getContext(options.useSketch);
<span id="line24448" class="line"></span>
<span id="line24449" class="line"></span>        context.translate(point.x, 0);
<span id="line24450" class="line"></span>        context.scale(-1, 1);
<span id="line24451" class="line"></span>        context.translate(-point.x, 0);
<span id="line24452" class="line"></span>    }
<span id="line24453" class="line"></span>
<span id="line24454" class="line"></span>    // private
<span id="line24455" class="line"></span>    _restoreRotationChanges(useSketch) {
<span id="line24456" class="line"></span>        const context = this._getContext(useSketch);
<span id="line24457" class="line"></span>        context.restore();
<span id="line24458" class="line"></span>    }
<span id="line24459" class="line"></span>
<span id="line24460" class="line"></span>    // private
<span id="line24461" class="line"></span>    _calculateCanvasSize() {
<span id="line24462" class="line"></span>        const pixelDensityRatio = $.pixelDensityRatio;
<span id="line24463" class="line"></span>        const viewportSize = this.viewport.getContainerSize();
<span id="line24464" class="line"></span>        return {
<span id="line24465" class="line"></span>            // canvas width and height are integers
<span id="line24466" class="line"></span>            x: Math.round(viewportSize.x * pixelDensityRatio),
<span id="line24467" class="line"></span>            y: Math.round(viewportSize.y * pixelDensityRatio)
<span id="line24468" class="line"></span>        };
<span id="line24469" class="line"></span>    }
<span id="line24470" class="line"></span>
<span id="line24471" class="line"></span>    // private
<span id="line24472" class="line"></span>    _calculateSketchCanvasSize() {
<span id="line24473" class="line"></span>        const canvasSize = this._calculateCanvasSize();
<span id="line24474" class="line"></span>        if (this.viewport.getRotation() === 0) {
<span id="line24475" class="line"></span>            return canvasSize;
<span id="line24476" class="line"></span>        }
<span id="line24477" class="line"></span>        // If the viewport is rotated, we need a larger sketch canvas in order
<span id="line24478" class="line"></span>        // to support edge smoothing.
<span id="line24479" class="line"></span>        const sketchCanvasSize = Math.ceil(Math.sqrt(
<span id="line24480" class="line"></span>            canvasSize.x * canvasSize.x +
<span id="line24481" class="line"></span>            canvasSize.y * canvasSize.y));
<span id="line24482" class="line"></span>        return {
<span id="line24483" class="line"></span>            x: sketchCanvasSize,
<span id="line24484" class="line"></span>            y: sketchCanvasSize
<span id="line24485" class="line"></span>        };
<span id="line24486" class="line"></span>    }
<span id="line24487" class="line"></span>}
<span id="line24488" class="line"></span>$.CanvasDrawer = CanvasDrawer;
<span id="line24489" class="line"></span>
<span id="line24490" class="line"></span>
<span id="line24491" class="line"></span>/**
<span id="line24492" class="line"></span> * Defines the value for subpixel rounding to fallback to in case of missing or
<span id="line24493" class="line"></span> * invalid value.
<span id="line24494" class="line"></span> * @private
<span id="line24495" class="line"></span> */
<span id="line24496" class="line"></span>const DEFAULT_SUBPIXEL_ROUNDING_RULE = $.SUBPIXEL_ROUNDING_OCCURRENCES.NEVER;
<span id="line24497" class="line"></span>
<span id="line24498" class="line"></span>/**
<span id="line24499" class="line"></span> * Checks whether the input value is an invalid subpixel rounding enum value.
<span id="line24500" class="line"></span> * @private
<span id="line24501" class="line"></span> *
<span id="line24502" class="line"></span> * @param {SUBPIXEL_ROUNDING_OCCURRENCES} value - The subpixel rounding enum value to check.
<span id="line24503" class="line"></span> * @returns {Boolean} Returns true if the input value is none of the expected
<span id="line24504" class="line"></span> * {@link SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS}, {@link SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST} or {@link SUBPIXEL_ROUNDING_OCCURRENCES.NEVER} value.
<span id="line24505" class="line"></span> */
<span id="line24506" class="line"></span>function isSubPixelRoundingRuleUnknown(value) {
<span id="line24507" class="line"></span>    return value !== $.SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS &amp;&amp;
<span id="line24508" class="line"></span>        value !== $.SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST &amp;&amp;
<span id="line24509" class="line"></span>        value !== $.SUBPIXEL_ROUNDING_OCCURRENCES.NEVER;
<span id="line24510" class="line"></span>}
<span id="line24511" class="line"></span>
<span id="line24512" class="line"></span>/**
<span id="line24513" class="line"></span> * Ensures the returned value is always a valid subpixel rounding enum value,
<span id="line24514" class="line"></span> * defaulting to {@link SUBPIXEL_ROUNDING_OCCURRENCES.NEVER} if input is missing or invalid.
<span id="line24515" class="line"></span> * @private
<span id="line24516" class="line"></span> * @param {SUBPIXEL_ROUNDING_OCCURRENCES} value - The subpixel rounding enum value to normalize.
<span id="line24517" class="line"></span> * @returns {SUBPIXEL_ROUNDING_OCCURRENCES} Returns a valid subpixel rounding enum value.
<span id="line24518" class="line"></span> */
<span id="line24519" class="line"></span>function normalizeSubPixelRoundingRule(value) {
<span id="line24520" class="line"></span>    if (isSubPixelRoundingRuleUnknown(value)) {
<span id="line24521" class="line"></span>        return DEFAULT_SUBPIXEL_ROUNDING_RULE;
<span id="line24522" class="line"></span>    }
<span id="line24523" class="line"></span>    return value;
<span id="line24524" class="line"></span>}
<span id="line24525" class="line"></span>
<span id="line24526" class="line"></span>/**
<span id="line24527" class="line"></span> * Ensures the returned value is always a valid subpixel rounding enum value,
<span id="line24528" class="line"></span> * defaulting to 'NEVER' if input is missing or invalid.
<span id="line24529" class="line"></span> * @private
<span id="line24530" class="line"></span> *
<span id="line24531" class="line"></span> * @param {Object} subPixelRoundingRules - A subpixel rounding enum values dictionary [{@link BROWSERS}] --&gt; {@link SUBPIXEL_ROUNDING_OCCURRENCES}.
<span id="line24532" class="line"></span> * @returns {SUBPIXEL_ROUNDING_OCCURRENCES} Returns the determined subpixel rounding enum value for the
<span id="line24533" class="line"></span> * current browser.
<span id="line24534" class="line"></span> */
<span id="line24535" class="line"></span>function determineSubPixelRoundingRule(subPixelRoundingRules) {
<span id="line24536" class="line"></span>    if (typeof subPixelRoundingRules === 'number') {
<span id="line24537" class="line"></span>        return normalizeSubPixelRoundingRule(subPixelRoundingRules);
<span id="line24538" class="line"></span>    }
<span id="line24539" class="line"></span>
<span id="line24540" class="line"></span>    if (!subPixelRoundingRules || !$.Browser) {
<span id="line24541" class="line"></span>        return DEFAULT_SUBPIXEL_ROUNDING_RULE;
<span id="line24542" class="line"></span>    }
<span id="line24543" class="line"></span>
<span id="line24544" class="line"></span>    let subPixelRoundingRule = subPixelRoundingRules[$.Browser.vendor];
<span id="line24545" class="line"></span>
<span id="line24546" class="line"></span>    if (isSubPixelRoundingRuleUnknown(subPixelRoundingRule)) {
<span id="line24547" class="line"></span>        subPixelRoundingRule = subPixelRoundingRules['*'];
<span id="line24548" class="line"></span>    }
<span id="line24549" class="line"></span>
<span id="line24550" class="line"></span>    return normalizeSubPixelRoundingRule(subPixelRoundingRule);
<span id="line24551" class="line"></span>}
<span id="line24552" class="line"></span>
<span id="line24553" class="line"></span>}( OpenSeadragon ));
<span id="line24554" class="line"></span>
<span id="line24555" class="line"></span>
<span id="line24556" class="line"></span>/*
<span id="line24557" class="line"></span> * OpenSeadragon - WebGLDrawer
<span id="line24558" class="line"></span> *
<span id="line24559" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line24560" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line24561" class="line"></span> *
<span id="line24562" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line24563" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line24564" class="line"></span> * met:
<span id="line24565" class="line"></span> *
<span id="line24566" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line24567" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line24568" class="line"></span> *
<span id="line24569" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line24570" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line24571" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line24572" class="line"></span> *
<span id="line24573" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line24574" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line24575" class="line"></span> *   this software without specific prior written permission.
<span id="line24576" class="line"></span> *
<span id="line24577" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line24578" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line24579" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line24580" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line24581" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line24582" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line24583" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line24584" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line24585" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line24586" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line24587" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line24588" class="line"></span> */
<span id="line24589" class="line"></span>
<span id="line24590" class="line"></span>(function( $ ){
<span id="line24591" class="line"></span>
<span id="line24592" class="line"></span>    const OpenSeadragon = $; // alias for JSDoc
<span id="line24593" class="line"></span>
<span id="line24594" class="line"></span>    /**
<span id="line24595" class="line"></span>     * @class WebglContextManager
<span id="line24596" class="line"></span>     * @classdesc Handles the webgl context, isolating it from the rest of the DrawerBase API.
<span id="line24597" class="line"></span>     * Manages WebGL context lifecycle, shaders, textures, framebuffers, and other WebGL resources.
<span id="line24598" class="line"></span>     * @param {Object} options - Options for the context manager
<span id="line24599" class="line"></span>     * @param {HTMLCanvasElement} options.renderingCanvas - The canvas element to use for WebGL context
<span id="line24600" class="line"></span>     * @param {Boolean} [options.unpackWithPremultipliedAlpha=false] - Whether to enable gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL
<span id="line24601" class="line"></span>     * @param {Boolean} [options.imageSmoothingEnabled=true] - Whether image smoothing is enabled
<span id="line24602" class="line"></span>     */
<span id="line24603" class="line"></span>    class WebglContextManager {
<span id="line24604" class="line"></span>        constructor(options) {
<span id="line24605" class="line"></span>            this._renderingCanvas = options.renderingCanvas;
<span id="line24606" class="line"></span>            this._unpackWithPremultipliedAlpha = !!options.unpackWithPremultipliedAlpha;
<span id="line24607" class="line"></span>            this._imageSmoothingEnabled = options.imageSmoothingEnabled !== undefined ? options.imageSmoothingEnabled : true;
<span id="line24608" class="line"></span>            this._initShaderProgram = options.initShaderProgram;
<span id="line24609" class="line"></span>
<span id="line24610" class="line"></span>            this._gl = null;
<span id="line24611" class="line"></span>            this._isWebGL2 = false;
<span id="line24612" class="line"></span>            this._extTextureFilterAnisotropic = null;
<span id="line24613" class="line"></span>            this._maxAnisotropy = 0;
<span id="line24614" class="line"></span>
<span id="line24615" class="line"></span>            this._firstPass = null;
<span id="line24616" class="line"></span>            this._secondPass = null;
<span id="line24617" class="line"></span>            this._glFrameBuffer = null;
<span id="line24618" class="line"></span>            this._renderToTexture = null;
<span id="line24619" class="line"></span>            this._glNumTextures = 0;
<span id="line24620" class="line"></span>            this._unitQuad = null;
<span id="line24621" class="line"></span>
<span id="line24622" class="line"></span>            this._destroyed = false;
<span id="line24623" class="line"></span>
<span id="line24624" class="line"></span>            // Create WebGL context
<span id="line24625" class="line"></span>            this._gl = this._renderingCanvas.getContext('webgl2');
<span id="line24626" class="line"></span>            if (this._gl) {
<span id="line24627" class="line"></span>                this._isWebGL2 = true;
<span id="line24628" class="line"></span>                this._setupWebGLExtensions();
<span id="line24629" class="line"></span>            } else {
<span id="line24630" class="line"></span>                this._gl = this._renderingCanvas.getContext('webgl');
<span id="line24631" class="line"></span>                this._isWebGL2 = false;
<span id="line24632" class="line"></span>                if (this._gl) {
<span id="line24633" class="line"></span>                    this._setupWebGLExtensions();
<span id="line24634" class="line"></span>                }
<span id="line24635" class="line"></span>            }
<span id="line24636" class="line"></span>
<span id="line24637" class="line"></span>            if (this._gl) {
<span id="line24638" class="line"></span>                this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._unpackWithPremultipliedAlpha);
<span id="line24639" class="line"></span>            }
<span id="line24640" class="line"></span>        }
<span id="line24641" class="line"></span>
<span id="line24642" class="line"></span>        /**
<span id="line24643" class="line"></span>         * Get the WebGL context
<span id="line24644" class="line"></span>         * @returns {WebGLRenderingContext|WebGL2RenderingContext|null} The WebGL context
<span id="line24645" class="line"></span>         */
<span id="line24646" class="line"></span>        getContext() {
<span id="line24647" class="line"></span>            return this._gl;
<span id="line24648" class="line"></span>        }
<span id="line24649" class="line"></span>
<span id="line24650" class="line"></span>        /**
<span id="line24651" class="line"></span>         * Check if using WebGL2
<span id="line24652" class="line"></span>         * @returns {Boolean} true if WebGL2, false if WebGL1
<span id="line24653" class="line"></span>         */
<span id="line24654" class="line"></span>        isWebGL2() {
<span id="line24655" class="line"></span>            return this._isWebGL2;
<span id="line24656" class="line"></span>        }
<span id="line24657" class="line"></span>
<span id="line24658" class="line"></span>        /**
<span id="line24659" class="line"></span>         * Get the maximum number of texture units
<span id="line24660" class="line"></span>         * @returns {Number} MAX_TEXTURE_IMAGE_UNITS value
<span id="line24661" class="line"></span>         */
<span id="line24662" class="line"></span>        getMaxTextures() {
<span id="line24663" class="line"></span>            if (!this._gl) {
<span id="line24664" class="line"></span>                return 0;
<span id="line24665" class="line"></span>            }
<span id="line24666" class="line"></span>            return this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS);
<span id="line24667" class="line"></span>        }
<span id="line24668" class="line"></span>
<span id="line24669" class="line"></span>        /**
<span id="line24670" class="line"></span>         * Get the rendering canvas element
<span id="line24671" class="line"></span>         * @returns {HTMLCanvasElement} The canvas element
<span id="line24672" class="line"></span>         */
<span id="line24673" class="line"></span>        getRenderingCanvas() {
<span id="line24674" class="line"></span>            return this._renderingCanvas;
<span id="line24675" class="line"></span>        }
<span id="line24676" class="line"></span>
<span id="line24677" class="line"></span>        /**
<span id="line24678" class="line"></span>         * Get the first pass shader program and resources
<span id="line24679" class="line"></span>         * @returns {Object|null} The first pass object with shader program, buffers, and uniforms
<span id="line24680" class="line"></span>         */
<span id="line24681" class="line"></span>        getFirstPass() {
<span id="line24682" class="line"></span>            return this._firstPass;
<span id="line24683" class="line"></span>        }
<span id="line24684" class="line"></span>
<span id="line24685" class="line"></span>        /**
<span id="line24686" class="line"></span>         * Get the second pass shader program and resources
<span id="line24687" class="line"></span>         * @returns {Object|null} The second pass object with shader program, buffers, and uniforms
<span id="line24688" class="line"></span>         */
<span id="line24689" class="line"></span>        getSecondPass() {
<span id="line24690" class="line"></span>            return this._secondPass;
<span id="line24691" class="line"></span>        }
<span id="line24692" class="line"></span>
<span id="line24693" class="line"></span>        /**
<span id="line24694" class="line"></span>         * Get the render-to-texture framebuffer
<span id="line24695" class="line"></span>         * @returns {WebGLFramebuffer|null} The framebuffer
<span id="line24696" class="line"></span>         */
<span id="line24697" class="line"></span>        getFrameBuffer() {
<span id="line24698" class="line"></span>            return this._glFrameBuffer;
<span id="line24699" class="line"></span>        }
<span id="line24700" class="line"></span>
<span id="line24701" class="line"></span>        /**
<span id="line24702" class="line"></span>         * Get the render-to-texture texture
<span id="line24703" class="line"></span>         * @returns {WebGLTexture|null} The texture
<span id="line24704" class="line"></span>         */
<span id="line24705" class="line"></span>        getRenderToTexture() {
<span id="line24706" class="line"></span>            return this._renderToTexture;
<span id="line24707" class="line"></span>        }
<span id="line24708" class="line"></span>
<span id="line24709" class="line"></span>        /**
<span id="line24710" class="line"></span>         * Get the unit quad vertex buffer
<span id="line24711" class="line"></span>         * @returns {Float32Array} The unit quad buffer
<span id="line24712" class="line"></span>         */
<span id="line24713" class="line"></span>        getUnitQuad() {
<span id="line24714" class="line"></span>            return this._unitQuad;
<span id="line24715" class="line"></span>        }
<span id="line24716" class="line"></span>
<span id="line24717" class="line"></span>        /**
<span id="line24718" class="line"></span>         * Set up WebGL extensions (works for both WebGL1 and WebGL2)
<span id="line24719" class="line"></span>         * @private
<span id="line24720" class="line"></span>         */
<span id="line24721" class="line"></span>        _setupWebGLExtensions() {
<span id="line24722" class="line"></span>            const gl = this._gl;
<span id="line24723" class="line"></span>
<span id="line24724" class="line"></span>            // Anisotropic filtering extension (available in both WebGL1 and WebGL2)
<span id="line24725" class="line"></span>            this._extTextureFilterAnisotropic =
<span id="line24726" class="line"></span>                gl.getExtension('EXT_texture_filter_anisotropic') ||
<span id="line24727" class="line"></span>                gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic') ||
<span id="line24728" class="line"></span>                gl.getExtension('MOZ_EXT_texture_filter_anisotropic');
<span id="line24729" class="line"></span>
<span id="line24730" class="line"></span>            if (this._extTextureFilterAnisotropic) {
<span id="line24731" class="line"></span>                this._maxAnisotropy = gl.getParameter(
<span id="line24732" class="line"></span>                    this._extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT
<span id="line24733" class="line"></span>                );
<span id="line24734" class="line"></span>            }
<span id="line24735" class="line"></span>        }
<span id="line24736" class="line"></span>
<span id="line24737" class="line"></span>        /**
<span id="line24738" class="line"></span>         * Get the texture filter constant (LINEAR or NEAREST)
<span id="line24739" class="line"></span>         * @returns {Number} gl.LINEAR or gl.NEAREST
<span id="line24740" class="line"></span>         */
<span id="line24741" class="line"></span>        getTextureFilter() {
<span id="line24742" class="line"></span>            const gl = this._gl;
<span id="line24743" class="line"></span>            return this._imageSmoothingEnabled ? gl.LINEAR : gl.NEAREST;
<span id="line24744" class="line"></span>        }
<span id="line24745" class="line"></span>
<span id="line24746" class="line"></span>        /**
<span id="line24747" class="line"></span>         * Apply anisotropic filtering to the currently bound texture if available
<span id="line24748" class="line"></span>         * @private
<span id="line24749" class="line"></span>         */
<span id="line24750" class="line"></span>        _applyAnisotropy() {
<span id="line24751" class="line"></span>            if (!this._imageSmoothingEnabled || !this._extTextureFilterAnisotropic || this._maxAnisotropy &lt;= 0) {
<span id="line24752" class="line"></span>                return;
<span id="line24753" class="line"></span>            }
<span id="line24754" class="line"></span>            const gl = this._gl;
<span id="line24755" class="line"></span>            gl.texParameterf(
<span id="line24756" class="line"></span>                gl.TEXTURE_2D,
<span id="line24757" class="line"></span>                this._extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
<span id="line24758" class="line"></span>                Math.min(4, this._maxAnisotropy)
<span id="line24759" class="line"></span>            );
<span id="line24760" class="line"></span>        }
<span id="line24761" class="line"></span>
<span id="line24762" class="line"></span>        /**
<span id="line24763" class="line"></span>         * Set up the renderer: create shaders, textures, and framebuffers
<span id="line24764" class="line"></span>         * @param {Number} width - Canvas width
<span id="line24765" class="line"></span>         * @param {Number} height - Canvas height
<span id="line24766" class="line"></span>         */
<span id="line24767" class="line"></span>        setupRenderer(width, height) {
<span id="line24768" class="line"></span>            const gl = this._gl;
<span id="line24769" class="line"></span>            if (!gl) {
<span id="line24770" class="line"></span>                $.console.error('WebGL context not available for setupRenderer');
<span id="line24771" class="line"></span>                return;
<span id="line24772" class="line"></span>            }
<span id="line24773" class="line"></span>
<span id="line24774" class="line"></span>            // Create unit quad once
<span id="line24775" class="line"></span>            this._unitQuad = this.makeQuadVertexBuffer(0, 1, 0, 1);
<span id="line24776" class="line"></span>
<span id="line24777" class="line"></span>            this._makeFirstPassShaderProgram();
<span id="line24778" class="line"></span>            this._makeSecondPassShaderProgram();
<span id="line24779" class="line"></span>
<span id="line24780" class="line"></span>            // set up the texture to render to in the first pass, and which will be used for rendering the second pass
<span id="line24781" class="line"></span>            this._renderToTexture = gl.createTexture();
<span id="line24782" class="line"></span>            gl.activeTexture(gl.TEXTURE0);
<span id="line24783" class="line"></span>            gl.bindTexture(gl.TEXTURE_2D, this._renderToTexture);
<span id="line24784" class="line"></span>            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
<span id="line24785" class="line"></span>            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.getTextureFilter());
<span id="line24786" class="line"></span>            this._applyAnisotropy();
<span id="line24787" class="line"></span>            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
<span id="line24788" class="line"></span>            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
<span id="line24789" class="line"></span>
<span id="line24790" class="line"></span>            // set up the framebuffer for render-to-texture
<span id="line24791" class="line"></span>            this._glFrameBuffer = gl.createFramebuffer();
<span id="line24792" class="line"></span>            gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
<span id="line24793" class="line"></span>            gl.framebufferTexture2D(
<span id="line24794" class="line"></span>                gl.FRAMEBUFFER,
<span id="line24795" class="line"></span>                gl.COLOR_ATTACHMENT0,
<span id="line24796" class="line"></span>                gl.TEXTURE_2D,
<span id="line24797" class="line"></span>                this._renderToTexture,
<span id="line24798" class="line"></span>                0
<span id="line24799" class="line"></span>            );
<span id="line24800" class="line"></span>
<span id="line24801" class="line"></span>            gl.enable(gl.BLEND);
<span id="line24802" class="line"></span>            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
<span id="line24803" class="line"></span>        }
<span id="line24804" class="line"></span>
<span id="line24805" class="line"></span>        /**
<span id="line24806" class="line"></span>         * Resize the render-to-texture when canvas size changes
<span id="line24807" class="line"></span>         * @param {Number} width - New canvas width
<span id="line24808" class="line"></span>         * @param {Number} height - New canvas height
<span id="line24809" class="line"></span>         */
<span id="line24810" class="line"></span>        resizeRenderer(width, height) {
<span id="line24811" class="line"></span>            const gl = this._gl;
<span id="line24812" class="line"></span>            if (!gl) {
<span id="line24813" class="line"></span>                return;
<span id="line24814" class="line"></span>            }
<span id="line24815" class="line"></span>            gl.viewport(0, 0, width, height);
<span id="line24816" class="line"></span>
<span id="line24817" class="line"></span>            //release the old texture
<span id="line24818" class="line"></span>            gl.deleteTexture(this._renderToTexture);
<span id="line24819" class="line"></span>            //create a new texture and set it up
<span id="line24820" class="line"></span>            this._renderToTexture = gl.createTexture();
<span id="line24821" class="line"></span>            gl.activeTexture(gl.TEXTURE0);
<span id="line24822" class="line"></span>            gl.bindTexture(gl.TEXTURE_2D, this._renderToTexture);
<span id="line24823" class="line"></span>            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
<span id="line24824" class="line"></span>            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.getTextureFilter());
<span id="line24825" class="line"></span>            this._applyAnisotropy();
<span id="line24826" class="line"></span>            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
<span id="line24827" class="line"></span>            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
<span id="line24828" class="line"></span>
<span id="line24829" class="line"></span>            //bind the frame buffer to the new texture
<span id="line24830" class="line"></span>            gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
<span id="line24831" class="line"></span>            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._renderToTexture, 0);
<span id="line24832" class="line"></span>        }
<span id="line24833" class="line"></span>
<span id="line24834" class="line"></span>        /**
<span id="line24835" class="line"></span>         * Create and upload a texture for a tile
<span id="line24836" class="line"></span>         * @param {HTMLImageElement|HTMLCanvasElement|ImageData} data - Image data to upload
<span id="line24837" class="line"></span>         * @param {Object} options - Texture options
<span id="line24838" class="line"></span>         * @param {Boolean} [options.unpackWithPremultipliedAlpha] - Override default unpack setting
<span id="line24839" class="line"></span>         * @returns {WebGLTexture|null} The created texture, or null on error
<span id="line24840" class="line"></span>         */
<span id="line24841" class="line"></span>        createTexture(data, options = {}) {
<span id="line24842" class="line"></span>            const gl = this._gl;
<span id="line24843" class="line"></span>            if (!gl) {
<span id="line24844" class="line"></span>                return null;
<span id="line24845" class="line"></span>            }
<span id="line24846" class="line"></span>
<span id="line24847" class="line"></span>            const texture = gl.createTexture();
<span id="line24848" class="line"></span>            gl.activeTexture(gl.TEXTURE0);
<span id="line24849" class="line"></span>            gl.bindTexture(gl.TEXTURE_2D, texture);
<span id="line24850" class="line"></span>            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
<span id="line24851" class="line"></span>            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
<span id="line24852" class="line"></span>            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.getTextureFilter());
<span id="line24853" class="line"></span>            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.getTextureFilter());
<span id="line24854" class="line"></span>            this._applyAnisotropy();
<span id="line24855" class="line"></span>
<span id="line24856" class="line"></span>            try {
<span id="line24857" class="line"></span>                const unpackPremultipliedAlpha = options.unpackWithPremultipliedAlpha !== undefined ?
<span id="line24858" class="line"></span>                    options.unpackWithPremultipliedAlpha :
<span id="line24859" class="line"></span>                    this._unpackWithPremultipliedAlpha;
<span id="line24860" class="line"></span>                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, unpackPremultipliedAlpha);
<span id="line24861" class="line"></span>                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);
<span id="line24862" class="line"></span>                return texture;
<span id="line24863" class="line"></span>            } catch (e) {
<span id="line24864" class="line"></span>                gl.deleteTexture(texture);
<span id="line24865" class="line"></span>                return null;
<span id="line24866" class="line"></span>            }
<span id="line24867" class="line"></span>        }
<span id="line24868" class="line"></span>
<span id="line24869" class="line"></span>        /**
<span id="line24870" class="line"></span>         * Delete a texture
<span id="line24871" class="line"></span>         * @param {WebGLTexture} texture - The texture to delete
<span id="line24872" class="line"></span>         */
<span id="line24873" class="line"></span>        deleteTexture(texture) {
<span id="line24874" class="line"></span>            if (this._gl &amp;&amp; texture) {
<span id="line24875" class="line"></span>                this._gl.deleteTexture(texture);
<span id="line24876" class="line"></span>            }
<span id="line24877" class="line"></span>        }
<span id="line24878" class="line"></span>
<span id="line24879" class="line"></span>        /**
<span id="line24880" class="line"></span>         * Set image smoothing enabled state
<span id="line24881" class="line"></span>         * @param {Boolean} enabled - Whether image smoothing is enabled
<span id="line24882" class="line"></span>         */
<span id="line24883" class="line"></span>        setImageSmoothingEnabled(enabled) {
<span id="line24884" class="line"></span>            this._imageSmoothingEnabled = !!enabled;
<span id="line24885" class="line"></span>        }
<span id="line24886" class="line"></span>
<span id="line24887" class="line"></span>        /**
<span id="line24888" class="line"></span>         * Set unpack with premultiplied alpha state
<span id="line24889" class="line"></span>         * @param {Boolean} enabled - Whether to use premultiplied alpha
<span id="line24890" class="line"></span>         */
<span id="line24891" class="line"></span>        setUnpackWithPremultipliedAlpha(enabled) {
<span id="line24892" class="line"></span>            this._unpackWithPremultipliedAlpha = !!enabled;
<span id="line24893" class="line"></span>            if (this._gl) {
<span id="line24894" class="line"></span>                this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._unpackWithPremultipliedAlpha);
<span id="line24895" class="line"></span>            }
<span id="line24896" class="line"></span>        }
<span id="line24897" class="line"></span>
<span id="line24898" class="line"></span>        /**
<span id="line24899" class="line"></span>         * Make a quad vertex buffer
<span id="line24900" class="line"></span>         * @param {Number} left - Left coordinate
<span id="line24901" class="line"></span>         * @param {Number} right - Right coordinate
<span id="line24902" class="line"></span>         * @param {Number} top - Top coordinate
<span id="line24903" class="line"></span>         * @param {Number} bottom - Bottom coordinate
<span id="line24904" class="line"></span>         * @returns {Float32Array} Vertex buffer
<span id="line24905" class="line"></span>         */
<span id="line24906" class="line"></span>        makeQuadVertexBuffer(left, right, top, bottom) {
<span id="line24907" class="line"></span>            return new Float32Array([
<span id="line24908" class="line"></span>                left, bottom,
<span id="line24909" class="line"></span>                right, bottom,
<span id="line24910" class="line"></span>                left, top,
<span id="line24911" class="line"></span>                left, top,
<span id="line24912" class="line"></span>                right, bottom,
<span id="line24913" class="line"></span>                right, top]);
<span id="line24914" class="line"></span>        }
<span id="line24915" class="line"></span>
<span id="line24916" class="line"></span>        /**
<span id="line24917" class="line"></span>         * Create the first pass shader program
<span id="line24918" class="line"></span>         * @private
<span id="line24919" class="line"></span>         */
<span id="line24920" class="line"></span>        _makeFirstPassShaderProgram() {
<span id="line24921" class="line"></span>            const numTextures = this._glNumTextures = this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS);
<span id="line24922" class="line"></span>            const makeMatrixUniforms = () =&gt; {
<span id="line24923" class="line"></span>                return [...Array(numTextures).keys()].map(index =&gt; `uniform mat3 u_matrix_${index};`).join('\n');
<span id="line24924" class="line"></span>            };
<span id="line24925" class="line"></span>            const makeConditionals = () =&gt; {
<span id="line24926" class="line"></span>                return [...Array(numTextures).keys()].map(index =&gt; `${index &gt; 0 ? 'else ' : ''}if(int(a_index) == ${index}) { transform_matrix = u_matrix_${index}; }`).join('\n');
<span id="line24927" class="line"></span>            };
<span id="line24928" class="line"></span>
<span id="line24929" class="line"></span>            const vertexShaderProgram = `
<span id="line24930" class="line"></span>            attribute vec2 a_output_position;
<span id="line24931" class="line"></span>            attribute vec2 a_texture_position;
<span id="line24932" class="line"></span>            attribute float a_index;
<span id="line24933" class="line"></span>
<span id="line24934" class="line"></span>            ${makeMatrixUniforms()} // create a uniform mat3 for each potential tile to draw
<span id="line24935" class="line"></span>
<span id="line24936" class="line"></span>            varying vec2 v_texture_position;
<span id="line24937" class="line"></span>            varying float v_image_index;
<span id="line24938" class="line"></span>
<span id="line24939" class="line"></span>            void main() {
<span id="line24940" class="line"></span>
<span id="line24941" class="line"></span>                mat3 transform_matrix; // value will be set by the if/elses in makeConditional()
<span id="line24942" class="line"></span>
<span id="line24943" class="line"></span>                ${makeConditionals()}
<span id="line24944" class="line"></span>
<span id="line24945" class="line"></span>                gl_Position = vec4(transform_matrix * vec3(a_output_position, 1), 1);
<span id="line24946" class="line"></span>
<span id="line24947" class="line"></span>                v_texture_position = a_texture_position;
<span id="line24948" class="line"></span>                v_image_index = a_index;
<span id="line24949" class="line"></span>            }
<span id="line24950" class="line"></span>            `;
<span id="line24951" class="line"></span>
<span id="line24952" class="line"></span>            const fragmentShaderProgram = `
<span id="line24953" class="line"></span>            precision mediump float;
<span id="line24954" class="line"></span>
<span id="line24955" class="line"></span>            // our textures
<span id="line24956" class="line"></span>            uniform sampler2D u_images[${numTextures}];
<span id="line24957" class="line"></span>            // our opacities
<span id="line24958" class="line"></span>            uniform float u_opacities[${numTextures}];
<span id="line24959" class="line"></span>
<span id="line24960" class="line"></span>            // the varyings passed in from the vertex shader.
<span id="line24961" class="line"></span>            varying vec2 v_texture_position;
<span id="line24962" class="line"></span>            varying float v_image_index;
<span id="line24963" class="line"></span>
<span id="line24964" class="line"></span>            void main() {
<span id="line24965" class="line"></span>                // can't index directly with a variable, need to use a loop iterator hack
<span id="line24966" class="line"></span>                for(int i = 0; i &lt; ${numTextures}; ++i){
<span id="line24967" class="line"></span>                    if(i == int(v_image_index)){
<span id="line24968" class="line"></span>                        gl_FragColor = texture2D(u_images[i], v_texture_position) * u_opacities[i];
<span id="line24969" class="line"></span>                    }
<span id="line24970" class="line"></span>                }
<span id="line24971" class="line"></span>            }
<span id="line24972" class="line"></span>            `;
<span id="line24973" class="line"></span>
<span id="line24974" class="line"></span>            const gl = this._gl;
<span id="line24975" class="line"></span>
<span id="line24976" class="line"></span>            const program = this._initShaderProgram(gl, vertexShaderProgram, fragmentShaderProgram);
<span id="line24977" class="line"></span>            gl.useProgram(program);
<span id="line24978" class="line"></span>
<span id="line24979" class="line"></span>            // get locations of attributes and uniforms, and create buffers for each attribute
<span id="line24980" class="line"></span>            this._firstPass = {
<span id="line24981" class="line"></span>                shaderProgram: program,
<span id="line24982" class="line"></span>                aOutputPosition: gl.getAttribLocation(program, 'a_output_position'),
<span id="line24983" class="line"></span>                aTexturePosition: gl.getAttribLocation(program, 'a_texture_position'),
<span id="line24984" class="line"></span>                aIndex: gl.getAttribLocation(program, 'a_index'),
<span id="line24985" class="line"></span>                uTransformMatrices: [...Array(this._glNumTextures).keys()].map(i=&gt;gl.getUniformLocation(program, `u_matrix_${i}`)),
<span id="line24986" class="line"></span>                uImages: gl.getUniformLocation(program, 'u_images'),
<span id="line24987" class="line"></span>                uOpacities: gl.getUniformLocation(program, 'u_opacities'),
<span id="line24988" class="line"></span>                bufferOutputPosition: gl.createBuffer(),
<span id="line24989" class="line"></span>                bufferTexturePosition: gl.createBuffer(),
<span id="line24990" class="line"></span>                bufferIndex: gl.createBuffer(),
<span id="line24991" class="line"></span>            };
<span id="line24992" class="line"></span>
<span id="line24993" class="line"></span>            gl.uniform1iv(this._firstPass.uImages, [...Array(numTextures).keys()]);
<span id="line24994" class="line"></span>
<span id="line24995" class="line"></span>            // provide coordinates for the rectangle in output space, i.e. a unit quad for each one.
<span id="line24996" class="line"></span>            const outputQuads = new Float32Array(numTextures * 12);
<span id="line24997" class="line"></span>            for(let i = 0; i &lt; numTextures; ++i){
<span id="line24998" class="line"></span>                outputQuads.set(Float32Array.from(this._unitQuad), i * 12);
<span id="line24999" class="line"></span>            }
<span id="line25000" class="line"></span>            gl.bindBuffer(gl.ARRAY_BUFFER, this._firstPass.bufferOutputPosition);
<span id="line25001" class="line"></span>            gl.bufferData(gl.ARRAY_BUFFER, outputQuads, gl.STATIC_DRAW); // bind data statically here, since it's unchanging
<span id="line25002" class="line"></span>            gl.enableVertexAttribArray(this._firstPass.aOutputPosition);
<span id="line25003" class="line"></span>
<span id="line25004" class="line"></span>            // provide texture coordinates for the rectangle in image (texture) space. Data will be set later.
<span id="line25005" class="line"></span>            gl.bindBuffer(gl.ARRAY_BUFFER, this._firstPass.bufferTexturePosition);
<span id="line25006" class="line"></span>            gl.enableVertexAttribArray(this._firstPass.aTexturePosition);
<span id="line25007" class="line"></span>
<span id="line25008" class="line"></span>            // for each vertex, provide an index into the array of textures/matrices to use for the correct tile
<span id="line25009" class="line"></span>            gl.bindBuffer(gl.ARRAY_BUFFER, this._firstPass.bufferIndex);
<span id="line25010" class="line"></span>            const indices = [...Array(this._glNumTextures).keys()].map(i =&gt; Array(6).fill(i)).flat(); // repeat each index 6 times, for the 6 vertices per tile (2 triangles)
<span id="line25011" class="line"></span>            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(indices), gl.STATIC_DRAW); // bind data statically here, since it's unchanging
<span id="line25012" class="line"></span>            gl.enableVertexAttribArray(this._firstPass.aIndex);
<span id="line25013" class="line"></span>        }
<span id="line25014" class="line"></span>
<span id="line25015" class="line"></span>        /**
<span id="line25016" class="line"></span>         * Create the second pass shader program
<span id="line25017" class="line"></span>         * @private
<span id="line25018" class="line"></span>         */
<span id="line25019" class="line"></span>        _makeSecondPassShaderProgram() {
<span id="line25020" class="line"></span>            const vertexShaderProgram = `
<span id="line25021" class="line"></span>            attribute vec2 a_output_position;
<span id="line25022" class="line"></span>            attribute vec2 a_texture_position;
<span id="line25023" class="line"></span>
<span id="line25024" class="line"></span>            varying vec2 v_texture_position;
<span id="line25025" class="line"></span>
<span id="line25026" class="line"></span>            void main() {
<span id="line25027" class="line"></span>                // Transform to clip space (0:1 --&gt; -1:1)
<span id="line25028" class="line"></span>                gl_Position = vec4(vec3(a_output_position * 2.0 - 1.0, 1), 1);
<span id="line25029" class="line"></span>
<span id="line25030" class="line"></span>                v_texture_position = a_texture_position;
<span id="line25031" class="line"></span>            }
<span id="line25032" class="line"></span>            `;
<span id="line25033" class="line"></span>
<span id="line25034" class="line"></span>            const fragmentShaderProgram = `
<span id="line25035" class="line"></span>            precision mediump float;
<span id="line25036" class="line"></span>
<span id="line25037" class="line"></span>            // our texture
<span id="line25038" class="line"></span>            uniform sampler2D u_image;
<span id="line25039" class="line"></span>
<span id="line25040" class="line"></span>            // the texCoords passed in from the vertex shader.
<span id="line25041" class="line"></span>            varying vec2 v_texture_position;
<span id="line25042" class="line"></span>
<span id="line25043" class="line"></span>            // the opacity multiplier for the image
<span id="line25044" class="line"></span>            uniform float u_opacity_multiplier;
<span id="line25045" class="line"></span>
<span id="line25046" class="line"></span>            void main() {
<span id="line25047" class="line"></span>                gl_FragColor = texture2D(u_image, v_texture_position);
<span id="line25048" class="line"></span>                gl_FragColor *= u_opacity_multiplier;
<span id="line25049" class="line"></span>            }
<span id="line25050" class="line"></span>            `;
<span id="line25051" class="line"></span>
<span id="line25052" class="line"></span>            const gl = this._gl;
<span id="line25053" class="line"></span>
<span id="line25054" class="line"></span>            const program = this._initShaderProgram(gl, vertexShaderProgram, fragmentShaderProgram);
<span id="line25055" class="line"></span>            gl.useProgram(program);
<span id="line25056" class="line"></span>
<span id="line25057" class="line"></span>            // get locations of attributes and uniforms, and create buffers for each attribute
<span id="line25058" class="line"></span>            this._secondPass = {
<span id="line25059" class="line"></span>                shaderProgram: program,
<span id="line25060" class="line"></span>                aOutputPosition: gl.getAttribLocation(program, 'a_output_position'),
<span id="line25061" class="line"></span>                aTexturePosition: gl.getAttribLocation(program, 'a_texture_position'),
<span id="line25062" class="line"></span>                uImage: gl.getUniformLocation(program, 'u_image'),
<span id="line25063" class="line"></span>                uOpacityMultiplier: gl.getUniformLocation(program, 'u_opacity_multiplier'),
<span id="line25064" class="line"></span>                bufferOutputPosition: gl.createBuffer(),
<span id="line25065" class="line"></span>                bufferTexturePosition: gl.createBuffer(),
<span id="line25066" class="line"></span>            };
<span id="line25067" class="line"></span>
<span id="line25068" class="line"></span>            // provide coordinates for the rectangle in output space, i.e. a unit quad for each one.
<span id="line25069" class="line"></span>            gl.bindBuffer(gl.ARRAY_BUFFER, this._secondPass.bufferOutputPosition);
<span id="line25070" class="line"></span>            gl.bufferData(gl.ARRAY_BUFFER, this._unitQuad, gl.STATIC_DRAW); // bind data statically here since it's unchanging
<span id="line25071" class="line"></span>            gl.enableVertexAttribArray(this._secondPass.aOutputPosition);
<span id="line25072" class="line"></span>
<span id="line25073" class="line"></span>            // provide texture coordinates for the rectangle in image (texture) space.
<span id="line25074" class="line"></span>            gl.bindBuffer(gl.ARRAY_BUFFER, this._secondPass.bufferTexturePosition);
<span id="line25075" class="line"></span>            gl.bufferData(gl.ARRAY_BUFFER, this._unitQuad, gl.DYNAMIC_DRAW); // bind data statically here since it's unchanging
<span id="line25076" class="line"></span>            gl.enableVertexAttribArray(this._secondPass.aTexturePosition);
<span id="line25077" class="line"></span>        }
<span id="line25078" class="line"></span>
<span id="line25079" class="line"></span>        /**
<span id="line25080" class="line"></span>         * Destroy the WebGL context and all resources
<span id="line25081" class="line"></span>         */
<span id="line25082" class="line"></span>        destroy() {
<span id="line25083" class="line"></span>            if (this._destroyed) {
<span id="line25084" class="line"></span>                return;
<span id="line25085" class="line"></span>            }
<span id="line25086" class="line"></span>            this._destroyed = true;
<span id="line25087" class="line"></span>
<span id="line25088" class="line"></span>            const gl = this._gl;
<span id="line25089" class="line"></span>            if (gl) {
<span id="line25090" class="line"></span>                try {
<span id="line25091" class="line"></span>                    // adapted from https://stackoverflow.com/a/23606581/1214731
<span id="line25092" class="line"></span>                    const numTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
<span id="line25093" class="line"></span>                    if (numTextureUnits &amp;&amp; numTextureUnits &gt; 0) {
<span id="line25094" class="line"></span>                        for (let unit = 0; unit &lt; numTextureUnits; ++unit) {
<span id="line25095" class="line"></span>                            gl.activeTexture(gl.TEXTURE0 + unit);
<span id="line25096" class="line"></span>                            gl.bindTexture(gl.TEXTURE_2D, null);
<span id="line25097" class="line"></span>                            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
<span id="line25098" class="line"></span>                        }
<span id="line25099" class="line"></span>                    }
<span id="line25100" class="line"></span>                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
<span id="line25101" class="line"></span>                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
<span id="line25102" class="line"></span>                    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
<span id="line25103" class="line"></span>                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
<span id="line25104" class="line"></span>
<span id="line25105" class="line"></span>                    // Delete all our created resources
<span id="line25106" class="line"></span>                    if (this._secondPass &amp;&amp; this._secondPass.bufferOutputPosition) {
<span id="line25107" class="line"></span>                        gl.deleteBuffer(this._secondPass.bufferOutputPosition);
<span id="line25108" class="line"></span>                    }
<span id="line25109" class="line"></span>                    if (this._glFrameBuffer) {
<span id="line25110" class="line"></span>                        gl.deleteFramebuffer(this._glFrameBuffer);
<span id="line25111" class="line"></span>                    }
<span id="line25112" class="line"></span>                } catch (e) {
<span id="line25113" class="line"></span>                    // Context may already be lost, continue with cleanup
<span id="line25114" class="line"></span>                    $.console.warn('Error during WebGL cleanup in WebglContextManager.destroy():', e);
<span id="line25115" class="line"></span>                }
<span id="line25116" class="line"></span>
<span id="line25117" class="line"></span>                const ext = gl.getExtension('WEBGL_lose_context');
<span id="line25118" class="line"></span>                if (ext) {
<span id="line25119" class="line"></span>                    ext.loseContext();
<span id="line25120" class="line"></span>                }
<span id="line25121" class="line"></span>            }
<span id="line25122" class="line"></span>
<span id="line25123" class="line"></span>            // Clean up references
<span id="line25124" class="line"></span>            this._gl = null;
<span id="line25125" class="line"></span>            this._firstPass = null;
<span id="line25126" class="line"></span>            this._secondPass = null;
<span id="line25127" class="line"></span>            this._glFrameBuffer = null;
<span id="line25128" class="line"></span>            this._renderToTexture = null;
<span id="line25129" class="line"></span>            this._unitQuad = null;
<span id="line25130" class="line"></span>        }
<span id="line25131" class="line"></span>
<span id="line25132" class="line"></span>        /**
<span id="line25133" class="line"></span>         * Check if this context manager has been destroyed
<span id="line25134" class="line"></span>         * @returns {Boolean} true if destroyed, false otherwise
<span id="line25135" class="line"></span>         */
<span id="line25136" class="line"></span>        isDestroyed() {
<span id="line25137" class="line"></span>            return this._destroyed;
<span id="line25138" class="line"></span>        }
<span id="line25139" class="line"></span>    }
<span id="line25140" class="line"></span>
<span id="line25141" class="line"></span>   /**
<span id="line25142" class="line"></span>    * @class OpenSeadragon.WebGLDrawer
<span id="line25143" class="line"></span>    * @classdesc Default implementation of WebGLDrawer for an {@link OpenSeadragon.Viewer}. The WebGLDrawer
<span id="line25144" class="line"></span>    * defines its own data type that ensures textures are correctly loaded to and deleted from the GPU memory.
<span id="line25145" class="line"></span>    * The drawer utilizes a context-dependent two pass drawing pipeline. For the first pass, tile composition
<span id="line25146" class="line"></span>    * for a given TiledImage is always done using a canvas with a WebGL context. This allows tiles to be stitched
<span id="line25147" class="line"></span>    * together without seams or artifacts, without requiring a tile source with overlap. If overlap is present,
<span id="line25148" class="line"></span>    * overlapping pixels are discarded. The second pass copies all pixel data from the WebGL context onto an output
<span id="line25149" class="line"></span>    * canvas with a Context2d context. This allows applications to have access to pixel data and other functionality
<span id="line25150" class="line"></span>    * provided by Context2d, regardless of whether the CanvasDrawer or the WebGLDrawer is used. Certain options,
<span id="line25151" class="line"></span>    * including compositeOperation, clip, croppingPolygons, and debugMode are implemented using Context2d operations;
<span id="line25152" class="line"></span>    * in these scenarios, each TiledImage is drawn onto the output canvas immediately after the tile composition step
<span id="line25153" class="line"></span>    * (pass 1). Otherwise, for efficiency, all TiledImages are copied over to the output canvas at once, after all
<span id="line25154" class="line"></span>    * tiles have been composited for all images.
<span id="line25155" class="line"></span>    * @param {Object} options - Options for this Drawer.
<span id="line25156" class="line"></span>    * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this Drawer.
<span id="line25157" class="line"></span>    * @param {OpenSeadragon.Viewport} options.viewport - Reference to Viewer viewport.
<span id="line25158" class="line"></span>    * @param {Element} options.element - Parent element.
<span id="line25159" class="line"></span>    * @param {Number} [options.debugGridColor] - See debugGridColor in {@link OpenSeadragon.Options} for details.
<span id="line25160" class="line"></span>    * @param {Boolean} [options.unpackWithPremultipliedAlpha=false] - Whether to enable gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL when uploading textures.
<span id="line25161" class="line"></span>    */
<span id="line25162" class="line"></span>    OpenSeadragon.WebGLDrawer = class WebGLDrawer extends OpenSeadragon.DrawerBase{
<span id="line25163" class="line"></span>        constructor(options){
<span id="line25164" class="line"></span>           super(options);
<span id="line25165" class="line"></span>
<span id="line25166" class="line"></span>            /**
<span id="line25167" class="line"></span>             * The HTML element (canvas) that this drawer uses for drawing
<span id="line25168" class="line"></span>             * @member {Element} canvas
<span id="line25169" class="line"></span>             * @memberof OpenSeadragon.WebGLDrawer#
<span id="line25170" class="line"></span>             */
<span id="line25171" class="line"></span>
<span id="line25172" class="line"></span>            /**
<span id="line25173" class="line"></span>             * The parent element of this Drawer instance, passed in when the Drawer was created.
<span id="line25174" class="line"></span>             * The parent of {@link OpenSeadragon.WebGLDrawer#canvas}.
<span id="line25175" class="line"></span>             * @member {Element} container
<span id="line25176" class="line"></span>             * @memberof OpenSeadragon.WebGLDrawer#
<span id="line25177" class="line"></span>             */
<span id="line25178" class="line"></span>
<span id="line25179" class="line"></span>            // private members
<span id="line25180" class="line"></span>            this._destroyed = false;
<span id="line25181" class="line"></span>            /**
<span id="line25182" class="line"></span>             * WebGL context manager instance
<span id="line25183" class="line"></span>             * @member {WebglContextManager} _glContext
<span id="line25184" class="line"></span>             * @memberof OpenSeadragon.WebGLDrawer#
<span id="line25185" class="line"></span>             * @private
<span id="line25186" class="line"></span>             */
<span id="line25187" class="line"></span>            this._glContext = null;
<span id="line25188" class="line"></span>            /**
<span id="line25189" class="line"></span>             * Flag to enable/disable automatic WebGL context re-initialization on context loss.
<span id="line25190" class="line"></span>             * When enabled, the drawer will attempt to recover from context exhaustion errors.
<span id="line25191" class="line"></span>             * @member {Boolean} _enableContextRecovery
<span id="line25192" class="line"></span>             * @memberof OpenSeadragon.WebGLDrawer#
<span id="line25193" class="line"></span>             * @private
<span id="line25194" class="line"></span>             */
<span id="line25195" class="line"></span>            this._enableContextRecovery = true;
<span id="line25196" class="line"></span>            this._outputCanvas = null;
<span id="line25197" class="line"></span>            this._outputContext = null;
<span id="line25198" class="line"></span>            this._clippingCanvas = null;
<span id="line25199" class="line"></span>            this._clippingContext = null;
<span id="line25200" class="line"></span>            this._renderingCanvas = null;
<span id="line25201" class="line"></span>            this._backupCanvasDrawer = null;
<span id="line25202" class="line"></span>            this._canvasFallbackAllowed = this.viewer.drawerCandidates &amp;&amp; this.viewer.drawerCandidates.includes('canvas');
<span id="line25203" class="line"></span>
<span id="line25204" class="line"></span>            this._imageSmoothingEnabled = true; // will be updated by setImageSmoothingEnabled
<span id="line25205" class="line"></span>            this._unpackWithPremultipliedAlpha = !!this.options.unpackWithPremultipliedAlpha;
<span id="line25206" class="line"></span>
<span id="line25207" class="line"></span>            // Reject listening for the tile-drawing and tile-drawn events, which this drawer does not fire
<span id="line25208" class="line"></span>            this.viewer.rejectEventHandler("tile-drawn", "The WebGLDrawer does not raise the tile-drawn event");
<span id="line25209" class="line"></span>            this.viewer.rejectEventHandler("tile-drawing", "The WebGLDrawer does not raise the tile-drawing event");
<span id="line25210" class="line"></span>
<span id="line25211" class="line"></span>            // this.viewer and this.canvas are part of the public DrawerBase API
<span id="line25212" class="line"></span>            // and are defined by the parent DrawerBase class. Additional setup is done by
<span id="line25213" class="line"></span>            // the private _setupCanvases and _setupRenderer functions.
<span id="line25214" class="line"></span>            this._setupCanvases();
<span id="line25215" class="line"></span>            this._setupRenderer();
<span id="line25216" class="line"></span>
<span id="line25217" class="line"></span>            this._supportedFormats = ["context2d", "image"];
<span id="line25218" class="line"></span>            this.context = this._outputContext; // API required by tests
<span id="line25219" class="line"></span>        }
<span id="line25220" class="line"></span>
<span id="line25221" class="line"></span>        get defaultOptions() {
<span id="line25222" class="line"></span>            return {
<span id="line25223" class="line"></span>                // use detached cache: our type conversion will not collide (and does not have to preserve CPU data ref)
<span id="line25224" class="line"></span>                usePrivateCache: true,
<span id="line25225" class="line"></span>                preloadCache: false,
<span id="line25226" class="line"></span>                unpackWithPremultipliedAlpha: false,
<span id="line25227" class="line"></span>            };
<span id="line25228" class="line"></span>        }
<span id="line25229" class="line"></span>
<span id="line25230" class="line"></span>        getSupportedDataFormats() {
<span id="line25231" class="line"></span>            return this._supportedFormats;
<span id="line25232" class="line"></span>        }
<span id="line25233" class="line"></span>
<span id="line25234" class="line"></span>        // Public API required by all Drawer implementations
<span id="line25235" class="line"></span>        /**
<span id="line25236" class="line"></span>        * Clean up the renderer, removing all resources
<span id="line25237" class="line"></span>        */
<span id="line25238" class="line"></span>        destroy(){
<span id="line25239" class="line"></span>            if(this._destroyed){
<span id="line25240" class="line"></span>                return;
<span id="line25241" class="line"></span>            }
<span id="line25242" class="line"></span>            super.destroy();
<span id="line25243" class="line"></span>            // Remove the resize handler to prevent memory leaks
<span id="line25244" class="line"></span>            if (this._resizeHandler) {
<span id="line25245" class="line"></span>                this.viewer.removeHandler("resize", this._resizeHandler);
<span id="line25246" class="line"></span>                this._resizeHandler = null;
<span id="line25247" class="line"></span>            }
<span id="line25248" class="line"></span>
<span id="line25249" class="line"></span>            // Destroy WebGL context manager
<span id="line25250" class="line"></span>            if (this._glContext) {
<span id="line25251" class="line"></span>                this._glContext.destroy();
<span id="line25252" class="line"></span>                this._glContext = null;
<span id="line25253" class="line"></span>            }
<span id="line25254" class="line"></span>
<span id="line25255" class="line"></span>            // make canvases 1 x 1 px and delete references
<span id="line25256" class="line"></span>            if (this._renderingCanvas) {
<span id="line25257" class="line"></span>                this._renderingCanvas.width = this._renderingCanvas.height = 1;
<span id="line25258" class="line"></span>            }
<span id="line25259" class="line"></span>            if (this._clippingCanvas) {
<span id="line25260" class="line"></span>                this._clippingCanvas.width = this._clippingCanvas.height = 1;
<span id="line25261" class="line"></span>            }
<span id="line25262" class="line"></span>            if (this._outputCanvas) {
<span id="line25263" class="line"></span>                this._outputCanvas.width = this._outputCanvas.height = 1;
<span id="line25264" class="line"></span>            }
<span id="line25265" class="line"></span>            this._renderingCanvas = null;
<span id="line25266" class="line"></span>            this._clippingCanvas = this._clippingContext = null;
<span id="line25267" class="line"></span>            this._outputCanvas = this._outputContext = null;
<span id="line25268" class="line"></span>
<span id="line25269" class="line"></span>            if(this._backupCanvasDrawer){
<span id="line25270" class="line"></span>                this._backupCanvasDrawer.destroy();
<span id="line25271" class="line"></span>                this._backupCanvasDrawer = null;
<span id="line25272" class="line"></span>            }
<span id="line25273" class="line"></span>
<span id="line25274" class="line"></span>            this.container.removeChild(this.canvas);
<span id="line25275" class="line"></span>            if(this.viewer.drawer === this){
<span id="line25276" class="line"></span>                this.viewer.drawer = null;
<span id="line25277" class="line"></span>            }
<span id="line25278" class="line"></span>
<span id="line25279" class="line"></span>            this.destroyInternalCache();
<span id="line25280" class="line"></span>
<span id="line25281" class="line"></span>            // set our destroyed flag to true
<span id="line25282" class="line"></span>            this._destroyed = true;
<span id="line25283" class="line"></span>        }
<span id="line25284" class="line"></span>
<span id="line25285" class="line"></span>        // Public API required by all Drawer implementations
<span id="line25286" class="line"></span>        /**
<span id="line25287" class="line"></span>        *
<span id="line25288" class="line"></span>        * @returns {Boolean} true
<span id="line25289" class="line"></span>        */
<span id="line25290" class="line"></span>        canRotate(){
<span id="line25291" class="line"></span>            return true;
<span id="line25292" class="line"></span>        }
<span id="line25293" class="line"></span>
<span id="line25294" class="line"></span>        // Public API required by all Drawer implementations
<span id="line25295" class="line"></span>        /**
<span id="line25296" class="line"></span>         * Functional test: true if WebGL is supported and the real first-pass shader pipeline
<span id="line25297" class="line"></span>         * can render (same shaders/context path used at runtime). Uses a temp context and
<span id="line25298" class="line"></span>         * WebglContextManager, draws known non-black pixels to an FBO, then readPixels.
<span id="line25299" class="line"></span>         * @returns {Boolean} true if WebGL is supported and the pipeline renders successfully
<span id="line25300" class="line"></span>         */
<span id="line25301" class="line"></span>        static isSupported(){
<span id="line25302" class="line"></span>            let contextManager = null;
<span id="line25303" class="line"></span>            let testTexture = null;
<span id="line25304" class="line"></span>            let gl = null;
<span id="line25305" class="line"></span>            try {
<span id="line25306" class="line"></span>                const size = 4;
<span id="line25307" class="line"></span>                const canvas = document.createElement('canvas');
<span id="line25308" class="line"></span>                canvas.width = size;
<span id="line25309" class="line"></span>                canvas.height = size;
<span id="line25310" class="line"></span>                if (!$.isFunction(canvas.getContext)) {
<span id="line25311" class="line"></span>                    return false;
<span id="line25312" class="line"></span>                }
<span id="line25313" class="line"></span>                gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
<span id="line25314" class="line"></span>                if (!gl) {
<span id="line25315" class="line"></span>                    return false;
<span id="line25316" class="line"></span>                }
<span id="line25317" class="line"></span>                contextManager = new WebglContextManager({
<span id="line25318" class="line"></span>                    renderingCanvas: canvas,
<span id="line25319" class="line"></span>                    unpackWithPremultipliedAlpha: false,
<span id="line25320" class="line"></span>                    imageSmoothingEnabled: true,
<span id="line25321" class="line"></span>                    initShaderProgram: WebGLDrawer.initShaderProgram
<span id="line25322" class="line"></span>                });
<span id="line25323" class="line"></span>                if (!contextManager.getContext()) {
<span id="line25324" class="line"></span>                    return false;
<span id="line25325" class="line"></span>                }
<span id="line25326" class="line"></span>                contextManager.setupRenderer(size, size);
<span id="line25327" class="line"></span>
<span id="line25328" class="line"></span>                const firstPass = contextManager.getFirstPass();
<span id="line25329" class="line"></span>                const glFrameBuffer = contextManager.getFrameBuffer();
<span id="line25330" class="line"></span>                if (!firstPass || !glFrameBuffer) {
<span id="line25331" class="line"></span>                    return false;
<span id="line25332" class="line"></span>                }
<span id="line25333" class="line"></span>
<span id="line25334" class="line"></span>                const maxTextures = contextManager.getMaxTextures();
<span id="line25335" class="line"></span>                if (!maxTextures || maxTextures &lt;= 0) {
<span id="line25336" class="line"></span>                    return false;
<span id="line25337" class="line"></span>                }
<span id="line25338" class="line"></span>
<span id="line25339" class="line"></span>                const imageData = new ImageData(size, size);
<span id="line25340" class="line"></span>                imageData.data[0] = 255;
<span id="line25341" class="line"></span>                imageData.data[1] = 0;
<span id="line25342" class="line"></span>                imageData.data[2] = 0;
<span id="line25343" class="line"></span>                imageData.data[3] = 255;
<span id="line25344" class="line"></span>                testTexture = contextManager.createTexture(imageData);
<span id="line25345" class="line"></span>                if (!testTexture) {
<span id="line25346" class="line"></span>                    return false;
<span id="line25347" class="line"></span>                }
<span id="line25348" class="line"></span>
<span id="line25349" class="line"></span>                const unitQuad = contextManager.makeQuadVertexBuffer(0, 1, 0, 1);
<span id="line25350" class="line"></span>                gl.viewport(0, 0, size, size);
<span id="line25351" class="line"></span>                gl.bindFramebuffer(gl.FRAMEBUFFER, glFrameBuffer);
<span id="line25352" class="line"></span>                gl.clearColor(0, 0, 0, 0);
<span id="line25353" class="line"></span>                gl.clear(gl.COLOR_BUFFER_BIT);
<span id="line25354" class="line"></span>                gl.useProgram(firstPass.shaderProgram);
<span id="line25355" class="line"></span>
<span id="line25356" class="line"></span>                gl.activeTexture(gl.TEXTURE0);
<span id="line25357" class="line"></span>                gl.bindTexture(gl.TEXTURE_2D, testTexture);
<span id="line25358" class="line"></span>                gl.bindBuffer(gl.ARRAY_BUFFER, firstPass.bufferTexturePosition);
<span id="line25359" class="line"></span>                gl.bufferData(gl.ARRAY_BUFFER, unitQuad, gl.DYNAMIC_DRAW);
<span id="line25360" class="line"></span>                const ndcMatrix = new Float32Array([2, 0, 0, 0, 2, 0, -1, -1, 1]);
<span id="line25361" class="line"></span>                gl.uniformMatrix3fv(firstPass.uTransformMatrices[0], false, ndcMatrix);
<span id="line25362" class="line"></span>                gl.uniform1fv(firstPass.uOpacities, new Float32Array([1]));
<span id="line25363" class="line"></span>
<span id="line25364" class="line"></span>                gl.bindBuffer(gl.ARRAY_BUFFER, firstPass.bufferOutputPosition);
<span id="line25365" class="line"></span>                gl.vertexAttribPointer(firstPass.aOutputPosition, 2, gl.FLOAT, false, 0, 0);
<span id="line25366" class="line"></span>                gl.bindBuffer(gl.ARRAY_BUFFER, firstPass.bufferTexturePosition);
<span id="line25367" class="line"></span>                gl.vertexAttribPointer(firstPass.aTexturePosition, 2, gl.FLOAT, false, 0, 0);
<span id="line25368" class="line"></span>                gl.bindBuffer(gl.ARRAY_BUFFER, firstPass.bufferIndex);
<span id="line25369" class="line"></span>                gl.vertexAttribPointer(firstPass.aIndex, 1, gl.FLOAT, false, 0, 0);
<span id="line25370" class="line"></span>
<span id="line25371" class="line"></span>                gl.drawArrays(gl.TRIANGLES, 0, 6);
<span id="line25372" class="line"></span>
<span id="line25373" class="line"></span>                const pixels = new Uint8Array(size * size * 4);
<span id="line25374" class="line"></span>                gl.readPixels(0, 0, size, size, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
<span id="line25375" class="line"></span>                const hasNonZero = pixels.some(v =&gt; v !== 0);
<span id="line25376" class="line"></span>                if (!hasNonZero) {
<span id="line25377" class="line"></span>                    $.console.warn('[WebGLDrawer.isSupported] Functional test failed: no non-zero pixels read back.');
<span id="line25378" class="line"></span>                    return false;
<span id="line25379" class="line"></span>                }
<span id="line25380" class="line"></span>                return true;
<span id="line25381" class="line"></span>            } catch (e) {
<span id="line25382" class="line"></span>                $.console.warn('[WebGLDrawer.isSupported] Functional test failed:', e &amp;&amp; e.message ? e.message : e);
<span id="line25383" class="line"></span>                return false;
<span id="line25384" class="line"></span>            } finally {
<span id="line25385" class="line"></span>                try {
<span id="line25386" class="line"></span>                    if (testTexture &amp;&amp; contextManager) {
<span id="line25387" class="line"></span>                        contextManager.deleteTexture(testTexture);
<span id="line25388" class="line"></span>                    }
<span id="line25389" class="line"></span>                    if (contextManager) {
<span id="line25390" class="line"></span>                        contextManager.destroy();
<span id="line25391" class="line"></span>                    } else if (gl) {
<span id="line25392" class="line"></span>                        const ext = gl.getExtension('WEBGL_lose_context');
<span id="line25393" class="line"></span>                        if (ext) {
<span id="line25394" class="line"></span>                            ext.loseContext();
<span id="line25395" class="line"></span>                        }
<span id="line25396" class="line"></span>                    }
<span id="line25397" class="line"></span>                } catch (cleanupErr) {
<span id="line25398" class="line"></span>                    // ignore cleanup errors so we preserve the test result
<span id="line25399" class="line"></span>                }
<span id="line25400" class="line"></span>            }
<span id="line25401" class="line"></span>        }
<span id="line25402" class="line"></span>
<span id="line25403" class="line"></span>        /**
<span id="line25404" class="line"></span>         *
<span id="line25405" class="line"></span>         * @returns {string} 'webgl'
<span id="line25406" class="line"></span>         */
<span id="line25407" class="line"></span>        getType(){
<span id="line25408" class="line"></span>            return 'webgl';
<span id="line25409" class="line"></span>        }
<span id="line25410" class="line"></span>
<span id="line25411" class="line"></span>        /**
<span id="line25412" class="line"></span>         * Check if the drawer is using WebGL2
<span id="line25413" class="line"></span>         * @returns {Boolean} true if WebGL2 is being used, false if WebGL1
<span id="line25414" class="line"></span>         */
<span id="line25415" class="line"></span>        isWebGL2(){
<span id="line25416" class="line"></span>            return this._glContext ? this._glContext.isWebGL2() : false;
<span id="line25417" class="line"></span>        }
<span id="line25418" class="line"></span>
<span id="line25419" class="line"></span>        /**
<span id="line25420" class="line"></span>         * Enable or disable automatic WebGL context re-initialization on context loss.
<span id="line25421" class="line"></span>         * When enabled, the drawer will attempt to recover from context exhaustion errors
<span id="line25422" class="line"></span>         * by re-initializing the WebGL context.
<span id="line25423" class="line"></span>         * @param {Boolean} enabled - true to enable recovery, false to disable
<span id="line25424" class="line"></span>         */
<span id="line25425" class="line"></span>        setContextRecoveryEnabled(enabled) {
<span id="line25426" class="line"></span>            this._enableContextRecovery = !!enabled;
<span id="line25427" class="line"></span>        }
<span id="line25428" class="line"></span>
<span id="line25429" class="line"></span>        /**
<span id="line25430" class="line"></span>         * Check if context recovery is enabled
<span id="line25431" class="line"></span>         * @returns {Boolean} true if recovery is enabled, false otherwise
<span id="line25432" class="line"></span>         */
<span id="line25433" class="line"></span>        isContextRecoveryEnabled() {
<span id="line25434" class="line"></span>            return this._enableContextRecovery;
<span id="line25435" class="line"></span>        }
<span id="line25436" class="line"></span>
<span id="line25437" class="line"></span>        /**
<span id="line25438" class="line"></span>         * @param {TiledImage} tiledImage the tiled image that is calling the function
<span id="line25439" class="line"></span>         * @returns {Boolean} Whether this drawer requires enforcing minimum tile overlap to avoid showing seams.
<span id="line25440" class="line"></span>         * @private
<span id="line25441" class="line"></span>         */
<span id="line25442" class="line"></span>        minimumOverlapRequired(tiledImage) {
<span id="line25443" class="line"></span>            // return true if we cannot render with webgl, since the backup canvas drawer will be used.
<span id="line25444" class="line"></span>            return tiledImage.hasIssue('webgl');
<span id="line25445" class="line"></span>        }
<span id="line25446" class="line"></span>
<span id="line25447" class="line"></span>        /**
<span id="line25448" class="line"></span>        * create the HTML element (canvas in this case) that the image will be drawn into
<span id="line25449" class="line"></span>        * @private
<span id="line25450" class="line"></span>        * @returns {Element} the canvas to draw into
<span id="line25451" class="line"></span>        */
<span id="line25452" class="line"></span>        _createDrawingElement(){
<span id="line25453" class="line"></span>            const canvas = $.makeNeutralElement("canvas");
<span id="line25454" class="line"></span>            const viewportSize = this._calculateCanvasSize();
<span id="line25455" class="line"></span>            canvas.width = viewportSize.x;
<span id="line25456" class="line"></span>            canvas.height = viewportSize.y;
<span id="line25457" class="line"></span>            return canvas;
<span id="line25458" class="line"></span>        }
<span id="line25459" class="line"></span>
<span id="line25460" class="line"></span>        /**
<span id="line25461" class="line"></span>         * Get the backup renderer (CanvasDrawer) to use if data cannot be used by webgl
<span id="line25462" class="line"></span>         * Lazy loaded
<span id="line25463" class="line"></span>         * @private
<span id="line25464" class="line"></span>         * @returns {CanvasDrawer}
<span id="line25465" class="line"></span>         */
<span id="line25466" class="line"></span>        _getBackupCanvasDrawer(){
<span id="line25467" class="line"></span>            if(!this._backupCanvasDrawer){
<span id="line25468" class="line"></span>                this._backupCanvasDrawer = this.viewer.requestDrawer('canvas', {mainDrawer: false});
<span id="line25469" class="line"></span>                this._backupCanvasDrawer.canvas.style.setProperty('visibility', 'hidden');
<span id="line25470" class="line"></span>                this._backupCanvasDrawer.getSupportedDataFormats = () =&gt; this._supportedFormats;
<span id="line25471" class="line"></span>                this._backupCanvasDrawer.getDataToDraw = this.getDataToDraw.bind(this);
<span id="line25472" class="line"></span>            }
<span id="line25473" class="line"></span>
<span id="line25474" class="line"></span>            return this._backupCanvasDrawer;
<span id="line25475" class="line"></span>        }
<span id="line25476" class="line"></span>
<span id="line25477" class="line"></span>        //
<span id="line25478" class="line"></span>        /**
<span id="line25479" class="line"></span>         * Internal draw method, wrapped in a try/catch within draw()
<span id="line25480" class="line"></span>         * @param {Array} tiledImages Array of TiledImage objects to draw
<span id="line25481" class="line"></span>         * @param {Boolean} [isRetry=false] Internal flag to prevent infinite retry loops
<span id="line25482" class="line"></span>         * @private
<span id="line25483" class="line"></span>         */
<span id="line25484" class="line"></span>        _draw(tiledImages, isRetry = false){
<span id="line25485" class="line"></span>            const gl = this._glContext ? this._glContext.getContext() : null;
<span id="line25486" class="line"></span>            if (!gl) {
<span id="line25487" class="line"></span>                return;
<span id="line25488" class="line"></span>            }
<span id="line25489" class="line"></span>            const firstPass = this._glContext.getFirstPass();
<span id="line25490" class="line"></span>            const secondPass = this._glContext.getSecondPass();
<span id="line25491" class="line"></span>            const glFrameBuffer = this._glContext.getFrameBuffer();
<span id="line25492" class="line"></span>            const renderToTexture = this._glContext.getRenderToTexture();
<span id="line25493" class="line"></span>            const bounds = this.viewport.getBoundsNoRotateWithMargins(true);
<span id="line25494" class="line"></span>            const view = {
<span id="line25495" class="line"></span>                bounds: bounds,
<span id="line25496" class="line"></span>                center: new OpenSeadragon.Point(bounds.x + bounds.width / 2, bounds.y + bounds.height / 2),
<span id="line25497" class="line"></span>                rotation: this.viewport.getRotation(true) * Math.PI / 180
<span id="line25498" class="line"></span>            };
<span id="line25499" class="line"></span>
<span id="line25500" class="line"></span>            const flipMultiplier = this.viewport.flipped ? -1 : 1;
<span id="line25501" class="line"></span>            // calculate view matrix for viewer
<span id="line25502" class="line"></span>            const posMatrix = $.Mat3.makeTranslation(-view.center.x, -view.center.y);
<span id="line25503" class="line"></span>            const scaleMatrix = $.Mat3.makeScaling(2 / view.bounds.width * flipMultiplier, -2 / view.bounds.height);
<span id="line25504" class="line"></span>            const rotMatrix = $.Mat3.makeRotation(-view.rotation);
<span id="line25505" class="line"></span>            const viewMatrix = scaleMatrix.multiply(rotMatrix).multiply(posMatrix);
<span id="line25506" class="line"></span>
<span id="line25507" class="line"></span>            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
<span id="line25508" class="line"></span>            gl.clear(gl.COLOR_BUFFER_BIT); // clear the back buffer
<span id="line25509" class="line"></span>
<span id="line25510" class="line"></span>            // clear the output canvas
<span id="line25511" class="line"></span>            this._outputContext.clearRect(0, 0, this._outputCanvas.width, this._outputCanvas.height);
<span id="line25512" class="line"></span>
<span id="line25513" class="line"></span>
<span id="line25514" class="line"></span>            let renderingBufferHasImageData = false;
<span id="line25515" class="line"></span>
<span id="line25516" class="line"></span>            //iterate over tiled images and draw each one using a two-pass rendering pipeline if needed
<span id="line25517" class="line"></span>            tiledImages.forEach( (tiledImage, tiledImageIndex) =&gt; {
<span id="line25518" class="line"></span>
<span id="line25519" class="line"></span>            if(tiledImage.getIssue('webgl')){
<span id="line25520" class="line"></span>                // first, draw any data left in the rendering buffer onto the output canvas
<span id="line25521" class="line"></span>                if(renderingBufferHasImageData){
<span id="line25522" class="line"></span>                    this._outputContext.drawImage(this._renderingCanvas, 0, 0);
<span id="line25523" class="line"></span>                    // clear the buffer
<span id="line25524" class="line"></span>                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
<span id="line25525" class="line"></span>                    gl.clear(gl.COLOR_BUFFER_BIT); // clear the back buffer
<span id="line25526" class="line"></span>                    renderingBufferHasImageData = false;
<span id="line25527" class="line"></span>                }
<span id="line25528" class="line"></span>
<span id="line25529" class="line"></span>                // next, use the backup canvas drawer to draw the tiled image (if allowed)
<span id="line25530" class="line"></span>                if(this._canvasFallbackAllowed){
<span id="line25531" class="line"></span>                    const canvasDrawer = this._getBackupCanvasDrawer();
<span id="line25532" class="line"></span>                    canvasDrawer.draw([tiledImage]);
<span id="line25533" class="line"></span>                    this._outputContext.drawImage(canvasDrawer.canvas, 0, 0);
<span id="line25534" class="line"></span>                }
<span id="line25535" class="line"></span>
<span id="line25536" class="line"></span>            } else {
<span id="line25537" class="line"></span>                const tilesToDraw = tiledImage.getTilesToDraw();
<span id="line25538" class="line"></span>
<span id="line25539" class="line"></span>                if ( tiledImage.placeholderFillStyle &amp;&amp; tiledImage._hasOpaqueTile === false ) {
<span id="line25540" class="line"></span>                    this._drawPlaceholder(tiledImage);
<span id="line25541" class="line"></span>                }
<span id="line25542" class="line"></span>
<span id="line25543" class="line"></span>                if(tilesToDraw.length === 0 || tiledImage.getOpacity() === 0){
<span id="line25544" class="line"></span>                    return;
<span id="line25545" class="line"></span>                }
<span id="line25546" class="line"></span>                const firstTile = tilesToDraw[0];
<span id="line25547" class="line"></span>
<span id="line25548" class="line"></span>                const useContext2dPipeline = ( tiledImage.compositeOperation ||
<span id="line25549" class="line"></span>                    this.viewer.compositeOperation ||
<span id="line25550" class="line"></span>                    tiledImage._clip ||
<span id="line25551" class="line"></span>                    tiledImage._croppingPolygons ||
<span id="line25552" class="line"></span>                    tiledImage.debugMode
<span id="line25553" class="line"></span>                );
<span id="line25554" class="line"></span>
<span id="line25555" class="line"></span>                const useTwoPassRendering = useContext2dPipeline || (tiledImage.opacity &lt; 1) || firstTile.tile.hasTransparency;
<span id="line25556" class="line"></span>
<span id="line25557" class="line"></span>                // using the context2d pipeline requires a clean rendering (back) buffer to start
<span id="line25558" class="line"></span>                if(useContext2dPipeline){
<span id="line25559" class="line"></span>                    // if the rendering buffer has image data currently, write it to the output canvas now and clear it
<span id="line25560" class="line"></span>
<span id="line25561" class="line"></span>                    if(renderingBufferHasImageData){
<span id="line25562" class="line"></span>                        this._outputContext.drawImage(this._renderingCanvas, 0, 0);
<span id="line25563" class="line"></span>                    }
<span id="line25564" class="line"></span>
<span id="line25565" class="line"></span>                    // clear the buffer
<span id="line25566" class="line"></span>                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
<span id="line25567" class="line"></span>                    gl.clear(gl.COLOR_BUFFER_BIT); // clear the back buffer
<span id="line25568" class="line"></span>                }
<span id="line25569" class="line"></span>
<span id="line25570" class="line"></span>                // First rendering pass: compose tiles that make up this tiledImage
<span id="line25571" class="line"></span>                gl.useProgram(firstPass.shaderProgram);
<span id="line25572" class="line"></span>
<span id="line25573" class="line"></span>                // bind to the framebuffer for render-to-texture if using two-pass rendering, otherwise back buffer (null)
<span id="line25574" class="line"></span>                if(useTwoPassRendering){
<span id="line25575" class="line"></span>                    gl.bindFramebuffer(gl.FRAMEBUFFER, glFrameBuffer);
<span id="line25576" class="line"></span>                    // clear the buffer to draw a new image
<span id="line25577" class="line"></span>                    gl.clear(gl.COLOR_BUFFER_BIT);
<span id="line25578" class="line"></span>                } else {
<span id="line25579" class="line"></span>                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
<span id="line25580" class="line"></span>                    // no need to clear, just draw on top of the existing pixels
<span id="line25581" class="line"></span>                }
<span id="line25582" class="line"></span>
<span id="line25583" class="line"></span>                let overallMatrix = viewMatrix;
<span id="line25584" class="line"></span>
<span id="line25585" class="line"></span>                const imageRotation = tiledImage.getRotation(true);
<span id="line25586" class="line"></span>                // if needed, handle the tiledImage being rotated
<span id="line25587" class="line"></span>                if( imageRotation % 360 !== 0){
<span id="line25588" class="line"></span>                    const imageRotationMatrix = $.Mat3.makeRotation(-imageRotation * Math.PI / 180);
<span id="line25589" class="line"></span>                    const imageCenter = tiledImage.getBoundsNoRotate(true).getCenter();
<span id="line25590" class="line"></span>                    const t1 = $.Mat3.makeTranslation(imageCenter.x, imageCenter.y);
<span id="line25591" class="line"></span>                    const t2 = $.Mat3.makeTranslation(-imageCenter.x, -imageCenter.y);
<span id="line25592" class="line"></span>
<span id="line25593" class="line"></span>                    // update the view matrix to account for this image's rotation
<span id="line25594" class="line"></span>                    const localMatrix = t1.multiply(imageRotationMatrix).multiply(t2);
<span id="line25595" class="line"></span>                    overallMatrix = viewMatrix.multiply(localMatrix);
<span id="line25596" class="line"></span>                }
<span id="line25597" class="line"></span>
<span id="line25598" class="line"></span>                // Check MAX_TEXTURE_IMAGE_UNITS - throw error if invalid (will be caught by outer try-catch)
<span id="line25599" class="line"></span>                const maxTextures = this._glContext.getMaxTextures();
<span id="line25600" class="line"></span>                if(maxTextures &lt;= 0 || maxTextures === null || maxTextures === undefined){
<span id="line25601" class="line"></span>                    // This can apparently happen on some systems if too many WebGL contexts have been created
<span id="line25602" class="line"></span>                    // in which case maxTextures can be null, leading to out of bounds errors with the array.
<span id="line25603" class="line"></span>                    // For example, when viewers were created and not destroyed in the test suite, this error
<span id="line25604" class="line"></span>                    // occurred in the TravisCI tests, though it did not happen when testing locally either in
<span id="line25605" class="line"></span>                    // a browser or on the command line via grunt test.
<span id="line25606" class="line"></span>
<span id="line25607" class="line"></span>                    throw new Error(`WebGL error: bad value for gl parameter MAX_TEXTURE_IMAGE_UNITS (${maxTextures}). This could happen
<span id="line25608" class="line"></span>                    if too many contexts have been created and not released, or there is another problem with the graphics card.`);
<span id="line25609" class="line"></span>                }
<span id="line25610" class="line"></span>
<span id="line25611" class="line"></span>                const texturePositionArray = new Float32Array(maxTextures * 12); // 6 vertices (2 triangles) x 2 coordinates per vertex
<span id="line25612" class="line"></span>                const textureDataArray = new Array(maxTextures);
<span id="line25613" class="line"></span>                const matrixArray = new Array(maxTextures);
<span id="line25614" class="line"></span>                const opacityArray = new Array(maxTextures);
<span id="line25615" class="line"></span>
<span id="line25616" class="line"></span>                // iterate over tiles and add data for each one to the buffers
<span id="line25617" class="line"></span>                for(let tileIndex = 0; tileIndex &lt; tilesToDraw.length; tileIndex++){
<span id="line25618" class="line"></span>                    const tile = tilesToDraw[tileIndex].tile;
<span id="line25619" class="line"></span>                    const indexInDrawArray = tileIndex % maxTextures;
<span id="line25620" class="line"></span>                    const numTilesToDraw =  indexInDrawArray + 1;
<span id="line25621" class="line"></span>                    const textureInfo = this.getDataToDraw(tile);
<span id="line25622" class="line"></span>
<span id="line25623" class="line"></span>                    if (textureInfo &amp;&amp; textureInfo.texture) {
<span id="line25624" class="line"></span>                        this._getTileData(tile, tiledImage, textureInfo, overallMatrix, indexInDrawArray, texturePositionArray, textureDataArray, matrixArray, opacityArray);
<span id="line25625" class="line"></span>                    }
<span id="line25626" class="line"></span>                    // else {
<span id="line25627" class="line"></span>                    //   If the texture info is not available, we cannot draw this tile. This is either because
<span id="line25628" class="line"></span>                    //   the tile data is still being processed, or the data was not correct - in that case,
<span id="line25629" class="line"></span>                    //   internalCacheCreate(..) already logged an error.
<span id="line25630" class="line"></span>                    // }
<span id="line25631" class="line"></span>
<span id="line25632" class="line"></span>                    if( (numTilesToDraw === maxTextures) || (tileIndex === tilesToDraw.length - 1)){
<span id="line25633" class="line"></span>                        // We've filled up the buffers: time to draw this set of tiles
<span id="line25634" class="line"></span>
<span id="line25635" class="line"></span>                        // bind each tile's texture to the appropriate gl.TEXTURE#
<span id="line25636" class="line"></span>                        for(let i = 0; i &lt; numTilesToDraw; i++){
<span id="line25637" class="line"></span>                            gl.activeTexture(gl.TEXTURE0 + i);
<span id="line25638" class="line"></span>                            gl.bindTexture(gl.TEXTURE_2D, textureDataArray[i]);
<span id="line25639" class="line"></span>                        }
<span id="line25640" class="line"></span>
<span id="line25641" class="line"></span>                        // set the buffer data for the texture coordinates to use for each tile
<span id="line25642" class="line"></span>                        gl.bindBuffer(gl.ARRAY_BUFFER, firstPass.bufferTexturePosition);
<span id="line25643" class="line"></span>                        gl.bufferData(gl.ARRAY_BUFFER, texturePositionArray, gl.DYNAMIC_DRAW);
<span id="line25644" class="line"></span>
<span id="line25645" class="line"></span>                        // set the transform matrix uniform for each tile
<span id="line25646" class="line"></span>                        matrixArray.forEach( (matrix, index) =&gt; {
<span id="line25647" class="line"></span>                            gl.uniformMatrix3fv(firstPass.uTransformMatrices[index], false, matrix);
<span id="line25648" class="line"></span>                        });
<span id="line25649" class="line"></span>                        // set the opacity uniform for each tile
<span id="line25650" class="line"></span>                        gl.uniform1fv(firstPass.uOpacities, new Float32Array(opacityArray));
<span id="line25651" class="line"></span>
<span id="line25652" class="line"></span>                        // bind vertex buffers and (re)set attributes before calling gl.drawArrays()
<span id="line25653" class="line"></span>                        gl.bindBuffer(gl.ARRAY_BUFFER, firstPass.bufferOutputPosition);
<span id="line25654" class="line"></span>                        gl.vertexAttribPointer(firstPass.aOutputPosition, 2, gl.FLOAT, false, 0, 0);
<span id="line25655" class="line"></span>
<span id="line25656" class="line"></span>                        gl.bindBuffer(gl.ARRAY_BUFFER, firstPass.bufferTexturePosition);
<span id="line25657" class="line"></span>                        gl.vertexAttribPointer(firstPass.aTexturePosition, 2, gl.FLOAT, false, 0, 0);
<span id="line25658" class="line"></span>
<span id="line25659" class="line"></span>                        gl.bindBuffer(gl.ARRAY_BUFFER, firstPass.bufferIndex);
<span id="line25660" class="line"></span>                        gl.vertexAttribPointer(firstPass.aIndex, 1, gl.FLOAT, false, 0, 0);
<span id="line25661" class="line"></span>
<span id="line25662" class="line"></span>                        // Draw! 6 vertices per tile (2 triangles per rectangle)
<span id="line25663" class="line"></span>                        gl.drawArrays(gl.TRIANGLES, 0, 6 * numTilesToDraw );
<span id="line25664" class="line"></span>                    }
<span id="line25665" class="line"></span>                }
<span id="line25666" class="line"></span>
<span id="line25667" class="line"></span>                if(useTwoPassRendering){
<span id="line25668" class="line"></span>                    // Second rendering pass: Render the tiled image from the framebuffer into the back buffer
<span id="line25669" class="line"></span>                    gl.useProgram(secondPass.shaderProgram);
<span id="line25670" class="line"></span>
<span id="line25671" class="line"></span>                    // set the rendering target to the back buffer (null)
<span id="line25672" class="line"></span>                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
<span id="line25673" class="line"></span>
<span id="line25674" class="line"></span>                    // bind the rendered texture from the first pass to use during this second pass
<span id="line25675" class="line"></span>                    gl.activeTexture(gl.TEXTURE0);
<span id="line25676" class="line"></span>                    gl.bindTexture(gl.TEXTURE_2D, renderToTexture);
<span id="line25677" class="line"></span>
<span id="line25678" class="line"></span>                    // set opacity to the value for the current tiledImage
<span id="line25679" class="line"></span>                    gl.uniform1f(secondPass.uOpacityMultiplier, tiledImage.opacity);
<span id="line25680" class="line"></span>
<span id="line25681" class="line"></span>                    // bind buffers and set attributes before calling gl.drawArrays
<span id="line25682" class="line"></span>                    gl.bindBuffer(gl.ARRAY_BUFFER, secondPass.bufferTexturePosition);
<span id="line25683" class="line"></span>                    gl.vertexAttribPointer(secondPass.aTexturePosition, 2, gl.FLOAT, false, 0, 0);
<span id="line25684" class="line"></span>                    gl.bindBuffer(gl.ARRAY_BUFFER, secondPass.bufferOutputPosition);
<span id="line25685" class="line"></span>                    gl.vertexAttribPointer(secondPass.aOutputPosition, 2, gl.FLOAT, false, 0, 0);
<span id="line25686" class="line"></span>
<span id="line25687" class="line"></span>                    // Draw the quad (two triangles)
<span id="line25688" class="line"></span>                    gl.drawArrays(gl.TRIANGLES, 0, 6);
<span id="line25689" class="line"></span>
<span id="line25690" class="line"></span>                }
<span id="line25691" class="line"></span>
<span id="line25692" class="line"></span>                renderingBufferHasImageData = true;
<span id="line25693" class="line"></span>
<span id="line25694" class="line"></span>                if(useContext2dPipeline){
<span id="line25695" class="line"></span>                    // draw from the rendering canvas onto the output canvas, clipping/cropping if needed.
<span id="line25696" class="line"></span>                    this._applyContext2dPipeline(tiledImage, tilesToDraw, tiledImageIndex);
<span id="line25697" class="line"></span>                    renderingBufferHasImageData = false;
<span id="line25698" class="line"></span>                    // clear the buffer
<span id="line25699" class="line"></span>                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
<span id="line25700" class="line"></span>                    gl.clear(gl.COLOR_BUFFER_BIT); // clear the back buffer
<span id="line25701" class="line"></span>                }
<span id="line25702" class="line"></span>
<span id="line25703" class="line"></span>                // after drawing the first TiledImage, fire the tiled-image-drawn event (for testing)
<span id="line25704" class="line"></span>                if(tiledImageIndex === 0){
<span id="line25705" class="line"></span>                    this._raiseTiledImageDrawnEvent(tiledImage, tilesToDraw.map(info=&gt;info.tile));
<span id="line25706" class="line"></span>                }
<span id="line25707" class="line"></span>            }
<span id="line25708" class="line"></span>
<span id="line25709" class="line"></span>            });
<span id="line25710" class="line"></span>
<span id="line25711" class="line"></span>            if(renderingBufferHasImageData){
<span id="line25712" class="line"></span>                this._outputContext.drawImage(this._renderingCanvas, 0, 0);
<span id="line25713" class="line"></span>            }
<span id="line25714" class="line"></span>        }
<span id="line25715" class="line"></span>        /**
<span id="line25716" class="line"></span>        *
<span id="line25717" class="line"></span>        * @param {Array} tiledImages Array of TiledImage objects to draw
<span id="line25718" class="line"></span>        * @param {Boolean} [isRetry=false] Internal flag to prevent infinite retry loops
<span id="line25719" class="line"></span>        */
<span id="line25720" class="line"></span>        draw(tiledImages, isRetry = false){
<span id="line25721" class="line"></span>            try {
<span id="line25722" class="line"></span>                this._draw(tiledImages, isRetry);
<span id="line25723" class="line"></span>            } catch (error) {
<span id="line25724" class="line"></span>                // Handle WebGL context errors that occur at any point during the draw operation
<span id="line25725" class="line"></span>                if (this._isWebGLContextError(error)) {
<span id="line25726" class="line"></span>                    // Try recovery if enabled and not a retry
<span id="line25727" class="line"></span>                    if (this._enableContextRecovery &amp;&amp; !isRetry) {
<span id="line25728" class="line"></span>                        $.console.warn('WebGL context error detected during draw operation, attempting to recreate context...', error);
<span id="line25729" class="line"></span>                        const recreatedDrawer = this._recreateContext();
<span id="line25730" class="line"></span>                        if (recreatedDrawer) {
<span id="line25731" class="line"></span>                            $.console.info('WebGL context recreated successfully, retrying draw operation');
<span id="line25732" class="line"></span>                            // Raise event for successful recovery
<span id="line25733" class="line"></span>                            if (this.viewer) {
<span id="line25734" class="line"></span>                                /**
<span id="line25735" class="line"></span>                                 * Raised when the WebGL drawer successfully recovers from a context loss.
<span id="line25736" class="line"></span>                                 *
<span id="line25737" class="line"></span>                                 * @event webgl-context-recovered
<span id="line25738" class="line"></span>                                 * @memberof OpenSeadragon.Viewer
<span id="line25739" class="line"></span>                                 * @type {object}
<span id="line25740" class="line"></span>                                 * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line25741" class="line"></span>                                 * @property {OpenSeadragon.WebGLDrawer} drawer - The drawer instance (same instance, context recreated).
<span id="line25742" class="line"></span>                                 * @property {Error} error - The original error that triggered the recovery.
<span id="line25743" class="line"></span>                                 * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line25744" class="line"></span>                                 */
<span id="line25745" class="line"></span>                                this.viewer.raiseEvent('webgl-context-recovered', {
<span id="line25746" class="line"></span>                                    drawer: this,
<span id="line25747" class="line"></span>                                    error: error
<span id="line25748" class="line"></span>                                });
<span id="line25749" class="line"></span>                            }
<span id="line25750" class="line"></span>                            // Retry draw on same instance
<span id="line25751" class="line"></span>                            this.draw(tiledImages, true);
<span id="line25752" class="line"></span>                        } else {
<span id="line25753" class="line"></span>                            // Recovery attempted but failed - fall back to canvas drawer (if allowed)
<span id="line25754" class="line"></span>                            this._fallbackToCanvasDrawer(error, tiledImages);
<span id="line25755" class="line"></span>                        }
<span id="line25756" class="line"></span>                    } else {
<span id="line25757" class="line"></span>                        // Recovery disabled or retry - fall back only when recovery was enabled (retry case)
<span id="line25758" class="line"></span>                        if (this._enableContextRecovery) {
<span id="line25759" class="line"></span>                            this._fallbackToCanvasDrawer(error, tiledImages); // will only happen if canvas fallback is allowed
<span id="line25760" class="line"></span>                        } else {
<span id="line25761" class="line"></span>                            throw error;
<span id="line25762" class="line"></span>                        }
<span id="line25763" class="line"></span>                    }
<span id="line25764" class="line"></span>                } else {
<span id="line25765" class="line"></span>                    // Not a WebGL context error - re-throw
<span id="line25766" class="line"></span>                    throw error;
<span id="line25767" class="line"></span>                }
<span id="line25768" class="line"></span>            }
<span id="line25769" class="line"></span>        }
<span id="line25770" class="line"></span>
<span id="line25771" class="line"></span>        // Public API required by all Drawer implementations
<span id="line25772" class="line"></span>        /**
<span id="line25773" class="line"></span>        * Sets whether image smoothing is enabled or disabled
<span id="line25774" class="line"></span>        * @param {Boolean} enabled If true, uses gl.LINEAR as the TEXTURE_MIN_FILTER and TEXTURE_MAX_FILTER, otherwise gl.NEAREST.
<span id="line25775" class="line"></span>        */
<span id="line25776" class="line"></span>        setImageSmoothingEnabled(enabled){
<span id="line25777" class="line"></span>            if( this._imageSmoothingEnabled !== enabled ){
<span id="line25778" class="line"></span>                this._imageSmoothingEnabled = enabled;
<span id="line25779" class="line"></span>                if (this._glContext) {
<span id="line25780" class="line"></span>                    this._glContext.setImageSmoothingEnabled(enabled);
<span id="line25781" class="line"></span>                }
<span id="line25782" class="line"></span>                this.setInternalCacheNeedsRefresh();
<span id="line25783" class="line"></span>                this.viewer.forceRedraw();
<span id="line25784" class="line"></span>            }
<span id="line25785" class="line"></span>        }
<span id="line25786" class="line"></span>
<span id="line25787" class="line"></span>        /**
<span id="line25788" class="line"></span>        * Sets whether textures are unpacked with premultiplied alpha
<span id="line25789" class="line"></span>        * @param {Boolean} enabled If true, sets gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL to true.
<span id="line25790" class="line"></span>        */
<span id="line25791" class="line"></span>        setUnpackWithPremultipliedAlpha(enabled){
<span id="line25792" class="line"></span>            if (this._unpackWithPremultipliedAlpha !== enabled){
<span id="line25793" class="line"></span>                this._unpackWithPremultipliedAlpha = enabled;
<span id="line25794" class="line"></span>                if (this._glContext) {
<span id="line25795" class="line"></span>                    this._glContext.setUnpackWithPremultipliedAlpha(enabled);
<span id="line25796" class="line"></span>                }
<span id="line25797" class="line"></span>                this.setInternalCacheNeedsRefresh();
<span id="line25798" class="line"></span>                this.viewer.forceRedraw();
<span id="line25799" class="line"></span>            }
<span id="line25800" class="line"></span>        }
<span id="line25801" class="line"></span>
<span id="line25802" class="line"></span>        /**
<span id="line25803" class="line"></span>        * Draw a rect onto the output canvas for debugging purposes
<span id="line25804" class="line"></span>        * @param {OpenSeadragon.Rect} rect
<span id="line25805" class="line"></span>        */
<span id="line25806" class="line"></span>        drawDebuggingRect(rect){
<span id="line25807" class="line"></span>            const context = this._outputContext;
<span id="line25808" class="line"></span>            context.save();
<span id="line25809" class="line"></span>            context.lineWidth = 2 * $.pixelDensityRatio;
<span id="line25810" class="line"></span>            context.strokeStyle = this.debugGridColor[0];
<span id="line25811" class="line"></span>            context.fillStyle = this.debugGridColor[0];
<span id="line25812" class="line"></span>
<span id="line25813" class="line"></span>            context.strokeRect(
<span id="line25814" class="line"></span>                rect.x * $.pixelDensityRatio,
<span id="line25815" class="line"></span>                rect.y * $.pixelDensityRatio,
<span id="line25816" class="line"></span>                rect.width * $.pixelDensityRatio,
<span id="line25817" class="line"></span>                rect.height * $.pixelDensityRatio
<span id="line25818" class="line"></span>            );
<span id="line25819" class="line"></span>
<span id="line25820" class="line"></span>            context.restore();
<span id="line25821" class="line"></span>        }
<span id="line25822" class="line"></span>
<span id="line25823" class="line"></span>        /**
<span id="line25824" class="line"></span>        * Draw data from the rendering canvas onto the output canvas, with clipping,
<span id="line25825" class="line"></span>        * cropping and/or debug info as requested.
<span id="line25826" class="line"></span>        * @private
<span id="line25827" class="line"></span>        * @param {OpenSeadragon.TiledImage} tiledImage - the tiledImage to draw
<span id="line25828" class="line"></span>        * @param {Array} tilesToDraw - array of objects containing tiles that were drawn
<span id="line25829" class="line"></span>        */
<span id="line25830" class="line"></span>        _applyContext2dPipeline(tiledImage, tilesToDraw, tiledImageIndex){
<span id="line25831" class="line"></span>            // composite onto the output canvas, clipping if necessary
<span id="line25832" class="line"></span>            this._outputContext.save();
<span id="line25833" class="line"></span>
<span id="line25834" class="line"></span>            // set composite operation; ignore for first image drawn
<span id="line25835" class="line"></span>            this._outputContext.globalCompositeOperation = tiledImageIndex === 0 ? null : tiledImage.compositeOperation || this.viewer.compositeOperation;
<span id="line25836" class="line"></span>            if(tiledImage._croppingPolygons || tiledImage._clip){
<span id="line25837" class="line"></span>                this._renderToClippingCanvas(tiledImage);
<span id="line25838" class="line"></span>                this._outputContext.drawImage(this._clippingCanvas, 0, 0);
<span id="line25839" class="line"></span>
<span id="line25840" class="line"></span>            } else {
<span id="line25841" class="line"></span>                this._outputContext.drawImage(this._renderingCanvas, 0, 0);
<span id="line25842" class="line"></span>            }
<span id="line25843" class="line"></span>            this._outputContext.restore();
<span id="line25844" class="line"></span>            if(tiledImage.debugMode){
<span id="line25845" class="line"></span>                const flipped = this.viewer.viewport.getFlip();
<span id="line25846" class="line"></span>                if(flipped){
<span id="line25847" class="line"></span>                    this._flip();
<span id="line25848" class="line"></span>                }
<span id="line25849" class="line"></span>                this._drawDebugInfo(tilesToDraw, tiledImage, flipped);
<span id="line25850" class="line"></span>                if(flipped){
<span id="line25851" class="line"></span>                    this._flip();
<span id="line25852" class="line"></span>                }
<span id="line25853" class="line"></span>            }
<span id="line25854" class="line"></span>
<span id="line25855" class="line"></span>
<span id="line25856" class="line"></span>        }
<span id="line25857" class="line"></span>
<span id="line25858" class="line"></span>        // private
<span id="line25859" class="line"></span>        _getTileData(tile, tiledImage, textureInfo, viewMatrix, index, texturePositionArray, textureDataArray, matrixArray, opacityArray){
<span id="line25860" class="line"></span>
<span id="line25861" class="line"></span>            const texture = textureInfo.texture;
<span id="line25862" class="line"></span>            const textureQuad = textureInfo.position;
<span id="line25863" class="line"></span>            const overlapFraction = textureInfo.overlapFraction;
<span id="line25864" class="line"></span>
<span id="line25865" class="line"></span>            // set the position of this texture
<span id="line25866" class="line"></span>            texturePositionArray.set(textureQuad, index * 12);
<span id="line25867" class="line"></span>
<span id="line25868" class="line"></span>            // compute offsets that account for tile overlap; needed for calculating the transform matrix appropriately
<span id="line25869" class="line"></span>            const xOffset = tile.positionedBounds.width * overlapFraction.x;
<span id="line25870" class="line"></span>            const yOffset = tile.positionedBounds.height * overlapFraction.y;
<span id="line25871" class="line"></span>            const x = tile.positionedBounds.x + (tile.x === 0 ? 0 : xOffset);
<span id="line25872" class="line"></span>            const y = tile.positionedBounds.y + (tile.y === 0 ? 0 : yOffset);
<span id="line25873" class="line"></span>            const right = tile.positionedBounds.x + tile.positionedBounds.width - (tile.isRightMost ? 0 : xOffset);
<span id="line25874" class="line"></span>            const bottom = tile.positionedBounds.y + tile.positionedBounds.height - (tile.isBottomMost ? 0 : yOffset);
<span id="line25875" class="line"></span>
<span id="line25876" class="line"></span>            const model = new $.Mat3([
<span id="line25877" class="line"></span>                right - x, 0, 0, // right - x = width
<span id="line25878" class="line"></span>                0, bottom - y, 0, // bottom - y = height
<span id="line25879" class="line"></span>                x, y, 1
<span id="line25880" class="line"></span>            ]);
<span id="line25881" class="line"></span>
<span id="line25882" class="line"></span>            if (tile.flipped) {
<span id="line25883" class="line"></span>                // For documentation:
<span id="line25884" class="line"></span>                // // flip the tile around the center of the unit quad
<span id="line25885" class="line"></span>                // let t1 = $.Mat3.makeTranslation(0.5, 0);
<span id="line25886" class="line"></span>                // let t2 = $.Mat3.makeTranslation(-0.5, 0);
<span id="line25887" class="line"></span>                //
<span id="line25888" class="line"></span>                // // update the view matrix to account for this image's rotation
<span id="line25889" class="line"></span>                // let localMatrix = t1.multiply($.Mat3.makeScaling(-1, 1)).multiply(t2);
<span id="line25890" class="line"></span>                // matrix = matrix.multiply(localMatrix);
<span id="line25891" class="line"></span>
<span id="line25892" class="line"></span>                //Optimized: this works since matrix only contains main diagonal values &amp; translation
<span id="line25893" class="line"></span>                model.scaleAndTranslateSelf(-1, 1, 1, 0);
<span id="line25894" class="line"></span>            }
<span id="line25895" class="line"></span>
<span id="line25896" class="line"></span>            model.scaleAndTranslateOtherSetSelf(viewMatrix);
<span id="line25897" class="line"></span>            opacityArray[index] = tile.opacity;
<span id="line25898" class="line"></span>            textureDataArray[index] = texture;
<span id="line25899" class="line"></span>            matrixArray[index] = model.values;
<span id="line25900" class="line"></span>        }
<span id="line25901" class="line"></span>
<span id="line25902" class="line"></span>
<span id="line25903" class="line"></span>        // private
<span id="line25904" class="line"></span>        _setupRenderer(){
<span id="line25905" class="line"></span>            if(!this._glContext || !this._glContext.getContext()){
<span id="line25906" class="line"></span>                $.console.error('_setupCanvases must be called before _setupRenderer');
<span id="line25907" class="line"></span>                return;
<span id="line25908" class="line"></span>            }
<span id="line25909" class="line"></span>            this._glContext.setupRenderer(this._renderingCanvas.width, this._renderingCanvas.height);
<span id="line25910" class="line"></span>        }
<span id="line25911" class="line"></span>
<span id="line25912" class="line"></span>
<span id="line25913" class="line"></span>        // private
<span id="line25914" class="line"></span>        _resizeRenderer(){
<span id="line25915" class="line"></span>            if(!this._glContext){
<span id="line25916" class="line"></span>                return;
<span id="line25917" class="line"></span>            }
<span id="line25918" class="line"></span>            this._glContext.resizeRenderer(this._renderingCanvas.width, this._renderingCanvas.height);
<span id="line25919" class="line"></span>        }
<span id="line25920" class="line"></span>
<span id="line25921" class="line"></span>        // private
<span id="line25922" class="line"></span>        _setupCanvases(){
<span id="line25923" class="line"></span>            const _this = this;
<span id="line25924" class="line"></span>
<span id="line25925" class="line"></span>            this._outputCanvas = this.canvas; //output canvas
<span id="line25926" class="line"></span>            this._outputContext = this._outputCanvas.getContext('2d');
<span id="line25927" class="line"></span>
<span id="line25928" class="line"></span>            this._renderingCanvas = document.createElement('canvas');
<span id="line25929" class="line"></span>
<span id="line25930" class="line"></span>            this._clippingCanvas = document.createElement('canvas');
<span id="line25931" class="line"></span>            this._clippingContext = this._clippingCanvas.getContext('2d');
<span id="line25932" class="line"></span>            this._renderingCanvas.width = this._clippingCanvas.width = this._outputCanvas.width;
<span id="line25933" class="line"></span>            this._renderingCanvas.height = this._clippingCanvas.height = this._outputCanvas.height;
<span id="line25934" class="line"></span>
<span id="line25935" class="line"></span>            // Create WebGL context manager
<span id="line25936" class="line"></span>            this._glContext = new WebglContextManager({
<span id="line25937" class="line"></span>                renderingCanvas: this._renderingCanvas,
<span id="line25938" class="line"></span>                unpackWithPremultipliedAlpha: this._unpackWithPremultipliedAlpha,
<span id="line25939" class="line"></span>                imageSmoothingEnabled: this._imageSmoothingEnabled,
<span id="line25940" class="line"></span>                initShaderProgram: this.constructor.initShaderProgram
<span id="line25941" class="line"></span>            });
<span id="line25942" class="line"></span>
<span id="line25943" class="line"></span>            this._resizeHandler = function(){
<span id="line25944" class="line"></span>
<span id="line25945" class="line"></span>                if(_this._outputCanvas !== _this.viewer.drawer.canvas){
<span id="line25946" class="line"></span>                    _this._outputCanvas.style.width = _this.viewer.drawer.canvas.clientWidth + 'px';
<span id="line25947" class="line"></span>                    _this._outputCanvas.style.height = _this.viewer.drawer.canvas.clientHeight + 'px';
<span id="line25948" class="line"></span>                }
<span id="line25949" class="line"></span>
<span id="line25950" class="line"></span>                const viewportSize = _this._calculateCanvasSize();
<span id="line25951" class="line"></span>                if( _this._outputCanvas.width !== viewportSize.x ||
<span id="line25952" class="line"></span>                    _this._outputCanvas.height !== viewportSize.y ) {
<span id="line25953" class="line"></span>                    _this._outputCanvas.width = viewportSize.x;
<span id="line25954" class="line"></span>                    _this._outputCanvas.height = viewportSize.y;
<span id="line25955" class="line"></span>                }
<span id="line25956" class="line"></span>
<span id="line25957" class="line"></span>                _this._renderingCanvas.style.width = _this._outputCanvas.clientWidth + 'px';
<span id="line25958" class="line"></span>                _this._renderingCanvas.style.height = _this._outputCanvas.clientHeight + 'px';
<span id="line25959" class="line"></span>                _this._renderingCanvas.width = _this._clippingCanvas.width = _this._outputCanvas.width;
<span id="line25960" class="line"></span>                _this._renderingCanvas.height = _this._clippingCanvas.height = _this._outputCanvas.height;
<span id="line25961" class="line"></span>
<span id="line25962" class="line"></span>                // important - update the size of the rendering viewport!
<span id="line25963" class="line"></span>                _this._resizeRenderer();
<span id="line25964" class="line"></span>            };
<span id="line25965" class="line"></span>
<span id="line25966" class="line"></span>            //make the additional canvas elements mirror size changes to the output canvas
<span id="line25967" class="line"></span>            this.viewer.addHandler("resize", this._resizeHandler);
<span id="line25968" class="line"></span>        }
<span id="line25969" class="line"></span>
<span id="line25970" class="line"></span>
<span id="line25971" class="line"></span>        /**
<span id="line25972" class="line"></span>         * Check if an error is related to WebGL context issues.
<span id="line25973" class="line"></span>         * @param {Error} error - The error to check
<span id="line25974" class="line"></span>         * @returns {Boolean} true if the error is a WebGL context error, false otherwise
<span id="line25975" class="line"></span>         * @private
<span id="line25976" class="line"></span>         */
<span id="line25977" class="line"></span>        _isWebGLContextError(error) {
<span id="line25978" class="line"></span>            if (!error || !error.message) {
<span id="line25979" class="line"></span>                return false;
<span id="line25980" class="line"></span>            }
<span id="line25981" class="line"></span>            const message = error.message.toLowerCase();
<span id="line25982" class="line"></span>            return message.includes('max_texture_image_units') ||
<span id="line25983" class="line"></span>                   (message.includes('webgl') &amp;&amp; ((message.includes('context') || message.includes('lost') || message.includes('invalid'))));
<span id="line25984" class="line"></span>        }
<span id="line25985" class="line"></span>
<span id="line25986" class="line"></span>        /**
<span id="line25987" class="line"></span>         * Recreate the WebGL context when it has been lost or exhausted.
<span id="line25988" class="line"></span>         * This method recreates only the WebglContextManager, preserving the drawer instance
<span id="line25989" class="line"></span>         * and all drawer state (canvases, options, cache, etc.).
<span id="line25990" class="line"></span>         * @returns {OpenSeadragon.WebGLDrawer|null} The same drawer instance if successful, null otherwise
<span id="line25991" class="line"></span>         * @private
<span id="line25992" class="line"></span>         */
<span id="line25993" class="line"></span>        _recreateContext() {
<span id="line25994" class="line"></span>            if (this._destroyed) {
<span id="line25995" class="line"></span>                return null;
<span id="line25996" class="line"></span>            }
<span id="line25997" class="line"></span>
<span id="line25998" class="line"></span>            try {
<span id="line25999" class="line"></span>                // Store old canvas properties
<span id="line26000" class="line"></span>                const oldCanvas = this._renderingCanvas;
<span id="line26001" class="line"></span>                const oldWidth = oldCanvas.width;
<span id="line26002" class="line"></span>                const oldHeight = oldCanvas.height;
<span id="line26003" class="line"></span>                const oldStyleWidth = oldCanvas.style.width;
<span id="line26004" class="line"></span>                const oldStyleHeight = oldCanvas.style.height;
<span id="line26005" class="line"></span>
<span id="line26006" class="line"></span>                // Destroy internal cache FIRST (while old context still exists)
<span id="line26007" class="line"></span>                // This ensures textures are freed using the old context before it's destroyed
<span id="line26008" class="line"></span>                this.destroyInternalCache();
<span id="line26009" class="line"></span>
<span id="line26010" class="line"></span>                // Destroy old context manager
<span id="line26011" class="line"></span>                if (this._glContext) {
<span id="line26012" class="line"></span>                    this._glContext.destroy();
<span id="line26013" class="line"></span>                    this._glContext = null;
<span id="line26014" class="line"></span>                }
<span id="line26015" class="line"></span>
<span id="line26016" class="line"></span>                // Note: destroyInternalCache() above already properly cleaned up all texture
<span id="line26017" class="line"></span>                // and glContext references via internalCacheFree() callbacks
<span id="line26018" class="line"></span>
<span id="line26019" class="line"></span>                // Create new rendering canvas element
<span id="line26020" class="line"></span>                this._renderingCanvas = document.createElement('canvas');
<span id="line26021" class="line"></span>                this._renderingCanvas.width = oldWidth;
<span id="line26022" class="line"></span>                this._renderingCanvas.height = oldHeight;
<span id="line26023" class="line"></span>                if (oldStyleWidth) {
<span id="line26024" class="line"></span>                    this._renderingCanvas.style.width = oldStyleWidth;
<span id="line26025" class="line"></span>                }
<span id="line26026" class="line"></span>                if (oldStyleHeight) {
<span id="line26027" class="line"></span>                    this._renderingCanvas.style.height = oldStyleHeight;
<span id="line26028" class="line"></span>                }
<span id="line26029" class="line"></span>
<span id="line26030" class="line"></span>                // Create new context manager with new canvas
<span id="line26031" class="line"></span>                this._glContext = new WebglContextManager({
<span id="line26032" class="line"></span>                    renderingCanvas: this._renderingCanvas,
<span id="line26033" class="line"></span>                    unpackWithPremultipliedAlpha: this._unpackWithPremultipliedAlpha,
<span id="line26034" class="line"></span>                    imageSmoothingEnabled: this._imageSmoothingEnabled,
<span id="line26035" class="line"></span>                    initShaderProgram: this.constructor.initShaderProgram
<span id="line26036" class="line"></span>                });
<span id="line26037" class="line"></span>
<span id="line26038" class="line"></span>                // Verify context is valid
<span id="line26039" class="line"></span>                if (!this._glContext.getContext()) {
<span id="line26040" class="line"></span>                    $.console.error('Failed to recreate WebGL context: no GL context');
<span id="line26041" class="line"></span>                    return null;
<span id="line26042" class="line"></span>                }
<span id="line26043" class="line"></span>
<span id="line26044" class="line"></span>                // Check if the new context has valid MAX_TEXTURE_IMAGE_UNITS
<span id="line26045" class="line"></span>                try {
<span id="line26046" class="line"></span>                    const maxTextures = this._glContext.getMaxTextures();
<span id="line26047" class="line"></span>                    if (!maxTextures || maxTextures &lt;= 0) {
<span id="line26048" class="line"></span>                        $.console.error('Failed to recreate WebGL context: invalid MAX_TEXTURE_IMAGE_UNITS');
<span id="line26049" class="line"></span>                        return null;
<span id="line26050" class="line"></span>                    }
<span id="line26051" class="line"></span>                } catch (e) {
<span id="line26052" class="line"></span>                    $.console.error('Failed to verify new WebGL context:', e);
<span id="line26053" class="line"></span>                    return null;
<span id="line26054" class="line"></span>                }
<span id="line26055" class="line"></span>
<span id="line26056" class="line"></span>                // Reinitialize renderer (shaders, framebuffers)
<span id="line26057" class="line"></span>                this._setupRenderer();
<span id="line26058" class="line"></span>
<span id="line26059" class="line"></span>                // Mark cache as needing refresh for future entries
<span id="line26060" class="line"></span>                // (Old entries were already freed above)
<span id="line26061" class="line"></span>                this.setInternalCacheNeedsRefresh();
<span id="line26062" class="line"></span>
<span id="line26063" class="line"></span>                return this; // Return same drawer instance
<span id="line26064" class="line"></span>            } catch (e) {
<span id="line26065" class="line"></span>                $.console.error('Failed to recreate WebGL context:', e);
<span id="line26066" class="line"></span>                return null;
<span id="line26067" class="line"></span>            }
<span id="line26068" class="line"></span>        }
<span id="line26069" class="line"></span>
<span id="line26070" class="line"></span>        /**
<span id="line26071" class="line"></span>         * Fall back to canvas drawer when WebGL fails (requires viewer.drawerCandidates to include 'canvas').
<span id="line26072" class="line"></span>         * If allowed, switches the viewer to use the canvas drawer, raises the webgl-context-recovery-failed event
<span id="line26073" class="line"></span>         * with the canvas drawer, and draws the current frame.
<span id="line26074" class="line"></span>         * Otherwise, raise the event with canvasDrawer: null and rethrow the error.
<span id="line26075" class="line"></span>         *
<span id="line26076" class="line"></span>         * @param {Error} error - The error that triggered the fallback
<span id="line26077" class="line"></span>         * @param {Array} tiledImages - Array of TiledImage objects to draw with the new drawer
<span id="line26078" class="line"></span>         * @throws {Error} Re-throws the error if canvas is not an allowed fallback or if canvas drawer creation fails
<span id="line26079" class="line"></span>         * @private
<span id="line26080" class="line"></span>         */
<span id="line26081" class="line"></span>        _fallbackToCanvasDrawer(error, tiledImages) {
<span id="line26082" class="line"></span>            const oldWebGLDrawer = this;
<span id="line26083" class="line"></span>            if (!this._canvasFallbackAllowed) {
<span id="line26084" class="line"></span>                oldWebGLDrawer._raiseContextRecoveryFailedEvent(error, null);
<span id="line26085" class="line"></span>                throw error;
<span id="line26086" class="line"></span>            }
<span id="line26087" class="line"></span>            const canvasDrawer = this.viewer.requestDrawer('canvas', {
<span id="line26088" class="line"></span>                mainDrawer: true,
<span id="line26089" class="line"></span>                redrawImmediately: false
<span id="line26090" class="line"></span>            });
<span id="line26091" class="line"></span>
<span id="line26092" class="line"></span>            if (canvasDrawer) {
<span id="line26093" class="line"></span>                $.console.error('Failed to recreate WebGL context, switching to canvas drawer');
<span id="line26094" class="line"></span>                oldWebGLDrawer._raiseContextRecoveryFailedEvent(error, canvasDrawer);
<span id="line26095" class="line"></span>                this.viewer.world.requestInvalidate(true);
<span id="line26096" class="line"></span>            } else {
<span id="line26097" class="line"></span>                $.console.error('Failed to create canvas drawer as fallback');
<span id="line26098" class="line"></span>                oldWebGLDrawer._raiseContextRecoveryFailedEvent(error, null);
<span id="line26099" class="line"></span>                throw error;
<span id="line26100" class="line"></span>            }
<span id="line26101" class="line"></span>        }
<span id="line26102" class="line"></span>
<span id="line26103" class="line"></span>        /**
<span id="line26104" class="line"></span>         * Raise the webgl-context-recovery-failed event.
<span id="line26105" class="line"></span>         * @param {Error} error - The error that triggered the recovery failure
<span id="line26106" class="line"></span>         * @param {OpenSeadragon.CanvasDrawer} [canvasDrawer=null] - The canvas drawer that was created as a fallback, or null if canvas was not an allowed fallback or creation failed
<span id="line26107" class="line"></span>         * @private
<span id="line26108" class="line"></span>         */
<span id="line26109" class="line"></span>        _raiseContextRecoveryFailedEvent(error, canvasDrawer = null) {
<span id="line26110" class="line"></span>            if (!this.viewer) {
<span id="line26111" class="line"></span>                return;
<span id="line26112" class="line"></span>            }
<span id="line26113" class="line"></span>            /**
<span id="line26114" class="line"></span>             * Raised when the WebGL drawer fails to recover from a context loss. The drawer may fall back to
<span id="line26115" class="line"></span>             * canvas drawer only when canvas is in the viewer's drawer list; otherwise canvasDrawer is null and no switch occurs.
<span id="line26116" class="line"></span>             *
<span id="line26117" class="line"></span>             * @event webgl-context-recovery-failed
<span id="line26118" class="line"></span>             * @memberof OpenSeadragon.Viewer
<span id="line26119" class="line"></span>             * @type {object}
<span id="line26120" class="line"></span>             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line26121" class="line"></span>             * @property {OpenSeadragon.WebGLDrawer} drawer - The WebGL drawer instance that failed to recover (may be destroyed).
<span id="line26122" class="line"></span>             * @property {OpenSeadragon.CanvasDrawer} canvasDrawer - The canvas drawer that was created as a fallback, or null if canvas was not an allowed fallback or creation failed.
<span id="line26123" class="line"></span>             * @property {Error} error - The original error that triggered the recovery attempt.
<span id="line26124" class="line"></span>             * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line26125" class="line"></span>             */
<span id="line26126" class="line"></span>            this.viewer.raiseEvent('webgl-context-recovery-failed', {
<span id="line26127" class="line"></span>                drawer: this,
<span id="line26128" class="line"></span>                canvasDrawer: canvasDrawer,
<span id="line26129" class="line"></span>                error: error
<span id="line26130" class="line"></span>            });
<span id="line26131" class="line"></span>        }
<span id="line26132" class="line"></span>
<span id="line26133" class="line"></span>        internalCacheCreate(cache, tile) {
<span id="line26134" class="line"></span>            const tiledImage = tile.tiledImage;
<span id="line26135" class="line"></span>            const gl = this._glContext ? this._glContext.getContext() : null;
<span id="line26136" class="line"></span>            if (!gl) {
<span id="line26137" class="line"></span>                $.console.error('WebGL context not available in internalCacheCreate');
<span id="line26138" class="line"></span>                return {};
<span id="line26139" class="line"></span>            }
<span id="line26140" class="line"></span>            let texture;
<span id="line26141" class="line"></span>            let position;
<span id="line26142" class="line"></span>
<span id="line26143" class="line"></span>            let data = cache.data;
<span id="line26144" class="line"></span>            let isCanvas = false;
<span id="line26145" class="line"></span>            if (data instanceof CanvasRenderingContext2D) {
<span id="line26146" class="line"></span>                data = data.canvas;
<span id="line26147" class="line"></span>                isCanvas = true;
<span id="line26148" class="line"></span>            }
<span id="line26149" class="line"></span>
<span id="line26150" class="line"></span>            if (!tiledImage.getIssue('webgl')) {
<span id="line26151" class="line"></span>                if (isCanvas &amp;&amp; $.isCanvasTainted(data)){
<span id="line26152" class="line"></span>                    tiledImage.setIssue('webgl', 'WebGL cannot be used to draw this TiledImage because it has tainted data. Does crossOriginPolicy need to be set?');
<span id="line26153" class="line"></span>                    this._raiseDrawerErrorEvent(tiledImage, this._canvasFallbackAllowed ?
<span id="line26154" class="line"></span>                        'Tainted data cannot be used by the WebGLDrawer. Falling back to CanvasDrawer for this TiledImage.' :
<span id="line26155" class="line"></span>                        'Tainted data cannot be used by the WebGLDrawer, and canvas fallback is not enabled.');
<span id="line26156" class="line"></span>                    this.setInternalCacheNeedsRefresh();
<span id="line26157" class="line"></span>                } else {
<span id="line26158" class="line"></span>                    let sourceWidthFraction, sourceHeightFraction;
<span id="line26159" class="line"></span>                    if (tile.sourceBounds) {
<span id="line26160" class="line"></span>                        sourceWidthFraction = Math.min(tile.sourceBounds.width, data.width) / data.width;
<span id="line26161" class="line"></span>                        sourceHeightFraction = Math.min(tile.sourceBounds.height, data.height) / data.height;
<span id="line26162" class="line"></span>                    } else {
<span id="line26163" class="line"></span>                        sourceWidthFraction = 1;
<span id="line26164" class="line"></span>                        sourceHeightFraction = 1;
<span id="line26165" class="line"></span>                    }
<span id="line26166" class="line"></span>
<span id="line26167" class="line"></span>                    const overlap = tiledImage.source.tileOverlap;
<span id="line26168" class="line"></span>                    const overlapFraction = this._calculateOverlapFraction(tile, tiledImage);
<span id="line26169" class="line"></span>                    if( overlap &gt; 0){
<span id="line26170" class="line"></span>                        // calculate the normalized position of the rect to actually draw
<span id="line26171" class="line"></span>                        // discarding overlap.
<span id="line26172" class="line"></span>                        const left = (tile.x === 0 ? 0 : overlapFraction.x) * sourceWidthFraction;
<span id="line26173" class="line"></span>                        const top = (tile.y === 0 ? 0 : overlapFraction.y) * sourceHeightFraction;
<span id="line26174" class="line"></span>                        const right = (tile.isRightMost ? 1 : 1 - overlapFraction.x) * sourceWidthFraction;
<span id="line26175" class="line"></span>                        const bottom = (tile.isBottomMost ? 1 : 1 - overlapFraction.y) * sourceHeightFraction;
<span id="line26176" class="line"></span>                        position = this._glContext.makeQuadVertexBuffer(left, right, top, bottom);
<span id="line26177" class="line"></span>                    } else if (sourceWidthFraction === 1 &amp;&amp; sourceHeightFraction === 1) {
<span id="line26178" class="line"></span>                        // no overlap and no padding: this texture can use the unit quad as its position data
<span id="line26179" class="line"></span>                        position = this._glContext.getUnitQuad();
<span id="line26180" class="line"></span>                    } else {
<span id="line26181" class="line"></span>                        position = this._glContext.makeQuadVertexBuffer(0, sourceWidthFraction, 0, sourceHeightFraction);
<span id="line26182" class="line"></span>                    }
<span id="line26183" class="line"></span>
<span id="line26184" class="line"></span>                    // create a gl Texture for this tile using the manager
<span id="line26185" class="line"></span>                    texture = this._glContext.createTexture(data, {
<span id="line26186" class="line"></span>                        unpackWithPremultipliedAlpha: this._unpackWithPremultipliedAlpha
<span id="line26187" class="line"></span>                    });
<span id="line26188" class="line"></span>
<span id="line26189" class="line"></span>                    if (!texture) {
<span id="line26190" class="line"></span>                        tiledImage.setIssue('webgl', 'Error creating texture in WebGL.');
<span id="line26191" class="line"></span>                        const canvasAllowed = this._canvasFallbackAllowed;
<span id="line26192" class="line"></span>                        this._raiseDrawerErrorEvent(tiledImage, canvasAllowed ?
<span id="line26193" class="line"></span>                            'Unknown error when creating texture. Falling back to CanvasDrawer for this TiledImage.' :
<span id="line26194" class="line"></span>                            'Cannot use WebGL for this TiledImage; canvas fallback is not enabled.');
<span id="line26195" class="line"></span>                        this.setInternalCacheNeedsRefresh();
<span id="line26196" class="line"></span>                    } else {
<span id="line26197" class="line"></span>                        // TextureInfo stored in the cache
<span id="line26198" class="line"></span>                        // Store reference to the context that created this texture
<span id="line26199" class="line"></span>                        return {
<span id="line26200" class="line"></span>                            texture: texture,
<span id="line26201" class="line"></span>                            position: position,
<span id="line26202" class="line"></span>                            overlapFraction: overlapFraction,
<span id="line26203" class="line"></span>                            glContext: this._glContext  // Store context reference for safe deletion
<span id="line26204" class="line"></span>                        };
<span id="line26205" class="line"></span>                    }
<span id="line26206" class="line"></span>                }
<span id="line26207" class="line"></span>            }
<span id="line26208" class="line"></span>            if (data instanceof Image) {
<span id="line26209" class="line"></span>                const canvas = document.createElement( 'canvas' );
<span id="line26210" class="line"></span>                canvas.width = data.width;
<span id="line26211" class="line"></span>                canvas.height = data.height;
<span id="line26212" class="line"></span>                const context = canvas.getContext('2d', { willReadFrequently: true });
<span id="line26213" class="line"></span>                context.drawImage( data, 0, 0 );
<span id="line26214" class="line"></span>                data = context;
<span id="line26215" class="line"></span>            }
<span id="line26216" class="line"></span>            if (data instanceof CanvasRenderingContext2D) {
<span id="line26217" class="line"></span>                return data;
<span id="line26218" class="line"></span>            }
<span id="line26219" class="line"></span>            $.console.error("Unsupported data used for WebGL Drawer - probably a bug!");
<span id="line26220" class="line"></span>            return {};
<span id="line26221" class="line"></span>        }
<span id="line26222" class="line"></span>
<span id="line26223" class="line"></span>        internalCacheFree(data) {
<span id="line26224" class="line"></span>            if (data &amp;&amp; data.texture) {
<span id="line26225" class="line"></span>                // Use the stored context reference if available, otherwise fall back to current context
<span id="line26226" class="line"></span>                const glContext = data.glContext || this._glContext;
<span id="line26227" class="line"></span>
<span id="line26228" class="line"></span>                if (glContext &amp;&amp; !glContext.isDestroyed()) {
<span id="line26229" class="line"></span>                    try {
<span id="line26230" class="line"></span>                        glContext.deleteTexture(data.texture);
<span id="line26231" class="line"></span>                    } catch (e) {
<span id="line26232" class="line"></span>                        // Context may have been destroyed between check and deletion - safe to ignore
<span id="line26233" class="line"></span>                    }
<span id="line26234" class="line"></span>                }
<span id="line26235" class="line"></span>
<span id="line26236" class="line"></span>                // Always nullify references
<span id="line26237" class="line"></span>                data.texture = null;
<span id="line26238" class="line"></span>                data.glContext = null;
<span id="line26239" class="line"></span>            }
<span id="line26240" class="line"></span>        }
<span id="line26241" class="line"></span>
<span id="line26242" class="line"></span>
<span id="line26243" class="line"></span>        // private
<span id="line26244" class="line"></span>        _calculateOverlapFraction(tile, tiledImage){
<span id="line26245" class="line"></span>            const overlap = tiledImage.source.tileOverlap;
<span id="line26246" class="line"></span>            const nativeWidth = tile.sourceBounds.width; // in pixels
<span id="line26247" class="line"></span>            const nativeHeight = tile.sourceBounds.height; // in pixels
<span id="line26248" class="line"></span>            const overlapWidth  = (tile.x === 0 ? 0 : overlap) + (tile.isRightMost ? 0 : overlap); // in pixels
<span id="line26249" class="line"></span>            const overlapHeight = (tile.y === 0 ? 0 : overlap) + (tile.isBottomMost ? 0 : overlap); // in pixels
<span id="line26250" class="line"></span>            const widthOverlapFraction = overlap / (nativeWidth + overlapWidth); // as a fraction of image including overlap
<span id="line26251" class="line"></span>            const heightOverlapFraction = overlap / (nativeHeight + overlapHeight); // as a fraction of image including overlap
<span id="line26252" class="line"></span>            return {
<span id="line26253" class="line"></span>                x: widthOverlapFraction,
<span id="line26254" class="line"></span>                y: heightOverlapFraction
<span id="line26255" class="line"></span>            };
<span id="line26256" class="line"></span>        }
<span id="line26257" class="line"></span>
<span id="line26258" class="line"></span>        _setClip(){
<span id="line26259" class="line"></span>            // no-op: called by _renderToClippingCanvas when tiledImage._clip is truthy
<span id="line26260" class="line"></span>            // so that tests will pass.
<span id="line26261" class="line"></span>        }
<span id="line26262" class="line"></span>
<span id="line26263" class="line"></span>        // private
<span id="line26264" class="line"></span>        _renderToClippingCanvas(item){
<span id="line26265" class="line"></span>
<span id="line26266" class="line"></span>            this._clippingContext.clearRect(0, 0, this._clippingCanvas.width, this._clippingCanvas.height);
<span id="line26267" class="line"></span>            this._clippingContext.save();
<span id="line26268" class="line"></span>            if(this.viewer.viewport.getFlip()){
<span id="line26269" class="line"></span>                const point = new $.Point(this.canvas.width / 2, this.canvas.height / 2);
<span id="line26270" class="line"></span>                this._clippingContext.translate(point.x, 0);
<span id="line26271" class="line"></span>                this._clippingContext.scale(-1, 1);
<span id="line26272" class="line"></span>                this._clippingContext.translate(-point.x, 0);
<span id="line26273" class="line"></span>            }
<span id="line26274" class="line"></span>
<span id="line26275" class="line"></span>            if(item._clip){
<span id="line26276" class="line"></span>                const polygon = [
<span id="line26277" class="line"></span>                    {x: item._clip.x, y: item._clip.y},
<span id="line26278" class="line"></span>                    {x: item._clip.x + item._clip.width, y: item._clip.y},
<span id="line26279" class="line"></span>                    {x: item._clip.x + item._clip.width, y: item._clip.y + item._clip.height},
<span id="line26280" class="line"></span>                    {x: item._clip.x, y: item._clip.y + item._clip.height},
<span id="line26281" class="line"></span>                ];
<span id="line26282" class="line"></span>                const clipPoints = polygon.map(coord =&gt; {
<span id="line26283" class="line"></span>                    const point = item.imageToViewportCoordinates(coord.x, coord.y, true)
<span id="line26284" class="line"></span>                        .rotate(this.viewer.viewport.getRotation(true), this.viewer.viewport.getCenter(true));
<span id="line26285" class="line"></span>                    const clipPoint = this.viewportCoordToDrawerCoord(point);
<span id="line26286" class="line"></span>                    return clipPoint;
<span id="line26287" class="line"></span>                });
<span id="line26288" class="line"></span>                this._clippingContext.beginPath();
<span id="line26289" class="line"></span>                clipPoints.forEach( (coord, i) =&gt; {
<span id="line26290" class="line"></span>                    this._clippingContext[i === 0 ? 'moveTo' : 'lineTo'](coord.x, coord.y);
<span id="line26291" class="line"></span>                });
<span id="line26292" class="line"></span>                this._clippingContext.clip();
<span id="line26293" class="line"></span>                this._setClip();
<span id="line26294" class="line"></span>            }
<span id="line26295" class="line"></span>            if(item._croppingPolygons){
<span id="line26296" class="line"></span>                const polygons = item._croppingPolygons.map(polygon =&gt; {
<span id="line26297" class="line"></span>                    return polygon.map(coord =&gt; {
<span id="line26298" class="line"></span>                        const point = item.imageToViewportCoordinates(coord.x, coord.y, true)
<span id="line26299" class="line"></span>                            .rotate(this.viewer.viewport.getRotation(true), this.viewer.viewport.getCenter(true));
<span id="line26300" class="line"></span>                        const clipPoint = this.viewportCoordToDrawerCoord(point);
<span id="line26301" class="line"></span>                        return clipPoint;
<span id="line26302" class="line"></span>                    });
<span id="line26303" class="line"></span>                });
<span id="line26304" class="line"></span>                this._clippingContext.beginPath();
<span id="line26305" class="line"></span>                polygons.forEach((polygon) =&gt; {
<span id="line26306" class="line"></span>                    polygon.forEach( (coord, i) =&gt; {
<span id="line26307" class="line"></span>                        this._clippingContext[i === 0 ? 'moveTo' : 'lineTo'](coord.x, coord.y);
<span id="line26308" class="line"></span>                    });
<span id="line26309" class="line"></span>                });
<span id="line26310" class="line"></span>                this._clippingContext.clip();
<span id="line26311" class="line"></span>            }
<span id="line26312" class="line"></span>
<span id="line26313" class="line"></span>            if(this.viewer.viewport.getFlip()){
<span id="line26314" class="line"></span>                const point = new $.Point(this.canvas.width / 2, this.canvas.height / 2);
<span id="line26315" class="line"></span>                this._clippingContext.translate(point.x, 0);
<span id="line26316" class="line"></span>                this._clippingContext.scale(-1, 1);
<span id="line26317" class="line"></span>                this._clippingContext.translate(-point.x, 0);
<span id="line26318" class="line"></span>            }
<span id="line26319" class="line"></span>
<span id="line26320" class="line"></span>            this._clippingContext.drawImage(this._renderingCanvas, 0, 0);
<span id="line26321" class="line"></span>
<span id="line26322" class="line"></span>            this._clippingContext.restore();
<span id="line26323" class="line"></span>        }
<span id="line26324" class="line"></span>
<span id="line26325" class="line"></span>        /**
<span id="line26326" class="line"></span>         * Set rotations for viewport &amp; tiledImage
<span id="line26327" class="line"></span>         * @private
<span id="line26328" class="line"></span>         * @param {OpenSeadragon.TiledImage} tiledImage
<span id="line26329" class="line"></span>         */
<span id="line26330" class="line"></span>        _setRotations(tiledImage) {
<span id="line26331" class="line"></span>            let saveContext = false;
<span id="line26332" class="line"></span>            if (this.viewport.getRotation(true) % 360 !== 0) {
<span id="line26333" class="line"></span>                this._offsetForRotation({
<span id="line26334" class="line"></span>                    degrees: this.viewport.getRotation(true),
<span id="line26335" class="line"></span>                    saveContext: saveContext
<span id="line26336" class="line"></span>                });
<span id="line26337" class="line"></span>                saveContext = false;
<span id="line26338" class="line"></span>            }
<span id="line26339" class="line"></span>            if (tiledImage.getRotation(true) % 360 !== 0) {
<span id="line26340" class="line"></span>                this._offsetForRotation({
<span id="line26341" class="line"></span>                    degrees: tiledImage.getRotation(true),
<span id="line26342" class="line"></span>                    point: this.viewport.pixelFromPointNoRotate(
<span id="line26343" class="line"></span>                        tiledImage._getRotationPoint(true), true),
<span id="line26344" class="line"></span>                    saveContext: saveContext
<span id="line26345" class="line"></span>                });
<span id="line26346" class="line"></span>            }
<span id="line26347" class="line"></span>        }
<span id="line26348" class="line"></span>
<span id="line26349" class="line"></span>        // private
<span id="line26350" class="line"></span>        _offsetForRotation(options) {
<span id="line26351" class="line"></span>            const point = options.point ?
<span id="line26352" class="line"></span>                options.point.times($.pixelDensityRatio) :
<span id="line26353" class="line"></span>                this._getCanvasCenter();
<span id="line26354" class="line"></span>
<span id="line26355" class="line"></span>            const context = this._outputContext;
<span id="line26356" class="line"></span>            context.save();
<span id="line26357" class="line"></span>
<span id="line26358" class="line"></span>            context.translate(point.x, point.y);
<span id="line26359" class="line"></span>            context.rotate(Math.PI / 180 * options.degrees);
<span id="line26360" class="line"></span>            context.translate(-point.x, -point.y);
<span id="line26361" class="line"></span>        }
<span id="line26362" class="line"></span>
<span id="line26363" class="line"></span>        // private
<span id="line26364" class="line"></span>        _flip(options) {
<span id="line26365" class="line"></span>            options = options || {};
<span id="line26366" class="line"></span>            const point = options.point ?
<span id="line26367" class="line"></span>            options.point.times($.pixelDensityRatio) :
<span id="line26368" class="line"></span>            this._getCanvasCenter();
<span id="line26369" class="line"></span>            const context = this._outputContext;
<span id="line26370" class="line"></span>
<span id="line26371" class="line"></span>            context.translate(point.x, 0);
<span id="line26372" class="line"></span>            context.scale(-1, 1);
<span id="line26373" class="line"></span>            context.translate(-point.x, 0);
<span id="line26374" class="line"></span>        }
<span id="line26375" class="line"></span>
<span id="line26376" class="line"></span>        // private
<span id="line26377" class="line"></span>        _drawDebugInfo( tilesToDraw, tiledImage, flipped ) {
<span id="line26378" class="line"></span>
<span id="line26379" class="line"></span>            for ( let i = tilesToDraw.length - 1; i &gt;= 0; i-- ) {
<span id="line26380" class="line"></span>                const tile = tilesToDraw[ i ].tile;
<span id="line26381" class="line"></span>                try {
<span id="line26382" class="line"></span>                    this._drawDebugInfoOnTile(tile, tilesToDraw.length, i, tiledImage, flipped);
<span id="line26383" class="line"></span>                } catch(e) {
<span id="line26384" class="line"></span>                    $.console.error(e);
<span id="line26385" class="line"></span>                }
<span id="line26386" class="line"></span>            }
<span id="line26387" class="line"></span>        }
<span id="line26388" class="line"></span>
<span id="line26389" class="line"></span>        // private
<span id="line26390" class="line"></span>        _drawDebugInfoOnTile(tile, count, i, tiledImage, flipped) {
<span id="line26391" class="line"></span>
<span id="line26392" class="line"></span>            const colorIndex = this.viewer.world.getIndexOfItem(tiledImage) % this.debugGridColor.length;
<span id="line26393" class="line"></span>            const context = this.context;
<span id="line26394" class="line"></span>            context.save();
<span id="line26395" class="line"></span>            context.lineWidth = 2 * $.pixelDensityRatio;
<span id="line26396" class="line"></span>            context.font = 'small-caps bold ' + (13 * $.pixelDensityRatio) + 'px arial';
<span id="line26397" class="line"></span>            context.strokeStyle = this.debugGridColor[colorIndex];
<span id="line26398" class="line"></span>            context.fillStyle = this.debugGridColor[colorIndex];
<span id="line26399" class="line"></span>
<span id="line26400" class="line"></span>            this._setRotations(tiledImage);
<span id="line26401" class="line"></span>
<span id="line26402" class="line"></span>            if(flipped){
<span id="line26403" class="line"></span>                this._flip({point: tile.position.plus(tile.size.divide(2))});
<span id="line26404" class="line"></span>            }
<span id="line26405" class="line"></span>
<span id="line26406" class="line"></span>            context.strokeRect(
<span id="line26407" class="line"></span>                tile.position.x * $.pixelDensityRatio,
<span id="line26408" class="line"></span>                tile.position.y * $.pixelDensityRatio,
<span id="line26409" class="line"></span>                tile.size.x * $.pixelDensityRatio,
<span id="line26410" class="line"></span>                tile.size.y * $.pixelDensityRatio
<span id="line26411" class="line"></span>            );
<span id="line26412" class="line"></span>
<span id="line26413" class="line"></span>            const tileCenterX = (tile.position.x + (tile.size.x / 2)) * $.pixelDensityRatio;
<span id="line26414" class="line"></span>            const tileCenterY = (tile.position.y + (tile.size.y / 2)) * $.pixelDensityRatio;
<span id="line26415" class="line"></span>
<span id="line26416" class="line"></span>            // Rotate the text the right way around.
<span id="line26417" class="line"></span>            context.translate( tileCenterX, tileCenterY );
<span id="line26418" class="line"></span>            const angleInDegrees = this.viewport.getRotation(true);
<span id="line26419" class="line"></span>            context.rotate( Math.PI / 180 * -angleInDegrees );
<span id="line26420" class="line"></span>            context.translate( -tileCenterX, -tileCenterY );
<span id="line26421" class="line"></span>
<span id="line26422" class="line"></span>            if( tile.x === 0 &amp;&amp; tile.y === 0 ){
<span id="line26423" class="line"></span>                context.fillText(
<span id="line26424" class="line"></span>                    "Zoom: " + this.viewport.getZoom(),
<span id="line26425" class="line"></span>                    tile.position.x * $.pixelDensityRatio,
<span id="line26426" class="line"></span>                    (tile.position.y - 30) * $.pixelDensityRatio
<span id="line26427" class="line"></span>                );
<span id="line26428" class="line"></span>                context.fillText(
<span id="line26429" class="line"></span>                    "Pan: " + this.viewport.getBounds().toString(),
<span id="line26430" class="line"></span>                    tile.position.x * $.pixelDensityRatio,
<span id="line26431" class="line"></span>                    (tile.position.y - 20) * $.pixelDensityRatio
<span id="line26432" class="line"></span>                );
<span id="line26433" class="line"></span>            }
<span id="line26434" class="line"></span>            context.fillText(
<span id="line26435" class="line"></span>                "Level: " + tile.level,
<span id="line26436" class="line"></span>                (tile.position.x + 10) * $.pixelDensityRatio,
<span id="line26437" class="line"></span>                (tile.position.y + 20) * $.pixelDensityRatio
<span id="line26438" class="line"></span>            );
<span id="line26439" class="line"></span>            context.fillText(
<span id="line26440" class="line"></span>                "Column: " + tile.x,
<span id="line26441" class="line"></span>                (tile.position.x + 10) * $.pixelDensityRatio,
<span id="line26442" class="line"></span>                (tile.position.y + 30) * $.pixelDensityRatio
<span id="line26443" class="line"></span>            );
<span id="line26444" class="line"></span>            context.fillText(
<span id="line26445" class="line"></span>                "Row: " + tile.y,
<span id="line26446" class="line"></span>                (tile.position.x + 10) * $.pixelDensityRatio,
<span id="line26447" class="line"></span>                (tile.position.y + 40) * $.pixelDensityRatio
<span id="line26448" class="line"></span>            );
<span id="line26449" class="line"></span>            context.fillText(
<span id="line26450" class="line"></span>                "Order: " + i + " of " + count,
<span id="line26451" class="line"></span>                (tile.position.x + 10) * $.pixelDensityRatio,
<span id="line26452" class="line"></span>                (tile.position.y + 50) * $.pixelDensityRatio
<span id="line26453" class="line"></span>            );
<span id="line26454" class="line"></span>            context.fillText(
<span id="line26455" class="line"></span>                "Size: " + tile.size.toString(),
<span id="line26456" class="line"></span>                (tile.position.x + 10) * $.pixelDensityRatio,
<span id="line26457" class="line"></span>                (tile.position.y + 60) * $.pixelDensityRatio
<span id="line26458" class="line"></span>            );
<span id="line26459" class="line"></span>            context.fillText(
<span id="line26460" class="line"></span>                "Position: " + tile.position.toString(),
<span id="line26461" class="line"></span>                (tile.position.x + 10) * $.pixelDensityRatio,
<span id="line26462" class="line"></span>                (tile.position.y + 70) * $.pixelDensityRatio
<span id="line26463" class="line"></span>            );
<span id="line26464" class="line"></span>
<span id="line26465" class="line"></span>            if (this.viewport.getRotation(true) % 360 !== 0 ) {
<span id="line26466" class="line"></span>                this._restoreRotationChanges();
<span id="line26467" class="line"></span>            }
<span id="line26468" class="line"></span>            if (tiledImage.getRotation(true) % 360 !== 0) {
<span id="line26469" class="line"></span>                this._restoreRotationChanges();
<span id="line26470" class="line"></span>            }
<span id="line26471" class="line"></span>
<span id="line26472" class="line"></span>            context.restore();
<span id="line26473" class="line"></span>        }
<span id="line26474" class="line"></span>
<span id="line26475" class="line"></span>        _drawPlaceholder(tiledImage){
<span id="line26476" class="line"></span>
<span id="line26477" class="line"></span>            const bounds = tiledImage.getBounds(true);
<span id="line26478" class="line"></span>            const rect = this.viewportToDrawerRectangle(tiledImage.getBounds(true));
<span id="line26479" class="line"></span>            const context = this._outputContext;
<span id="line26480" class="line"></span>
<span id="line26481" class="line"></span>            let fillStyle;
<span id="line26482" class="line"></span>            if ( typeof tiledImage.placeholderFillStyle === "function" ) {
<span id="line26483" class="line"></span>                fillStyle = tiledImage.placeholderFillStyle(tiledImage, context);
<span id="line26484" class="line"></span>            }
<span id="line26485" class="line"></span>            else {
<span id="line26486" class="line"></span>                fillStyle = tiledImage.placeholderFillStyle;
<span id="line26487" class="line"></span>            }
<span id="line26488" class="line"></span>
<span id="line26489" class="line"></span>            this._offsetForRotation({degrees: this.viewer.viewport.getRotation(true)});
<span id="line26490" class="line"></span>            context.fillStyle = fillStyle;
<span id="line26491" class="line"></span>            context.translate(rect.x, rect.y);
<span id="line26492" class="line"></span>            context.rotate(Math.PI / 180 * bounds.degrees);
<span id="line26493" class="line"></span>            context.translate(-rect.x, -rect.y);
<span id="line26494" class="line"></span>            context.fillRect(rect.x, rect.y, rect.width, rect.height);
<span id="line26495" class="line"></span>            this._restoreRotationChanges();
<span id="line26496" class="line"></span>
<span id="line26497" class="line"></span>        }
<span id="line26498" class="line"></span>
<span id="line26499" class="line"></span>        /**
<span id="line26500" class="line"></span>         * Get the canvas center
<span id="line26501" class="line"></span>         * @private
<span id="line26502" class="line"></span>         * @returns {OpenSeadragon.Point} The center point of the canvas
<span id="line26503" class="line"></span>         */
<span id="line26504" class="line"></span>        _getCanvasCenter() {
<span id="line26505" class="line"></span>            return new $.Point(this.canvas.width / 2, this.canvas.height / 2);
<span id="line26506" class="line"></span>        }
<span id="line26507" class="line"></span>
<span id="line26508" class="line"></span>        // private
<span id="line26509" class="line"></span>        _restoreRotationChanges() {
<span id="line26510" class="line"></span>            const context = this._outputContext;
<span id="line26511" class="line"></span>            context.restore();
<span id="line26512" class="line"></span>        }
<span id="line26513" class="line"></span>
<span id="line26514" class="line"></span>        // modified from https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Adding_2D_content_to_a_WebGL_context
<span id="line26515" class="line"></span>        static initShaderProgram(gl, vsSource, fsSource) {
<span id="line26516" class="line"></span>
<span id="line26517" class="line"></span>            function loadShader(gl, type, source) {
<span id="line26518" class="line"></span>                const shader = gl.createShader(type);
<span id="line26519" class="line"></span>
<span id="line26520" class="line"></span>                // Send the source to the shader object
<span id="line26521" class="line"></span>
<span id="line26522" class="line"></span>                gl.shaderSource(shader, source);
<span id="line26523" class="line"></span>
<span id="line26524" class="line"></span>                // Compile the shader program
<span id="line26525" class="line"></span>
<span id="line26526" class="line"></span>                gl.compileShader(shader);
<span id="line26527" class="line"></span>
<span id="line26528" class="line"></span>                // See if it compiled successfully
<span id="line26529" class="line"></span>
<span id="line26530" class="line"></span>                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
<span id="line26531" class="line"></span>                    $.console.error(
<span id="line26532" class="line"></span>                        `An error occurred compiling the shaders: ${gl.getShaderInfoLog(shader)}`
<span id="line26533" class="line"></span>                    );
<span id="line26534" class="line"></span>                    gl.deleteShader(shader);
<span id="line26535" class="line"></span>                    return null;
<span id="line26536" class="line"></span>                }
<span id="line26537" class="line"></span>
<span id="line26538" class="line"></span>                return shader;
<span id="line26539" class="line"></span>            }
<span id="line26540" class="line"></span>
<span id="line26541" class="line"></span>            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
<span id="line26542" class="line"></span>            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
<span id="line26543" class="line"></span>
<span id="line26544" class="line"></span>            // Create the shader program
<span id="line26545" class="line"></span>
<span id="line26546" class="line"></span>            const shaderProgram = gl.createProgram();
<span id="line26547" class="line"></span>            gl.attachShader(shaderProgram, vertexShader);
<span id="line26548" class="line"></span>            gl.attachShader(shaderProgram, fragmentShader);
<span id="line26549" class="line"></span>            gl.linkProgram(shaderProgram);
<span id="line26550" class="line"></span>
<span id="line26551" class="line"></span>            // If creating the shader program failed, alert
<span id="line26552" class="line"></span>
<span id="line26553" class="line"></span>            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
<span id="line26554" class="line"></span>            $.console.error(
<span id="line26555" class="line"></span>                `Unable to initialize the shader program: ${gl.getProgramInfoLog(
<span id="line26556" class="line"></span>                shaderProgram
<span id="line26557" class="line"></span>                )}`
<span id="line26558" class="line"></span>            );
<span id="line26559" class="line"></span>            return null;
<span id="line26560" class="line"></span>            }
<span id="line26561" class="line"></span>
<span id="line26562" class="line"></span>            return shaderProgram;
<span id="line26563" class="line"></span>        }
<span id="line26564" class="line"></span>    };
<span id="line26565" class="line"></span>
<span id="line26566" class="line"></span>
<span id="line26567" class="line"></span>}( OpenSeadragon ));
<span id="line26568" class="line"></span>
<span id="line26569" class="line"></span>/*
<span id="line26570" class="line"></span> * OpenSeadragon - Viewport
<span id="line26571" class="line"></span> *
<span id="line26572" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line26573" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line26574" class="line"></span> *
<span id="line26575" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line26576" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line26577" class="line"></span> * met:
<span id="line26578" class="line"></span> *
<span id="line26579" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line26580" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line26581" class="line"></span> *
<span id="line26582" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line26583" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line26584" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line26585" class="line"></span> *
<span id="line26586" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line26587" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line26588" class="line"></span> *   this software without specific prior written permission.
<span id="line26589" class="line"></span> *
<span id="line26590" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line26591" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line26592" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line26593" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line26594" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line26595" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line26596" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line26597" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line26598" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line26599" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line26600" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line26601" class="line"></span> */
<span id="line26602" class="line"></span>
<span id="line26603" class="line"></span>(function( $ ){
<span id="line26604" class="line"></span>
<span id="line26605" class="line"></span>
<span id="line26606" class="line"></span>/**
<span id="line26607" class="line"></span> * @class Viewport
<span id="line26608" class="line"></span> * @memberof OpenSeadragon
<span id="line26609" class="line"></span> * @classdesc Handles coordinate-related functionality (zoom, pan, rotation, etc.)
<span id="line26610" class="line"></span> * for an {@link OpenSeadragon.Viewer}.
<span id="line26611" class="line"></span> * @param {Object} options - Options for this Viewport.
<span id="line26612" class="line"></span> * @param {Object} [options.margins] - See viewportMargins in {@link OpenSeadragon.Options}.
<span id="line26613" class="line"></span> * @param {Number} [options.springStiffness] - See springStiffness in {@link OpenSeadragon.Options}.
<span id="line26614" class="line"></span> * @param {Number} [options.animationTime] - See animationTime in {@link OpenSeadragon.Options}.
<span id="line26615" class="line"></span> * @param {Number} [options.minZoomImageRatio] - See minZoomImageRatio in {@link OpenSeadragon.Options}.
<span id="line26616" class="line"></span> * @param {Number} [options.maxZoomPixelRatio] - See maxZoomPixelRatio in {@link OpenSeadragon.Options}.
<span id="line26617" class="line"></span> * @param {Number} [options.visibilityRatio] - See visibilityRatio in {@link OpenSeadragon.Options}.
<span id="line26618" class="line"></span> * @param {Boolean} [options.wrapHorizontal] - See wrapHorizontal in {@link OpenSeadragon.Options}.
<span id="line26619" class="line"></span> * @param {Boolean} [options.wrapVertical] - See wrapVertical in {@link OpenSeadragon.Options}.
<span id="line26620" class="line"></span> * @param {Number} [options.defaultZoomLevel] - See defaultZoomLevel in {@link OpenSeadragon.Options}.
<span id="line26621" class="line"></span> * @param {Number} [options.minZoomLevel] - See minZoomLevel in {@link OpenSeadragon.Options}.
<span id="line26622" class="line"></span> * @param {Number} [options.maxZoomLevel] - See maxZoomLevel in {@link OpenSeadragon.Options}.
<span id="line26623" class="line"></span> * @param {Number} [options.degrees] - See degrees in {@link OpenSeadragon.Options}.
<span id="line26624" class="line"></span> * @param {Boolean} [options.homeFillsViewer] - See homeFillsViewer in {@link OpenSeadragon.Options}.
<span id="line26625" class="line"></span> * @param {Boolean} [options.silenceMultiImageWarnings] - See silenceMultiImageWarnings in {@link OpenSeadragon.Options}.
<span id="line26626" class="line"></span> */
<span id="line26627" class="line"></span>$.Viewport = function( options ) {
<span id="line26628" class="line"></span>
<span id="line26629" class="line"></span>    //backward compatibility for positional args while preferring more
<span id="line26630" class="line"></span>    //idiomatic javascript options object as the only argument
<span id="line26631" class="line"></span>    const args = arguments;
<span id="line26632" class="line"></span>    if (args.length &amp;&amp; args[0] instanceof $.Point) {
<span id="line26633" class="line"></span>        options = {
<span id="line26634" class="line"></span>            containerSize:  args[0],
<span id="line26635" class="line"></span>            contentSize:    args[1],
<span id="line26636" class="line"></span>            config:         args[2]
<span id="line26637" class="line"></span>        };
<span id="line26638" class="line"></span>    }
<span id="line26639" class="line"></span>
<span id="line26640" class="line"></span>    //options.config and the general config argument are deprecated
<span id="line26641" class="line"></span>    //in favor of the more direct specification of optional settings
<span id="line26642" class="line"></span>    //being passed directly on the options object
<span id="line26643" class="line"></span>    if ( options.config ){
<span id="line26644" class="line"></span>        $.extend( true, options, options.config );
<span id="line26645" class="line"></span>        delete options.config;
<span id="line26646" class="line"></span>    }
<span id="line26647" class="line"></span>
<span id="line26648" class="line"></span>    this._margins = $.extend({
<span id="line26649" class="line"></span>        left: 0,
<span id="line26650" class="line"></span>        top: 0,
<span id="line26651" class="line"></span>        right: 0,
<span id="line26652" class="line"></span>        bottom: 0
<span id="line26653" class="line"></span>    }, options.margins || {});
<span id="line26654" class="line"></span>
<span id="line26655" class="line"></span>    delete options.margins;
<span id="line26656" class="line"></span>
<span id="line26657" class="line"></span>    options.initialDegrees = options.degrees;
<span id="line26658" class="line"></span>    delete options.degrees;
<span id="line26659" class="line"></span>
<span id="line26660" class="line"></span>    $.extend( true, this, {
<span id="line26661" class="line"></span>
<span id="line26662" class="line"></span>        //required settings
<span id="line26663" class="line"></span>        containerSize:      null,
<span id="line26664" class="line"></span>        contentSize:        null,
<span id="line26665" class="line"></span>
<span id="line26666" class="line"></span>        //internal state properties
<span id="line26667" class="line"></span>        zoomPoint:          null,
<span id="line26668" class="line"></span>        rotationPivot:      null,
<span id="line26669" class="line"></span>        viewer:             null,
<span id="line26670" class="line"></span>
<span id="line26671" class="line"></span>        //configurable options
<span id="line26672" class="line"></span>        springStiffness:            $.DEFAULT_SETTINGS.springStiffness,
<span id="line26673" class="line"></span>        animationTime:              $.DEFAULT_SETTINGS.animationTime,
<span id="line26674" class="line"></span>        minZoomImageRatio:          $.DEFAULT_SETTINGS.minZoomImageRatio,
<span id="line26675" class="line"></span>        maxZoomPixelRatio:          $.DEFAULT_SETTINGS.maxZoomPixelRatio,
<span id="line26676" class="line"></span>        visibilityRatio:            $.DEFAULT_SETTINGS.visibilityRatio,
<span id="line26677" class="line"></span>        wrapHorizontal:             $.DEFAULT_SETTINGS.wrapHorizontal,
<span id="line26678" class="line"></span>        wrapVertical:               $.DEFAULT_SETTINGS.wrapVertical,
<span id="line26679" class="line"></span>        defaultZoomLevel:           $.DEFAULT_SETTINGS.defaultZoomLevel,
<span id="line26680" class="line"></span>        minZoomLevel:               $.DEFAULT_SETTINGS.minZoomLevel,
<span id="line26681" class="line"></span>        maxZoomLevel:               $.DEFAULT_SETTINGS.maxZoomLevel,
<span id="line26682" class="line"></span>        initialDegrees:             $.DEFAULT_SETTINGS.degrees,
<span id="line26683" class="line"></span>        flipped:                    $.DEFAULT_SETTINGS.flipped,
<span id="line26684" class="line"></span>        homeFillsViewer:            $.DEFAULT_SETTINGS.homeFillsViewer,
<span id="line26685" class="line"></span>        silenceMultiImageWarnings:  $.DEFAULT_SETTINGS.silenceMultiImageWarnings
<span id="line26686" class="line"></span>
<span id="line26687" class="line"></span>    }, options );
<span id="line26688" class="line"></span>
<span id="line26689" class="line"></span>    this._updateContainerInnerSize();
<span id="line26690" class="line"></span>
<span id="line26691" class="line"></span>    this.centerSpringX = new $.Spring({
<span id="line26692" class="line"></span>        initial: 0,
<span id="line26693" class="line"></span>        springStiffness: this.springStiffness,
<span id="line26694" class="line"></span>        animationTime:   this.animationTime
<span id="line26695" class="line"></span>    });
<span id="line26696" class="line"></span>    this.centerSpringY = new $.Spring({
<span id="line26697" class="line"></span>        initial: 0,
<span id="line26698" class="line"></span>        springStiffness: this.springStiffness,
<span id="line26699" class="line"></span>        animationTime:   this.animationTime
<span id="line26700" class="line"></span>    });
<span id="line26701" class="line"></span>    this.zoomSpring    = new $.Spring({
<span id="line26702" class="line"></span>        exponential: true,
<span id="line26703" class="line"></span>        initial: 1,
<span id="line26704" class="line"></span>        springStiffness: this.springStiffness,
<span id="line26705" class="line"></span>        animationTime:   this.animationTime
<span id="line26706" class="line"></span>    });
<span id="line26707" class="line"></span>
<span id="line26708" class="line"></span>    this.degreesSpring = new $.Spring({
<span id="line26709" class="line"></span>        initial: options.initialDegrees,
<span id="line26710" class="line"></span>        springStiffness: this.springStiffness,
<span id="line26711" class="line"></span>        animationTime: this.animationTime
<span id="line26712" class="line"></span>    });
<span id="line26713" class="line"></span>
<span id="line26714" class="line"></span>    this._oldCenterX = this.centerSpringX.current.value;
<span id="line26715" class="line"></span>    this._oldCenterY = this.centerSpringY.current.value;
<span id="line26716" class="line"></span>    this._oldZoom    = this.zoomSpring.current.value;
<span id="line26717" class="line"></span>    this._oldDegrees = this.degreesSpring.current.value;
<span id="line26718" class="line"></span>
<span id="line26719" class="line"></span>    this._sizeChanged = false;
<span id="line26720" class="line"></span>
<span id="line26721" class="line"></span>    this._setContentBounds(new $.Rect(0, 0, 1, 1), 1);
<span id="line26722" class="line"></span>
<span id="line26723" class="line"></span>    this.goHome(true);
<span id="line26724" class="line"></span>    this.update();
<span id="line26725" class="line"></span>};
<span id="line26726" class="line"></span>
<span id="line26727" class="line"></span>/** @lends OpenSeadragon.Viewport.prototype */
<span id="line26728" class="line"></span>$.Viewport.prototype = {
<span id="line26729" class="line"></span>
<span id="line26730" class="line"></span>    // deprecated
<span id="line26731" class="line"></span>    get degrees () {
<span id="line26732" class="line"></span>        $.console.warn('Accessing [Viewport.degrees] is deprecated. Use viewport.getRotation instead.');
<span id="line26733" class="line"></span>        return this.getRotation();
<span id="line26734" class="line"></span>    },
<span id="line26735" class="line"></span>
<span id="line26736" class="line"></span>    // deprecated
<span id="line26737" class="line"></span>    set degrees (degrees) {
<span id="line26738" class="line"></span>        $.console.warn('Setting [Viewport.degrees] is deprecated. Use viewport.rotateTo, viewport.rotateBy, or viewport.setRotation instead.');
<span id="line26739" class="line"></span>        this.rotateTo(degrees);
<span id="line26740" class="line"></span>    },
<span id="line26741" class="line"></span>
<span id="line26742" class="line"></span>    /**
<span id="line26743" class="line"></span>     * Updates the viewport's home bounds and constraints for the given content size.
<span id="line26744" class="line"></span>     * @function
<span id="line26745" class="line"></span>     * @param {OpenSeadragon.Point} contentSize - size of the content in content units
<span id="line26746" class="line"></span>     * @returns {OpenSeadragon.Viewport} Chainable.
<span id="line26747" class="line"></span>     * @fires OpenSeadragon.Viewer.event:reset-size
<span id="line26748" class="line"></span>     */
<span id="line26749" class="line"></span>    resetContentSize: function(contentSize) {
<span id="line26750" class="line"></span>        $.console.assert(contentSize, "[Viewport.resetContentSize] contentSize is required");
<span id="line26751" class="line"></span>        $.console.assert(contentSize instanceof $.Point, "[Viewport.resetContentSize] contentSize must be an OpenSeadragon.Point");
<span id="line26752" class="line"></span>        $.console.assert(contentSize.x &gt; 0, "[Viewport.resetContentSize] contentSize.x must be greater than 0");
<span id="line26753" class="line"></span>        $.console.assert(contentSize.y &gt; 0, "[Viewport.resetContentSize] contentSize.y must be greater than 0");
<span id="line26754" class="line"></span>
<span id="line26755" class="line"></span>        this._setContentBounds(new $.Rect(0, 0, 1, contentSize.y / contentSize.x), contentSize.x);
<span id="line26756" class="line"></span>        return this;
<span id="line26757" class="line"></span>    },
<span id="line26758" class="line"></span>
<span id="line26759" class="line"></span>    // deprecated
<span id="line26760" class="line"></span>    setHomeBounds: function(bounds, contentFactor) {
<span id="line26761" class="line"></span>        $.console.error("[Viewport.setHomeBounds] this function is deprecated; The content bounds should not be set manually.");
<span id="line26762" class="line"></span>        this._setContentBounds(bounds, contentFactor);
<span id="line26763" class="line"></span>    },
<span id="line26764" class="line"></span>
<span id="line26765" class="line"></span>    // Set the viewport's content bounds
<span id="line26766" class="line"></span>    // @param {OpenSeadragon.Rect} bounds - the new bounds in viewport coordinates
<span id="line26767" class="line"></span>    // without rotation
<span id="line26768" class="line"></span>    // @param {Number} contentFactor - how many content units per viewport unit
<span id="line26769" class="line"></span>    // @fires OpenSeadragon.Viewer.event:reset-size
<span id="line26770" class="line"></span>    // @private
<span id="line26771" class="line"></span>    _setContentBounds: function(bounds, contentFactor) {
<span id="line26772" class="line"></span>        $.console.assert(bounds, "[Viewport._setContentBounds] bounds is required");
<span id="line26773" class="line"></span>        $.console.assert(bounds instanceof $.Rect, "[Viewport._setContentBounds] bounds must be an OpenSeadragon.Rect");
<span id="line26774" class="line"></span>        $.console.assert(bounds.width &gt; 0, "[Viewport._setContentBounds] bounds.width must be greater than 0");
<span id="line26775" class="line"></span>        $.console.assert(bounds.height &gt; 0, "[Viewport._setContentBounds] bounds.height must be greater than 0");
<span id="line26776" class="line"></span>
<span id="line26777" class="line"></span>        this._contentBoundsNoRotate = bounds.clone();
<span id="line26778" class="line"></span>        this._contentSizeNoRotate = this._contentBoundsNoRotate.getSize().times(
<span id="line26779" class="line"></span>            contentFactor);
<span id="line26780" class="line"></span>
<span id="line26781" class="line"></span>        this._contentBounds = bounds.rotate(this.getRotation()).getBoundingBox();
<span id="line26782" class="line"></span>        this._contentSize = this._contentBounds.getSize().times(contentFactor);
<span id="line26783" class="line"></span>        this._contentAspectRatio = this._contentSize.x / this._contentSize.y;
<span id="line26784" class="line"></span>
<span id="line26785" class="line"></span>        if (this.viewer) {
<span id="line26786" class="line"></span>            /**
<span id="line26787" class="line"></span>             * Raised when the viewer's content size or home bounds are reset
<span id="line26788" class="line"></span>             * (see {@link OpenSeadragon.Viewport#resetContentSize}).
<span id="line26789" class="line"></span>             *
<span id="line26790" class="line"></span>             * @event reset-size
<span id="line26791" class="line"></span>             * @memberof OpenSeadragon.Viewer
<span id="line26792" class="line"></span>             * @type {object}
<span id="line26793" class="line"></span>             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line26794" class="line"></span>             * @property {OpenSeadragon.Point} contentSize
<span id="line26795" class="line"></span>             * @property {OpenSeadragon.Rect} contentBounds - Content bounds.
<span id="line26796" class="line"></span>             * @property {OpenSeadragon.Rect} homeBounds - Content bounds.
<span id="line26797" class="line"></span>             * Deprecated use contentBounds instead.
<span id="line26798" class="line"></span>             * @property {Number} contentFactor
<span id="line26799" class="line"></span>             * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line26800" class="line"></span>             */
<span id="line26801" class="line"></span>            this.viewer.raiseEvent('reset-size', {
<span id="line26802" class="line"></span>                contentSize: this._contentSizeNoRotate.clone(),
<span id="line26803" class="line"></span>                contentFactor: contentFactor,
<span id="line26804" class="line"></span>                homeBounds: this._contentBoundsNoRotate.clone(),
<span id="line26805" class="line"></span>                contentBounds: this._contentBounds.clone()
<span id="line26806" class="line"></span>            });
<span id="line26807" class="line"></span>        }
<span id="line26808" class="line"></span>    },
<span id="line26809" class="line"></span>
<span id="line26810" class="line"></span>    /**
<span id="line26811" class="line"></span>     * Returns the home zoom in "viewport zoom" value.
<span id="line26812" class="line"></span>     * @function
<span id="line26813" class="line"></span>     * @returns {Number} The home zoom in "viewport zoom".
<span id="line26814" class="line"></span>     */
<span id="line26815" class="line"></span>    getHomeZoom: function() {
<span id="line26816" class="line"></span>        if (this.defaultZoomLevel) {
<span id="line26817" class="line"></span>            return this.defaultZoomLevel;
<span id="line26818" class="line"></span>        }
<span id="line26819" class="line"></span>
<span id="line26820" class="line"></span>        const aspectFactor = this._contentAspectRatio / this.getAspectRatio();
<span id="line26821" class="line"></span>        let output;
<span id="line26822" class="line"></span>        if (this.homeFillsViewer) { // fill the viewer and clip the image
<span id="line26823" class="line"></span>            output = aspectFactor &gt;= 1 ? aspectFactor : 1;
<span id="line26824" class="line"></span>        } else {
<span id="line26825" class="line"></span>            output = aspectFactor &gt;= 1 ? 1 : aspectFactor;
<span id="line26826" class="line"></span>        }
<span id="line26827" class="line"></span>
<span id="line26828" class="line"></span>        return output / this._contentBounds.width;
<span id="line26829" class="line"></span>    },
<span id="line26830" class="line"></span>
<span id="line26831" class="line"></span>    /**
<span id="line26832" class="line"></span>     * Returns the home bounds in viewport coordinates.
<span id="line26833" class="line"></span>     * @function
<span id="line26834" class="line"></span>     * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.
<span id="line26835" class="line"></span>     */
<span id="line26836" class="line"></span>    getHomeBounds: function() {
<span id="line26837" class="line"></span>        return this.getHomeBoundsNoRotate().rotate(-this.getRotation());
<span id="line26838" class="line"></span>    },
<span id="line26839" class="line"></span>
<span id="line26840" class="line"></span>    /**
<span id="line26841" class="line"></span>     * Returns the home bounds in viewport coordinates.
<span id="line26842" class="line"></span>     * This method ignores the viewport rotation. Use
<span id="line26843" class="line"></span>     * {@link OpenSeadragon.Viewport#getHomeBounds} to take it into account.
<span id="line26844" class="line"></span>     * @function
<span id="line26845" class="line"></span>     * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.
<span id="line26846" class="line"></span>     */
<span id="line26847" class="line"></span>    getHomeBoundsNoRotate: function() {
<span id="line26848" class="line"></span>        const center = this._contentBounds.getCenter();
<span id="line26849" class="line"></span>        const width  = 1.0 / this.getHomeZoom();
<span id="line26850" class="line"></span>        const height = width / this.getAspectRatio();
<span id="line26851" class="line"></span>
<span id="line26852" class="line"></span>        return new $.Rect(
<span id="line26853" class="line"></span>            center.x - (width / 2.0),
<span id="line26854" class="line"></span>            center.y - (height / 2.0),
<span id="line26855" class="line"></span>            width,
<span id="line26856" class="line"></span>            height
<span id="line26857" class="line"></span>        );
<span id="line26858" class="line"></span>    },
<span id="line26859" class="line"></span>
<span id="line26860" class="line"></span>    /**
<span id="line26861" class="line"></span>     * @function
<span id="line26862" class="line"></span>     * @param {Boolean} immediately
<span id="line26863" class="line"></span>     * @fires OpenSeadragon.Viewer.event:home
<span id="line26864" class="line"></span>     */
<span id="line26865" class="line"></span>    goHome: function(immediately) {
<span id="line26866" class="line"></span>        if (this.viewer) {
<span id="line26867" class="line"></span>            /**
<span id="line26868" class="line"></span>             * Raised when the "home" operation occurs (see {@link OpenSeadragon.Viewport#goHome}).
<span id="line26869" class="line"></span>             *
<span id="line26870" class="line"></span>             * @event home
<span id="line26871" class="line"></span>             * @memberof OpenSeadragon.Viewer
<span id="line26872" class="line"></span>             * @type {object}
<span id="line26873" class="line"></span>             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line26874" class="line"></span>             * @property {Boolean} immediately
<span id="line26875" class="line"></span>             * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line26876" class="line"></span>             */
<span id="line26877" class="line"></span>            this.viewer.raiseEvent('home', {
<span id="line26878" class="line"></span>                immediately: immediately
<span id="line26879" class="line"></span>            });
<span id="line26880" class="line"></span>        }
<span id="line26881" class="line"></span>        return this.fitBounds(this.getHomeBounds(), immediately);
<span id="line26882" class="line"></span>    },
<span id="line26883" class="line"></span>
<span id="line26884" class="line"></span>    /**
<span id="line26885" class="line"></span>     * @function
<span id="line26886" class="line"></span>     */
<span id="line26887" class="line"></span>    getMinZoom: function() {
<span id="line26888" class="line"></span>        const homeZoom = this.getHomeZoom();
<span id="line26889" class="line"></span>        const zoom = this.minZoomLevel ?
<span id="line26890" class="line"></span>            this.minZoomLevel :
<span id="line26891" class="line"></span>                this.minZoomImageRatio * homeZoom;
<span id="line26892" class="line"></span>
<span id="line26893" class="line"></span>        return zoom;
<span id="line26894" class="line"></span>    },
<span id="line26895" class="line"></span>
<span id="line26896" class="line"></span>    /**
<span id="line26897" class="line"></span>     * @function
<span id="line26898" class="line"></span>     */
<span id="line26899" class="line"></span>    getMaxZoom: function() {
<span id="line26900" class="line"></span>        let zoom = this.maxZoomLevel;
<span id="line26901" class="line"></span>        if (!zoom) {
<span id="line26902" class="line"></span>            zoom = this._contentSize.x * this.maxZoomPixelRatio / this._containerInnerSize.x;
<span id="line26903" class="line"></span>            zoom /= this._contentBounds.width;
<span id="line26904" class="line"></span>        }
<span id="line26905" class="line"></span>
<span id="line26906" class="line"></span>        return Math.max( zoom, this.getHomeZoom() );
<span id="line26907" class="line"></span>    },
<span id="line26908" class="line"></span>
<span id="line26909" class="line"></span>    /**
<span id="line26910" class="line"></span>     * @function
<span id="line26911" class="line"></span>     */
<span id="line26912" class="line"></span>    getAspectRatio: function() {
<span id="line26913" class="line"></span>        return this._containerInnerSize.x / this._containerInnerSize.y;
<span id="line26914" class="line"></span>    },
<span id="line26915" class="line"></span>
<span id="line26916" class="line"></span>    /**
<span id="line26917" class="line"></span>     * @function
<span id="line26918" class="line"></span>     * @returns {OpenSeadragon.Point} The size of the container, in screen coordinates.
<span id="line26919" class="line"></span>     */
<span id="line26920" class="line"></span>    getContainerSize: function() {
<span id="line26921" class="line"></span>        return new $.Point(
<span id="line26922" class="line"></span>            this.containerSize.x,
<span id="line26923" class="line"></span>            this.containerSize.y
<span id="line26924" class="line"></span>        );
<span id="line26925" class="line"></span>    },
<span id="line26926" class="line"></span>
<span id="line26927" class="line"></span>    /**
<span id="line26928" class="line"></span>     * The margins push the "home" region in from the sides by the specified amounts.
<span id="line26929" class="line"></span>     * @function
<span id="line26930" class="line"></span>     * @returns {Object} Properties (Numbers, in screen coordinates): left, top, right, bottom.
<span id="line26931" class="line"></span>     */
<span id="line26932" class="line"></span>    getMargins: function() {
<span id="line26933" class="line"></span>        return $.extend({}, this._margins); // Make a copy so we are not returning our original
<span id="line26934" class="line"></span>    },
<span id="line26935" class="line"></span>
<span id="line26936" class="line"></span>    /**
<span id="line26937" class="line"></span>     * The margins push the "home" region in from the sides by the specified amounts.
<span id="line26938" class="line"></span>     * @function
<span id="line26939" class="line"></span>     * @param {Object} margins - Properties (Numbers, in screen coordinates): left, top, right, bottom.
<span id="line26940" class="line"></span>     */
<span id="line26941" class="line"></span>    setMargins: function(margins) {
<span id="line26942" class="line"></span>        $.console.assert($.type(margins) === 'object', '[Viewport.setMargins] margins must be an object');
<span id="line26943" class="line"></span>
<span id="line26944" class="line"></span>        this._margins = $.extend({
<span id="line26945" class="line"></span>            left: 0,
<span id="line26946" class="line"></span>            top: 0,
<span id="line26947" class="line"></span>            right: 0,
<span id="line26948" class="line"></span>            bottom: 0
<span id="line26949" class="line"></span>        }, margins);
<span id="line26950" class="line"></span>
<span id="line26951" class="line"></span>        this._updateContainerInnerSize();
<span id="line26952" class="line"></span>        if (this.viewer) {
<span id="line26953" class="line"></span>            this.viewer.forceRedraw();
<span id="line26954" class="line"></span>        }
<span id="line26955" class="line"></span>    },
<span id="line26956" class="line"></span>
<span id="line26957" class="line"></span>    /**
<span id="line26958" class="line"></span>     * Returns the bounds of the visible area in viewport coordinates.
<span id="line26959" class="line"></span>     * @function
<span id="line26960" class="line"></span>     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
<span id="line26961" class="line"></span>     * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.
<span id="line26962" class="line"></span>     */
<span id="line26963" class="line"></span>    getBounds: function(current) {
<span id="line26964" class="line"></span>        return this.getBoundsNoRotate(current).rotate(-this.getRotation(current));
<span id="line26965" class="line"></span>    },
<span id="line26966" class="line"></span>
<span id="line26967" class="line"></span>    /**
<span id="line26968" class="line"></span>     * Returns the bounds of the visible area in viewport coordinates.
<span id="line26969" class="line"></span>     * This method ignores the viewport rotation. Use
<span id="line26970" class="line"></span>     * {@link OpenSeadragon.Viewport#getBounds} to take it into account.
<span id="line26971" class="line"></span>     * @function
<span id="line26972" class="line"></span>     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
<span id="line26973" class="line"></span>     * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.
<span id="line26974" class="line"></span>     */
<span id="line26975" class="line"></span>    getBoundsNoRotate: function(current) {
<span id="line26976" class="line"></span>        const center = this.getCenter(current);
<span id="line26977" class="line"></span>        const width  = 1.0 / this.getZoom(current);
<span id="line26978" class="line"></span>        const height = width / this.getAspectRatio();
<span id="line26979" class="line"></span>
<span id="line26980" class="line"></span>        return new $.Rect(
<span id="line26981" class="line"></span>            center.x - (width / 2.0),
<span id="line26982" class="line"></span>            center.y - (height / 2.0),
<span id="line26983" class="line"></span>            width,
<span id="line26984" class="line"></span>            height
<span id="line26985" class="line"></span>        );
<span id="line26986" class="line"></span>    },
<span id="line26987" class="line"></span>
<span id="line26988" class="line"></span>    /**
<span id="line26989" class="line"></span>     * @function
<span id="line26990" class="line"></span>     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
<span id="line26991" class="line"></span>     * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,
<span id="line26992" class="line"></span>     * including the space taken by margins, in viewport coordinates.
<span id="line26993" class="line"></span>     */
<span id="line26994" class="line"></span>    getBoundsWithMargins: function(current) {
<span id="line26995" class="line"></span>        return this.getBoundsNoRotateWithMargins(current).rotate(
<span id="line26996" class="line"></span>            -this.getRotation(current), this.getCenter(current));
<span id="line26997" class="line"></span>    },
<span id="line26998" class="line"></span>
<span id="line26999" class="line"></span>    /**
<span id="line27000" class="line"></span>     * @function
<span id="line27001" class="line"></span>     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
<span id="line27002" class="line"></span>     * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,
<span id="line27003" class="line"></span>     * including the space taken by margins, in viewport coordinates.
<span id="line27004" class="line"></span>     */
<span id="line27005" class="line"></span>    getBoundsNoRotateWithMargins: function(current) {
<span id="line27006" class="line"></span>        const bounds = this.getBoundsNoRotate(current);
<span id="line27007" class="line"></span>        const factor = this._containerInnerSize.x * this.getZoom(current);
<span id="line27008" class="line"></span>        bounds.x -= this._margins.left / factor;
<span id="line27009" class="line"></span>        bounds.y -= this._margins.top / factor;
<span id="line27010" class="line"></span>        bounds.width += (this._margins.left + this._margins.right) / factor;
<span id="line27011" class="line"></span>        bounds.height += (this._margins.top + this._margins.bottom) / factor;
<span id="line27012" class="line"></span>        return bounds;
<span id="line27013" class="line"></span>    },
<span id="line27014" class="line"></span>
<span id="line27015" class="line"></span>    /**
<span id="line27016" class="line"></span>     * @function
<span id="line27017" class="line"></span>     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
<span id="line27018" class="line"></span>     */
<span id="line27019" class="line"></span>    getCenter: function( current ) {
<span id="line27020" class="line"></span>        const centerCurrent = new $.Point(
<span id="line27021" class="line"></span>                this.centerSpringX.current.value,
<span id="line27022" class="line"></span>                this.centerSpringY.current.value
<span id="line27023" class="line"></span>            );
<span id="line27024" class="line"></span>        const centerTarget = new $.Point(
<span id="line27025" class="line"></span>                this.centerSpringX.target.value,
<span id="line27026" class="line"></span>                this.centerSpringY.target.value
<span id="line27027" class="line"></span>            );
<span id="line27028" class="line"></span>
<span id="line27029" class="line"></span>        if ( current ) {
<span id="line27030" class="line"></span>            return centerCurrent;
<span id="line27031" class="line"></span>        } else if ( !this.zoomPoint ) {
<span id="line27032" class="line"></span>            return centerTarget;
<span id="line27033" class="line"></span>        }
<span id="line27034" class="line"></span>
<span id="line27035" class="line"></span>        const oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
<span id="line27036" class="line"></span>
<span id="line27037" class="line"></span>        const zoom    = this.getZoom();
<span id="line27038" class="line"></span>        const width   = 1.0 / zoom;
<span id="line27039" class="line"></span>        const height  = width / this.getAspectRatio();
<span id="line27040" class="line"></span>        const bounds  = new $.Rect(
<span id="line27041" class="line"></span>            centerCurrent.x - width / 2.0,
<span id="line27042" class="line"></span>            centerCurrent.y - height / 2.0,
<span id="line27043" class="line"></span>            width,
<span id="line27044" class="line"></span>            height
<span id="line27045" class="line"></span>        );
<span id="line27046" class="line"></span>
<span id="line27047" class="line"></span>        const newZoomPixel = this._pixelFromPoint(this.zoomPoint, bounds);
<span id="line27048" class="line"></span>        const deltaZoomPixels = newZoomPixel.minus( oldZoomPixel ).rotate(-this.getRotation(true));
<span id="line27049" class="line"></span>        const deltaZoomPoints = deltaZoomPixels.divide( this._containerInnerSize.x * zoom );
<span id="line27050" class="line"></span>
<span id="line27051" class="line"></span>        return centerTarget.plus( deltaZoomPoints );
<span id="line27052" class="line"></span>    },
<span id="line27053" class="line"></span>
<span id="line27054" class="line"></span>    /**
<span id="line27055" class="line"></span>     * @function
<span id="line27056" class="line"></span>     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
<span id="line27057" class="line"></span>     */
<span id="line27058" class="line"></span>    getZoom: function( current ) {
<span id="line27059" class="line"></span>        if ( current ) {
<span id="line27060" class="line"></span>            return this.zoomSpring.current.value;
<span id="line27061" class="line"></span>        } else {
<span id="line27062" class="line"></span>            return this.zoomSpring.target.value;
<span id="line27063" class="line"></span>        }
<span id="line27064" class="line"></span>    },
<span id="line27065" class="line"></span>
<span id="line27066" class="line"></span>    // private
<span id="line27067" class="line"></span>    _applyZoomConstraints: function(zoom) {
<span id="line27068" class="line"></span>        return Math.max(
<span id="line27069" class="line"></span>            Math.min(zoom, this.getMaxZoom()),
<span id="line27070" class="line"></span>            this.getMinZoom());
<span id="line27071" class="line"></span>    },
<span id="line27072" class="line"></span>
<span id="line27073" class="line"></span>    /**
<span id="line27074" class="line"></span>     * @function
<span id="line27075" class="line"></span>     * @private
<span id="line27076" class="line"></span>     * @param {OpenSeadragon.Rect} bounds
<span id="line27077" class="line"></span>     * @returns {OpenSeadragon.Rect} constrained bounds.
<span id="line27078" class="line"></span>     */
<span id="line27079" class="line"></span>    _applyBoundaryConstraints: function(bounds) {
<span id="line27080" class="line"></span>        const newBounds = this.viewportToViewerElementRectangle(bounds).getBoundingBox();
<span id="line27081" class="line"></span>        const cb = this.viewportToViewerElementRectangle(this._contentBoundsNoRotate).getBoundingBox();
<span id="line27082" class="line"></span>
<span id="line27083" class="line"></span>        let xConstrained = false;
<span id="line27084" class="line"></span>        let yConstrained = false;
<span id="line27085" class="line"></span>
<span id="line27086" class="line"></span>        if (this.wrapHorizontal) {
<span id="line27087" class="line"></span>            //do nothing
<span id="line27088" class="line"></span>        } else {
<span id="line27089" class="line"></span>            const boundsRight = newBounds.x + newBounds.width;
<span id="line27090" class="line"></span>            const contentRight = cb.x + cb.width;
<span id="line27091" class="line"></span>
<span id="line27092" class="line"></span>            let horizontalThreshold, leftDx, rightDx;
<span id="line27093" class="line"></span>            if (newBounds.width &gt; cb.width) {
<span id="line27094" class="line"></span>                horizontalThreshold = this.visibilityRatio * cb.width;
<span id="line27095" class="line"></span>            } else {
<span id="line27096" class="line"></span>                horizontalThreshold = this.visibilityRatio * newBounds.width;
<span id="line27097" class="line"></span>            }
<span id="line27098" class="line"></span>
<span id="line27099" class="line"></span>            leftDx = cb.x - boundsRight + horizontalThreshold;
<span id="line27100" class="line"></span>            rightDx = contentRight - newBounds.x - horizontalThreshold;
<span id="line27101" class="line"></span>            if (horizontalThreshold &gt; cb.width) {
<span id="line27102" class="line"></span>                newBounds.x += (leftDx + rightDx) / 2;
<span id="line27103" class="line"></span>                xConstrained = true;
<span id="line27104" class="line"></span>            } else if (rightDx &lt; 0) {
<span id="line27105" class="line"></span>                newBounds.x += rightDx;
<span id="line27106" class="line"></span>                xConstrained = true;
<span id="line27107" class="line"></span>            } else if (leftDx &gt; 0) {
<span id="line27108" class="line"></span>                newBounds.x += leftDx;
<span id="line27109" class="line"></span>                xConstrained = true;
<span id="line27110" class="line"></span>            }
<span id="line27111" class="line"></span>
<span id="line27112" class="line"></span>        }
<span id="line27113" class="line"></span>
<span id="line27114" class="line"></span>        if (this.wrapVertical) {
<span id="line27115" class="line"></span>            //do nothing
<span id="line27116" class="line"></span>        } else {
<span id="line27117" class="line"></span>            const boundsBottom = newBounds.y + newBounds.height;
<span id="line27118" class="line"></span>            const contentBottom = cb.y + cb.height;
<span id="line27119" class="line"></span>
<span id="line27120" class="line"></span>            let verticalThreshold, topDy, bottomDy;
<span id="line27121" class="line"></span>            if (newBounds.height &gt; cb.height) {
<span id="line27122" class="line"></span>                verticalThreshold = this.visibilityRatio * cb.height;
<span id="line27123" class="line"></span>            } else{
<span id="line27124" class="line"></span>                verticalThreshold = this.visibilityRatio * newBounds.height;
<span id="line27125" class="line"></span>            }
<span id="line27126" class="line"></span>
<span id="line27127" class="line"></span>            topDy = cb.y - boundsBottom + verticalThreshold;
<span id="line27128" class="line"></span>            bottomDy = contentBottom - newBounds.y - verticalThreshold;
<span id="line27129" class="line"></span>            if (verticalThreshold &gt; cb.height) {
<span id="line27130" class="line"></span>                newBounds.y += (topDy + bottomDy) / 2;
<span id="line27131" class="line"></span>                yConstrained = true;
<span id="line27132" class="line"></span>            } else if (bottomDy &lt; 0) {
<span id="line27133" class="line"></span>                newBounds.y += bottomDy;
<span id="line27134" class="line"></span>                yConstrained = true;
<span id="line27135" class="line"></span>            } else if (topDy &gt; 0) {
<span id="line27136" class="line"></span>                newBounds.y += topDy;
<span id="line27137" class="line"></span>                yConstrained = true;
<span id="line27138" class="line"></span>            }
<span id="line27139" class="line"></span>
<span id="line27140" class="line"></span>        }
<span id="line27141" class="line"></span>
<span id="line27142" class="line"></span>        const constraintApplied = xConstrained || yConstrained;
<span id="line27143" class="line"></span>        const newViewportBounds = constraintApplied ? this.viewerElementToViewportRectangle(newBounds) : bounds.clone();
<span id="line27144" class="line"></span>        newViewportBounds.xConstrained = xConstrained;
<span id="line27145" class="line"></span>        newViewportBounds.yConstrained = yConstrained;
<span id="line27146" class="line"></span>        newViewportBounds.constraintApplied = constraintApplied;
<span id="line27147" class="line"></span>
<span id="line27148" class="line"></span>        return newViewportBounds;
<span id="line27149" class="line"></span>    },
<span id="line27150" class="line"></span>
<span id="line27151" class="line"></span>    /**
<span id="line27152" class="line"></span>     * @function
<span id="line27153" class="line"></span>     * @private
<span id="line27154" class="line"></span>     * @param {Boolean} [immediately=false] - whether the function that triggered this event was
<span id="line27155" class="line"></span>     * called with the "immediately" flag
<span id="line27156" class="line"></span>     */
<span id="line27157" class="line"></span>    _raiseConstraintsEvent: function(immediately) {
<span id="line27158" class="line"></span>        if (this.viewer) {
<span id="line27159" class="line"></span>            /**
<span id="line27160" class="line"></span>             * Raised when the viewport constraints are applied (see {@link OpenSeadragon.Viewport#applyConstraints}).
<span id="line27161" class="line"></span>             *
<span id="line27162" class="line"></span>             * @event constrain
<span id="line27163" class="line"></span>             * @memberof OpenSeadragon.Viewer
<span id="line27164" class="line"></span>             * @type {object}
<span id="line27165" class="line"></span>             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line27166" class="line"></span>             * @property {Boolean} immediately - whether the function that triggered this event was
<span id="line27167" class="line"></span>             * called with the "immediately" flag
<span id="line27168" class="line"></span>             * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line27169" class="line"></span>             */
<span id="line27170" class="line"></span>            this.viewer.raiseEvent( 'constrain', {
<span id="line27171" class="line"></span>                immediately: immediately
<span id="line27172" class="line"></span>            });
<span id="line27173" class="line"></span>        }
<span id="line27174" class="line"></span>    },
<span id="line27175" class="line"></span>
<span id="line27176" class="line"></span>    /**
<span id="line27177" class="line"></span>     * Enforces the minZoom, maxZoom and visibilityRatio constraints by
<span id="line27178" class="line"></span>     * zooming and panning to the closest acceptable zoom and location.
<span id="line27179" class="line"></span>     * @function
<span id="line27180" class="line"></span>     * @param {Boolean} [immediately=false]
<span id="line27181" class="line"></span>     * @returns {OpenSeadragon.Viewport} Chainable.
<span id="line27182" class="line"></span>     * @fires OpenSeadragon.Viewer.event:constrain if constraints were applied
<span id="line27183" class="line"></span>     */
<span id="line27184" class="line"></span>    applyConstraints: function(immediately) {
<span id="line27185" class="line"></span>        const actualZoom = this.getZoom();
<span id="line27186" class="line"></span>        const constrainedZoom = this._applyZoomConstraints(actualZoom);
<span id="line27187" class="line"></span>
<span id="line27188" class="line"></span>        if (actualZoom !== constrainedZoom) {
<span id="line27189" class="line"></span>            this.zoomTo(constrainedZoom, this.zoomPoint, immediately);
<span id="line27190" class="line"></span>        }
<span id="line27191" class="line"></span>
<span id="line27192" class="line"></span>        const constrainedBounds = this.getConstrainedBounds(false);
<span id="line27193" class="line"></span>
<span id="line27194" class="line"></span>        if(constrainedBounds.constraintApplied){
<span id="line27195" class="line"></span>            this.fitBounds(constrainedBounds, immediately);
<span id="line27196" class="line"></span>            this._raiseConstraintsEvent(immediately);
<span id="line27197" class="line"></span>        }
<span id="line27198" class="line"></span>
<span id="line27199" class="line"></span>        return this;
<span id="line27200" class="line"></span>    },
<span id="line27201" class="line"></span>
<span id="line27202" class="line"></span>    /**
<span id="line27203" class="line"></span>     * Equivalent to {@link OpenSeadragon.Viewport#applyConstraints}
<span id="line27204" class="line"></span>     * @function
<span id="line27205" class="line"></span>     * @param {Boolean} [immediately=false]
<span id="line27206" class="line"></span>     * @returns {OpenSeadragon.Viewport} Chainable.
<span id="line27207" class="line"></span>     * @fires OpenSeadragon.Viewer.event:constrain
<span id="line27208" class="line"></span>     */
<span id="line27209" class="line"></span>    ensureVisible: function(immediately) {
<span id="line27210" class="line"></span>        return this.applyConstraints(immediately);
<span id="line27211" class="line"></span>    },
<span id="line27212" class="line"></span>
<span id="line27213" class="line"></span>    /**
<span id="line27214" class="line"></span>     * @function
<span id="line27215" class="line"></span>     * @private
<span id="line27216" class="line"></span>     * @param {OpenSeadragon.Rect} bounds
<span id="line27217" class="line"></span>     * @param {Object} options (immediately=false, constraints=false)
<span id="line27218" class="line"></span>     * @returns {OpenSeadragon.Viewport} Chainable.
<span id="line27219" class="line"></span>     */
<span id="line27220" class="line"></span>    _fitBounds: function(bounds, options) {
<span id="line27221" class="line"></span>        options = options || {};
<span id="line27222" class="line"></span>        const immediately = options.immediately || false;
<span id="line27223" class="line"></span>        const constraints = options.constraints || false;
<span id="line27224" class="line"></span>
<span id="line27225" class="line"></span>        const aspect = this.getAspectRatio();
<span id="line27226" class="line"></span>        const center = bounds.getCenter();
<span id="line27227" class="line"></span>
<span id="line27228" class="line"></span>        // Compute width and height of bounding box.
<span id="line27229" class="line"></span>        const newBounds = new $.Rect(
<span id="line27230" class="line"></span>            bounds.x,
<span id="line27231" class="line"></span>            bounds.y,
<span id="line27232" class="line"></span>            bounds.width,
<span id="line27233" class="line"></span>            bounds.height,
<span id="line27234" class="line"></span>            bounds.degrees + this.getRotation())
<span id="line27235" class="line"></span>            .getBoundingBox();
<span id="line27236" class="line"></span>
<span id="line27237" class="line"></span>        if (newBounds.getAspectRatio() &gt;= aspect) {
<span id="line27238" class="line"></span>            newBounds.height = newBounds.width / aspect;
<span id="line27239" class="line"></span>        } else {
<span id="line27240" class="line"></span>            newBounds.width = newBounds.height * aspect;
<span id="line27241" class="line"></span>        }
<span id="line27242" class="line"></span>
<span id="line27243" class="line"></span>        // Compute x and y from width, height and center position
<span id="line27244" class="line"></span>        newBounds.x = center.x - newBounds.width / 2;
<span id="line27245" class="line"></span>        newBounds.y = center.y - newBounds.height / 2;
<span id="line27246" class="line"></span>        let newZoom = 1.0 / newBounds.width;
<span id="line27247" class="line"></span>
<span id="line27248" class="line"></span>        if (immediately) {
<span id="line27249" class="line"></span>            this.panTo(center, true);
<span id="line27250" class="line"></span>            this.zoomTo(newZoom, null, true);
<span id="line27251" class="line"></span>            if(constraints){
<span id="line27252" class="line"></span>                this.applyConstraints(true);
<span id="line27253" class="line"></span>            }
<span id="line27254" class="line"></span>            return this;
<span id="line27255" class="line"></span>        }
<span id="line27256" class="line"></span>
<span id="line27257" class="line"></span>        const currentCenter = this.getCenter(true);
<span id="line27258" class="line"></span>        const currentZoom = this.getZoom(true);
<span id="line27259" class="line"></span>        this.panTo(currentCenter, true);
<span id="line27260" class="line"></span>        this.zoomTo(currentZoom, null, true);
<span id="line27261" class="line"></span>
<span id="line27262" class="line"></span>        const oldBounds = this.getBounds();
<span id="line27263" class="line"></span>        const oldZoom   = this.getZoom();
<span id="line27264" class="line"></span>
<span id="line27265" class="line"></span>        if (oldZoom === 0 || Math.abs(newZoom / oldZoom - 1) &lt; 0.00000001) {
<span id="line27266" class="line"></span>            this.zoomTo(newZoom, null, true);
<span id="line27267" class="line"></span>            this.panTo(center, immediately);
<span id="line27268" class="line"></span>            if(constraints){
<span id="line27269" class="line"></span>                this.applyConstraints(false);
<span id="line27270" class="line"></span>            }
<span id="line27271" class="line"></span>            return this;
<span id="line27272" class="line"></span>        }
<span id="line27273" class="line"></span>
<span id="line27274" class="line"></span>        if(constraints){
<span id="line27275" class="line"></span>            this.panTo(center, false);
<span id="line27276" class="line"></span>
<span id="line27277" class="line"></span>            newZoom = this._applyZoomConstraints(newZoom);
<span id="line27278" class="line"></span>            this.zoomTo(newZoom, null, false);
<span id="line27279" class="line"></span>
<span id="line27280" class="line"></span>            const constrainedBounds = this.getConstrainedBounds();
<span id="line27281" class="line"></span>
<span id="line27282" class="line"></span>            this.panTo(currentCenter, true);
<span id="line27283" class="line"></span>            this.zoomTo(currentZoom, null, true);
<span id="line27284" class="line"></span>
<span id="line27285" class="line"></span>            this.fitBounds(constrainedBounds);
<span id="line27286" class="line"></span>        } else {
<span id="line27287" class="line"></span>            const rotatedNewBounds = newBounds.rotate(-this.getRotation());
<span id="line27288" class="line"></span>            const referencePoint = rotatedNewBounds.getTopLeft().times(newZoom)
<span id="line27289" class="line"></span>                .minus(oldBounds.getTopLeft().times(oldZoom))
<span id="line27290" class="line"></span>                .divide(newZoom - oldZoom);
<span id="line27291" class="line"></span>
<span id="line27292" class="line"></span>            this.zoomTo(newZoom, referencePoint, immediately);
<span id="line27293" class="line"></span>        }
<span id="line27294" class="line"></span>        return this;
<span id="line27295" class="line"></span>    },
<span id="line27296" class="line"></span>
<span id="line27297" class="line"></span>    /**
<span id="line27298" class="line"></span>     * Makes the viewport zoom and pan so that the specified bounds take
<span id="line27299" class="line"></span>     * as much space as possible in the viewport.
<span id="line27300" class="line"></span>     * Note: this method ignores the constraints (minZoom, maxZoom and
<span id="line27301" class="line"></span>     * visibilityRatio).
<span id="line27302" class="line"></span>     * Use {@link OpenSeadragon.Viewport#fitBoundsWithConstraints} to enforce
<span id="line27303" class="line"></span>     * them.
<span id="line27304" class="line"></span>     * @function
<span id="line27305" class="line"></span>     * @param {OpenSeadragon.Rect} bounds
<span id="line27306" class="line"></span>     * @param {Boolean} [immediately=false]
<span id="line27307" class="line"></span>     * @returns {OpenSeadragon.Viewport} Chainable.
<span id="line27308" class="line"></span>     */
<span id="line27309" class="line"></span>    fitBounds: function(bounds, immediately) {
<span id="line27310" class="line"></span>        return this._fitBounds(bounds, {
<span id="line27311" class="line"></span>            immediately: immediately,
<span id="line27312" class="line"></span>            constraints: false
<span id="line27313" class="line"></span>        });
<span id="line27314" class="line"></span>    },
<span id="line27315" class="line"></span>
<span id="line27316" class="line"></span>    /**
<span id="line27317" class="line"></span>     * Makes the viewport zoom and pan so that the specified bounds take
<span id="line27318" class="line"></span>     * as much space as possible in the viewport while enforcing the constraints
<span id="line27319" class="line"></span>     * (minZoom, maxZoom and visibilityRatio).
<span id="line27320" class="line"></span>     * Note: because this method enforces the constraints, part of the
<span id="line27321" class="line"></span>     * provided bounds may end up outside of the viewport.
<span id="line27322" class="line"></span>     * Use {@link OpenSeadragon.Viewport#fitBounds} to ignore them.
<span id="line27323" class="line"></span>     * @function
<span id="line27324" class="line"></span>     * @param {OpenSeadragon.Rect} bounds
<span id="line27325" class="line"></span>     * @param {Boolean} [immediately=false]
<span id="line27326" class="line"></span>     * @returns {OpenSeadragon.Viewport} Chainable.
<span id="line27327" class="line"></span>     */
<span id="line27328" class="line"></span>    fitBoundsWithConstraints: function(bounds, immediately) {
<span id="line27329" class="line"></span>        return this._fitBounds(bounds, {
<span id="line27330" class="line"></span>            immediately: immediately,
<span id="line27331" class="line"></span>            constraints: true
<span id="line27332" class="line"></span>        });
<span id="line27333" class="line"></span>    },
<span id="line27334" class="line"></span>
<span id="line27335" class="line"></span>    /**
<span id="line27336" class="line"></span>     * Zooms so the image just fills the viewer vertically.
<span id="line27337" class="line"></span>     * @param {Boolean} immediately
<span id="line27338" class="line"></span>     * @returns {OpenSeadragon.Viewport} Chainable.
<span id="line27339" class="line"></span>     */
<span id="line27340" class="line"></span>    fitVertically: function(immediately) {
<span id="line27341" class="line"></span>        const box = new $.Rect(
<span id="line27342" class="line"></span>            this._contentBounds.x + (this._contentBounds.width / 2),
<span id="line27343" class="line"></span>            this._contentBounds.y,
<span id="line27344" class="line"></span>            0,
<span id="line27345" class="line"></span>            this._contentBounds.height);
<span id="line27346" class="line"></span>        return this.fitBounds(box, immediately);
<span id="line27347" class="line"></span>    },
<span id="line27348" class="line"></span>
<span id="line27349" class="line"></span>    /**
<span id="line27350" class="line"></span>     * Zooms so the image just fills the viewer horizontally.
<span id="line27351" class="line"></span>     * @param {Boolean} immediately
<span id="line27352" class="line"></span>     * @returns {OpenSeadragon.Viewport} Chainable.
<span id="line27353" class="line"></span>     */
<span id="line27354" class="line"></span>    fitHorizontally: function(immediately) {
<span id="line27355" class="line"></span>        const box = new $.Rect(
<span id="line27356" class="line"></span>            this._contentBounds.x,
<span id="line27357" class="line"></span>            this._contentBounds.y + (this._contentBounds.height / 2),
<span id="line27358" class="line"></span>            this._contentBounds.width,
<span id="line27359" class="line"></span>            0);
<span id="line27360" class="line"></span>        return this.fitBounds(box, immediately);
<span id="line27361" class="line"></span>    },
<span id="line27362" class="line"></span>
<span id="line27363" class="line"></span>
<span id="line27364" class="line"></span>    /**
<span id="line27365" class="line"></span>     * Returns bounds taking constraints into account
<span id="line27366" class="line"></span>     * Added to improve constrained panning
<span id="line27367" class="line"></span>     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
<span id="line27368" class="line"></span>     * @returns {OpenSeadragon.Rect} The bounds in viewport coordinates after applying constraints. The returned $.Rect
<span id="line27369" class="line"></span>     *                               contains additional properties constraintsApplied, xConstrained and yConstrained.
<span id="line27370" class="line"></span>     *                               These flags indicate whether the viewport bounds were modified by the constraints
<span id="line27371" class="line"></span>     *                               of the viewer rectangle, and in which dimension(s).
<span id="line27372" class="line"></span>     */
<span id="line27373" class="line"></span>    getConstrainedBounds: function(current) {
<span id="line27374" class="line"></span>        const bounds = this.getBounds(current);
<span id="line27375" class="line"></span>        const constrainedBounds = this._applyBoundaryConstraints(bounds);
<span id="line27376" class="line"></span>
<span id="line27377" class="line"></span>        return constrainedBounds;
<span id="line27378" class="line"></span>    },
<span id="line27379" class="line"></span>
<span id="line27380" class="line"></span>    /**
<span id="line27381" class="line"></span>     * @function
<span id="line27382" class="line"></span>     * @param {OpenSeadragon.Point} delta
<span id="line27383" class="line"></span>     * @param {Boolean} immediately
<span id="line27384" class="line"></span>     * @returns {OpenSeadragon.Viewport} Chainable.
<span id="line27385" class="line"></span>     * @fires OpenSeadragon.Viewer.event:pan
<span id="line27386" class="line"></span>     */
<span id="line27387" class="line"></span>    panBy: function( delta, immediately ) {
<span id="line27388" class="line"></span>        const center = new $.Point();
<span id="line27389" class="line"></span>        if (immediately) {
<span id="line27390" class="line"></span>            center.x = this.centerSpringX.current.value;
<span id="line27391" class="line"></span>            center.y = this.centerSpringY.current.value;
<span id="line27392" class="line"></span>        } else {
<span id="line27393" class="line"></span>            center.x = this.centerSpringX.target.value;
<span id="line27394" class="line"></span>            center.y = this.centerSpringY.target.value;
<span id="line27395" class="line"></span>        }
<span id="line27396" class="line"></span>        return this.panTo( center.plus( delta ), immediately );
<span id="line27397" class="line"></span>    },
<span id="line27398" class="line"></span>
<span id="line27399" class="line"></span>    /**
<span id="line27400" class="line"></span>     * @function
<span id="line27401" class="line"></span>     * @param {OpenSeadragon.Point} center
<span id="line27402" class="line"></span>     * @param {Boolean} immediately
<span id="line27403" class="line"></span>     * @returns {OpenSeadragon.Viewport} Chainable.
<span id="line27404" class="line"></span>     * @fires OpenSeadragon.Viewer.event:pan
<span id="line27405" class="line"></span>     */
<span id="line27406" class="line"></span>    panTo: function( center, immediately ) {
<span id="line27407" class="line"></span>        if ( immediately ) {
<span id="line27408" class="line"></span>            this.centerSpringX.resetTo( center.x );
<span id="line27409" class="line"></span>            this.centerSpringY.resetTo( center.y );
<span id="line27410" class="line"></span>        } else {
<span id="line27411" class="line"></span>            this.centerSpringX.springTo( center.x );
<span id="line27412" class="line"></span>            this.centerSpringY.springTo( center.y );
<span id="line27413" class="line"></span>        }
<span id="line27414" class="line"></span>
<span id="line27415" class="line"></span>        if( this.viewer ){
<span id="line27416" class="line"></span>            /**
<span id="line27417" class="line"></span>             * Raised when the viewport is panned (see {@link OpenSeadragon.Viewport#panBy} and {@link OpenSeadragon.Viewport#panTo}).
<span id="line27418" class="line"></span>             *
<span id="line27419" class="line"></span>             * @event pan
<span id="line27420" class="line"></span>             * @memberof OpenSeadragon.Viewer
<span id="line27421" class="line"></span>             * @type {object}
<span id="line27422" class="line"></span>             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line27423" class="line"></span>             * @property {OpenSeadragon.Point} center
<span id="line27424" class="line"></span>             * @property {Boolean} immediately
<span id="line27425" class="line"></span>             * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line27426" class="line"></span>             */
<span id="line27427" class="line"></span>            this.viewer.raiseEvent( 'pan', {
<span id="line27428" class="line"></span>                center: center,
<span id="line27429" class="line"></span>                immediately: immediately
<span id="line27430" class="line"></span>            });
<span id="line27431" class="line"></span>        }
<span id="line27432" class="line"></span>
<span id="line27433" class="line"></span>        return this;
<span id="line27434" class="line"></span>    },
<span id="line27435" class="line"></span>
<span id="line27436" class="line"></span>    /**
<span id="line27437" class="line"></span>     * @function
<span id="line27438" class="line"></span>     * @returns {OpenSeadragon.Viewport} Chainable.
<span id="line27439" class="line"></span>     * @fires OpenSeadragon.Viewer.event:zoom
<span id="line27440" class="line"></span>     */
<span id="line27441" class="line"></span>    zoomBy: function(factor, refPoint, immediately) {
<span id="line27442" class="line"></span>        return this.zoomTo(
<span id="line27443" class="line"></span>            this.zoomSpring.target.value * factor, refPoint, immediately);
<span id="line27444" class="line"></span>    },
<span id="line27445" class="line"></span>
<span id="line27446" class="line"></span>    /**
<span id="line27447" class="line"></span>     * Zooms to the specified zoom level
<span id="line27448" class="line"></span>     * @function
<span id="line27449" class="line"></span>     * @param {Number} zoom The zoom level to zoom to.
<span id="line27450" class="line"></span>     * @param {OpenSeadragon.Point} [refPoint] The point which will stay at
<span id="line27451" class="line"></span>     * the same screen location. Defaults to the viewport center.
<span id="line27452" class="line"></span>     * @param {Boolean} [immediately=false]
<span id="line27453" class="line"></span>     * @returns {OpenSeadragon.Viewport} Chainable.
<span id="line27454" class="line"></span>     * @fires OpenSeadragon.Viewer.event:zoom
<span id="line27455" class="line"></span>     */
<span id="line27456" class="line"></span>    zoomTo: function(zoom, refPoint, immediately) {
<span id="line27457" class="line"></span>        const _this = this;
<span id="line27458" class="line"></span>
<span id="line27459" class="line"></span>        this.zoomPoint = refPoint instanceof $.Point &amp;&amp;
<span id="line27460" class="line"></span>            !isNaN(refPoint.x) &amp;&amp;
<span id="line27461" class="line"></span>            !isNaN(refPoint.y) ?
<span id="line27462" class="line"></span>            refPoint :
<span id="line27463" class="line"></span>            null;
<span id="line27464" class="line"></span>
<span id="line27465" class="line"></span>        if (immediately) {
<span id="line27466" class="line"></span>            this._adjustCenterSpringsForZoomPoint(function() {
<span id="line27467" class="line"></span>                _this.zoomSpring.resetTo(zoom);
<span id="line27468" class="line"></span>            });
<span id="line27469" class="line"></span>        } else {
<span id="line27470" class="line"></span>            this.zoomSpring.springTo(zoom);
<span id="line27471" class="line"></span>        }
<span id="line27472" class="line"></span>
<span id="line27473" class="line"></span>        if (this.viewer) {
<span id="line27474" class="line"></span>            /**
<span id="line27475" class="line"></span>             * Raised when the viewport zoom level changes (see {@link OpenSeadragon.Viewport#zoomBy} and {@link OpenSeadragon.Viewport#zoomTo}).
<span id="line27476" class="line"></span>             *
<span id="line27477" class="line"></span>             * @event zoom
<span id="line27478" class="line"></span>             * @memberof OpenSeadragon.Viewer
<span id="line27479" class="line"></span>             * @type {object}
<span id="line27480" class="line"></span>             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line27481" class="line"></span>             * @property {Number} zoom
<span id="line27482" class="line"></span>             * @property {OpenSeadragon.Point} refPoint
<span id="line27483" class="line"></span>             * @property {Boolean} immediately
<span id="line27484" class="line"></span>             * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line27485" class="line"></span>             */
<span id="line27486" class="line"></span>            this.viewer.raiseEvent('zoom', {
<span id="line27487" class="line"></span>                zoom: zoom,
<span id="line27488" class="line"></span>                refPoint: refPoint,
<span id="line27489" class="line"></span>                immediately: immediately
<span id="line27490" class="line"></span>            });
<span id="line27491" class="line"></span>        }
<span id="line27492" class="line"></span>
<span id="line27493" class="line"></span>        return this;
<span id="line27494" class="line"></span>    },
<span id="line27495" class="line"></span>
<span id="line27496" class="line"></span>    /**
<span id="line27497" class="line"></span>     * Rotates this viewport to the angle specified.
<span id="line27498" class="line"></span>     * @function
<span id="line27499" class="line"></span>     * @param {Number} degrees The degrees to set the rotation to.
<span id="line27500" class="line"></span>     * @param {Boolean} [immediately=false] Whether to animate to the new angle
<span id="line27501" class="line"></span>     * or rotate immediately.
<span id="line27502" class="line"></span>     * * @returns {OpenSeadragon.Viewport} Chainable.
<span id="line27503" class="line"></span>     */
<span id="line27504" class="line"></span>    setRotation: function(degrees, immediately) {
<span id="line27505" class="line"></span>        return this.rotateTo(degrees, null, immediately);
<span id="line27506" class="line"></span>    },
<span id="line27507" class="line"></span>
<span id="line27508" class="line"></span>    /**
<span id="line27509" class="line"></span>     * Gets the current rotation in degrees.
<span id="line27510" class="line"></span>     * @function
<span id="line27511" class="line"></span>     * @param {Boolean} [current=false] True for current rotation, false for target.
<span id="line27512" class="line"></span>     * @returns {Number} The current rotation in degrees.
<span id="line27513" class="line"></span>     */
<span id="line27514" class="line"></span>    getRotation: function(current) {
<span id="line27515" class="line"></span>        return current ?
<span id="line27516" class="line"></span>            this.degreesSpring.current.value :
<span id="line27517" class="line"></span>            this.degreesSpring.target.value;
<span id="line27518" class="line"></span>    },
<span id="line27519" class="line"></span>
<span id="line27520" class="line"></span>    /**
<span id="line27521" class="line"></span>     * Rotates this viewport to the angle specified around a pivot point. Alias for rotateTo.
<span id="line27522" class="line"></span>     * @function
<span id="line27523" class="line"></span>     * @param {Number} degrees The degrees to set the rotation to.
<span id="line27524" class="line"></span>     * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
<span id="line27525" class="line"></span>     * around which the rotation should be performed. Defaults to the center of the viewport.
<span id="line27526" class="line"></span>     * @param {Boolean} [immediately=false] Whether to animate to the new angle
<span id="line27527" class="line"></span>     * or rotate immediately.
<span id="line27528" class="line"></span>     * * @returns {OpenSeadragon.Viewport} Chainable.
<span id="line27529" class="line"></span>     */
<span id="line27530" class="line"></span>    setRotationWithPivot: function(degrees, pivot, immediately) {
<span id="line27531" class="line"></span>        return this.rotateTo(degrees, pivot, immediately);
<span id="line27532" class="line"></span>    },
<span id="line27533" class="line"></span>
<span id="line27534" class="line"></span>    /**
<span id="line27535" class="line"></span>     * Rotates this viewport to the angle specified.
<span id="line27536" class="line"></span>     * @function
<span id="line27537" class="line"></span>     * @param {Number} degrees The degrees to set the rotation to.
<span id="line27538" class="line"></span>     * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
<span id="line27539" class="line"></span>     * around which the rotation should be performed. Defaults to the center of the viewport.
<span id="line27540" class="line"></span>     * @param {Boolean} [immediately=false] Whether to animate to the new angle
<span id="line27541" class="line"></span>     * or rotate immediately.
<span id="line27542" class="line"></span>     * @returns {OpenSeadragon.Viewport} Chainable.
<span id="line27543" class="line"></span>     */
<span id="line27544" class="line"></span>    rotateTo: function(degrees, pivot, immediately){
<span id="line27545" class="line"></span>        if (!this.viewer || !this.viewer.drawer.canRotate()) {
<span id="line27546" class="line"></span>            return this;
<span id="line27547" class="line"></span>        }
<span id="line27548" class="line"></span>
<span id="line27549" class="line"></span>        if (this.degreesSpring.target.value === degrees &amp;&amp;
<span id="line27550" class="line"></span>            this.degreesSpring.isAtTargetValue()) {
<span id="line27551" class="line"></span>            return this;
<span id="line27552" class="line"></span>        }
<span id="line27553" class="line"></span>        this.rotationPivot = pivot instanceof $.Point &amp;&amp;
<span id="line27554" class="line"></span>            !isNaN(pivot.x) &amp;&amp;
<span id="line27555" class="line"></span>            !isNaN(pivot.y) ?
<span id="line27556" class="line"></span>            pivot :
<span id="line27557" class="line"></span>            null;
<span id="line27558" class="line"></span>        if (immediately) {
<span id="line27559" class="line"></span>            if(this.rotationPivot){
<span id="line27560" class="line"></span>                const changeInDegrees = degrees - this._oldDegrees;
<span id="line27561" class="line"></span>                if(!changeInDegrees){
<span id="line27562" class="line"></span>                    this.rotationPivot = null;
<span id="line27563" class="line"></span>                    return this;
<span id="line27564" class="line"></span>                }
<span id="line27565" class="line"></span>                this._rotateAboutPivot(degrees);
<span id="line27566" class="line"></span>            } else{
<span id="line27567" class="line"></span>                this.degreesSpring.resetTo(degrees);
<span id="line27568" class="line"></span>            }
<span id="line27569" class="line"></span>        } else {
<span id="line27570" class="line"></span>            const normalizedFrom = $.positiveModulo(this.degreesSpring.current.value, 360);
<span id="line27571" class="line"></span>            let normalizedTo = $.positiveModulo(degrees, 360);
<span id="line27572" class="line"></span>            const diff = normalizedTo - normalizedFrom;
<span id="line27573" class="line"></span>            if (diff &gt; 180) {
<span id="line27574" class="line"></span>                normalizedTo -= 360;
<span id="line27575" class="line"></span>            } else if (diff &lt; -180) {
<span id="line27576" class="line"></span>                normalizedTo += 360;
<span id="line27577" class="line"></span>            }
<span id="line27578" class="line"></span>
<span id="line27579" class="line"></span>            const reverseDiff = normalizedFrom - normalizedTo;
<span id="line27580" class="line"></span>            this.degreesSpring.resetTo(degrees + reverseDiff);
<span id="line27581" class="line"></span>            this.degreesSpring.springTo(degrees);
<span id="line27582" class="line"></span>        }
<span id="line27583" class="line"></span>
<span id="line27584" class="line"></span>        this._setContentBounds(
<span id="line27585" class="line"></span>            this.viewer.world.getHomeBounds(),
<span id="line27586" class="line"></span>            this.viewer.world.getContentFactor());
<span id="line27587" class="line"></span>        this.viewer.forceRedraw();
<span id="line27588" class="line"></span>
<span id="line27589" class="line"></span>        /**
<span id="line27590" class="line"></span>         * Raised when rotation has been changed.
<span id="line27591" class="line"></span>         *
<span id="line27592" class="line"></span>         * @event rotate
<span id="line27593" class="line"></span>         * @memberof OpenSeadragon.Viewer
<span id="line27594" class="line"></span>         * @type {object}
<span id="line27595" class="line"></span>         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line27596" class="line"></span>         * @property {Number} degrees - The number of degrees the rotation was set to.
<span id="line27597" class="line"></span>         * @property {Boolean} immediately - Whether the rotation happened immediately or was animated
<span id="line27598" class="line"></span>         * @property {OpenSeadragon.Point} pivot - The point in viewport coordinates around which the rotation (if any) happened
<span id="line27599" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line27600" class="line"></span>         */
<span id="line27601" class="line"></span>        this.viewer.raiseEvent('rotate', {degrees: degrees, immediately: !!immediately, pivot: this.rotationPivot || this.getCenter()});
<span id="line27602" class="line"></span>        return this;
<span id="line27603" class="line"></span>    },
<span id="line27604" class="line"></span>
<span id="line27605" class="line"></span>    /**
<span id="line27606" class="line"></span>     * Rotates this viewport by the angle specified.
<span id="line27607" class="line"></span>     * @function
<span id="line27608" class="line"></span>     * @param {Number} degrees The degrees by which to rotate the viewport.
<span id="line27609" class="line"></span>     * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
<span id="line27610" class="line"></span>     * around which the rotation should be performed. Defaults to the center of the viewport.
<span id="line27611" class="line"></span>     * * @param {Boolean} [immediately=false] Whether to animate to the new angle
<span id="line27612" class="line"></span>     * or rotate immediately.
<span id="line27613" class="line"></span>     * @returns {OpenSeadragon.Viewport} Chainable.
<span id="line27614" class="line"></span>     */
<span id="line27615" class="line"></span>    rotateBy: function(degrees, pivot, immediately){
<span id="line27616" class="line"></span>        return this.rotateTo(this.degreesSpring.target.value + degrees, pivot, immediately);
<span id="line27617" class="line"></span>    },
<span id="line27618" class="line"></span>
<span id="line27619" class="line"></span>    /**
<span id="line27620" class="line"></span>     * @function
<span id="line27621" class="line"></span>     * @returns {OpenSeadragon.Viewport} Chainable.
<span id="line27622" class="line"></span>     * @fires OpenSeadragon.Viewer.event:resize
<span id="line27623" class="line"></span>     */
<span id="line27624" class="line"></span>    resize: function( newContainerSize, maintain ) {
<span id="line27625" class="line"></span>        const oldBounds = this.getBoundsNoRotate();
<span id="line27626" class="line"></span>        const newBounds = oldBounds;
<span id="line27627" class="line"></span>        let widthDeltaFactor;
<span id="line27628" class="line"></span>        this._sizeChanged = !this.containerSize.equals(newContainerSize);
<span id="line27629" class="line"></span>
<span id="line27630" class="line"></span>        this.containerSize.x = newContainerSize.x;
<span id="line27631" class="line"></span>        this.containerSize.y = newContainerSize.y;
<span id="line27632" class="line"></span>
<span id="line27633" class="line"></span>        this._updateContainerInnerSize();
<span id="line27634" class="line"></span>
<span id="line27635" class="line"></span>        if ( maintain ) {
<span id="line27636" class="line"></span>            // TODO: widthDeltaFactor will always be 1; probably not what's intended
<span id="line27637" class="line"></span>            widthDeltaFactor = newContainerSize.x / this.containerSize.x;
<span id="line27638" class="line"></span>            newBounds.width  = oldBounds.width * widthDeltaFactor;
<span id="line27639" class="line"></span>            newBounds.height = newBounds.width / this.getAspectRatio();
<span id="line27640" class="line"></span>        }
<span id="line27641" class="line"></span>
<span id="line27642" class="line"></span>        if( this.viewer ){
<span id="line27643" class="line"></span>            /**
<span id="line27644" class="line"></span>             * Raised when a viewer resize operation is initiated (see {@link OpenSeadragon.Viewport#resize}).
<span id="line27645" class="line"></span>             * This event happens before the viewport bounds have been updated.
<span id="line27646" class="line"></span>             * See also {@link OpenSeadragon.Viewer#after-resize} which reflects
<span id="line27647" class="line"></span>             * the new viewport bounds following the resize action.
<span id="line27648" class="line"></span>             *
<span id="line27649" class="line"></span>             * @event resize
<span id="line27650" class="line"></span>             * @memberof OpenSeadragon.Viewer
<span id="line27651" class="line"></span>             * @type {object}
<span id="line27652" class="line"></span>             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line27653" class="line"></span>             * @property {OpenSeadragon.Point} newContainerSize
<span id="line27654" class="line"></span>             * @property {Boolean} maintain
<span id="line27655" class="line"></span>             * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line27656" class="line"></span>             */
<span id="line27657" class="line"></span>            this.viewer.raiseEvent( 'resize', {
<span id="line27658" class="line"></span>                newContainerSize: newContainerSize,
<span id="line27659" class="line"></span>                maintain: maintain
<span id="line27660" class="line"></span>            });
<span id="line27661" class="line"></span>        }
<span id="line27662" class="line"></span>
<span id="line27663" class="line"></span>        const output = this.fitBounds( newBounds, true );
<span id="line27664" class="line"></span>
<span id="line27665" class="line"></span>        if( this.viewer ){
<span id="line27666" class="line"></span>            /**
<span id="line27667" class="line"></span>             * Raised after the viewer is resized (see {@link OpenSeadragon.Viewport#resize}).
<span id="line27668" class="line"></span>             * See also {@link OpenSeadragon.Viewer#resize} event which happens
<span id="line27669" class="line"></span>             * before the new bounds have been calculated and applied.
<span id="line27670" class="line"></span>             *
<span id="line27671" class="line"></span>             * @event after-resize
<span id="line27672" class="line"></span>             * @memberof OpenSeadragon.Viewer
<span id="line27673" class="line"></span>             * @type {object}
<span id="line27674" class="line"></span>             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
<span id="line27675" class="line"></span>             * @property {OpenSeadragon.Point} newContainerSize
<span id="line27676" class="line"></span>             * @property {Boolean} maintain
<span id="line27677" class="line"></span>             * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line27678" class="line"></span>             */
<span id="line27679" class="line"></span>            this.viewer.raiseEvent( 'after-resize', {
<span id="line27680" class="line"></span>                newContainerSize: newContainerSize,
<span id="line27681" class="line"></span>                maintain: maintain
<span id="line27682" class="line"></span>            });
<span id="line27683" class="line"></span>        }
<span id="line27684" class="line"></span>
<span id="line27685" class="line"></span>        return output;
<span id="line27686" class="line"></span>    },
<span id="line27687" class="line"></span>
<span id="line27688" class="line"></span>    // private
<span id="line27689" class="line"></span>    _updateContainerInnerSize: function() {
<span id="line27690" class="line"></span>        this._containerInnerSize = new $.Point(
<span id="line27691" class="line"></span>            Math.max(1, this.containerSize.x - (this._margins.left + this._margins.right)),
<span id="line27692" class="line"></span>            Math.max(1, this.containerSize.y - (this._margins.top + this._margins.bottom))
<span id="line27693" class="line"></span>        );
<span id="line27694" class="line"></span>    },
<span id="line27695" class="line"></span>
<span id="line27696" class="line"></span>    /**
<span id="line27697" class="line"></span>     * Update the zoom, degrees, and center (X and Y) springs.
<span id="line27698" class="line"></span>     * @function
<span id="line27699" class="line"></span>     * @returns {Boolean} True if the viewport is still animating, false otherwise.
<span id="line27700" class="line"></span>     */
<span id="line27701" class="line"></span>    update: function() {
<span id="line27702" class="line"></span>        const _this = this;
<span id="line27703" class="line"></span>        this._adjustCenterSpringsForZoomPoint(function() {
<span id="line27704" class="line"></span>            _this.zoomSpring.update();
<span id="line27705" class="line"></span>        });
<span id="line27706" class="line"></span>        if(this.degreesSpring.isAtTargetValue()){
<span id="line27707" class="line"></span>            this.rotationPivot = null;
<span id="line27708" class="line"></span>        }
<span id="line27709" class="line"></span>        this.centerSpringX.update();
<span id="line27710" class="line"></span>        this.centerSpringY.update();
<span id="line27711" class="line"></span>
<span id="line27712" class="line"></span>        if(this.rotationPivot){
<span id="line27713" class="line"></span>            this._rotateAboutPivot(true);
<span id="line27714" class="line"></span>        }
<span id="line27715" class="line"></span>        else{
<span id="line27716" class="line"></span>            this.degreesSpring.update();
<span id="line27717" class="line"></span>        }
<span id="line27718" class="line"></span>
<span id="line27719" class="line"></span>
<span id="line27720" class="line"></span>        const changed = this.centerSpringX.current.value !== this._oldCenterX ||
<span id="line27721" class="line"></span>            this.centerSpringY.current.value !== this._oldCenterY ||
<span id="line27722" class="line"></span>            this.zoomSpring.current.value !== this._oldZoom ||
<span id="line27723" class="line"></span>            this.degreesSpring.current.value !== this._oldDegrees ||
<span id="line27724" class="line"></span>            this._sizeChanged;
<span id="line27725" class="line"></span>
<span id="line27726" class="line"></span>        this._sizeChanged = false;
<span id="line27727" class="line"></span>
<span id="line27728" class="line"></span>
<span id="line27729" class="line"></span>        this._oldCenterX = this.centerSpringX.current.value;
<span id="line27730" class="line"></span>        this._oldCenterY = this.centerSpringY.current.value;
<span id="line27731" class="line"></span>        this._oldZoom    = this.zoomSpring.current.value;
<span id="line27732" class="line"></span>        this._oldDegrees = this.degreesSpring.current.value;
<span id="line27733" class="line"></span>
<span id="line27734" class="line"></span>        const isAnimating = changed ||
<span id="line27735" class="line"></span>                          !this.zoomSpring.isAtTargetValue() ||
<span id="line27736" class="line"></span>                          !this.centerSpringX.isAtTargetValue() ||
<span id="line27737" class="line"></span>                          !this.centerSpringY.isAtTargetValue() ||
<span id="line27738" class="line"></span>                          !this.degreesSpring.isAtTargetValue();
<span id="line27739" class="line"></span>
<span id="line27740" class="line"></span>        return isAnimating;
<span id="line27741" class="line"></span>    },
<span id="line27742" class="line"></span>
<span id="line27743" class="line"></span>    // private - pass true to use spring, or a number for degrees for immediate rotation
<span id="line27744" class="line"></span>    _rotateAboutPivot: function(degreesOrUseSpring){
<span id="line27745" class="line"></span>        const useSpring = degreesOrUseSpring === true;
<span id="line27746" class="line"></span>
<span id="line27747" class="line"></span>        const delta = this.rotationPivot.minus(this.getCenter());
<span id="line27748" class="line"></span>        this.centerSpringX.shiftBy(delta.x);
<span id="line27749" class="line"></span>        this.centerSpringY.shiftBy(delta.y);
<span id="line27750" class="line"></span>
<span id="line27751" class="line"></span>        if(useSpring){
<span id="line27752" class="line"></span>            this.degreesSpring.update();
<span id="line27753" class="line"></span>        } else {
<span id="line27754" class="line"></span>            this.degreesSpring.resetTo(degreesOrUseSpring);
<span id="line27755" class="line"></span>        }
<span id="line27756" class="line"></span>
<span id="line27757" class="line"></span>        const changeInDegrees = this.degreesSpring.current.value - this._oldDegrees;
<span id="line27758" class="line"></span>        const rdelta = delta.rotate(changeInDegrees * -1).times(-1);
<span id="line27759" class="line"></span>        this.centerSpringX.shiftBy(rdelta.x);
<span id="line27760" class="line"></span>        this.centerSpringY.shiftBy(rdelta.y);
<span id="line27761" class="line"></span>    },
<span id="line27762" class="line"></span>
<span id="line27763" class="line"></span>    // private
<span id="line27764" class="line"></span>    _adjustCenterSpringsForZoomPoint: function(zoomSpringHandler) {
<span id="line27765" class="line"></span>        if (this.zoomPoint) {
<span id="line27766" class="line"></span>            const oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
<span id="line27767" class="line"></span>            zoomSpringHandler();
<span id="line27768" class="line"></span>            const newZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
<span id="line27769" class="line"></span>
<span id="line27770" class="line"></span>            const deltaZoomPixels = newZoomPixel.minus(oldZoomPixel);
<span id="line27771" class="line"></span>            const deltaZoomPoints = this.deltaPointsFromPixels(
<span id="line27772" class="line"></span>                deltaZoomPixels, true);
<span id="line27773" class="line"></span>
<span id="line27774" class="line"></span>            this.centerSpringX.shiftBy(deltaZoomPoints.x);
<span id="line27775" class="line"></span>            this.centerSpringY.shiftBy(deltaZoomPoints.y);
<span id="line27776" class="line"></span>
<span id="line27777" class="line"></span>            if (this.zoomSpring.isAtTargetValue()) {
<span id="line27778" class="line"></span>                this.zoomPoint = null;
<span id="line27779" class="line"></span>            }
<span id="line27780" class="line"></span>        } else {
<span id="line27781" class="line"></span>            zoomSpringHandler();
<span id="line27782" class="line"></span>        }
<span id="line27783" class="line"></span>    },
<span id="line27784" class="line"></span>
<span id="line27785" class="line"></span>    /**
<span id="line27786" class="line"></span>     * Convert a delta (translation vector) from viewport coordinates to pixels
<span id="line27787" class="line"></span>     * coordinates. This method does not take rotation into account.
<span id="line27788" class="line"></span>     * Consider using deltaPixelsFromPoints if you need to account for rotation.
<span id="line27789" class="line"></span>     * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.
<span id="line27790" class="line"></span>     * @param {Boolean} [current=false] - Pass true for the current location;
<span id="line27791" class="line"></span>     * defaults to false (target location).
<span id="line27792" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line27793" class="line"></span>     */
<span id="line27794" class="line"></span>    deltaPixelsFromPointsNoRotate: function(deltaPoints, current) {
<span id="line27795" class="line"></span>        return deltaPoints.times(
<span id="line27796" class="line"></span>            this._containerInnerSize.x * this.getZoom(current)
<span id="line27797" class="line"></span>        );
<span id="line27798" class="line"></span>    },
<span id="line27799" class="line"></span>
<span id="line27800" class="line"></span>    /**
<span id="line27801" class="line"></span>     * Convert a delta (translation vector) from viewport coordinates to pixels
<span id="line27802" class="line"></span>     * coordinates.
<span id="line27803" class="line"></span>     * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.
<span id="line27804" class="line"></span>     * @param {Boolean} [current=false] - Pass true for the current location;
<span id="line27805" class="line"></span>     * defaults to false (target location).
<span id="line27806" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line27807" class="line"></span>     */
<span id="line27808" class="line"></span>    deltaPixelsFromPoints: function(deltaPoints, current) {
<span id="line27809" class="line"></span>        return this.deltaPixelsFromPointsNoRotate(
<span id="line27810" class="line"></span>            deltaPoints.rotate(this.getRotation(current)),
<span id="line27811" class="line"></span>            current);
<span id="line27812" class="line"></span>    },
<span id="line27813" class="line"></span>
<span id="line27814" class="line"></span>    /**
<span id="line27815" class="line"></span>     * Convert a delta (translation vector) from pixels coordinates to viewport
<span id="line27816" class="line"></span>     * coordinates. This method does not take rotation into account.
<span id="line27817" class="line"></span>     * Consider using deltaPointsFromPixels if you need to account for rotation.
<span id="line27818" class="line"></span>     * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.
<span id="line27819" class="line"></span>     * @param {Boolean} [current=false] - Pass true for the current location;
<span id="line27820" class="line"></span>     * defaults to false (target location).
<span id="line27821" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line27822" class="line"></span>     */
<span id="line27823" class="line"></span>    deltaPointsFromPixelsNoRotate: function(deltaPixels, current) {
<span id="line27824" class="line"></span>        return deltaPixels.divide(
<span id="line27825" class="line"></span>            this._containerInnerSize.x * this.getZoom(current)
<span id="line27826" class="line"></span>        );
<span id="line27827" class="line"></span>    },
<span id="line27828" class="line"></span>
<span id="line27829" class="line"></span>    /**
<span id="line27830" class="line"></span>     * Convert a delta (translation vector) from pixels coordinates to viewport
<span id="line27831" class="line"></span>     * coordinates.
<span id="line27832" class="line"></span>     * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.
<span id="line27833" class="line"></span>     * @param {Boolean} [current=false] - Pass true for the current location;
<span id="line27834" class="line"></span>     * defaults to false (target location).
<span id="line27835" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line27836" class="line"></span>     */
<span id="line27837" class="line"></span>    deltaPointsFromPixels: function(deltaPixels, current) {
<span id="line27838" class="line"></span>        return this.deltaPointsFromPixelsNoRotate(deltaPixels, current)
<span id="line27839" class="line"></span>            .rotate(-this.getRotation(current));
<span id="line27840" class="line"></span>    },
<span id="line27841" class="line"></span>
<span id="line27842" class="line"></span>    /**
<span id="line27843" class="line"></span>     * Convert viewport coordinates to pixels coordinates.
<span id="line27844" class="line"></span>     * This method does not take rotation into account.
<span id="line27845" class="line"></span>     * Consider using pixelFromPoint if you need to account for rotation.
<span id="line27846" class="line"></span>     * @param {OpenSeadragon.Point} point the viewport coordinates
<span id="line27847" class="line"></span>     * @param {Boolean} [current=false] - Pass true for the current location;
<span id="line27848" class="line"></span>     * defaults to false (target location).
<span id="line27849" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line27850" class="line"></span>     */
<span id="line27851" class="line"></span>    pixelFromPointNoRotate: function(point, current) {
<span id="line27852" class="line"></span>        return this._pixelFromPointNoRotate(
<span id="line27853" class="line"></span>            point, this.getBoundsNoRotate(current));
<span id="line27854" class="line"></span>    },
<span id="line27855" class="line"></span>
<span id="line27856" class="line"></span>    /**
<span id="line27857" class="line"></span>     * Convert viewport coordinates to pixel coordinates.
<span id="line27858" class="line"></span>     * @param {OpenSeadragon.Point} point the viewport coordinates
<span id="line27859" class="line"></span>     * @param {Boolean} [current=false] - Pass true for the current location;
<span id="line27860" class="line"></span>     * defaults to false (target location).
<span id="line27861" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line27862" class="line"></span>     */
<span id="line27863" class="line"></span>    pixelFromPoint: function(point, current) {
<span id="line27864" class="line"></span>        return this._pixelFromPoint(point, this.getBoundsNoRotate(current));
<span id="line27865" class="line"></span>    },
<span id="line27866" class="line"></span>
<span id="line27867" class="line"></span>    // private
<span id="line27868" class="line"></span>    _pixelFromPointNoRotate: function(point, bounds) {
<span id="line27869" class="line"></span>        return point.minus(
<span id="line27870" class="line"></span>            bounds.getTopLeft()
<span id="line27871" class="line"></span>        ).times(
<span id="line27872" class="line"></span>            this._containerInnerSize.x / bounds.width
<span id="line27873" class="line"></span>        ).plus(
<span id="line27874" class="line"></span>            new $.Point(this._margins.left, this._margins.top)
<span id="line27875" class="line"></span>        );
<span id="line27876" class="line"></span>    },
<span id="line27877" class="line"></span>
<span id="line27878" class="line"></span>    // private
<span id="line27879" class="line"></span>    _pixelFromPoint: function(point, bounds) {
<span id="line27880" class="line"></span>        return this._pixelFromPointNoRotate(
<span id="line27881" class="line"></span>            point.rotate(this.getRotation(true), this.getCenter(true)),
<span id="line27882" class="line"></span>            bounds);
<span id="line27883" class="line"></span>    },
<span id="line27884" class="line"></span>
<span id="line27885" class="line"></span>    /**
<span id="line27886" class="line"></span>     * Convert pixel coordinates to viewport coordinates.
<span id="line27887" class="line"></span>     * This method does not take rotation into account.
<span id="line27888" class="line"></span>     * Consider using pointFromPixel if you need to account for rotation.
<span id="line27889" class="line"></span>     * @param {OpenSeadragon.Point} pixel Pixel coordinates
<span id="line27890" class="line"></span>     * @param {Boolean} [current=false] - Pass true for the current location;
<span id="line27891" class="line"></span>     * defaults to false (target location).
<span id="line27892" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line27893" class="line"></span>     */
<span id="line27894" class="line"></span>    pointFromPixelNoRotate: function(pixel, current) {
<span id="line27895" class="line"></span>        const bounds = this.getBoundsNoRotate(current);
<span id="line27896" class="line"></span>        return pixel.minus(
<span id="line27897" class="line"></span>            new $.Point(this._margins.left, this._margins.top)
<span id="line27898" class="line"></span>        ).divide(
<span id="line27899" class="line"></span>            this._containerInnerSize.x / bounds.width
<span id="line27900" class="line"></span>        ).plus(
<span id="line27901" class="line"></span>            bounds.getTopLeft()
<span id="line27902" class="line"></span>        );
<span id="line27903" class="line"></span>    },
<span id="line27904" class="line"></span>
<span id="line27905" class="line"></span>    /**
<span id="line27906" class="line"></span>     * Convert pixel coordinates to viewport coordinates.
<span id="line27907" class="line"></span>     * @param {OpenSeadragon.Point} pixel Pixel coordinates
<span id="line27908" class="line"></span>     * @param {Boolean} [current=false] - Pass true for the current location;
<span id="line27909" class="line"></span>     * defaults to false (target location).
<span id="line27910" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line27911" class="line"></span>     */
<span id="line27912" class="line"></span>    pointFromPixel: function(pixel, current) {
<span id="line27913" class="line"></span>        return this.pointFromPixelNoRotate(pixel, current).rotate(
<span id="line27914" class="line"></span>            -this.getRotation(current),
<span id="line27915" class="line"></span>            this.getCenter(current)
<span id="line27916" class="line"></span>        );
<span id="line27917" class="line"></span>    },
<span id="line27918" class="line"></span>
<span id="line27919" class="line"></span>    // private
<span id="line27920" class="line"></span>    _viewportToImageDelta: function( viewerX, viewerY ) {
<span id="line27921" class="line"></span>        const scale = this._contentBoundsNoRotate.width;
<span id="line27922" class="line"></span>        return new $.Point(
<span id="line27923" class="line"></span>            viewerX * this._contentSizeNoRotate.x / scale,
<span id="line27924" class="line"></span>            viewerY * this._contentSizeNoRotate.x / scale);
<span id="line27925" class="line"></span>    },
<span id="line27926" class="line"></span>
<span id="line27927" class="line"></span>    /**
<span id="line27928" class="line"></span>     * Translates from OpenSeadragon viewer coordinate system to image coordinate system.
<span id="line27929" class="line"></span>     * This method can be called either by passing X,Y coordinates or an
<span id="line27930" class="line"></span>     * OpenSeadragon.Point
<span id="line27931" class="line"></span>     * Note: not accurate with multi-image; use TiledImage.viewportToImageCoordinates instead.
<span id="line27932" class="line"></span>     * @function
<span id="line27933" class="line"></span>     * @param {(OpenSeadragon.Point|Number)} viewerX either a point or the X
<span id="line27934" class="line"></span>     * coordinate in viewport coordinate system.
<span id="line27935" class="line"></span>     * @param {Number} [viewerY] Y coordinate in viewport coordinate system.
<span id="line27936" class="line"></span>     * @returns {OpenSeadragon.Point} a point representing the coordinates in the image.
<span id="line27937" class="line"></span>     */
<span id="line27938" class="line"></span>    viewportToImageCoordinates: function(viewerX, viewerY) {
<span id="line27939" class="line"></span>        if (viewerX instanceof $.Point) {
<span id="line27940" class="line"></span>            //they passed a point instead of individual components
<span id="line27941" class="line"></span>            return this.viewportToImageCoordinates(viewerX.x, viewerX.y);
<span id="line27942" class="line"></span>        }
<span id="line27943" class="line"></span>
<span id="line27944" class="line"></span>        if (this.viewer) {
<span id="line27945" class="line"></span>            const count = this.viewer.world.getItemCount();
<span id="line27946" class="line"></span>            if (count &gt; 1) {
<span id="line27947" class="line"></span>                if (!this.silenceMultiImageWarnings) {
<span id="line27948" class="line"></span>                    $.console.error('[Viewport.viewportToImageCoordinates] is not accurate ' +
<span id="line27949" class="line"></span>                        'with multi-image; use TiledImage.viewportToImageCoordinates instead.');
<span id="line27950" class="line"></span>                }
<span id="line27951" class="line"></span>            } else if (count === 1) {
<span id="line27952" class="line"></span>                // It is better to use TiledImage.viewportToImageCoordinates
<span id="line27953" class="line"></span>                // because this._contentBoundsNoRotate can not be relied on
<span id="line27954" class="line"></span>                // with clipping.
<span id="line27955" class="line"></span>                const item = this.viewer.world.getItemAt(0);
<span id="line27956" class="line"></span>                return item.viewportToImageCoordinates(viewerX, viewerY, true);
<span id="line27957" class="line"></span>            }
<span id="line27958" class="line"></span>        }
<span id="line27959" class="line"></span>
<span id="line27960" class="line"></span>        return this._viewportToImageDelta(
<span id="line27961" class="line"></span>            viewerX - this._contentBoundsNoRotate.x,
<span id="line27962" class="line"></span>            viewerY - this._contentBoundsNoRotate.y);
<span id="line27963" class="line"></span>    },
<span id="line27964" class="line"></span>
<span id="line27965" class="line"></span>    // private
<span id="line27966" class="line"></span>    _imageToViewportDelta: function( imageX, imageY ) {
<span id="line27967" class="line"></span>        const scale = this._contentBoundsNoRotate.width;
<span id="line27968" class="line"></span>        return new $.Point(
<span id="line27969" class="line"></span>            imageX / this._contentSizeNoRotate.x * scale,
<span id="line27970" class="line"></span>            imageY / this._contentSizeNoRotate.x * scale);
<span id="line27971" class="line"></span>    },
<span id="line27972" class="line"></span>
<span id="line27973" class="line"></span>    /**
<span id="line27974" class="line"></span>     * Translates from image coordinate system to OpenSeadragon viewer coordinate system
<span id="line27975" class="line"></span>     * This method can be called either by passing X,Y coordinates or an
<span id="line27976" class="line"></span>     * OpenSeadragon.Point
<span id="line27977" class="line"></span>     * Note: not accurate with multi-image; use TiledImage.imageToViewportCoordinates instead.
<span id="line27978" class="line"></span>     * @function
<span id="line27979" class="line"></span>     * @param {(OpenSeadragon.Point | Number)} imageX the point or the
<span id="line27980" class="line"></span>     * X coordinate in image coordinate system.
<span id="line27981" class="line"></span>     * @param {Number} [imageY] Y coordinate in image coordinate system.
<span id="line27982" class="line"></span>     * @returns {OpenSeadragon.Point} a point representing the coordinates in the viewport.
<span id="line27983" class="line"></span>     */
<span id="line27984" class="line"></span>    imageToViewportCoordinates: function(imageX, imageY) {
<span id="line27985" class="line"></span>        if (imageX instanceof $.Point) {
<span id="line27986" class="line"></span>            //they passed a point instead of individual components
<span id="line27987" class="line"></span>            return this.imageToViewportCoordinates(imageX.x, imageX.y);
<span id="line27988" class="line"></span>        }
<span id="line27989" class="line"></span>
<span id="line27990" class="line"></span>        if (this.viewer) {
<span id="line27991" class="line"></span>            const count = this.viewer.world.getItemCount();
<span id="line27992" class="line"></span>            if (count &gt; 1) {
<span id="line27993" class="line"></span>                if (!this.silenceMultiImageWarnings) {
<span id="line27994" class="line"></span>                    $.console.error('[Viewport.imageToViewportCoordinates] is not accurate ' +
<span id="line27995" class="line"></span>                        'with multi-image; use TiledImage.imageToViewportCoordinates instead.');
<span id="line27996" class="line"></span>                }
<span id="line27997" class="line"></span>            } else if (count === 1) {
<span id="line27998" class="line"></span>                // It is better to use TiledImage.viewportToImageCoordinates
<span id="line27999" class="line"></span>                // because this._contentBoundsNoRotate can not be relied on
<span id="line28000" class="line"></span>                // with clipping.
<span id="line28001" class="line"></span>                const item = this.viewer.world.getItemAt(0);
<span id="line28002" class="line"></span>                return item.imageToViewportCoordinates(imageX, imageY, true);
<span id="line28003" class="line"></span>            }
<span id="line28004" class="line"></span>        }
<span id="line28005" class="line"></span>
<span id="line28006" class="line"></span>        const point = this._imageToViewportDelta(imageX, imageY);
<span id="line28007" class="line"></span>        point.x += this._contentBoundsNoRotate.x;
<span id="line28008" class="line"></span>        point.y += this._contentBoundsNoRotate.y;
<span id="line28009" class="line"></span>        return point;
<span id="line28010" class="line"></span>    },
<span id="line28011" class="line"></span>
<span id="line28012" class="line"></span>    /**
<span id="line28013" class="line"></span>     * Translates from a rectangle which describes a portion of the image in
<span id="line28014" class="line"></span>     * pixel coordinates to OpenSeadragon viewport rectangle coordinates.
<span id="line28015" class="line"></span>     * This method can be called either by passing X,Y,width,height or an
<span id="line28016" class="line"></span>     * OpenSeadragon.Rect
<span id="line28017" class="line"></span>     * Note: not accurate with multi-image; use TiledImage.imageToViewportRectangle instead.
<span id="line28018" class="line"></span>     * @function
<span id="line28019" class="line"></span>     * @param {(OpenSeadragon.Rect | Number)} imageX the rectangle or the X
<span id="line28020" class="line"></span>     * coordinate of the top left corner of the rectangle in image coordinate system.
<span id="line28021" class="line"></span>     * @param {Number} [imageY] the Y coordinate of the top left corner of the rectangle
<span id="line28022" class="line"></span>     * in image coordinate system.
<span id="line28023" class="line"></span>     * @param {Number} [pixelWidth] the width in pixel of the rectangle.
<span id="line28024" class="line"></span>     * @param {Number} [pixelHeight] the height in pixel of the rectangle.
<span id="line28025" class="line"></span>     * @returns {OpenSeadragon.Rect} This image's bounds in viewport coordinates
<span id="line28026" class="line"></span>     */
<span id="line28027" class="line"></span>    imageToViewportRectangle: function(imageX, imageY, pixelWidth, pixelHeight) {
<span id="line28028" class="line"></span>        let rect = imageX;
<span id="line28029" class="line"></span>        if (!(rect instanceof $.Rect)) {
<span id="line28030" class="line"></span>            //they passed individual components instead of a rectangle
<span id="line28031" class="line"></span>            rect = new $.Rect(imageX, imageY, pixelWidth, pixelHeight);
<span id="line28032" class="line"></span>        }
<span id="line28033" class="line"></span>
<span id="line28034" class="line"></span>        if (this.viewer) {
<span id="line28035" class="line"></span>            const count = this.viewer.world.getItemCount();
<span id="line28036" class="line"></span>            if (count &gt; 1) {
<span id="line28037" class="line"></span>                if (!this.silenceMultiImageWarnings) {
<span id="line28038" class="line"></span>                    $.console.error('[Viewport.imageToViewportRectangle] is not accurate ' +
<span id="line28039" class="line"></span>                       'with multi-image; use TiledImage.imageToViewportRectangle instead.');
<span id="line28040" class="line"></span>                }
<span id="line28041" class="line"></span>            } else if (count === 1) {
<span id="line28042" class="line"></span>                // It is better to use TiledImage.imageToViewportRectangle
<span id="line28043" class="line"></span>                // because this._contentBoundsNoRotate can not be relied on
<span id="line28044" class="line"></span>                // with clipping.
<span id="line28045" class="line"></span>                const item = this.viewer.world.getItemAt(0);
<span id="line28046" class="line"></span>                return item.imageToViewportRectangle(
<span id="line28047" class="line"></span>                    imageX, imageY, pixelWidth, pixelHeight, true);
<span id="line28048" class="line"></span>            }
<span id="line28049" class="line"></span>        }
<span id="line28050" class="line"></span>
<span id="line28051" class="line"></span>        const coordA = this.imageToViewportCoordinates(rect.x, rect.y);
<span id="line28052" class="line"></span>        const coordB = this._imageToViewportDelta(rect.width, rect.height);
<span id="line28053" class="line"></span>        return new $.Rect(
<span id="line28054" class="line"></span>            coordA.x,
<span id="line28055" class="line"></span>            coordA.y,
<span id="line28056" class="line"></span>            coordB.x,
<span id="line28057" class="line"></span>            coordB.y,
<span id="line28058" class="line"></span>            rect.degrees
<span id="line28059" class="line"></span>        );
<span id="line28060" class="line"></span>    },
<span id="line28061" class="line"></span>
<span id="line28062" class="line"></span>    /**
<span id="line28063" class="line"></span>     * Translates from a rectangle which describes a portion of
<span id="line28064" class="line"></span>     * the viewport in point coordinates to image rectangle coordinates.
<span id="line28065" class="line"></span>     * This method can be called either by passing X,Y,width,height or an
<span id="line28066" class="line"></span>     * OpenSeadragon.Rect
<span id="line28067" class="line"></span>     * Note: not accurate with multi-image; use TiledImage.viewportToImageRectangle instead.
<span id="line28068" class="line"></span>     * @function
<span id="line28069" class="line"></span>     * @param {(OpenSeadragon.Rect | Number)} viewerX either a rectangle or
<span id="line28070" class="line"></span>     * the X coordinate of the top left corner of the rectangle in viewport
<span id="line28071" class="line"></span>     * coordinate system.
<span id="line28072" class="line"></span>     * @param {Number} [viewerY] the Y coordinate of the top left corner of the rectangle
<span id="line28073" class="line"></span>     * in viewport coordinate system.
<span id="line28074" class="line"></span>     * @param {Number} [pointWidth] the width of the rectangle in viewport coordinate system.
<span id="line28075" class="line"></span>     * @param {Number} [pointHeight] the height of the rectangle in viewport coordinate system.
<span id="line28076" class="line"></span>     */
<span id="line28077" class="line"></span>    viewportToImageRectangle: function(viewerX, viewerY, pointWidth, pointHeight) {
<span id="line28078" class="line"></span>        let rect = viewerX;
<span id="line28079" class="line"></span>        if (!(rect instanceof $.Rect)) {
<span id="line28080" class="line"></span>            //they passed individual components instead of a rectangle
<span id="line28081" class="line"></span>            rect = new $.Rect(viewerX, viewerY, pointWidth, pointHeight);
<span id="line28082" class="line"></span>        }
<span id="line28083" class="line"></span>
<span id="line28084" class="line"></span>        if (this.viewer) {
<span id="line28085" class="line"></span>            const count = this.viewer.world.getItemCount();
<span id="line28086" class="line"></span>            if (count &gt; 1) {
<span id="line28087" class="line"></span>                if (!this.silenceMultiImageWarnings) {
<span id="line28088" class="line"></span>                    $.console.error('[Viewport.viewportToImageRectangle] is not accurate ' +
<span id="line28089" class="line"></span>                        'with multi-image; use TiledImage.viewportToImageRectangle instead.');
<span id="line28090" class="line"></span>                }
<span id="line28091" class="line"></span>            } else if (count === 1) {
<span id="line28092" class="line"></span>                // It is better to use TiledImage.viewportToImageCoordinates
<span id="line28093" class="line"></span>                // because this._contentBoundsNoRotate can not be relied on
<span id="line28094" class="line"></span>                // with clipping.
<span id="line28095" class="line"></span>                const item = this.viewer.world.getItemAt(0);
<span id="line28096" class="line"></span>                return item.viewportToImageRectangle(
<span id="line28097" class="line"></span>                    viewerX, viewerY, pointWidth, pointHeight, true);
<span id="line28098" class="line"></span>            }
<span id="line28099" class="line"></span>        }
<span id="line28100" class="line"></span>
<span id="line28101" class="line"></span>        const coordA = this.viewportToImageCoordinates(rect.x, rect.y);
<span id="line28102" class="line"></span>        const coordB = this._viewportToImageDelta(rect.width, rect.height);
<span id="line28103" class="line"></span>        return new $.Rect(
<span id="line28104" class="line"></span>            coordA.x,
<span id="line28105" class="line"></span>            coordA.y,
<span id="line28106" class="line"></span>            coordB.x,
<span id="line28107" class="line"></span>            coordB.y,
<span id="line28108" class="line"></span>            rect.degrees
<span id="line28109" class="line"></span>        );
<span id="line28110" class="line"></span>    },
<span id="line28111" class="line"></span>
<span id="line28112" class="line"></span>    /**
<span id="line28113" class="line"></span>     * Convert pixel coordinates relative to the viewer element to image
<span id="line28114" class="line"></span>     * coordinates.
<span id="line28115" class="line"></span>     * Note: not accurate with multi-image.
<span id="line28116" class="line"></span>     * @param {OpenSeadragon.Point} pixel
<span id="line28117" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line28118" class="line"></span>     */
<span id="line28119" class="line"></span>    viewerElementToImageCoordinates: function( pixel ) {
<span id="line28120" class="line"></span>        const point = this.pointFromPixel( pixel, true );
<span id="line28121" class="line"></span>        return this.viewportToImageCoordinates( point );
<span id="line28122" class="line"></span>    },
<span id="line28123" class="line"></span>
<span id="line28124" class="line"></span>    /**
<span id="line28125" class="line"></span>     * Convert pixel coordinates relative to the image to
<span id="line28126" class="line"></span>     * viewer element coordinates.
<span id="line28127" class="line"></span>     * Note: not accurate with multi-image.
<span id="line28128" class="line"></span>     * @param {OpenSeadragon.Point} pixel
<span id="line28129" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line28130" class="line"></span>     */
<span id="line28131" class="line"></span>    imageToViewerElementCoordinates: function( pixel ) {
<span id="line28132" class="line"></span>        const point = this.imageToViewportCoordinates( pixel );
<span id="line28133" class="line"></span>        return this.pixelFromPoint( point, true );
<span id="line28134" class="line"></span>    },
<span id="line28135" class="line"></span>
<span id="line28136" class="line"></span>    /**
<span id="line28137" class="line"></span>     * Convert pixel coordinates relative to the window to image coordinates.
<span id="line28138" class="line"></span>     * Note: not accurate with multi-image.
<span id="line28139" class="line"></span>     * @param {OpenSeadragon.Point} pixel
<span id="line28140" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line28141" class="line"></span>     */
<span id="line28142" class="line"></span>    windowToImageCoordinates: function(pixel) {
<span id="line28143" class="line"></span>        $.console.assert(this.viewer,
<span id="line28144" class="line"></span>            "[Viewport.windowToImageCoordinates] the viewport must have a viewer.");
<span id="line28145" class="line"></span>        const viewerCoordinates = pixel.minus(
<span id="line28146" class="line"></span>                $.getElementPosition(this.viewer.container));
<span id="line28147" class="line"></span>        return this.viewerElementToImageCoordinates(viewerCoordinates);
<span id="line28148" class="line"></span>    },
<span id="line28149" class="line"></span>
<span id="line28150" class="line"></span>    /**
<span id="line28151" class="line"></span>     * Convert image coordinates to pixel coordinates relative to the window.
<span id="line28152" class="line"></span>     * Note: not accurate with multi-image.
<span id="line28153" class="line"></span>     * @param {OpenSeadragon.Point} pixel
<span id="line28154" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line28155" class="line"></span>     */
<span id="line28156" class="line"></span>    imageToWindowCoordinates: function(pixel) {
<span id="line28157" class="line"></span>        $.console.assert(this.viewer,
<span id="line28158" class="line"></span>            "[Viewport.imageToWindowCoordinates] the viewport must have a viewer.");
<span id="line28159" class="line"></span>        const viewerCoordinates = this.imageToViewerElementCoordinates(pixel);
<span id="line28160" class="line"></span>        return viewerCoordinates.plus(
<span id="line28161" class="line"></span>                $.getElementPosition(this.viewer.container));
<span id="line28162" class="line"></span>    },
<span id="line28163" class="line"></span>
<span id="line28164" class="line"></span>    /**
<span id="line28165" class="line"></span>     * Convert pixel coordinates relative to the viewer element to viewport
<span id="line28166" class="line"></span>     * coordinates.
<span id="line28167" class="line"></span>     * @param {OpenSeadragon.Point} pixel
<span id="line28168" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line28169" class="line"></span>     */
<span id="line28170" class="line"></span>    viewerElementToViewportCoordinates: function( pixel ) {
<span id="line28171" class="line"></span>        return this.pointFromPixel( pixel, true );
<span id="line28172" class="line"></span>    },
<span id="line28173" class="line"></span>
<span id="line28174" class="line"></span>    /**
<span id="line28175" class="line"></span>     * Convert viewport coordinates to pixel coordinates relative to the
<span id="line28176" class="line"></span>     * viewer element.
<span id="line28177" class="line"></span>     * @param {OpenSeadragon.Point} point
<span id="line28178" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line28179" class="line"></span>     */
<span id="line28180" class="line"></span>    viewportToViewerElementCoordinates: function( point ) {
<span id="line28181" class="line"></span>        return this.pixelFromPoint( point, true );
<span id="line28182" class="line"></span>    },
<span id="line28183" class="line"></span>
<span id="line28184" class="line"></span>    /**
<span id="line28185" class="line"></span>     * Convert a rectangle in pixel coordinates relative to the viewer element
<span id="line28186" class="line"></span>     * to viewport coordinates.
<span id="line28187" class="line"></span>     * @param {OpenSeadragon.Rect} rectangle the rectangle to convert
<span id="line28188" class="line"></span>     * @returns {OpenSeadragon.Rect} the converted rectangle
<span id="line28189" class="line"></span>     */
<span id="line28190" class="line"></span>    viewerElementToViewportRectangle: function(rectangle) {
<span id="line28191" class="line"></span>        return $.Rect.fromSummits(
<span id="line28192" class="line"></span>            this.pointFromPixel(rectangle.getTopLeft(), true),
<span id="line28193" class="line"></span>            this.pointFromPixel(rectangle.getTopRight(), true),
<span id="line28194" class="line"></span>            this.pointFromPixel(rectangle.getBottomLeft(), true)
<span id="line28195" class="line"></span>        );
<span id="line28196" class="line"></span>    },
<span id="line28197" class="line"></span>
<span id="line28198" class="line"></span>    /**
<span id="line28199" class="line"></span>     * Convert a rectangle in viewport coordinates to pixel coordinates relative
<span id="line28200" class="line"></span>     * to the viewer element.
<span id="line28201" class="line"></span>     * @param {OpenSeadragon.Rect} rectangle the rectangle to convert
<span id="line28202" class="line"></span>     * @returns {OpenSeadragon.Rect} the converted rectangle
<span id="line28203" class="line"></span>     */
<span id="line28204" class="line"></span>    viewportToViewerElementRectangle: function(rectangle) {
<span id="line28205" class="line"></span>        return $.Rect.fromSummits(
<span id="line28206" class="line"></span>            this.pixelFromPoint(rectangle.getTopLeft(), true),
<span id="line28207" class="line"></span>            this.pixelFromPoint(rectangle.getTopRight(), true),
<span id="line28208" class="line"></span>            this.pixelFromPoint(rectangle.getBottomLeft(), true)
<span id="line28209" class="line"></span>        );
<span id="line28210" class="line"></span>    },
<span id="line28211" class="line"></span>
<span id="line28212" class="line"></span>    /**
<span id="line28213" class="line"></span>     * Convert pixel coordinates relative to the window to viewport coordinates.
<span id="line28214" class="line"></span>     * @param {OpenSeadragon.Point} pixel
<span id="line28215" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line28216" class="line"></span>     */
<span id="line28217" class="line"></span>    windowToViewportCoordinates: function(pixel) {
<span id="line28218" class="line"></span>        $.console.assert(this.viewer,
<span id="line28219" class="line"></span>            "[Viewport.windowToViewportCoordinates] the viewport must have a viewer.");
<span id="line28220" class="line"></span>        const viewerCoordinates = pixel.minus(
<span id="line28221" class="line"></span>                $.getElementPosition(this.viewer.container));
<span id="line28222" class="line"></span>        return this.viewerElementToViewportCoordinates(viewerCoordinates);
<span id="line28223" class="line"></span>    },
<span id="line28224" class="line"></span>
<span id="line28225" class="line"></span>    /**
<span id="line28226" class="line"></span>     * Convert viewport coordinates to pixel coordinates relative to the window.
<span id="line28227" class="line"></span>     * @param {OpenSeadragon.Point} point
<span id="line28228" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line28229" class="line"></span>     */
<span id="line28230" class="line"></span>    viewportToWindowCoordinates: function(point) {
<span id="line28231" class="line"></span>        $.console.assert(this.viewer,
<span id="line28232" class="line"></span>            "[Viewport.viewportToWindowCoordinates] the viewport must have a viewer.");
<span id="line28233" class="line"></span>        const viewerCoordinates = this.viewportToViewerElementCoordinates(point);
<span id="line28234" class="line"></span>        return viewerCoordinates.plus(
<span id="line28235" class="line"></span>                $.getElementPosition(this.viewer.container));
<span id="line28236" class="line"></span>    },
<span id="line28237" class="line"></span>
<span id="line28238" class="line"></span>    /**
<span id="line28239" class="line"></span>     * Convert a viewport zoom to an image zoom.
<span id="line28240" class="line"></span>     * Image zoom: ratio of the original image size to displayed image size.
<span id="line28241" class="line"></span>     * 1 means original image size, 0.5 half size...
<span id="line28242" class="line"></span>     * Viewport zoom: ratio of the displayed image's width to viewport's width.
<span id="line28243" class="line"></span>     * 1 means identical width, 2 means image's width is twice the viewport's width...
<span id="line28244" class="line"></span>     * Note: not accurate with multi-image.
<span id="line28245" class="line"></span>     * @function
<span id="line28246" class="line"></span>     * @param {Number} viewportZoom The viewport zoom
<span id="line28247" class="line"></span>     * target zoom.
<span id="line28248" class="line"></span>     * @returns {Number} imageZoom The image zoom
<span id="line28249" class="line"></span>     */
<span id="line28250" class="line"></span>    viewportToImageZoom: function(viewportZoom) {
<span id="line28251" class="line"></span>        if (this.viewer) {
<span id="line28252" class="line"></span>            const count = this.viewer.world.getItemCount();
<span id="line28253" class="line"></span>            if (count &gt; 1) {
<span id="line28254" class="line"></span>                if (!this.silenceMultiImageWarnings) {
<span id="line28255" class="line"></span>                    $.console.error('[Viewport.viewportToImageZoom] is not ' +
<span id="line28256" class="line"></span>                        'accurate with multi-image.');
<span id="line28257" class="line"></span>                }
<span id="line28258" class="line"></span>            } else if (count === 1) {
<span id="line28259" class="line"></span>                // It is better to use TiledImage.viewportToImageZoom
<span id="line28260" class="line"></span>                // because this._contentBoundsNoRotate can not be relied on
<span id="line28261" class="line"></span>                // with clipping.
<span id="line28262" class="line"></span>                const item = this.viewer.world.getItemAt(0);
<span id="line28263" class="line"></span>                return item.viewportToImageZoom(viewportZoom);
<span id="line28264" class="line"></span>            }
<span id="line28265" class="line"></span>        }
<span id="line28266" class="line"></span>
<span id="line28267" class="line"></span>        const imageWidth = this._contentSizeNoRotate.x;
<span id="line28268" class="line"></span>        const containerWidth = this._containerInnerSize.x;
<span id="line28269" class="line"></span>        const scale = this._contentBoundsNoRotate.width;
<span id="line28270" class="line"></span>        const viewportToImageZoomRatio = (containerWidth / imageWidth) * scale;
<span id="line28271" class="line"></span>        return viewportZoom * viewportToImageZoomRatio;
<span id="line28272" class="line"></span>    },
<span id="line28273" class="line"></span>
<span id="line28274" class="line"></span>    /**
<span id="line28275" class="line"></span>     * Convert an image zoom to a viewport zoom.
<span id="line28276" class="line"></span>     * Image zoom: ratio of the original image size to displayed image size.
<span id="line28277" class="line"></span>     * 1 means original image size, 0.5 half size...
<span id="line28278" class="line"></span>     * Viewport zoom: ratio of the displayed image's width to viewport's width.
<span id="line28279" class="line"></span>     * 1 means identical width, 2 means image's width is twice the viewport's width...
<span id="line28280" class="line"></span>     * Note: not accurate with multi-image; use [TiledImage.imageToViewportZoom] for the specific image of interest.
<span id="line28281" class="line"></span>     * @function
<span id="line28282" class="line"></span>     * @param {Number} imageZoom The image zoom
<span id="line28283" class="line"></span>     * target zoom.
<span id="line28284" class="line"></span>     * @returns {Number} viewportZoom The viewport zoom
<span id="line28285" class="line"></span>     */
<span id="line28286" class="line"></span>    imageToViewportZoom: function(imageZoom) {
<span id="line28287" class="line"></span>        if (this.viewer) {
<span id="line28288" class="line"></span>            const count = this.viewer.world.getItemCount();
<span id="line28289" class="line"></span>            if (count &gt; 1) {
<span id="line28290" class="line"></span>                if (!this.silenceMultiImageWarnings) {
<span id="line28291" class="line"></span>                    $.console.error('[Viewport.imageToViewportZoom] is not accurate ' +
<span id="line28292" class="line"></span>                        'with multi-image. Instead, use [TiledImage.imageToViewportZoom] for the specific image of interest');
<span id="line28293" class="line"></span>                }
<span id="line28294" class="line"></span>            } else if (count === 1) {
<span id="line28295" class="line"></span>                // It is better to use TiledImage.imageToViewportZoom
<span id="line28296" class="line"></span>                // because this._contentBoundsNoRotate can not be relied on
<span id="line28297" class="line"></span>                // with clipping.
<span id="line28298" class="line"></span>                const item = this.viewer.world.getItemAt(0);
<span id="line28299" class="line"></span>                return item.imageToViewportZoom(imageZoom);
<span id="line28300" class="line"></span>            }
<span id="line28301" class="line"></span>        }
<span id="line28302" class="line"></span>
<span id="line28303" class="line"></span>        const imageWidth = this._contentSizeNoRotate.x;
<span id="line28304" class="line"></span>        const containerWidth = this._containerInnerSize.x;
<span id="line28305" class="line"></span>        const scale = this._contentBoundsNoRotate.width;
<span id="line28306" class="line"></span>        const viewportToImageZoomRatio = (imageWidth / containerWidth) / scale;
<span id="line28307" class="line"></span>        return imageZoom * viewportToImageZoomRatio;
<span id="line28308" class="line"></span>    },
<span id="line28309" class="line"></span>
<span id="line28310" class="line"></span>    /**
<span id="line28311" class="line"></span>     * Toggles flip state and demands a new drawing on navigator and viewer objects.
<span id="line28312" class="line"></span>     * @function
<span id="line28313" class="line"></span>     * @returns {OpenSeadragon.Viewport} Chainable.
<span id="line28314" class="line"></span>     */
<span id="line28315" class="line"></span>    toggleFlip: function() {
<span id="line28316" class="line"></span>      this.setFlip(!this.getFlip());
<span id="line28317" class="line"></span>      return this;
<span id="line28318" class="line"></span>    },
<span id="line28319" class="line"></span>
<span id="line28320" class="line"></span>    /**
<span id="line28321" class="line"></span>     * Get flip state stored on viewport.
<span id="line28322" class="line"></span>     * @function
<span id="line28323" class="line"></span>     * @returns {Boolean} Flip state.
<span id="line28324" class="line"></span>     */
<span id="line28325" class="line"></span>    getFlip: function() {
<span id="line28326" class="line"></span>      return this.flipped;
<span id="line28327" class="line"></span>    },
<span id="line28328" class="line"></span>
<span id="line28329" class="line"></span>    /**
<span id="line28330" class="line"></span>     * Sets flip state according to the state input argument.
<span id="line28331" class="line"></span>     * @function
<span id="line28332" class="line"></span>     * @param {Boolean} state - Flip state to set.
<span id="line28333" class="line"></span>     * @returns {OpenSeadragon.Viewport} Chainable.
<span id="line28334" class="line"></span>     */
<span id="line28335" class="line"></span>    setFlip: function( state ) {
<span id="line28336" class="line"></span>      if ( this.flipped === state ) {
<span id="line28337" class="line"></span>        return this;
<span id="line28338" class="line"></span>      }
<span id="line28339" class="line"></span>
<span id="line28340" class="line"></span>      this.flipped = state;
<span id="line28341" class="line"></span>      if(this.viewer.navigator){
<span id="line28342" class="line"></span>        this.viewer.navigator.setFlip(this.getFlip());
<span id="line28343" class="line"></span>      }
<span id="line28344" class="line"></span>      this.viewer.forceRedraw();
<span id="line28345" class="line"></span>
<span id="line28346" class="line"></span>      /**
<span id="line28347" class="line"></span>       * Raised when flip state has been changed.
<span id="line28348" class="line"></span>       *
<span id="line28349" class="line"></span>       * @event flip
<span id="line28350" class="line"></span>       * @memberof OpenSeadragon.Viewer
<span id="line28351" class="line"></span>       * @type {object}
<span id="line28352" class="line"></span>       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line28353" class="line"></span>       * @property {Number} flipped - The flip state after this change.
<span id="line28354" class="line"></span>       * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line28355" class="line"></span>       */
<span id="line28356" class="line"></span>      this.viewer.raiseEvent('flip', {flipped: state});
<span id="line28357" class="line"></span>      return this;
<span id="line28358" class="line"></span>    },
<span id="line28359" class="line"></span>
<span id="line28360" class="line"></span>    /**
<span id="line28361" class="line"></span>     * Gets current max zoom pixel ratio
<span id="line28362" class="line"></span>     * @function
<span id="line28363" class="line"></span>     * @returns {Number} Max zoom pixel ratio
<span id="line28364" class="line"></span>     */
<span id="line28365" class="line"></span>    getMaxZoomPixelRatio: function() {
<span id="line28366" class="line"></span>        return this.maxZoomPixelRatio;
<span id="line28367" class="line"></span>    },
<span id="line28368" class="line"></span>
<span id="line28369" class="line"></span>    /**
<span id="line28370" class="line"></span>     * Sets max zoom pixel ratio
<span id="line28371" class="line"></span>     * @function
<span id="line28372" class="line"></span>     * @param {Number} ratio - Max zoom pixel ratio
<span id="line28373" class="line"></span>     * @param {Boolean} [applyConstraints=true] - Apply constraints after setting ratio;
<span id="line28374" class="line"></span>     * Takes effect only if current zoom is greater than set max zoom pixel ratio
<span id="line28375" class="line"></span>     * @param {Boolean} [immediately=false] - Whether to animate to new zoom
<span id="line28376" class="line"></span>     */
<span id="line28377" class="line"></span>    setMaxZoomPixelRatio: function(ratio, applyConstraints = true, immediately = false) {
<span id="line28378" class="line"></span>
<span id="line28379" class="line"></span>        $.console.assert(!isNaN(ratio), "[Viewport.setMaxZoomPixelRatio] ratio must be a number");
<span id="line28380" class="line"></span>
<span id="line28381" class="line"></span>        if (isNaN(ratio)) {
<span id="line28382" class="line"></span>            return;
<span id="line28383" class="line"></span>        }
<span id="line28384" class="line"></span>
<span id="line28385" class="line"></span>        this.maxZoomPixelRatio = ratio;
<span id="line28386" class="line"></span>
<span id="line28387" class="line"></span>        if (applyConstraints) {
<span id="line28388" class="line"></span>            if (this.getZoom() &gt; this.getMaxZoom()) {
<span id="line28389" class="line"></span>                this.applyConstraints(immediately);
<span id="line28390" class="line"></span>            }
<span id="line28391" class="line"></span>        }
<span id="line28392" class="line"></span>    },
<span id="line28393" class="line"></span>
<span id="line28394" class="line"></span>};
<span id="line28395" class="line"></span>
<span id="line28396" class="line"></span>}( OpenSeadragon ));
<span id="line28397" class="line"></span>
<span id="line28398" class="line"></span>/*
<span id="line28399" class="line"></span> * OpenSeadragon - TiledImage
<span id="line28400" class="line"></span> *
<span id="line28401" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line28402" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line28403" class="line"></span> *
<span id="line28404" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line28405" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line28406" class="line"></span> * met:
<span id="line28407" class="line"></span> *
<span id="line28408" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line28409" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line28410" class="line"></span> *
<span id="line28411" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line28412" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line28413" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line28414" class="line"></span> *
<span id="line28415" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line28416" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line28417" class="line"></span> *   this software without specific prior written permission.
<span id="line28418" class="line"></span> *
<span id="line28419" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line28420" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line28421" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line28422" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line28423" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line28424" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line28425" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line28426" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line28427" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line28428" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line28429" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line28430" class="line"></span>*/
<span id="line28431" class="line"></span>
<span id="line28432" class="line"></span>(function( $ ){
<span id="line28433" class="line"></span>
<span id="line28434" class="line"></span>/**
<span id="line28435" class="line"></span> * Object that keeps ready-to-draw tile state information. These properties might differ in time
<span id="line28436" class="line"></span> * dynamically, e.g. when blending/animating.
<span id="line28437" class="line"></span> * TODO: info.level is probably info.tile.level - remove?
<span id="line28438" class="line"></span> * @typedef {Object} OpenSeadragon.TiledImage.DrawTileInfo
<span id="line28439" class="line"></span> * @property {Number} level
<span id="line28440" class="line"></span> * @property {Number} levelOpacity
<span id="line28441" class="line"></span> * @property {Number} currentTime
<span id="line28442" class="line"></span> * @property {OpenSeadragon.Tile} tile
<span id="line28443" class="line"></span> */
<span id="line28444" class="line"></span>
<span id="line28445" class="line"></span>/**
<span id="line28446" class="line"></span> * Issues enum that records issues for the target image
<span id="line28447" class="line"></span> * @typedef {('webgl')} OpenSeadragon.TiledImage.Issue
<span id="line28448" class="line"></span> */
<span id="line28449" class="line"></span>
<span id="line28450" class="line"></span>/**
<span id="line28451" class="line"></span> * You shouldn't have to create a TiledImage instance directly; get it asynchronously by
<span id="line28452" class="line"></span> * using {@link OpenSeadragon.Viewer#open} or {@link OpenSeadragon.Viewer#addTiledImage} instead.
<span id="line28453" class="line"></span> * @class TiledImage
<span id="line28454" class="line"></span> * @memberof OpenSeadragon
<span id="line28455" class="line"></span> * @extends OpenSeadragon.EventSource
<span id="line28456" class="line"></span> * @classdesc Handles rendering of tiles for an {@link OpenSeadragon.Viewer}.
<span id="line28457" class="line"></span> * A new instance is created for each TileSource opened.
<span id="line28458" class="line"></span> * @param {Object} options - Configuration for this TiledImage.
<span id="line28459" class="line"></span> * @param {OpenSeadragon.TileSource} options.source - The TileSource that defines this TiledImage.
<span id="line28460" class="line"></span> * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this TiledImage.
<span id="line28461" class="line"></span> * @param {OpenSeadragon.TileCache} options.tileCache - The TileCache for this TiledImage to use.
<span id="line28462" class="line"></span> * @param {OpenSeadragon.Drawer} options.drawer - The Drawer for this TiledImage to draw onto.
<span id="line28463" class="line"></span> * @param {OpenSeadragon.ImageLoader} options.imageLoader - The ImageLoader for this TiledImage to use.
<span id="line28464" class="line"></span> * @param {Number} [options.x=0] - Left position, in viewport coordinates.
<span id="line28465" class="line"></span> * @param {Number} [options.y=0] - Top position, in viewport coordinates.
<span id="line28466" class="line"></span> * @param {Number} [options.width=1] - Width, in viewport coordinates.
<span id="line28467" class="line"></span> * @param {Number} [options.height] - Height, in viewport coordinates.
<span id="line28468" class="line"></span> * @param {OpenSeadragon.Rect} [options.fitBounds] The bounds in viewport coordinates
<span id="line28469" class="line"></span> * to fit the image into. If specified, x, y, width and height get ignored.
<span id="line28470" class="line"></span> * @param {OpenSeadragon.Placement} [options.fitBoundsPlacement=OpenSeadragon.Placement.CENTER]
<span id="line28471" class="line"></span> * How to anchor the image in the bounds if options.fitBounds is set.
<span id="line28472" class="line"></span> * @param {OpenSeadragon.Rect} [options.clip] - An area, in image pixels, to clip to
<span id="line28473" class="line"></span> * (portions of the image outside of this area will not be visible). Only works on
<span id="line28474" class="line"></span> * browsers that support the HTML5 canvas.
<span id="line28475" class="line"></span> * @param {Number} [options.springStiffness] - See {@link OpenSeadragon.Options}.
<span id="line28476" class="line"></span> * @param {Boolean} [options.animationTime] - See {@link OpenSeadragon.Options}.
<span id="line28477" class="line"></span> * @param {Number} [options.minZoomImageRatio] - See {@link OpenSeadragon.Options}.
<span id="line28478" class="line"></span> * @param {Boolean} [options.wrapHorizontal] - See {@link OpenSeadragon.Options}.
<span id="line28479" class="line"></span> * @param {Boolean} [options.wrapVertical] - See {@link OpenSeadragon.Options}.
<span id="line28480" class="line"></span> * @param {Boolean} [options.immediateRender] - See {@link OpenSeadragon.Options}.
<span id="line28481" class="line"></span> * @param {Number} [options.blendTime] - See {@link OpenSeadragon.Options}.
<span id="line28482" class="line"></span> * @param {Boolean} [options.alwaysBlend] - See {@link OpenSeadragon.Options}.
<span id="line28483" class="line"></span> * @param {Number} [options.minPixelRatio] - See {@link OpenSeadragon.Options}.
<span id="line28484" class="line"></span> * @param {Number} [options.smoothTileEdgesMinZoom] - See {@link OpenSeadragon.Options}.
<span id="line28485" class="line"></span> * @param {Boolean} [options.iOSDevice] - See {@link OpenSeadragon.Options}.
<span id="line28486" class="line"></span> * @param {Number} [options.opacity=1] - Set to draw at proportional opacity. If zero, images will not draw.
<span id="line28487" class="line"></span> * @param {Boolean} [options.preload=false] - Set true to load even when the image is hidden by zero opacity.
<span id="line28488" class="line"></span> * @param {String} [options.compositeOperation] - How the image is composited onto other images;
<span id="line28489" class="line"></span> * see compositeOperation in {@link OpenSeadragon.Options} for possible values.
<span id="line28490" class="line"></span> * @param {Boolean} [options.debugMode] - See {@link OpenSeadragon.Options}.
<span id="line28491" class="line"></span> * @param {String|CanvasGradient|CanvasPattern|Function} [options.placeholderFillStyle] - See {@link OpenSeadragon.Options}.
<span id="line28492" class="line"></span> * @param {String|Boolean} [options.crossOriginPolicy] - See {@link OpenSeadragon.Options}.
<span id="line28493" class="line"></span> * @param {Boolean} [options.ajaxWithCredentials] - See {@link OpenSeadragon.Options}.
<span id="line28494" class="line"></span> * @param {Boolean} [options.loadTilesWithAjax]
<span id="line28495" class="line"></span> *      Whether to load tile data using AJAX requests.
<span id="line28496" class="line"></span> *      Defaults to the setting in {@link OpenSeadragon.Options}.
<span id="line28497" class="line"></span> * @param {Object} [options.ajaxHeaders={}]
<span id="line28498" class="line"></span> *      A set of headers to include when making tile AJAX requests.
<span id="line28499" class="line"></span> * @param {string|string[]} [options.originalDataType=undefined]
<span id="line28500" class="line"></span> *      A default format to convert tiles to at the beginning. The format is the base tile format,
<span id="line28501" class="line"></span> *      and this can optimize rendering or processing logics, for example, in case a plugin always requires a certain
<span id="line28502" class="line"></span> *      format to convert to.
<span id="line28503" class="line"></span> */
<span id="line28504" class="line"></span>$.TiledImage = function( options ) {
<span id="line28505" class="line"></span>    this._initialized = false;
<span id="line28506" class="line"></span>    /**
<span id="line28507" class="line"></span>     * The {@link OpenSeadragon.TileSource} that defines this TiledImage.
<span id="line28508" class="line"></span>     * @member {OpenSeadragon.TileSource} source
<span id="line28509" class="line"></span>     * @memberof OpenSeadragon.TiledImage#
<span id="line28510" class="line"></span>     */
<span id="line28511" class="line"></span>    $.console.assert( options.tileCache, "[TiledImage] options.tileCache is required" );
<span id="line28512" class="line"></span>    $.console.assert( options.drawer, "[TiledImage] options.drawer is required" );
<span id="line28513" class="line"></span>    $.console.assert( options.viewer, "[TiledImage] options.viewer is required" );
<span id="line28514" class="line"></span>    $.console.assert( options.imageLoader, "[TiledImage] options.imageLoader is required" );
<span id="line28515" class="line"></span>    $.console.assert( options.source, "[TiledImage] options.source is required" );
<span id="line28516" class="line"></span>    $.console.assert(!options.clip || options.clip instanceof $.Rect,
<span id="line28517" class="line"></span>        "[TiledImage] options.clip must be an OpenSeadragon.Rect if present");
<span id="line28518" class="line"></span>
<span id="line28519" class="line"></span>    $.EventSource.call( this );
<span id="line28520" class="line"></span>    // Asynchronously loaded items remember where users wanted them
<span id="line28521" class="line"></span>    this._optimalWorldIndex = undefined;
<span id="line28522" class="line"></span>
<span id="line28523" class="line"></span>    this._tileCache = options.tileCache;
<span id="line28524" class="line"></span>    delete options.tileCache;
<span id="line28525" class="line"></span>
<span id="line28526" class="line"></span>    this._drawer = options.drawer;
<span id="line28527" class="line"></span>    delete options.drawer;
<span id="line28528" class="line"></span>
<span id="line28529" class="line"></span>    this._imageLoader = options.imageLoader;
<span id="line28530" class="line"></span>    delete options.imageLoader;
<span id="line28531" class="line"></span>
<span id="line28532" class="line"></span>    if (options.clip instanceof $.Rect) {
<span id="line28533" class="line"></span>        this._clip = options.clip.clone();
<span id="line28534" class="line"></span>    }
<span id="line28535" class="line"></span>
<span id="line28536" class="line"></span>    delete options.clip;
<span id="line28537" class="line"></span>
<span id="line28538" class="line"></span>    const x = options.x || 0;
<span id="line28539" class="line"></span>    delete options.x;
<span id="line28540" class="line"></span>    const y = options.y || 0;
<span id="line28541" class="line"></span>    delete options.y;
<span id="line28542" class="line"></span>
<span id="line28543" class="line"></span>    // Ratio of zoomable image height to width.
<span id="line28544" class="line"></span>    this.normHeight = options.source.dimensions.y / options.source.dimensions.x;
<span id="line28545" class="line"></span>    this.contentAspectX = options.source.dimensions.x / options.source.dimensions.y;
<span id="line28546" class="line"></span>
<span id="line28547" class="line"></span>    let scale = 1;
<span id="line28548" class="line"></span>    if ( options.width ) {
<span id="line28549" class="line"></span>        scale = options.width;
<span id="line28550" class="line"></span>        delete options.width;
<span id="line28551" class="line"></span>
<span id="line28552" class="line"></span>        if ( options.height ) {
<span id="line28553" class="line"></span>            $.console.error( "specifying both width and height to a tiledImage is not supported" );
<span id="line28554" class="line"></span>            delete options.height;
<span id="line28555" class="line"></span>        }
<span id="line28556" class="line"></span>    } else if ( options.height ) {
<span id="line28557" class="line"></span>        scale = options.height / this.normHeight;
<span id="line28558" class="line"></span>        delete options.height;
<span id="line28559" class="line"></span>    }
<span id="line28560" class="line"></span>
<span id="line28561" class="line"></span>    const fitBounds = options.fitBounds;
<span id="line28562" class="line"></span>    delete options.fitBounds;
<span id="line28563" class="line"></span>    const fitBoundsPlacement = options.fitBoundsPlacement || OpenSeadragon.Placement.CENTER;
<span id="line28564" class="line"></span>    delete options.fitBoundsPlacement;
<span id="line28565" class="line"></span>
<span id="line28566" class="line"></span>    const degrees = options.degrees || 0;
<span id="line28567" class="line"></span>    delete options.degrees;
<span id="line28568" class="line"></span>
<span id="line28569" class="line"></span>    const ajaxHeaders = options.ajaxHeaders;
<span id="line28570" class="line"></span>    delete options.ajaxHeaders;
<span id="line28571" class="line"></span>
<span id="line28572" class="line"></span>    // Setter ensures lowercase
<span id="line28573" class="line"></span>    this.crossOriginPolicy = options.crossOriginPolicy;
<span id="line28574" class="line"></span>    delete options.crossOriginPolicy;
<span id="line28575" class="line"></span>
<span id="line28576" class="line"></span>    $.extend( true, this, {
<span id="line28577" class="line"></span>
<span id="line28578" class="line"></span>        //internal state properties
<span id="line28579" class="line"></span>        viewer:         null,
<span id="line28580" class="line"></span>        tilesMatrix:    {},    // A '3d' dictionary [level][x][y] --&gt; Tile.
<span id="line28581" class="line"></span>        coverage:       {},    // A '3d' dictionary [level][x][y] --&gt; Boolean; shows what areas have been drawn.
<span id="line28582" class="line"></span>        loadingCoverage: {},   // A '3d' dictionary [level][x][y] --&gt; Boolean; shows what areas are loaded or are being loaded/blended.
<span id="line28583" class="line"></span>        lastResetTime:  0,     // Last time for which the tiledImage was reset.
<span id="line28584" class="line"></span>        _needsDraw:     true,  // Does the tiledImage need to be drawn again?
<span id="line28585" class="line"></span>        _needsUpdate:   true,  // Does the tiledImage need to update the viewport again?
<span id="line28586" class="line"></span>        _hasOpaqueTile: false,  // Do we have even one fully opaque tile?
<span id="line28587" class="line"></span>        _tilesLoading:  0,     // The number of pending tile requests.
<span id="line28588" class="line"></span>        _zombieCache:   false, // Allow cache to stay in memory upon deletion.
<span id="line28589" class="line"></span>        _tilesToDraw:   [],    // info about the tiles currently in the viewport, two deep: array[level][tile]
<span id="line28590" class="line"></span>        _lastDrawn:     [],    // array of tiles that were last fetched by the drawer
<span id="line28591" class="line"></span>        _arrayCacheMap: [],    // array cache to avoid constant re-creation and GC overload
<span id="line28592" class="line"></span>        _isBlending:    false, // Are any tiles still being blended?
<span id="line28593" class="line"></span>        _wasBlending:   false, // Were any tiles blending before the last draw?
<span id="line28594" class="line"></span>        _issues:        {},    // An issue flag map - image was marked as problematic by some entity (usually a drawer)?
<span id="line28595" class="line"></span>        //configurable settings
<span id="line28596" class="line"></span>        springStiffness:                   $.DEFAULT_SETTINGS.springStiffness,
<span id="line28597" class="line"></span>        animationTime:                     $.DEFAULT_SETTINGS.animationTime,
<span id="line28598" class="line"></span>        minZoomImageRatio:                 $.DEFAULT_SETTINGS.minZoomImageRatio,
<span id="line28599" class="line"></span>        wrapHorizontal:                    $.DEFAULT_SETTINGS.wrapHorizontal,
<span id="line28600" class="line"></span>        wrapVertical:                      $.DEFAULT_SETTINGS.wrapVertical,
<span id="line28601" class="line"></span>        immediateRender:                   $.DEFAULT_SETTINGS.immediateRender,
<span id="line28602" class="line"></span>        loadDestinationTilesOnAnimation:   $.DEFAULT_SETTINGS.loadDestinationTilesOnAnimation,
<span id="line28603" class="line"></span>        blendTime:                         $.DEFAULT_SETTINGS.blendTime,
<span id="line28604" class="line"></span>        alwaysBlend:                       $.DEFAULT_SETTINGS.alwaysBlend,
<span id="line28605" class="line"></span>        minPixelRatio:                     $.DEFAULT_SETTINGS.minPixelRatio,
<span id="line28606" class="line"></span>        smoothTileEdgesMinZoom:            $.DEFAULT_SETTINGS.smoothTileEdgesMinZoom,
<span id="line28607" class="line"></span>        iOSDevice:                         $.DEFAULT_SETTINGS.iOSDevice,
<span id="line28608" class="line"></span>        debugMode:                         $.DEFAULT_SETTINGS.debugMode,
<span id="line28609" class="line"></span>        ajaxWithCredentials:               $.DEFAULT_SETTINGS.ajaxWithCredentials,
<span id="line28610" class="line"></span>        placeholderFillStyle:              $.DEFAULT_SETTINGS.placeholderFillStyle,
<span id="line28611" class="line"></span>        opacity:                           $.DEFAULT_SETTINGS.opacity,
<span id="line28612" class="line"></span>        preload:                           $.DEFAULT_SETTINGS.preload,
<span id="line28613" class="line"></span>        compositeOperation:                $.DEFAULT_SETTINGS.compositeOperation,
<span id="line28614" class="line"></span>        subPixelRoundingForTransparency:   $.DEFAULT_SETTINGS.subPixelRoundingForTransparency,
<span id="line28615" class="line"></span>        maxTilesPerFrame:                  $.DEFAULT_SETTINGS.maxTilesPerFrame,
<span id="line28616" class="line"></span>        originalDataType:                  undefined,
<span id="line28617" class="line"></span>        _currentMaxTilesPerFrame:          (options.maxTilesPerFrame || $.DEFAULT_SETTINGS.maxTilesPerFrame) * 10
<span id="line28618" class="line"></span>    }, options );
<span id="line28619" class="line"></span>
<span id="line28620" class="line"></span>    this._preload = this.preload;
<span id="line28621" class="line"></span>    delete this.preload;
<span id="line28622" class="line"></span>
<span id="line28623" class="line"></span>    this._fullyLoaded = false;
<span id="line28624" class="line"></span>
<span id="line28625" class="line"></span>    this._xSpring = new $.Spring({
<span id="line28626" class="line"></span>        initial: x,
<span id="line28627" class="line"></span>        springStiffness: this.springStiffness,
<span id="line28628" class="line"></span>        animationTime: this.animationTime
<span id="line28629" class="line"></span>    });
<span id="line28630" class="line"></span>
<span id="line28631" class="line"></span>    this._ySpring = new $.Spring({
<span id="line28632" class="line"></span>        initial: y,
<span id="line28633" class="line"></span>        springStiffness: this.springStiffness,
<span id="line28634" class="line"></span>        animationTime: this.animationTime
<span id="line28635" class="line"></span>    });
<span id="line28636" class="line"></span>
<span id="line28637" class="line"></span>    this._scaleSpring = new $.Spring({
<span id="line28638" class="line"></span>        initial: scale,
<span id="line28639" class="line"></span>        springStiffness: this.springStiffness,
<span id="line28640" class="line"></span>        animationTime: this.animationTime
<span id="line28641" class="line"></span>    });
<span id="line28642" class="line"></span>
<span id="line28643" class="line"></span>    this._degreesSpring = new $.Spring({
<span id="line28644" class="line"></span>        initial: degrees,
<span id="line28645" class="line"></span>        springStiffness: this.springStiffness,
<span id="line28646" class="line"></span>        animationTime: this.animationTime
<span id="line28647" class="line"></span>    });
<span id="line28648" class="line"></span>
<span id="line28649" class="line"></span>    this._updateForScale();
<span id="line28650" class="line"></span>
<span id="line28651" class="line"></span>    if (fitBounds) {
<span id="line28652" class="line"></span>        this.fitBounds(fitBounds, fitBoundsPlacement, true);
<span id="line28653" class="line"></span>    }
<span id="line28654" class="line"></span>
<span id="line28655" class="line"></span>    this._ownAjaxHeaders = {};
<span id="line28656" class="line"></span>    this.setAjaxHeaders(ajaxHeaders, false);
<span id="line28657" class="line"></span>    this._initialized = true;
<span id="line28658" class="line"></span>    // this.invalidatedAt = 0;
<span id="line28659" class="line"></span>};
<span id="line28660" class="line"></span>
<span id="line28661" class="line"></span>$.extend($.TiledImage.prototype, $.EventSource.prototype, /** @lends OpenSeadragon.TiledImage.prototype */{
<span id="line28662" class="line"></span>    /**
<span id="line28663" class="line"></span>     * @returns {Boolean} Whether the TiledImage needs to be drawn.
<span id="line28664" class="line"></span>     */
<span id="line28665" class="line"></span>    needsDraw: function() {
<span id="line28666" class="line"></span>        return this._needsDraw;
<span id="line28667" class="line"></span>    },
<span id="line28668" class="line"></span>
<span id="line28669" class="line"></span>    /**
<span id="line28670" class="line"></span>     * Mark the tiled image as needing to be (re)drawn
<span id="line28671" class="line"></span>     */
<span id="line28672" class="line"></span>    redraw: function() {
<span id="line28673" class="line"></span>        this._needsDraw = true;
<span id="line28674" class="line"></span>    },
<span id="line28675" class="line"></span>
<span id="line28676" class="line"></span>    /**
<span id="line28677" class="line"></span>     * @returns {Boolean} Whether all tiles necessary for this TiledImage to draw at the current view have been loaded.
<span id="line28678" class="line"></span>     */
<span id="line28679" class="line"></span>    getFullyLoaded: function() {
<span id="line28680" class="line"></span>        return this._fullyLoaded;
<span id="line28681" class="line"></span>    },
<span id="line28682" class="line"></span>
<span id="line28683" class="line"></span>    /**
<span id="line28684" class="line"></span>     * Executes the provided callback when the TiledImage is fully loaded. If already loaded,
<span id="line28685" class="line"></span>     * schedules the callback asynchronously. Otherwise, attaches a one-time event listener
<span id="line28686" class="line"></span>     * for the 'fully-loaded-change' event.
<span id="line28687" class="line"></span>     * @param {Function} callback - Function to execute when loading completes
<span id="line28688" class="line"></span>     */
<span id="line28689" class="line"></span>    whenFullyLoaded: function(callback) {
<span id="line28690" class="line"></span>        if (this.getFullyLoaded()) {
<span id="line28691" class="line"></span>            setTimeout(callback, 1); // Asynchronous execution
<span id="line28692" class="line"></span>        } else {
<span id="line28693" class="line"></span>            this.addOnceHandler('fully-loaded-change', function() {
<span id="line28694" class="line"></span>                callback(); // Maintain context
<span id="line28695" class="line"></span>            });
<span id="line28696" class="line"></span>        }
<span id="line28697" class="line"></span>    },
<span id="line28698" class="line"></span>
<span id="line28699" class="line"></span>    // private
<span id="line28700" class="line"></span>    _setFullyLoaded: function(flag) {
<span id="line28701" class="line"></span>        if (flag === this._fullyLoaded) {
<span id="line28702" class="line"></span>            return;
<span id="line28703" class="line"></span>        }
<span id="line28704" class="line"></span>
<span id="line28705" class="line"></span>        this._fullyLoaded = flag;
<span id="line28706" class="line"></span>
<span id="line28707" class="line"></span>        /**
<span id="line28708" class="line"></span>         * Fired when the TiledImage's "fully loaded" flag (whether all tiles necessary for this TiledImage
<span id="line28709" class="line"></span>         * to draw at the current view have been loaded) changes.
<span id="line28710" class="line"></span>         *
<span id="line28711" class="line"></span>         * @event fully-loaded-change
<span id="line28712" class="line"></span>         * @memberof OpenSeadragon.TiledImage
<span id="line28713" class="line"></span>         * @type {object}
<span id="line28714" class="line"></span>         * @property {Boolean} fullyLoaded - The new "fully loaded" value.
<span id="line28715" class="line"></span>         * @property {OpenSeadragon.TiledImage} eventSource - A reference to the TiledImage which raised the event.
<span id="line28716" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line28717" class="line"></span>         */
<span id="line28718" class="line"></span>        this.raiseEvent('fully-loaded-change', {
<span id="line28719" class="line"></span>            fullyLoaded: this._fullyLoaded
<span id="line28720" class="line"></span>        });
<span id="line28721" class="line"></span>    },
<span id="line28722" class="line"></span>
<span id="line28723" class="line"></span>    /**
<span id="line28724" class="line"></span>     * Forces the system consider all tiles in this tiled image
<span id="line28725" class="line"></span>     * as outdated, and fire tile update event on relevant tiles
<span id="line28726" class="line"></span>     * Detailed description is available within the 'tile-invalidated'
<span id="line28727" class="line"></span>     * event.
<span id="line28728" class="line"></span>     * @param {Boolean} [restoreTiles=true] if true, tile processing starts from the tile original data
<span id="line28729" class="line"></span>     * @param {boolean} [viewportOnly=false] optionally invalidate only viewport-visible tiles if true
<span id="line28730" class="line"></span>     * @param {number} [tStamp=OpenSeadragon.now()] optionally provide tStamp of the update event
<span id="line28731" class="line"></span>     * @return {OpenSeadragon.Promise}
<span id="line28732" class="line"></span>     */
<span id="line28733" class="line"></span>    requestInvalidate: function (restoreTiles = true, viewportOnly = false, tStamp = $.now()) {
<span id="line28734" class="line"></span>        const tiles = viewportOnly ? this._lastDrawn.map(x =&gt; x.tile) : this._tileCache.getLoadedTilesFor(this);
<span id="line28735" class="line"></span>        return this.viewer.world.requestTileInvalidateEvent(tiles, tStamp, restoreTiles);
<span id="line28736" class="line"></span>    },
<span id="line28737" class="line"></span>
<span id="line28738" class="line"></span>    /**
<span id="line28739" class="line"></span>     * Clears all tiles and triggers an update on the next call to
<span id="line28740" class="line"></span>     * {@link OpenSeadragon.TiledImage#update}.
<span id="line28741" class="line"></span>     */
<span id="line28742" class="line"></span>    reset: function() {
<span id="line28743" class="line"></span>        this._tileCache.clearTilesFor(this);
<span id="line28744" class="line"></span>        this._currentMaxTilesPerFrame = this.maxTilesPerFrame * 10;
<span id="line28745" class="line"></span>        this.lastResetTime = $.now();
<span id="line28746" class="line"></span>        this._needsDraw = true;
<span id="line28747" class="line"></span>        this._fullyLoaded = false;
<span id="line28748" class="line"></span>    },
<span id="line28749" class="line"></span>
<span id="line28750" class="line"></span>    /**
<span id="line28751" class="line"></span>     * Updates the TiledImage's bounds, animating if needed. Based on the new
<span id="line28752" class="line"></span>     * bounds, updates the levels and tiles to be drawn into the viewport.
<span id="line28753" class="line"></span>     * @param viewportChanged Whether the viewport changed meaning tiles need to be updated.
<span id="line28754" class="line"></span>     * @returns {Boolean} Whether the TiledImage needs to be drawn.
<span id="line28755" class="line"></span>     */
<span id="line28756" class="line"></span>    update: function(viewportChanged) {
<span id="line28757" class="line"></span>        const xUpdated = this._xSpring.update();
<span id="line28758" class="line"></span>        const yUpdated = this._ySpring.update();
<span id="line28759" class="line"></span>        const scaleUpdated = this._scaleSpring.update();
<span id="line28760" class="line"></span>        const degreesUpdated = this._degreesSpring.update();
<span id="line28761" class="line"></span>
<span id="line28762" class="line"></span>        const updated = (xUpdated || yUpdated || scaleUpdated || degreesUpdated || this._needsUpdate);
<span id="line28763" class="line"></span>
<span id="line28764" class="line"></span>        if (updated || viewportChanged || !this._fullyLoaded){
<span id="line28765" class="line"></span>            const fullyLoadedFlag = this._updateLevelsForViewport();
<span id="line28766" class="line"></span>            this._setFullyLoaded(fullyLoadedFlag);
<span id="line28767" class="line"></span>        }
<span id="line28768" class="line"></span>
<span id="line28769" class="line"></span>        this._needsUpdate = false;
<span id="line28770" class="line"></span>
<span id="line28771" class="line"></span>        if (updated) {
<span id="line28772" class="line"></span>            this._updateForScale();
<span id="line28773" class="line"></span>            this._raiseBoundsChange();
<span id="line28774" class="line"></span>            this._needsDraw = true;
<span id="line28775" class="line"></span>            return true;
<span id="line28776" class="line"></span>        }
<span id="line28777" class="line"></span>
<span id="line28778" class="line"></span>        return false;
<span id="line28779" class="line"></span>    },
<span id="line28780" class="line"></span>
<span id="line28781" class="line"></span>    /**
<span id="line28782" class="line"></span>     * Mark this TiledImage as having been drawn, so that it will only be drawn
<span id="line28783" class="line"></span>     * again if something changes about the image. If the image is still blending,
<span id="line28784" class="line"></span>     * this will have no effect.
<span id="line28785" class="line"></span>     * @returns {Boolean} whether the item still needs to be drawn due to blending
<span id="line28786" class="line"></span>     */
<span id="line28787" class="line"></span>    setDrawn: function(){
<span id="line28788" class="line"></span>        this._needsDraw = this._isBlending || this._wasBlending ||
<span id="line28789" class="line"></span>            (this.opacity &gt; 0 &amp;&amp; this._lastDrawn.length &lt; 1);
<span id="line28790" class="line"></span>        return this._needsDraw;
<span id="line28791" class="line"></span>    },
<span id="line28792" class="line"></span>
<span id="line28793" class="line"></span>    get crossOriginPolicy(){
<span id="line28794" class="line"></span>        return this._crossOriginPolicy;
<span id="line28795" class="line"></span>    },
<span id="line28796" class="line"></span>
<span id="line28797" class="line"></span>    set crossOriginPolicy(crossOriginPolicy) {
<span id="line28798" class="line"></span>        if (typeof crossOriginPolicy === 'string') {
<span id="line28799" class="line"></span>            this._crossOriginPolicy = crossOriginPolicy.toLowerCase();
<span id="line28800" class="line"></span>        } else {
<span id="line28801" class="line"></span>            this._crossOriginPolicy = $.DEFAULT_SETTINGS.crossOriginPolicy;
<span id="line28802" class="line"></span>        }
<span id="line28803" class="line"></span>    },
<span id="line28804" class="line"></span>
<span id="line28805" class="line"></span>    /**
<span id="line28806" class="line"></span>     * Set the internal issue flag for this TiledImage. Lazy loaded - not
<span id="line28807" class="line"></span>     * checked each time a Tile is loaded, but can be set if a consumer of the
<span id="line28808" class="line"></span>     * tiles (e.g. a Drawer) discovers a Tile to have certain data issue so that further
<span id="line28809" class="line"></span>     * checks are not needed and alternative rendering strategies can be used.
<span id="line28810" class="line"></span>     * @param {OpenSeadragon.TiledImage.Issue} issueType
<span id="line28811" class="line"></span>     * @param {string} description
<span id="line28812" class="line"></span>     * @param {Error|any} error
<span id="line28813" class="line"></span>     * @private
<span id="line28814" class="line"></span>     */
<span id="line28815" class="line"></span>    setIssue(issueType, description = undefined, error = undefined){
<span id="line28816" class="line"></span>        const errorText = error ? (error.message || error) : '';
<span id="line28817" class="line"></span>        this._issues[issueType] = (description || `TiledImage is ${issueType}}`) + errorText;
<span id="line28818" class="line"></span>        $.console.warn(this._issues[issueType], error);
<span id="line28819" class="line"></span>    },
<span id="line28820" class="line"></span>
<span id="line28821" class="line"></span>    /**
<span id="line28822" class="line"></span>     * @param {OpenSeadragon.TiledImage.Issue} issueType
<span id="line28823" class="line"></span>     * @returns {string} issue details or undefined if the issue does not apply
<span id="line28824" class="line"></span>     */
<span id="line28825" class="line"></span>    getIssue(issueType) {
<span id="line28826" class="line"></span>        return this._issues[issueType];
<span id="line28827" class="line"></span>    },
<span id="line28828" class="line"></span>
<span id="line28829" class="line"></span>    /**
<span id="line28830" class="line"></span>     * @param {OpenSeadragon.TiledImage.Issue} issueType
<span id="line28831" class="line"></span>     * @returns {Boolean} whether the TiledImage has been marked with a given issue
<span id="line28832" class="line"></span>     */
<span id="line28833" class="line"></span>    hasIssue(issueType){
<span id="line28834" class="line"></span>        return !!this.getIssue(issueType);
<span id="line28835" class="line"></span>    },
<span id="line28836" class="line"></span>
<span id="line28837" class="line"></span>    /**
<span id="line28838" class="line"></span>     * Destroy the TiledImage (unload current loaded tiles).
<span id="line28839" class="line"></span>     */
<span id="line28840" class="line"></span>    destroy: function() {
<span id="line28841" class="line"></span>        this.reset();
<span id="line28842" class="line"></span>        this.source.destroy(this.viewer);
<span id="line28843" class="line"></span>    },
<span id="line28844" class="line"></span>
<span id="line28845" class="line"></span>    /**
<span id="line28846" class="line"></span>     * Get this TiledImage's bounds in viewport coordinates.
<span id="line28847" class="line"></span>     * @param {Boolean} [current=false] - Pass true for the current location;
<span id="line28848" class="line"></span>     * false for target location.
<span id="line28849" class="line"></span>     * @returns {OpenSeadragon.Rect} This TiledImage's bounds in viewport coordinates.
<span id="line28850" class="line"></span>     */
<span id="line28851" class="line"></span>    getBounds: function(current) {
<span id="line28852" class="line"></span>        return this.getBoundsNoRotate(current)
<span id="line28853" class="line"></span>            .rotate(this.getRotation(current), this._getRotationPoint(current));
<span id="line28854" class="line"></span>    },
<span id="line28855" class="line"></span>
<span id="line28856" class="line"></span>    /**
<span id="line28857" class="line"></span>     * Get this TiledImage's bounds in viewport coordinates without taking
<span id="line28858" class="line"></span>     * rotation into account.
<span id="line28859" class="line"></span>     * @param {Boolean} [current=false] - Pass true for the current location;
<span id="line28860" class="line"></span>     * false for target location.
<span id="line28861" class="line"></span>     * @returns {OpenSeadragon.Rect} This TiledImage's bounds in viewport coordinates.
<span id="line28862" class="line"></span>     */
<span id="line28863" class="line"></span>    getBoundsNoRotate: function(current) {
<span id="line28864" class="line"></span>        return current ?
<span id="line28865" class="line"></span>            new $.Rect(
<span id="line28866" class="line"></span>                this._xSpring.current.value,
<span id="line28867" class="line"></span>                this._ySpring.current.value,
<span id="line28868" class="line"></span>                this._worldWidthCurrent,
<span id="line28869" class="line"></span>                this._worldHeightCurrent) :
<span id="line28870" class="line"></span>            new $.Rect(
<span id="line28871" class="line"></span>                this._xSpring.target.value,
<span id="line28872" class="line"></span>                this._ySpring.target.value,
<span id="line28873" class="line"></span>                this._worldWidthTarget,
<span id="line28874" class="line"></span>                this._worldHeightTarget);
<span id="line28875" class="line"></span>    },
<span id="line28876" class="line"></span>
<span id="line28877" class="line"></span>    // deprecated
<span id="line28878" class="line"></span>    getWorldBounds: function() {
<span id="line28879" class="line"></span>        $.console.error('[TiledImage.getWorldBounds] is deprecated; use TiledImage.getBounds instead');
<span id="line28880" class="line"></span>        return this.getBounds();
<span id="line28881" class="line"></span>    },
<span id="line28882" class="line"></span>
<span id="line28883" class="line"></span>    /**
<span id="line28884" class="line"></span>     * Get the bounds of the displayed part of the tiled image.
<span id="line28885" class="line"></span>     * @param {Boolean} [current=false] Pass true for the current location,
<span id="line28886" class="line"></span>     * false for the target location.
<span id="line28887" class="line"></span>     * @returns {$.Rect} The clipped bounds in viewport coordinates.
<span id="line28888" class="line"></span>     */
<span id="line28889" class="line"></span>    getClippedBounds: function(current) {
<span id="line28890" class="line"></span>        let bounds = this.getBoundsNoRotate(current);
<span id="line28891" class="line"></span>        if (this._clip) {
<span id="line28892" class="line"></span>            const worldWidth = current ?
<span id="line28893" class="line"></span>                this._worldWidthCurrent : this._worldWidthTarget;
<span id="line28894" class="line"></span>            const ratio = worldWidth / this.source.dimensions.x;
<span id="line28895" class="line"></span>            const clip = this._clip.times(ratio);
<span id="line28896" class="line"></span>            bounds = new $.Rect(
<span id="line28897" class="line"></span>                bounds.x + clip.x,
<span id="line28898" class="line"></span>                bounds.y + clip.y,
<span id="line28899" class="line"></span>                clip.width,
<span id="line28900" class="line"></span>                clip.height);
<span id="line28901" class="line"></span>        }
<span id="line28902" class="line"></span>        return bounds.rotate(this.getRotation(current), this._getRotationPoint(current));
<span id="line28903" class="line"></span>    },
<span id="line28904" class="line"></span>
<span id="line28905" class="line"></span>    /**
<span id="line28906" class="line"></span>     * @function
<span id="line28907" class="line"></span>     * @param {Number} level
<span id="line28908" class="line"></span>     * @param {Number} x
<span id="line28909" class="line"></span>     * @param {Number} y
<span id="line28910" class="line"></span>     * @returns {OpenSeadragon.Rect} Where this tile fits (in normalized coordinates).
<span id="line28911" class="line"></span>     */
<span id="line28912" class="line"></span>    getTileBounds: function( level, x, y ) {
<span id="line28913" class="line"></span>        const numTiles = this.source.getNumTiles(level);
<span id="line28914" class="line"></span>        const xMod    = ( numTiles.x + ( x % numTiles.x ) ) % numTiles.x;
<span id="line28915" class="line"></span>        const yMod    = ( numTiles.y + ( y % numTiles.y ) ) % numTiles.y;
<span id="line28916" class="line"></span>        const bounds = this.source.getTileBounds(level, xMod, yMod);
<span id="line28917" class="line"></span>        if (this.getFlip()) {
<span id="line28918" class="line"></span>            bounds.x = Math.max(0, 1 - bounds.x - bounds.width);
<span id="line28919" class="line"></span>        }
<span id="line28920" class="line"></span>        bounds.x += (x - xMod) / numTiles.x;
<span id="line28921" class="line"></span>        bounds.y += (this._worldHeightCurrent / this._worldWidthCurrent) * ((y - yMod) / numTiles.y);
<span id="line28922" class="line"></span>        return bounds;
<span id="line28923" class="line"></span>    },
<span id="line28924" class="line"></span>
<span id="line28925" class="line"></span>    /**
<span id="line28926" class="line"></span>     * @returns {OpenSeadragon.Point} This TiledImage's content size, in original pixels.
<span id="line28927" class="line"></span>     */
<span id="line28928" class="line"></span>    getContentSize: function() {
<span id="line28929" class="line"></span>        return new $.Point(this.source.dimensions.x, this.source.dimensions.y);
<span id="line28930" class="line"></span>    },
<span id="line28931" class="line"></span>
<span id="line28932" class="line"></span>    /**
<span id="line28933" class="line"></span>     * @returns {OpenSeadragon.Point} The TiledImage's content size, in window coordinates.
<span id="line28934" class="line"></span>     */
<span id="line28935" class="line"></span>    getSizeInWindowCoordinates: function() {
<span id="line28936" class="line"></span>        const topLeft = this.imageToWindowCoordinates(new $.Point(0, 0));
<span id="line28937" class="line"></span>        const bottomRight = this.imageToWindowCoordinates(this.getContentSize());
<span id="line28938" class="line"></span>        return new $.Point(bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
<span id="line28939" class="line"></span>    },
<span id="line28940" class="line"></span>
<span id="line28941" class="line"></span>    /**
<span id="line28942" class="line"></span>     * Get tile list that was used to draw the viewport current or last frame.
<span id="line28943" class="line"></span>     * @return {OpenSeadragon.OpenSeadragon.TiledImage.DrawTileInfo[]}
<span id="line28944" class="line"></span>     */
<span id="line28945" class="line"></span>    get lastDrawn() {
<span id="line28946" class="line"></span>        return this._lastDrawn;
<span id="line28947" class="line"></span>    },
<span id="line28948" class="line"></span>
<span id="line28949" class="line"></span>    /**
<span id="line28950" class="line"></span>     * Get drawer instance used to draw this tiled image. Normally,
<span id="line28951" class="line"></span>     * it is the drawer of the base viewer that owns the tiled image.
<span id="line28952" class="line"></span>     * However, if the image is instantiated manually and used for example
<span id="line28953" class="line"></span>     * in offscreen rendering, you might need to change the reference drawer.
<span id="line28954" class="line"></span>     * @returns {OpenSeadragon.DrawerBase} The drawer instance used to draw this tiled image.
<span id="line28955" class="line"></span>     */
<span id="line28956" class="line"></span>    getDrawer: function () {
<span id="line28957" class="line"></span>        return this.viewer.drawer;
<span id="line28958" class="line"></span>    },
<span id="line28959" class="line"></span>
<span id="line28960" class="line"></span>    // private
<span id="line28961" class="line"></span>    _viewportToImageDelta: function( viewerX, viewerY, current ) {
<span id="line28962" class="line"></span>        const scale = (current ? this._scaleSpring.current.value : this._scaleSpring.target.value);
<span id="line28963" class="line"></span>        return new $.Point(viewerX * (this.source.dimensions.x / scale),
<span id="line28964" class="line"></span>            viewerY * ((this.source.dimensions.y * this.contentAspectX) / scale));
<span id="line28965" class="line"></span>    },
<span id="line28966" class="line"></span>
<span id="line28967" class="line"></span>    /**
<span id="line28968" class="line"></span>     * Translates from OpenSeadragon viewer coordinate system to image coordinate system.
<span id="line28969" class="line"></span>     * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.
<span id="line28970" class="line"></span>     * @param {Number|OpenSeadragon.Point} viewerX - The X coordinate or point in viewport coordinate system.
<span id="line28971" class="line"></span>     * @param {Number} [viewerY] - The Y coordinate in viewport coordinate system.
<span id="line28972" class="line"></span>     * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
<span id="line28973" class="line"></span>     * @returns {OpenSeadragon.Point} A point representing the coordinates in the image.
<span id="line28974" class="line"></span>     */
<span id="line28975" class="line"></span>    viewportToImageCoordinates: function(viewerX, viewerY, current) {
<span id="line28976" class="line"></span>        let point;
<span id="line28977" class="line"></span>        if (viewerX instanceof $.Point) {
<span id="line28978" class="line"></span>            //they passed a point instead of individual components
<span id="line28979" class="line"></span>            current = viewerY;
<span id="line28980" class="line"></span>            point = viewerX;
<span id="line28981" class="line"></span>        } else {
<span id="line28982" class="line"></span>            point = new $.Point(viewerX, viewerY);
<span id="line28983" class="line"></span>        }
<span id="line28984" class="line"></span>
<span id="line28985" class="line"></span>        point = point.rotate(-this.getRotation(current), this._getRotationPoint(current));
<span id="line28986" class="line"></span>        return current ?
<span id="line28987" class="line"></span>            this._viewportToImageDelta(
<span id="line28988" class="line"></span>                point.x - this._xSpring.current.value,
<span id="line28989" class="line"></span>                point.y - this._ySpring.current.value) :
<span id="line28990" class="line"></span>            this._viewportToImageDelta(
<span id="line28991" class="line"></span>                point.x - this._xSpring.target.value,
<span id="line28992" class="line"></span>                point.y - this._ySpring.target.value);
<span id="line28993" class="line"></span>    },
<span id="line28994" class="line"></span>
<span id="line28995" class="line"></span>    // private
<span id="line28996" class="line"></span>    _imageToViewportDelta: function( imageX, imageY, current ) {
<span id="line28997" class="line"></span>        const scale = (current ? this._scaleSpring.current.value : this._scaleSpring.target.value);
<span id="line28998" class="line"></span>        return new $.Point((imageX / this.source.dimensions.x) * scale,
<span id="line28999" class="line"></span>            (imageY / this.source.dimensions.y / this.contentAspectX) * scale);
<span id="line29000" class="line"></span>    },
<span id="line29001" class="line"></span>
<span id="line29002" class="line"></span>    /**
<span id="line29003" class="line"></span>     * Translates from image coordinate system to OpenSeadragon viewer coordinate system
<span id="line29004" class="line"></span>     * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.
<span id="line29005" class="line"></span>     * @param {Number|OpenSeadragon.Point} imageX - The X coordinate or point in image coordinate system.
<span id="line29006" class="line"></span>     * @param {Number} [imageY] - The Y coordinate in image coordinate system.
<span id="line29007" class="line"></span>     * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
<span id="line29008" class="line"></span>     * @returns {OpenSeadragon.Point} A point representing the coordinates in the viewport.
<span id="line29009" class="line"></span>     */
<span id="line29010" class="line"></span>    imageToViewportCoordinates: function(imageX, imageY, current) {
<span id="line29011" class="line"></span>        if (imageX instanceof $.Point) {
<span id="line29012" class="line"></span>            //they passed a point instead of individual components
<span id="line29013" class="line"></span>            current = imageY;
<span id="line29014" class="line"></span>            imageY = imageX.y;
<span id="line29015" class="line"></span>            imageX = imageX.x;
<span id="line29016" class="line"></span>        }
<span id="line29017" class="line"></span>
<span id="line29018" class="line"></span>        const point = this._imageToViewportDelta(imageX, imageY, current);
<span id="line29019" class="line"></span>        if (current) {
<span id="line29020" class="line"></span>            point.x += this._xSpring.current.value;
<span id="line29021" class="line"></span>            point.y += this._ySpring.current.value;
<span id="line29022" class="line"></span>        } else {
<span id="line29023" class="line"></span>            point.x += this._xSpring.target.value;
<span id="line29024" class="line"></span>            point.y += this._ySpring.target.value;
<span id="line29025" class="line"></span>        }
<span id="line29026" class="line"></span>
<span id="line29027" class="line"></span>        return point.rotate(this.getRotation(current), this._getRotationPoint(current));
<span id="line29028" class="line"></span>    },
<span id="line29029" class="line"></span>
<span id="line29030" class="line"></span>    /**
<span id="line29031" class="line"></span>     * Translates from a rectangle which describes a portion of the image in
<span id="line29032" class="line"></span>     * pixel coordinates to OpenSeadragon viewport rectangle coordinates.
<span id="line29033" class="line"></span>     * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.
<span id="line29034" class="line"></span>     * @param {Number|OpenSeadragon.Rect} imageX - The left coordinate or rectangle in image coordinate system.
<span id="line29035" class="line"></span>     * @param {Number} [imageY] - The top coordinate in image coordinate system.
<span id="line29036" class="line"></span>     * @param {Number} [pixelWidth] - The width in pixel of the rectangle.
<span id="line29037" class="line"></span>     * @param {Number} [pixelHeight] - The height in pixel of the rectangle.
<span id="line29038" class="line"></span>     * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
<span id="line29039" class="line"></span>     * @returns {OpenSeadragon.Rect} A rect representing the coordinates in the viewport.
<span id="line29040" class="line"></span>     */
<span id="line29041" class="line"></span>    imageToViewportRectangle: function(imageX, imageY, pixelWidth, pixelHeight, current) {
<span id="line29042" class="line"></span>        let rect = imageX;
<span id="line29043" class="line"></span>        if (rect instanceof $.Rect) {
<span id="line29044" class="line"></span>            //they passed a rect instead of individual components
<span id="line29045" class="line"></span>            current = imageY;
<span id="line29046" class="line"></span>        } else {
<span id="line29047" class="line"></span>            rect = new $.Rect(imageX, imageY, pixelWidth, pixelHeight);
<span id="line29048" class="line"></span>        }
<span id="line29049" class="line"></span>
<span id="line29050" class="line"></span>        const coordA = this.imageToViewportCoordinates(rect.getTopLeft(), current);
<span id="line29051" class="line"></span>        const coordB = this._imageToViewportDelta(rect.width, rect.height, current);
<span id="line29052" class="line"></span>
<span id="line29053" class="line"></span>        return new $.Rect(
<span id="line29054" class="line"></span>            coordA.x,
<span id="line29055" class="line"></span>            coordA.y,
<span id="line29056" class="line"></span>            coordB.x,
<span id="line29057" class="line"></span>            coordB.y,
<span id="line29058" class="line"></span>            rect.degrees + this.getRotation(current)
<span id="line29059" class="line"></span>        );
<span id="line29060" class="line"></span>    },
<span id="line29061" class="line"></span>
<span id="line29062" class="line"></span>    /**
<span id="line29063" class="line"></span>     * Translates from a rectangle which describes a portion of
<span id="line29064" class="line"></span>     * the viewport in point coordinates to image rectangle coordinates.
<span id="line29065" class="line"></span>     * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.
<span id="line29066" class="line"></span>     * @param {Number|OpenSeadragon.Rect} viewerX - The left coordinate or rectangle in viewport coordinate system.
<span id="line29067" class="line"></span>     * @param {Number} [viewerY] - The top coordinate in viewport coordinate system.
<span id="line29068" class="line"></span>     * @param {Number} [pointWidth] - The width in viewport coordinate system.
<span id="line29069" class="line"></span>     * @param {Number} [pointHeight] - The height in viewport coordinate system.
<span id="line29070" class="line"></span>     * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
<span id="line29071" class="line"></span>     * @returns {OpenSeadragon.Rect} A rect representing the coordinates in the image.
<span id="line29072" class="line"></span>     */
<span id="line29073" class="line"></span>    viewportToImageRectangle: function( viewerX, viewerY, pointWidth, pointHeight, current ) {
<span id="line29074" class="line"></span>        let rect = viewerX;
<span id="line29075" class="line"></span>        if (viewerX instanceof $.Rect) {
<span id="line29076" class="line"></span>            //they passed a rect instead of individual components
<span id="line29077" class="line"></span>            current = viewerY;
<span id="line29078" class="line"></span>        } else {
<span id="line29079" class="line"></span>            rect = new $.Rect(viewerX, viewerY, pointWidth, pointHeight);
<span id="line29080" class="line"></span>        }
<span id="line29081" class="line"></span>
<span id="line29082" class="line"></span>        const coordA = this.viewportToImageCoordinates(rect.getTopLeft(), current);
<span id="line29083" class="line"></span>        const coordB = this._viewportToImageDelta(rect.width, rect.height, current);
<span id="line29084" class="line"></span>
<span id="line29085" class="line"></span>        return new $.Rect(
<span id="line29086" class="line"></span>            coordA.x,
<span id="line29087" class="line"></span>            coordA.y,
<span id="line29088" class="line"></span>            coordB.x,
<span id="line29089" class="line"></span>            coordB.y,
<span id="line29090" class="line"></span>            rect.degrees - this.getRotation(current)
<span id="line29091" class="line"></span>        );
<span id="line29092" class="line"></span>    },
<span id="line29093" class="line"></span>
<span id="line29094" class="line"></span>    /**
<span id="line29095" class="line"></span>     * Convert pixel coordinates relative to the viewer element to image
<span id="line29096" class="line"></span>     * coordinates.
<span id="line29097" class="line"></span>     * @param {OpenSeadragon.Point} pixel
<span id="line29098" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line29099" class="line"></span>     */
<span id="line29100" class="line"></span>    viewerElementToImageCoordinates: function( pixel ) {
<span id="line29101" class="line"></span>        const point = this.viewport.pointFromPixel( pixel, true );
<span id="line29102" class="line"></span>        return this.viewportToImageCoordinates( point );
<span id="line29103" class="line"></span>    },
<span id="line29104" class="line"></span>
<span id="line29105" class="line"></span>    /**
<span id="line29106" class="line"></span>     * Convert pixel coordinates relative to the image to
<span id="line29107" class="line"></span>     * viewer element coordinates.
<span id="line29108" class="line"></span>     * @param {OpenSeadragon.Point} pixel
<span id="line29109" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line29110" class="line"></span>     */
<span id="line29111" class="line"></span>    imageToViewerElementCoordinates: function( pixel ) {
<span id="line29112" class="line"></span>        const point = this.imageToViewportCoordinates( pixel );
<span id="line29113" class="line"></span>        return this.viewport.pixelFromPoint( point, true );
<span id="line29114" class="line"></span>    },
<span id="line29115" class="line"></span>
<span id="line29116" class="line"></span>    /**
<span id="line29117" class="line"></span>     * Convert pixel coordinates relative to the window to image coordinates.
<span id="line29118" class="line"></span>     * @param {OpenSeadragon.Point} pixel
<span id="line29119" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line29120" class="line"></span>     */
<span id="line29121" class="line"></span>    windowToImageCoordinates: function( pixel ) {
<span id="line29122" class="line"></span>        const viewerCoordinates = pixel.minus(
<span id="line29123" class="line"></span>            OpenSeadragon.getElementPosition( this.viewer.element ));
<span id="line29124" class="line"></span>        return this.viewerElementToImageCoordinates( viewerCoordinates );
<span id="line29125" class="line"></span>    },
<span id="line29126" class="line"></span>
<span id="line29127" class="line"></span>    /**
<span id="line29128" class="line"></span>     * Convert image coordinates to pixel coordinates relative to the window.
<span id="line29129" class="line"></span>     * @param {OpenSeadragon.Point} pixel
<span id="line29130" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line29131" class="line"></span>     */
<span id="line29132" class="line"></span>    imageToWindowCoordinates: function( pixel ) {
<span id="line29133" class="line"></span>        const viewerCoordinates = this.imageToViewerElementCoordinates( pixel );
<span id="line29134" class="line"></span>        return viewerCoordinates.plus(
<span id="line29135" class="line"></span>            OpenSeadragon.getElementPosition( this.viewer.element ));
<span id="line29136" class="line"></span>    },
<span id="line29137" class="line"></span>
<span id="line29138" class="line"></span>    // private
<span id="line29139" class="line"></span>    // Convert rectangle in viewport coordinates to this tiled image point
<span id="line29140" class="line"></span>    // coordinates (x in [0, 1] and y in [0, aspectRatio])
<span id="line29141" class="line"></span>    _viewportToTiledImageRectangle: function(rect) {
<span id="line29142" class="line"></span>        const scale = this._scaleSpring.current.value;
<span id="line29143" class="line"></span>        rect = rect.rotate(-this.getRotation(true), this._getRotationPoint(true));
<span id="line29144" class="line"></span>        return new $.Rect(
<span id="line29145" class="line"></span>            (rect.x - this._xSpring.current.value) / scale,
<span id="line29146" class="line"></span>            (rect.y - this._ySpring.current.value) / scale,
<span id="line29147" class="line"></span>            rect.width / scale,
<span id="line29148" class="line"></span>            rect.height / scale,
<span id="line29149" class="line"></span>            rect.degrees);
<span id="line29150" class="line"></span>    },
<span id="line29151" class="line"></span>
<span id="line29152" class="line"></span>    /**
<span id="line29153" class="line"></span>     * Convert a viewport zoom to an image zoom.
<span id="line29154" class="line"></span>     * Image zoom: ratio of the original image size to displayed image size.
<span id="line29155" class="line"></span>     * 1 means original image size, 0.5 half size...
<span id="line29156" class="line"></span>     * Viewport zoom: ratio of the displayed image's width to viewport's width.
<span id="line29157" class="line"></span>     * 1 means identical width, 2 means image's width is twice the viewport's width...
<span id="line29158" class="line"></span>     * @function
<span id="line29159" class="line"></span>     * @param {Number} viewportZoom The viewport zoom
<span id="line29160" class="line"></span>     * @returns {Number} imageZoom The image zoom
<span id="line29161" class="line"></span>     */
<span id="line29162" class="line"></span>    viewportToImageZoom: function( viewportZoom ) {
<span id="line29163" class="line"></span>        const ratio = this._scaleSpring.current.value *
<span id="line29164" class="line"></span>            this.viewport._containerInnerSize.x / this.source.dimensions.x;
<span id="line29165" class="line"></span>        return ratio * viewportZoom;
<span id="line29166" class="line"></span>    },
<span id="line29167" class="line"></span>
<span id="line29168" class="line"></span>    /**
<span id="line29169" class="line"></span>     * Convert an image zoom to a viewport zoom.
<span id="line29170" class="line"></span>     * Image zoom: ratio of the original image size to displayed image size.
<span id="line29171" class="line"></span>     * 1 means original image size, 0.5 half size...
<span id="line29172" class="line"></span>     * Viewport zoom: ratio of the displayed image's width to viewport's width.
<span id="line29173" class="line"></span>     * 1 means identical width, 2 means image's width is twice the viewport's width...
<span id="line29174" class="line"></span>     * @function
<span id="line29175" class="line"></span>     * @param {Number} imageZoom The image zoom
<span id="line29176" class="line"></span>     * @returns {Number} viewportZoom The viewport zoom
<span id="line29177" class="line"></span>     */
<span id="line29178" class="line"></span>    imageToViewportZoom: function( imageZoom ) {
<span id="line29179" class="line"></span>        const ratio = this._scaleSpring.current.value *
<span id="line29180" class="line"></span>            this.viewport._containerInnerSize.x / this.source.dimensions.x;
<span id="line29181" class="line"></span>        return imageZoom / ratio;
<span id="line29182" class="line"></span>    },
<span id="line29183" class="line"></span>
<span id="line29184" class="line"></span>    /**
<span id="line29185" class="line"></span>     * Sets the TiledImage's position in the world.
<span id="line29186" class="line"></span>     * @param {OpenSeadragon.Point} position - The new position, in viewport coordinates.
<span id="line29187" class="line"></span>     * @param {Boolean} [immediately=false] - Whether to animate to the new position or snap immediately.
<span id="line29188" class="line"></span>     * @fires OpenSeadragon.TiledImage.event:bounds-change
<span id="line29189" class="line"></span>     */
<span id="line29190" class="line"></span>    setPosition: function(position, immediately) {
<span id="line29191" class="line"></span>        const sameTarget = (this._xSpring.target.value === position.x &amp;&amp;
<span id="line29192" class="line"></span>            this._ySpring.target.value === position.y);
<span id="line29193" class="line"></span>
<span id="line29194" class="line"></span>        if (immediately) {
<span id="line29195" class="line"></span>            if (sameTarget &amp;&amp; this._xSpring.current.value === position.x &amp;&amp;
<span id="line29196" class="line"></span>                this._ySpring.current.value === position.y) {
<span id="line29197" class="line"></span>                return;
<span id="line29198" class="line"></span>            }
<span id="line29199" class="line"></span>
<span id="line29200" class="line"></span>            this._xSpring.resetTo(position.x);
<span id="line29201" class="line"></span>            this._ySpring.resetTo(position.y);
<span id="line29202" class="line"></span>            this._needsDraw = true;
<span id="line29203" class="line"></span>            this._needsUpdate = true;
<span id="line29204" class="line"></span>        } else {
<span id="line29205" class="line"></span>            if (sameTarget) {
<span id="line29206" class="line"></span>                return;
<span id="line29207" class="line"></span>            }
<span id="line29208" class="line"></span>
<span id="line29209" class="line"></span>            this._xSpring.springTo(position.x);
<span id="line29210" class="line"></span>            this._ySpring.springTo(position.y);
<span id="line29211" class="line"></span>            this._needsDraw = true;
<span id="line29212" class="line"></span>            this._needsUpdate = true;
<span id="line29213" class="line"></span>        }
<span id="line29214" class="line"></span>
<span id="line29215" class="line"></span>        if (!sameTarget) {
<span id="line29216" class="line"></span>            this._raiseBoundsChange();
<span id="line29217" class="line"></span>        }
<span id="line29218" class="line"></span>    },
<span id="line29219" class="line"></span>
<span id="line29220" class="line"></span>    /**
<span id="line29221" class="line"></span>     * Sets the TiledImage's width in the world, adjusting the height to match based on aspect ratio.
<span id="line29222" class="line"></span>     * @param {Number} width - The new width, in viewport coordinates.
<span id="line29223" class="line"></span>     * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.
<span id="line29224" class="line"></span>     * @fires OpenSeadragon.TiledImage.event:bounds-change
<span id="line29225" class="line"></span>     */
<span id="line29226" class="line"></span>    setWidth: function(width, immediately) {
<span id="line29227" class="line"></span>        this._setScale(width, immediately);
<span id="line29228" class="line"></span>    },
<span id="line29229" class="line"></span>
<span id="line29230" class="line"></span>    /**
<span id="line29231" class="line"></span>     * Sets the TiledImage's height in the world, adjusting the width to match based on aspect ratio.
<span id="line29232" class="line"></span>     * @param {Number} height - The new height, in viewport coordinates.
<span id="line29233" class="line"></span>     * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.
<span id="line29234" class="line"></span>     * @fires OpenSeadragon.TiledImage.event:bounds-change
<span id="line29235" class="line"></span>     */
<span id="line29236" class="line"></span>    setHeight: function(height, immediately) {
<span id="line29237" class="line"></span>        this._setScale(height / this.normHeight, immediately);
<span id="line29238" class="line"></span>    },
<span id="line29239" class="line"></span>
<span id="line29240" class="line"></span>    /**
<span id="line29241" class="line"></span>     * Sets an array of polygons to crop the TiledImage during draw tiles.
<span id="line29242" class="line"></span>     * The render function will use the default non-zero winding rule.
<span id="line29243" class="line"></span>     * @param {OpenSeadragon.Point[][]} polygons - represented in an array of point object in image coordinates.
<span id="line29244" class="line"></span>     * Example format: [
<span id="line29245" class="line"></span>     *  [{x: 197, y:172}, {x: 226, y:172}, {x: 226, y:198}, {x: 197, y:198}], // First polygon
<span id="line29246" class="line"></span>     *  [{x: 328, y:200}, {x: 330, y:199}, {x: 332, y:201}, {x: 329, y:202}]  // Second polygon
<span id="line29247" class="line"></span>     *  [{x: 321, y:201}, {x: 356, y:205}, {x: 341, y:250}] // Third polygon
<span id="line29248" class="line"></span>     * ]
<span id="line29249" class="line"></span>     */
<span id="line29250" class="line"></span>    setCroppingPolygons: function( polygons ) {
<span id="line29251" class="line"></span>        const isXYObject = function(obj) {
<span id="line29252" class="line"></span>            return obj instanceof $.Point || (typeof obj.x === 'number' &amp;&amp; typeof obj.y === 'number');
<span id="line29253" class="line"></span>        };
<span id="line29254" class="line"></span>
<span id="line29255" class="line"></span>        const objectToSimpleXYObject = function(objs) {
<span id="line29256" class="line"></span>            return objs.map(function(obj) {
<span id="line29257" class="line"></span>                try {
<span id="line29258" class="line"></span>                    if (isXYObject(obj)) {
<span id="line29259" class="line"></span>                        return { x: obj.x, y: obj.y };
<span id="line29260" class="line"></span>                    } else {
<span id="line29261" class="line"></span>                        throw new Error();
<span id="line29262" class="line"></span>                    }
<span id="line29263" class="line"></span>                } catch(e) {
<span id="line29264" class="line"></span>                    throw new Error('A Provided cropping polygon point is not supported');
<span id="line29265" class="line"></span>                }
<span id="line29266" class="line"></span>            });
<span id="line29267" class="line"></span>        };
<span id="line29268" class="line"></span>
<span id="line29269" class="line"></span>        try {
<span id="line29270" class="line"></span>            if (!$.isArray(polygons)) {
<span id="line29271" class="line"></span>                throw new Error('Provided cropping polygon is not an array');
<span id="line29272" class="line"></span>            }
<span id="line29273" class="line"></span>            this._croppingPolygons = polygons.map(function(polygon){
<span id="line29274" class="line"></span>                return objectToSimpleXYObject(polygon);
<span id="line29275" class="line"></span>            });
<span id="line29276" class="line"></span>            this._needsDraw = true;
<span id="line29277" class="line"></span>        } catch (e) {
<span id="line29278" class="line"></span>            $.console.error('[TiledImage.setCroppingPolygons] Cropping polygon format not supported');
<span id="line29279" class="line"></span>            $.console.error(e);
<span id="line29280" class="line"></span>            this.resetCroppingPolygons();
<span id="line29281" class="line"></span>        }
<span id="line29282" class="line"></span>    },
<span id="line29283" class="line"></span>
<span id="line29284" class="line"></span>    /**
<span id="line29285" class="line"></span>     * Resets the cropping polygons, thus next render will remove all cropping
<span id="line29286" class="line"></span>     * polygon effects.
<span id="line29287" class="line"></span>     */
<span id="line29288" class="line"></span>    resetCroppingPolygons: function() {
<span id="line29289" class="line"></span>        this._croppingPolygons = null;
<span id="line29290" class="line"></span>        this._needsDraw = true;
<span id="line29291" class="line"></span>    },
<span id="line29292" class="line"></span>
<span id="line29293" class="line"></span>    /**
<span id="line29294" class="line"></span>     * Positions and scales the TiledImage to fit in the specified bounds.
<span id="line29295" class="line"></span>     * Note: this method fires OpenSeadragon.TiledImage.event:bounds-change
<span id="line29296" class="line"></span>     * twice
<span id="line29297" class="line"></span>     * @param {OpenSeadragon.Rect} bounds The bounds to fit the image into.
<span id="line29298" class="line"></span>     * @param {OpenSeadragon.Placement} [anchor=OpenSeadragon.Placement.CENTER]
<span id="line29299" class="line"></span>     * How to anchor the image in the bounds.
<span id="line29300" class="line"></span>     * @param {Boolean} [immediately=false] Whether to animate to the new size
<span id="line29301" class="line"></span>     * or snap immediately.
<span id="line29302" class="line"></span>     * @fires OpenSeadragon.TiledImage.event:bounds-change
<span id="line29303" class="line"></span>     */
<span id="line29304" class="line"></span>    fitBounds: function(bounds, anchor, immediately) {
<span id="line29305" class="line"></span>        anchor = anchor || $.Placement.CENTER;
<span id="line29306" class="line"></span>        const anchorProperties = $.Placement.properties[anchor];
<span id="line29307" class="line"></span>        let aspectRatio = this.contentAspectX;
<span id="line29308" class="line"></span>        let xOffset = 0;
<span id="line29309" class="line"></span>        let yOffset = 0;
<span id="line29310" class="line"></span>        let displayedWidthRatio = 1;
<span id="line29311" class="line"></span>        let displayedHeightRatio = 1;
<span id="line29312" class="line"></span>
<span id="line29313" class="line"></span>        if (this._clip) {
<span id="line29314" class="line"></span>            aspectRatio = this._clip.getAspectRatio();
<span id="line29315" class="line"></span>            displayedWidthRatio = this._clip.width / this.source.dimensions.x;
<span id="line29316" class="line"></span>            displayedHeightRatio = this._clip.height / this.source.dimensions.y;
<span id="line29317" class="line"></span>            if (bounds.getAspectRatio() &gt; aspectRatio) {
<span id="line29318" class="line"></span>                xOffset = this._clip.x / this._clip.height * bounds.height;
<span id="line29319" class="line"></span>                yOffset = this._clip.y / this._clip.height * bounds.height;
<span id="line29320" class="line"></span>            } else {
<span id="line29321" class="line"></span>                xOffset = this._clip.x / this._clip.width * bounds.width;
<span id="line29322" class="line"></span>                yOffset = this._clip.y / this._clip.width * bounds.width;
<span id="line29323" class="line"></span>            }
<span id="line29324" class="line"></span>        }
<span id="line29325" class="line"></span>
<span id="line29326" class="line"></span>        if (bounds.getAspectRatio() &gt; aspectRatio) {
<span id="line29327" class="line"></span>            // We will have margins on the X axis
<span id="line29328" class="line"></span>            const height = bounds.height / displayedHeightRatio;
<span id="line29329" class="line"></span>            let marginLeft = 0;
<span id="line29330" class="line"></span>            if (anchorProperties.isHorizontallyCentered) {
<span id="line29331" class="line"></span>                marginLeft = (bounds.width - bounds.height * aspectRatio) / 2;
<span id="line29332" class="line"></span>            } else if (anchorProperties.isRight) {
<span id="line29333" class="line"></span>                marginLeft = bounds.width - bounds.height * aspectRatio;
<span id="line29334" class="line"></span>            }
<span id="line29335" class="line"></span>            this.setPosition(
<span id="line29336" class="line"></span>                new $.Point(bounds.x - xOffset + marginLeft, bounds.y - yOffset),
<span id="line29337" class="line"></span>                immediately);
<span id="line29338" class="line"></span>            this.setHeight(height, immediately);
<span id="line29339" class="line"></span>        } else {
<span id="line29340" class="line"></span>            // We will have margins on the Y axis
<span id="line29341" class="line"></span>            const width = bounds.width / displayedWidthRatio;
<span id="line29342" class="line"></span>            let marginTop = 0;
<span id="line29343" class="line"></span>            if (anchorProperties.isVerticallyCentered) {
<span id="line29344" class="line"></span>                marginTop = (bounds.height - bounds.width / aspectRatio) / 2;
<span id="line29345" class="line"></span>            } else if (anchorProperties.isBottom) {
<span id="line29346" class="line"></span>                marginTop = bounds.height - bounds.width / aspectRatio;
<span id="line29347" class="line"></span>            }
<span id="line29348" class="line"></span>            this.setPosition(
<span id="line29349" class="line"></span>                new $.Point(bounds.x - xOffset, bounds.y - yOffset + marginTop),
<span id="line29350" class="line"></span>                immediately);
<span id="line29351" class="line"></span>            this.setWidth(width, immediately);
<span id="line29352" class="line"></span>        }
<span id="line29353" class="line"></span>    },
<span id="line29354" class="line"></span>
<span id="line29355" class="line"></span>    /**
<span id="line29356" class="line"></span>     * @returns {OpenSeadragon.Rect|null} The TiledImage's current clip rectangle,
<span id="line29357" class="line"></span>     * in image pixels, or null if none.
<span id="line29358" class="line"></span>     */
<span id="line29359" class="line"></span>    getClip: function() {
<span id="line29360" class="line"></span>        if (this._clip) {
<span id="line29361" class="line"></span>            return this._clip.clone();
<span id="line29362" class="line"></span>        }
<span id="line29363" class="line"></span>
<span id="line29364" class="line"></span>        return null;
<span id="line29365" class="line"></span>    },
<span id="line29366" class="line"></span>
<span id="line29367" class="line"></span>    /**
<span id="line29368" class="line"></span>     * @param {OpenSeadragon.Rect|null} newClip - An area, in image pixels, to clip to
<span id="line29369" class="line"></span>     * (portions of the image outside of this area will not be visible). Only works on
<span id="line29370" class="line"></span>     * browsers that support the HTML5 canvas.
<span id="line29371" class="line"></span>     * @fires OpenSeadragon.TiledImage.event:clip-change
<span id="line29372" class="line"></span>     */
<span id="line29373" class="line"></span>    setClip: function(newClip) {
<span id="line29374" class="line"></span>        $.console.assert(!newClip || newClip instanceof $.Rect,
<span id="line29375" class="line"></span>            "[TiledImage.setClip] newClip must be an OpenSeadragon.Rect or null");
<span id="line29376" class="line"></span>
<span id="line29377" class="line"></span>        if (newClip instanceof $.Rect) {
<span id="line29378" class="line"></span>            this._clip = newClip.clone();
<span id="line29379" class="line"></span>        } else {
<span id="line29380" class="line"></span>            this._clip = null;
<span id="line29381" class="line"></span>        }
<span id="line29382" class="line"></span>
<span id="line29383" class="line"></span>        this._needsUpdate = true;
<span id="line29384" class="line"></span>        this._needsDraw = true;
<span id="line29385" class="line"></span>        /**
<span id="line29386" class="line"></span>         * Raised when the TiledImage's clip is changed.
<span id="line29387" class="line"></span>         * @event clip-change
<span id="line29388" class="line"></span>         * @memberOf OpenSeadragon.TiledImage
<span id="line29389" class="line"></span>         * @type {object}
<span id="line29390" class="line"></span>         * @property {OpenSeadragon.TiledImage} eventSource - A reference to the
<span id="line29391" class="line"></span>         * TiledImage which raised the event.
<span id="line29392" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line29393" class="line"></span>         */
<span id="line29394" class="line"></span>        this.raiseEvent('clip-change');
<span id="line29395" class="line"></span>    },
<span id="line29396" class="line"></span>
<span id="line29397" class="line"></span>    /**
<span id="line29398" class="line"></span>     * @returns {Boolean} Whether the TiledImage should be flipped before rendering.
<span id="line29399" class="line"></span>     */
<span id="line29400" class="line"></span>    getFlip: function() {
<span id="line29401" class="line"></span>        return this.flipped;
<span id="line29402" class="line"></span>    },
<span id="line29403" class="line"></span>
<span id="line29404" class="line"></span>    /**
<span id="line29405" class="line"></span>     * @param {Boolean} flip Whether the TiledImage should be flipped before rendering.
<span id="line29406" class="line"></span>     * @fires OpenSeadragon.TiledImage.event:bounds-change
<span id="line29407" class="line"></span>     */
<span id="line29408" class="line"></span>    setFlip: function(flip) {
<span id="line29409" class="line"></span>        this.flipped = flip;
<span id="line29410" class="line"></span>    },
<span id="line29411" class="line"></span>
<span id="line29412" class="line"></span>    get flipped() {
<span id="line29413" class="line"></span>        return this._flipped;
<span id="line29414" class="line"></span>    },
<span id="line29415" class="line"></span>    set flipped(flipped) {
<span id="line29416" class="line"></span>        const changed = this._flipped !== !!flipped;
<span id="line29417" class="line"></span>        this._flipped = !!flipped;
<span id="line29418" class="line"></span>        if (changed &amp;&amp; this._initialized) {
<span id="line29419" class="line"></span>            this.update(true);
<span id="line29420" class="line"></span>            this._needsDraw = true;
<span id="line29421" class="line"></span>            this._raiseBoundsChange();
<span id="line29422" class="line"></span>        }
<span id="line29423" class="line"></span>    },
<span id="line29424" class="line"></span>
<span id="line29425" class="line"></span>    get wrapHorizontal(){
<span id="line29426" class="line"></span>        return this._wrapHorizontal;
<span id="line29427" class="line"></span>    },
<span id="line29428" class="line"></span>    set wrapHorizontal(wrap){
<span id="line29429" class="line"></span>        const changed = this._wrapHorizontal !== !!wrap;
<span id="line29430" class="line"></span>        this._wrapHorizontal = !!wrap;
<span id="line29431" class="line"></span>        if(this._initialized &amp;&amp; changed){
<span id="line29432" class="line"></span>            this.update(true);
<span id="line29433" class="line"></span>            this._needsDraw = true;
<span id="line29434" class="line"></span>            // this._raiseBoundsChange();
<span id="line29435" class="line"></span>        }
<span id="line29436" class="line"></span>    },
<span id="line29437" class="line"></span>
<span id="line29438" class="line"></span>    get wrapVertical(){
<span id="line29439" class="line"></span>        return this._wrapVertical;
<span id="line29440" class="line"></span>    },
<span id="line29441" class="line"></span>    set wrapVertical(wrap){
<span id="line29442" class="line"></span>        const changed = this._wrapVertical !== !!wrap;
<span id="line29443" class="line"></span>        this._wrapVertical = !!wrap;
<span id="line29444" class="line"></span>        if(this._initialized &amp;&amp; changed){
<span id="line29445" class="line"></span>            this.update(true);
<span id="line29446" class="line"></span>            this._needsDraw = true;
<span id="line29447" class="line"></span>            // this._raiseBoundsChange();
<span id="line29448" class="line"></span>        }
<span id="line29449" class="line"></span>    },
<span id="line29450" class="line"></span>
<span id="line29451" class="line"></span>    get debugMode(){
<span id="line29452" class="line"></span>        return this._debugMode;
<span id="line29453" class="line"></span>    },
<span id="line29454" class="line"></span>    set debugMode(debug){
<span id="line29455" class="line"></span>        this._debugMode = !!debug;
<span id="line29456" class="line"></span>        this._needsDraw = true;
<span id="line29457" class="line"></span>    },
<span id="line29458" class="line"></span>
<span id="line29459" class="line"></span>    /**
<span id="line29460" class="line"></span>     * @returns {Number} The TiledImage's current opacity.
<span id="line29461" class="line"></span>     */
<span id="line29462" class="line"></span>    getOpacity: function() {
<span id="line29463" class="line"></span>        return this.opacity;
<span id="line29464" class="line"></span>    },
<span id="line29465" class="line"></span>
<span id="line29466" class="line"></span>    /**
<span id="line29467" class="line"></span>     * @param {Number} opacity Opacity the tiled image should be drawn at.
<span id="line29468" class="line"></span>     * @fires OpenSeadragon.TiledImage.event:opacity-change
<span id="line29469" class="line"></span>     */
<span id="line29470" class="line"></span>    setOpacity: function(opacity) {
<span id="line29471" class="line"></span>        this.opacity = opacity;
<span id="line29472" class="line"></span>    },
<span id="line29473" class="line"></span>
<span id="line29474" class="line"></span>    get opacity() {
<span id="line29475" class="line"></span>        return this._opacity;
<span id="line29476" class="line"></span>    },
<span id="line29477" class="line"></span>
<span id="line29478" class="line"></span>    set opacity(opacity) {
<span id="line29479" class="line"></span>        if (opacity === this.opacity) {
<span id="line29480" class="line"></span>            return;
<span id="line29481" class="line"></span>        }
<span id="line29482" class="line"></span>
<span id="line29483" class="line"></span>        this._opacity = opacity;
<span id="line29484" class="line"></span>        this._needsDraw = true;
<span id="line29485" class="line"></span>        this._needsUpdate = true;
<span id="line29486" class="line"></span>        /**
<span id="line29487" class="line"></span>         * Raised when the TiledImage's opacity is changed.
<span id="line29488" class="line"></span>         * @event opacity-change
<span id="line29489" class="line"></span>         * @memberOf OpenSeadragon.TiledImage
<span id="line29490" class="line"></span>         * @type {object}
<span id="line29491" class="line"></span>         * @property {Number} opacity - The new opacity value.
<span id="line29492" class="line"></span>         * @property {OpenSeadragon.TiledImage} eventSource - A reference to the
<span id="line29493" class="line"></span>         * TiledImage which raised the event.
<span id="line29494" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line29495" class="line"></span>         */
<span id="line29496" class="line"></span>        this.raiseEvent('opacity-change', {
<span id="line29497" class="line"></span>            opacity: this.opacity
<span id="line29498" class="line"></span>        });
<span id="line29499" class="line"></span>    },
<span id="line29500" class="line"></span>
<span id="line29501" class="line"></span>    /**
<span id="line29502" class="line"></span>     * @returns {Boolean} whether the tiledImage can load its tiles even when it has zero opacity.
<span id="line29503" class="line"></span>     */
<span id="line29504" class="line"></span>    getPreload: function() {
<span id="line29505" class="line"></span>        return this._preload;
<span id="line29506" class="line"></span>    },
<span id="line29507" class="line"></span>
<span id="line29508" class="line"></span>    /**
<span id="line29509" class="line"></span>     * Set true to load even when hidden. Set false to block loading when hidden.
<span id="line29510" class="line"></span>     */
<span id="line29511" class="line"></span>    setPreload: function(preload) {
<span id="line29512" class="line"></span>        this._preload = !!preload;
<span id="line29513" class="line"></span>        this._needsDraw = true;
<span id="line29514" class="line"></span>    },
<span id="line29515" class="line"></span>
<span id="line29516" class="line"></span>    /**
<span id="line29517" class="line"></span>     * Get the rotation of this tiled image in degrees.
<span id="line29518" class="line"></span>     * @param {Boolean} [current=false] True for current rotation, false for target.
<span id="line29519" class="line"></span>     * @returns {Number} the rotation of this tiled image in degrees.
<span id="line29520" class="line"></span>     */
<span id="line29521" class="line"></span>    getRotation: function(current) {
<span id="line29522" class="line"></span>        return current ?
<span id="line29523" class="line"></span>            this._degreesSpring.current.value :
<span id="line29524" class="line"></span>            this._degreesSpring.target.value;
<span id="line29525" class="line"></span>    },
<span id="line29526" class="line"></span>
<span id="line29527" class="line"></span>    /**
<span id="line29528" class="line"></span>     * Set the current rotation of this tiled image in degrees.
<span id="line29529" class="line"></span>     * @param {Number} degrees the rotation in degrees.
<span id="line29530" class="line"></span>     * @param {Boolean} [immediately=false] Whether to animate to the new angle
<span id="line29531" class="line"></span>     * or rotate immediately.
<span id="line29532" class="line"></span>     * @fires OpenSeadragon.TiledImage.event:bounds-change
<span id="line29533" class="line"></span>     */
<span id="line29534" class="line"></span>    setRotation: function(degrees, immediately) {
<span id="line29535" class="line"></span>        if (this._degreesSpring.target.value === degrees &amp;&amp;
<span id="line29536" class="line"></span>            this._degreesSpring.isAtTargetValue()) {
<span id="line29537" class="line"></span>            return;
<span id="line29538" class="line"></span>        }
<span id="line29539" class="line"></span>        if (immediately) {
<span id="line29540" class="line"></span>            this._degreesSpring.resetTo(degrees);
<span id="line29541" class="line"></span>        } else {
<span id="line29542" class="line"></span>            this._degreesSpring.springTo(degrees);
<span id="line29543" class="line"></span>        }
<span id="line29544" class="line"></span>        this._needsDraw = true;
<span id="line29545" class="line"></span>        this._needsUpdate = true;
<span id="line29546" class="line"></span>        this._raiseBoundsChange();
<span id="line29547" class="line"></span>    },
<span id="line29548" class="line"></span>
<span id="line29549" class="line"></span>    /**
<span id="line29550" class="line"></span>     * Get the region of this tiled image that falls within the viewport.
<span id="line29551" class="line"></span>     * @returns {OpenSeadragon.Rect} the region of this tiled image that falls within the viewport.
<span id="line29552" class="line"></span>     * Returns false for images with opacity==0 unless preload==true
<span id="line29553" class="line"></span>     */
<span id="line29554" class="line"></span>    getDrawArea: function(){
<span id="line29555" class="line"></span>
<span id="line29556" class="line"></span>        if( this._opacity === 0 &amp;&amp; !this._preload){
<span id="line29557" class="line"></span>            return false;
<span id="line29558" class="line"></span>        }
<span id="line29559" class="line"></span>
<span id="line29560" class="line"></span>        let drawArea = this._viewportToTiledImageRectangle(
<span id="line29561" class="line"></span>            this.viewport.getBoundsWithMargins(true));
<span id="line29562" class="line"></span>
<span id="line29563" class="line"></span>        if (!this.wrapHorizontal &amp;&amp; !this.wrapVertical) {
<span id="line29564" class="line"></span>            const tiledImageBounds = this._viewportToTiledImageRectangle(
<span id="line29565" class="line"></span>                this.getClippedBounds(true));
<span id="line29566" class="line"></span>            drawArea = drawArea.intersection(tiledImageBounds);
<span id="line29567" class="line"></span>        }
<span id="line29568" class="line"></span>
<span id="line29569" class="line"></span>        return drawArea;
<span id="line29570" class="line"></span>    },
<span id="line29571" class="line"></span>
<span id="line29572" class="line"></span>    getLoadArea: function() {
<span id="line29573" class="line"></span>        let loadArea = this._viewportToTiledImageRectangle(
<span id="line29574" class="line"></span>            this.viewport.getBoundsWithMargins(false));
<span id="line29575" class="line"></span>
<span id="line29576" class="line"></span>        if (!this.wrapHorizontal &amp;&amp; !this.wrapVertical) {
<span id="line29577" class="line"></span>            const tiledImageBounds = this._viewportToTiledImageRectangle(
<span id="line29578" class="line"></span>                this.getClippedBounds(false));
<span id="line29579" class="line"></span>            loadArea = loadArea.intersection(tiledImageBounds);
<span id="line29580" class="line"></span>        }
<span id="line29581" class="line"></span>
<span id="line29582" class="line"></span>        return loadArea;
<span id="line29583" class="line"></span>    },
<span id="line29584" class="line"></span>
<span id="line29585" class="line"></span>    /**
<span id="line29586" class="line"></span>     * Get tiles that should be drawn at the current position of tiled image.
<span id="line29587" class="line"></span>     * Note: this method should be called only once per frame.
<span id="line29588" class="line"></span>     * @returns {OpenSeadragon.TiledImage.DrawTileInfo[]} Array of Tiles that make up the current view
<span id="line29589" class="line"></span>     */
<span id="line29590" class="line"></span>    getTilesToDraw: function(){
<span id="line29591" class="line"></span>        // start with all the tiles added to this._tilesToDraw during the most recent
<span id="line29592" class="line"></span>        // call to this.update. Then update them so the blending and coverage properties
<span id="line29593" class="line"></span>        // are updated based on the current time
<span id="line29594" class="line"></span>
<span id="line29595" class="line"></span>        // reuse last-drawn array to avoid allocations
<span id="line29596" class="line"></span>        const lastDrawn = this._lastDrawn;
<span id="line29597" class="line"></span>
<span id="line29598" class="line"></span>        let insertionIndex = 0;
<span id="line29599" class="line"></span>        for (const maybeNested of this._tilesToDraw) {
<span id="line29600" class="line"></span>            if (Array.isArray(maybeNested)) {
<span id="line29601" class="line"></span>                for (const item of maybeNested) {
<span id="line29602" class="line"></span>                    lastDrawn[insertionIndex++] = item;
<span id="line29603" class="line"></span>                }
<span id="line29604" class="line"></span>            } else if (maybeNested) {
<span id="line29605" class="line"></span>                lastDrawn[insertionIndex++] = maybeNested;
<span id="line29606" class="line"></span>            }
<span id="line29607" class="line"></span>        }
<span id="line29608" class="line"></span>        lastDrawn.length = insertionIndex;
<span id="line29609" class="line"></span>        // update all tiles, which can change the coverage provided
<span id="line29610" class="line"></span>        this._updateTilesInViewport(lastDrawn);
<span id="line29611" class="line"></span>
<span id="line29612" class="line"></span>        // _tilesToDraw might have been updated by the update; refresh it
<span id="line29613" class="line"></span>        // mark the tiles as being drawn, so that they won't be discarded from
<span id="line29614" class="line"></span>        // the tileCache
<span id="line29615" class="line"></span>        insertionIndex = 0;
<span id="line29616" class="line"></span>        for (const maybeNested of this._tilesToDraw) {
<span id="line29617" class="line"></span>            if (Array.isArray(maybeNested)) {
<span id="line29618" class="line"></span>                for (const item of maybeNested) {
<span id="line29619" class="line"></span>                    if (item.tile.loaded) {
<span id="line29620" class="line"></span>                        item.tile.beingDrawn = true;
<span id="line29621" class="line"></span>                        lastDrawn[insertionIndex++] = item;
<span id="line29622" class="line"></span>                    }
<span id="line29623" class="line"></span>                }
<span id="line29624" class="line"></span>            } else if (maybeNested) {
<span id="line29625" class="line"></span>                if (maybeNested.tile.loaded) {
<span id="line29626" class="line"></span>                    maybeNested.tile.beingDrawn = true;
<span id="line29627" class="line"></span>                    lastDrawn[insertionIndex++] = maybeNested;
<span id="line29628" class="line"></span>                }
<span id="line29629" class="line"></span>            }
<span id="line29630" class="line"></span>        }
<span id="line29631" class="line"></span>        lastDrawn.length = insertionIndex;
<span id="line29632" class="line"></span>        return lastDrawn;
<span id="line29633" class="line"></span>    },
<span id="line29634" class="line"></span>
<span id="line29635" class="line"></span>    /**
<span id="line29636" class="line"></span>     * Get the point around which this tiled image is rotated
<span id="line29637" class="line"></span>     * @private
<span id="line29638" class="line"></span>     * @param {Boolean} current True for current rotation point, false for target.
<span id="line29639" class="line"></span>     * @returns {OpenSeadragon.Point}
<span id="line29640" class="line"></span>     */
<span id="line29641" class="line"></span>    _getRotationPoint: function(current) {
<span id="line29642" class="line"></span>        return this.getBoundsNoRotate(current).getCenter();
<span id="line29643" class="line"></span>    },
<span id="line29644" class="line"></span>
<span id="line29645" class="line"></span>    get compositeOperation(){
<span id="line29646" class="line"></span>        return this._compositeOperation;
<span id="line29647" class="line"></span>    },
<span id="line29648" class="line"></span>
<span id="line29649" class="line"></span>    set compositeOperation(compositeOperation){
<span id="line29650" class="line"></span>
<span id="line29651" class="line"></span>        if (compositeOperation === this._compositeOperation) {
<span id="line29652" class="line"></span>            return;
<span id="line29653" class="line"></span>        }
<span id="line29654" class="line"></span>        this._compositeOperation = compositeOperation;
<span id="line29655" class="line"></span>        this._needsDraw = true;
<span id="line29656" class="line"></span>        /**
<span id="line29657" class="line"></span>         * Raised when the TiledImage's opacity is changed.
<span id="line29658" class="line"></span>         * @event composite-operation-change
<span id="line29659" class="line"></span>         * @memberOf OpenSeadragon.TiledImage
<span id="line29660" class="line"></span>         * @type {object}
<span id="line29661" class="line"></span>         * @property {String} compositeOperation - The new compositeOperation value.
<span id="line29662" class="line"></span>         * @property {OpenSeadragon.TiledImage} eventSource - A reference to the
<span id="line29663" class="line"></span>         * TiledImage which raised the event.
<span id="line29664" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line29665" class="line"></span>         */
<span id="line29666" class="line"></span>        this.raiseEvent('composite-operation-change', {
<span id="line29667" class="line"></span>            compositeOperation: this._compositeOperation
<span id="line29668" class="line"></span>        });
<span id="line29669" class="line"></span>
<span id="line29670" class="line"></span>    },
<span id="line29671" class="line"></span>
<span id="line29672" class="line"></span>    /**
<span id="line29673" class="line"></span>     * @returns {String} The TiledImage's current compositeOperation.
<span id="line29674" class="line"></span>     */
<span id="line29675" class="line"></span>    getCompositeOperation: function() {
<span id="line29676" class="line"></span>        return this._compositeOperation;
<span id="line29677" class="line"></span>    },
<span id="line29678" class="line"></span>
<span id="line29679" class="line"></span>    /**
<span id="line29680" class="line"></span>     * @param {String} compositeOperation the tiled image should be drawn with this globalCompositeOperation.
<span id="line29681" class="line"></span>     * @fires OpenSeadragon.TiledImage.event:composite-operation-change
<span id="line29682" class="line"></span>     */
<span id="line29683" class="line"></span>    setCompositeOperation: function(compositeOperation) {
<span id="line29684" class="line"></span>        this.compositeOperation = compositeOperation; //invokes setter
<span id="line29685" class="line"></span>    },
<span id="line29686" class="line"></span>
<span id="line29687" class="line"></span>    /**
<span id="line29688" class="line"></span>     * Update headers to include when making AJAX requests.
<span id="line29689" class="line"></span>     *
<span id="line29690" class="line"></span>     * Unless `propagate` is set to false (which is likely only useful in rare circumstances),
<span id="line29691" class="line"></span>     * the updated headers are propagated to all tiles and queued image loader jobs.
<span id="line29692" class="line"></span>     *
<span id="line29693" class="line"></span>     * Note that the rules for merging headers still apply, i.e. headers returned by
<span id="line29694" class="line"></span>     * {@link OpenSeadragon.TileSource#getTileAjaxHeaders} take precedence over
<span id="line29695" class="line"></span>     * the headers here in the tiled image (`TiledImage.ajaxHeaders`).
<span id="line29696" class="line"></span>     *
<span id="line29697" class="line"></span>     * @function
<span id="line29698" class="line"></span>     * @param {Object} ajaxHeaders Updated AJAX headers, which will be merged over any headers specified in {@link OpenSeadragon.Options}.
<span id="line29699" class="line"></span>     * @param {Boolean} [propagate=true] Whether to propagate updated headers to existing tiles and queued image loader jobs.
<span id="line29700" class="line"></span>     */
<span id="line29701" class="line"></span>    setAjaxHeaders: function(ajaxHeaders, propagate) {
<span id="line29702" class="line"></span>        if (ajaxHeaders === null) {
<span id="line29703" class="line"></span>            ajaxHeaders = {};
<span id="line29704" class="line"></span>        }
<span id="line29705" class="line"></span>        if (!$.isPlainObject(ajaxHeaders)) {
<span id="line29706" class="line"></span>            $.console.error('[TiledImage.setAjaxHeaders] Ignoring invalid headers, must be a plain object');
<span id="line29707" class="line"></span>            return;
<span id="line29708" class="line"></span>        }
<span id="line29709" class="line"></span>
<span id="line29710" class="line"></span>        this._ownAjaxHeaders = ajaxHeaders;
<span id="line29711" class="line"></span>        this._updateAjaxHeaders(propagate);
<span id="line29712" class="line"></span>    },
<span id="line29713" class="line"></span>
<span id="line29714" class="line"></span>    /**
<span id="line29715" class="line"></span>     * Update headers to include when making AJAX requests.
<span id="line29716" class="line"></span>     *
<span id="line29717" class="line"></span>     * This function has the same effect as calling {@link OpenSeadragon.TiledImage#setAjaxHeaders},
<span id="line29718" class="line"></span>     * except that the headers for this tiled image do not change. This is especially useful
<span id="line29719" class="line"></span>     * for propagating updated headers from {@link OpenSeadragon.TileSource#getTileAjaxHeaders}
<span id="line29720" class="line"></span>     * to existing tiles.
<span id="line29721" class="line"></span>     *
<span id="line29722" class="line"></span>     * @private
<span id="line29723" class="line"></span>     * @function
<span id="line29724" class="line"></span>     * @param {Boolean} [propagate=true] Whether to propagate updated headers to existing tiles and queued image loader jobs.
<span id="line29725" class="line"></span>     */
<span id="line29726" class="line"></span>    _updateAjaxHeaders: function(propagate) {
<span id="line29727" class="line"></span>        if (propagate === undefined) {
<span id="line29728" class="line"></span>            propagate = true;
<span id="line29729" class="line"></span>        }
<span id="line29730" class="line"></span>
<span id="line29731" class="line"></span>        // merge with viewer's headers
<span id="line29732" class="line"></span>        if ($.isPlainObject(this.viewer.ajaxHeaders)) {
<span id="line29733" class="line"></span>            this.ajaxHeaders = $.extend({}, this.viewer.ajaxHeaders, this._ownAjaxHeaders);
<span id="line29734" class="line"></span>        } else {
<span id="line29735" class="line"></span>            this.ajaxHeaders = this._ownAjaxHeaders;
<span id="line29736" class="line"></span>        }
<span id="line29737" class="line"></span>
<span id="line29738" class="line"></span>        // propagate header updates to all tiles and queued image loader jobs
<span id="line29739" class="line"></span>        if (propagate) {
<span id="line29740" class="line"></span>            let numTiles, xMod, yMod, tile;
<span id="line29741" class="line"></span>
<span id="line29742" class="line"></span>            for (const level in this.tilesMatrix) {
<span id="line29743" class="line"></span>                numTiles = this.source.getNumTiles(level);
<span id="line29744" class="line"></span>                const matrixLevel = this.tilesMatrix[level];
<span id="line29745" class="line"></span>
<span id="line29746" class="line"></span>                for (const x in matrixLevel) {
<span id="line29747" class="line"></span>                    xMod = ( numTiles.x + ( x % numTiles.x ) ) % numTiles.x;
<span id="line29748" class="line"></span>
<span id="line29749" class="line"></span>                    for (const y in matrixLevel[x]) {
<span id="line29750" class="line"></span>                        yMod = ( numTiles.y + ( y % numTiles.y ) ) % numTiles.y;
<span id="line29751" class="line"></span>                        tile = matrixLevel[x][y];
<span id="line29752" class="line"></span>
<span id="line29753" class="line"></span>                        tile.loadWithAjax = this.loadTilesWithAjax;
<span id="line29754" class="line"></span>                        if (tile.loadWithAjax) {
<span id="line29755" class="line"></span>                            const tileAjaxHeaders = this.source.getTileAjaxHeaders( level, xMod, yMod );
<span id="line29756" class="line"></span>                            tile.ajaxHeaders = $.extend({}, this.ajaxHeaders, tileAjaxHeaders);
<span id="line29757" class="line"></span>                        } else {
<span id="line29758" class="line"></span>                            tile.ajaxHeaders = null;
<span id="line29759" class="line"></span>                        }
<span id="line29760" class="line"></span>                    }
<span id="line29761" class="line"></span>                }
<span id="line29762" class="line"></span>            }
<span id="line29763" class="line"></span>
<span id="line29764" class="line"></span>            for (let i = 0; i &lt; this._imageLoader.jobQueue.length; i++) {
<span id="line29765" class="line"></span>                const job = this._imageLoader.jobQueue[i];
<span id="line29766" class="line"></span>                job.loadWithAjax = job.tile.loadWithAjax;
<span id="line29767" class="line"></span>                job.ajaxHeaders = job.tile.loadWithAjax ? job.tile.ajaxHeaders : null;
<span id="line29768" class="line"></span>            }
<span id="line29769" class="line"></span>        }
<span id="line29770" class="line"></span>    },
<span id="line29771" class="line"></span>
<span id="line29772" class="line"></span>    /**
<span id="line29773" class="line"></span>     * Enable cache preservation even without this tile image,
<span id="line29774" class="line"></span>     * by default disabled. It means that upon removing,
<span id="line29775" class="line"></span>     * the tile cache does not get immediately erased but
<span id="line29776" class="line"></span>     * stays in the memory to be potentially re-used by other
<span id="line29777" class="line"></span>     * TiledImages.
<span id="line29778" class="line"></span>     * @param {boolean} allow
<span id="line29779" class="line"></span>     */
<span id="line29780" class="line"></span>    allowZombieCache: function(allow) {
<span id="line29781" class="line"></span>        this._zombieCache = allow;
<span id="line29782" class="line"></span>    },
<span id="line29783" class="line"></span>
<span id="line29784" class="line"></span>    // private
<span id="line29785" class="line"></span>    _setScale: function(scale, immediately) {
<span id="line29786" class="line"></span>        const sameTarget = (this._scaleSpring.target.value === scale);
<span id="line29787" class="line"></span>        if (immediately) {
<span id="line29788" class="line"></span>            if (sameTarget &amp;&amp; this._scaleSpring.current.value === scale) {
<span id="line29789" class="line"></span>                return;
<span id="line29790" class="line"></span>            }
<span id="line29791" class="line"></span>
<span id="line29792" class="line"></span>            this._scaleSpring.resetTo(scale);
<span id="line29793" class="line"></span>            this._updateForScale();
<span id="line29794" class="line"></span>            this._needsDraw = true;
<span id="line29795" class="line"></span>            this._needsUpdate = true;
<span id="line29796" class="line"></span>        } else {
<span id="line29797" class="line"></span>            if (sameTarget) {
<span id="line29798" class="line"></span>                return;
<span id="line29799" class="line"></span>            }
<span id="line29800" class="line"></span>
<span id="line29801" class="line"></span>            this._scaleSpring.springTo(scale);
<span id="line29802" class="line"></span>            this._updateForScale();
<span id="line29803" class="line"></span>            this._needsDraw = true;
<span id="line29804" class="line"></span>            this._needsUpdate = true;
<span id="line29805" class="line"></span>        }
<span id="line29806" class="line"></span>
<span id="line29807" class="line"></span>        if (!sameTarget) {
<span id="line29808" class="line"></span>            this._raiseBoundsChange();
<span id="line29809" class="line"></span>        }
<span id="line29810" class="line"></span>    },
<span id="line29811" class="line"></span>
<span id="line29812" class="line"></span>    // private
<span id="line29813" class="line"></span>    _updateForScale: function() {
<span id="line29814" class="line"></span>        this._worldWidthTarget = this._scaleSpring.target.value;
<span id="line29815" class="line"></span>        this._worldHeightTarget = this.normHeight * this._scaleSpring.target.value;
<span id="line29816" class="line"></span>        this._worldWidthCurrent = this._scaleSpring.current.value;
<span id="line29817" class="line"></span>        this._worldHeightCurrent = this.normHeight * this._scaleSpring.current.value;
<span id="line29818" class="line"></span>    },
<span id="line29819" class="line"></span>
<span id="line29820" class="line"></span>    // private
<span id="line29821" class="line"></span>    _raiseBoundsChange: function() {
<span id="line29822" class="line"></span>        /**
<span id="line29823" class="line"></span>         * Raised when the TiledImage's bounds are changed.
<span id="line29824" class="line"></span>         * Note that this event is triggered only when the animation target is changed;
<span id="line29825" class="line"></span>         * not for every frame of animation.
<span id="line29826" class="line"></span>         * @event bounds-change
<span id="line29827" class="line"></span>         * @memberOf OpenSeadragon.TiledImage
<span id="line29828" class="line"></span>         * @type {object}
<span id="line29829" class="line"></span>         * @property {OpenSeadragon.TiledImage} eventSource - A reference to the
<span id="line29830" class="line"></span>         * TiledImage which raised the event.
<span id="line29831" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line29832" class="line"></span>         */
<span id="line29833" class="line"></span>        this.raiseEvent('bounds-change');
<span id="line29834" class="line"></span>    },
<span id="line29835" class="line"></span>
<span id="line29836" class="line"></span>    // private
<span id="line29837" class="line"></span>    _isBottomItem: function() {
<span id="line29838" class="line"></span>        return this.viewer.world.getItemAt(0) === this;
<span id="line29839" class="line"></span>    },
<span id="line29840" class="line"></span>
<span id="line29841" class="line"></span>    // private
<span id="line29842" class="line"></span>    _getLevelsInterval: function() {
<span id="line29843" class="line"></span>        let lowestLevel = Math.max(
<span id="line29844" class="line"></span>            this.source.minLevel,
<span id="line29845" class="line"></span>            Math.floor(Math.log(this.minZoomImageRatio) / Math.log(2))
<span id="line29846" class="line"></span>        );
<span id="line29847" class="line"></span>        const currentZeroRatio = this.viewport.deltaPixelsFromPointsNoRotate(
<span id="line29848" class="line"></span>                this.source.getPixelRatio(0), true).x *
<span id="line29849" class="line"></span>            this._scaleSpring.current.value;
<span id="line29850" class="line"></span>        let highestLevel = Math.min(
<span id="line29851" class="line"></span>            Math.abs(this.source.maxLevel),
<span id="line29852" class="line"></span>            Math.abs(Math.floor(
<span id="line29853" class="line"></span>                Math.log(currentZeroRatio / this.minPixelRatio) / Math.log(2)
<span id="line29854" class="line"></span>            ))
<span id="line29855" class="line"></span>        );
<span id="line29856" class="line"></span>
<span id="line29857" class="line"></span>        // Calculations for the interval of levels to draw
<span id="line29858" class="line"></span>        // can return invalid intervals; fix that here if necessary
<span id="line29859" class="line"></span>        highestLevel = Math.max(highestLevel, this.source.minLevel || 0);
<span id="line29860" class="line"></span>        lowestLevel = Math.min(lowestLevel, highestLevel);
<span id="line29861" class="line"></span>        return {
<span id="line29862" class="line"></span>            lowestLevel: lowestLevel,
<span id="line29863" class="line"></span>            highestLevel: highestLevel
<span id="line29864" class="line"></span>        };
<span id="line29865" class="line"></span>    },
<span id="line29866" class="line"></span>
<span id="line29867" class="line"></span>    // returns boolean flag of whether the image should be marked as fully loaded
<span id="line29868" class="line"></span>    _updateLevelsForViewport: function(){
<span id="line29869" class="line"></span>        const levelsInterval = this._getLevelsInterval();
<span id="line29870" class="line"></span>        const lowestLevel = levelsInterval.lowestLevel; // the lowest level we should draw at our current zoom
<span id="line29871" class="line"></span>        const highestLevel = levelsInterval.highestLevel; // the highest level we should draw at our current zoom
<span id="line29872" class="line"></span>        const drawArea = this.getDrawArea();
<span id="line29873" class="line"></span>
<span id="line29874" class="line"></span>        let loadArea = drawArea;
<span id="line29875" class="line"></span>        let bestLoadTileCandidates = this._getCachedArray('bestLoadTileCandidates', 0);
<span id="line29876" class="line"></span>
<span id="line29877" class="line"></span>        if (this.loadDestinationTilesOnAnimation) {
<span id="line29878" class="line"></span>            loadArea = this.getLoadArea();
<span id="line29879" class="line"></span>        }
<span id="line29880" class="line"></span>        const currentTime = $.now();
<span id="line29881" class="line"></span>
<span id="line29882" class="line"></span>        // reset each tile's beingDrawn flag
<span id="line29883" class="line"></span>        for (const tileInfo of this._lastDrawn) {
<span id="line29884" class="line"></span>            tileInfo.tile.beingDrawn = false;
<span id="line29885" class="line"></span>        }
<span id="line29886" class="line"></span>        // clear the list of tiles to draw
<span id="line29887" class="line"></span>        this._tilesToDraw.length = 0;
<span id="line29888" class="line"></span>        this._tilesLoading = 0;
<span id="line29889" class="line"></span>        this.loadingCoverage = {};
<span id="line29890" class="line"></span>
<span id="line29891" class="line"></span>        if (!drawArea){
<span id="line29892" class="line"></span>            this._needsDraw = false;
<span id="line29893" class="line"></span>            return this._fullyLoaded;
<span id="line29894" class="line"></span>        }
<span id="line29895" class="line"></span>
<span id="line29896" class="line"></span>        // make a list of levels to use for the current zoom level
<span id="line29897" class="line"></span>        const levelList = this._getCachedArray('levelList', highestLevel - lowestLevel + 1);
<span id="line29898" class="line"></span>        // go from highest to lowest resolution
<span id="line29899" class="line"></span>        for (let i = 0, level = highestLevel; level &gt;= lowestLevel; level--, i++) {
<span id="line29900" class="line"></span>            levelList[i] = level;
<span id="line29901" class="line"></span>        }
<span id="line29902" class="line"></span>
<span id="line29903" class="line"></span>        // if a single-tile level is loaded, add that to the end of the list
<span id="line29904" class="line"></span>        // as a fallback to use during zooming out, until a lower-res tile is
<span id="line29905" class="line"></span>        // loaded
<span id="line29906" class="line"></span>        for (let level = highestLevel + 1; level &lt;= this.source.maxLevel; level++) {
<span id="line29907" class="line"></span>            const tile = (
<span id="line29908" class="line"></span>                this.tilesMatrix[level] &amp;&amp;
<span id="line29909" class="line"></span>                this.tilesMatrix[level][0] &amp;&amp;
<span id="line29910" class="line"></span>                this.tilesMatrix[level][0][0]
<span id="line29911" class="line"></span>            );
<span id="line29912" class="line"></span>            if (tile &amp;&amp; tile.isBottomMost &amp;&amp; tile.isRightMost &amp;&amp; tile.loaded) {
<span id="line29913" class="line"></span>                levelList.push(level);
<span id="line29914" class="line"></span>                break;
<span id="line29915" class="line"></span>            }
<span id="line29916" class="line"></span>        }
<span id="line29917" class="line"></span>
<span id="line29918" class="line"></span>
<span id="line29919" class="line"></span>        // Update any level that will be drawn.
<span id="line29920" class="line"></span>        // We are iterating from highest resolution to lowest resolution
<span id="line29921" class="line"></span>        // Once a level fully covers the viewport the loop is halted and
<span id="line29922" class="line"></span>        // lower-resolution levels are skipped
<span id="line29923" class="line"></span>        let useLevel = false;
<span id="line29924" class="line"></span>        for (let i = 0; i &lt; levelList.length; i++) {
<span id="line29925" class="line"></span>            const level = levelList[i];
<span id="line29926" class="line"></span>
<span id="line29927" class="line"></span>            const currentRenderPixelRatio = this.viewport.deltaPixelsFromPointsNoRotate(
<span id="line29928" class="line"></span>                this.source.getPixelRatio(level),
<span id="line29929" class="line"></span>                true
<span id="line29930" class="line"></span>            ).x * this._scaleSpring.current.value;
<span id="line29931" class="line"></span>
<span id="line29932" class="line"></span>            // make sure we skip levels until currentRenderPixelRatio becomes &gt;= minPixelRatio
<span id="line29933" class="line"></span>            // but always use the last level in the list so we draw something
<span id="line29934" class="line"></span>            if (i === levelList.length - 1 || currentRenderPixelRatio &gt;= this.minPixelRatio ) {
<span id="line29935" class="line"></span>                useLevel = true;
<span id="line29936" class="line"></span>            } else if (!useLevel) {
<span id="line29937" class="line"></span>                continue;
<span id="line29938" class="line"></span>            }
<span id="line29939" class="line"></span>
<span id="line29940" class="line"></span>            const targetRenderPixelRatio = this.viewport.deltaPixelsFromPointsNoRotate(
<span id="line29941" class="line"></span>                this.source.getPixelRatio(level),
<span id="line29942" class="line"></span>                false
<span id="line29943" class="line"></span>            ).x * this._scaleSpring.current.value;
<span id="line29944" class="line"></span>
<span id="line29945" class="line"></span>            const targetZeroRatio = this.viewport.deltaPixelsFromPointsNoRotate(
<span id="line29946" class="line"></span>                this.source.getPixelRatio(
<span id="line29947" class="line"></span>                    Math.max(
<span id="line29948" class="line"></span>                        this.source.getClosestLevel(),
<span id="line29949" class="line"></span>                        0
<span id="line29950" class="line"></span>                    )
<span id="line29951" class="line"></span>                ),
<span id="line29952" class="line"></span>                false
<span id="line29953" class="line"></span>            ).x * this._scaleSpring.current.value;
<span id="line29954" class="line"></span>
<span id="line29955" class="line"></span>            const optimalRatio = this.immediateRender ? 1 : targetZeroRatio;
<span id="line29956" class="line"></span>            const levelOpacity = Math.min(1, (currentRenderPixelRatio - 0.5) / 0.5);
<span id="line29957" class="line"></span>            const levelVisibility = optimalRatio / Math.abs(
<span id="line29958" class="line"></span>                optimalRatio - targetRenderPixelRatio
<span id="line29959" class="line"></span>            );
<span id="line29960" class="line"></span>
<span id="line29961" class="line"></span>            // Update the level and keep track of 'best' tiles to load
<span id="line29962" class="line"></span>            const result = this._updateLevel(
<span id="line29963" class="line"></span>                level,
<span id="line29964" class="line"></span>                levelOpacity,
<span id="line29965" class="line"></span>                levelVisibility,
<span id="line29966" class="line"></span>                drawArea,
<span id="line29967" class="line"></span>                loadArea,
<span id="line29968" class="line"></span>                currentTime,
<span id="line29969" class="line"></span>                bestLoadTileCandidates
<span id="line29970" class="line"></span>            );
<span id="line29971" class="line"></span>
<span id="line29972" class="line"></span>            this.viewer.world.ensureTilesUpToDate(result.tilesToDraw);
<span id="line29973" class="line"></span>
<span id="line29974" class="line"></span>            bestLoadTileCandidates = result.bestLoadTileCandidates;
<span id="line29975" class="line"></span>            this._tilesToDraw[level] = result.tilesToDraw;
<span id="line29976" class="line"></span>
<span id="line29977" class="line"></span>            // Stop the loop if lower-res tiles would all be covered by
<span id="line29978" class="line"></span>            // already drawn tiles
<span id="line29979" class="line"></span>            if (this._providesCoverage(this.coverage, level)) {
<span id="line29980" class="line"></span>                break;
<span id="line29981" class="line"></span>            }
<span id="line29982" class="line"></span>        }
<span id="line29983" class="line"></span>
<span id="line29984" class="line"></span>
<span id="line29985" class="line"></span>        // Load the new 'best' n tiles
<span id="line29986" class="line"></span>        if (bestLoadTileCandidates &amp;&amp; bestLoadTileCandidates.length &gt; 0) {
<span id="line29987" class="line"></span>            // We need to set loading state immediatelly, if we need setTimeout() here,
<span id="line29988" class="line"></span>            // we should immediatelly set loading=true to all tiles
<span id="line29989" class="line"></span>            for (const tile of bestLoadTileCandidates) {
<span id="line29990" class="line"></span>                if (tile) {
<span id="line29991" class="line"></span>                    this._loadTile(tile, currentTime);
<span id="line29992" class="line"></span>                }
<span id="line29993" class="line"></span>            }
<span id="line29994" class="line"></span>            this._needsDraw = true;
<span id="line29995" class="line"></span>            return false;
<span id="line29996" class="line"></span>        } else {
<span id="line29997" class="line"></span>            return this._tilesLoading === 0;
<span id="line29998" class="line"></span>        }
<span id="line29999" class="line"></span>    },
<span id="line30000" class="line"></span>
<span id="line30001" class="line"></span>    /**
<span id="line30002" class="line"></span>     * Update all tiles that contribute to the current view
<span id="line30003" class="line"></span>     * @private
<span id="line30004" class="line"></span>     *
<span id="line30005" class="line"></span>     */
<span id="line30006" class="line"></span>    _updateTilesInViewport: function(tiles) {
<span id="line30007" class="line"></span>        const currentTime = $.now();
<span id="line30008" class="line"></span>        const _this = this;
<span id="line30009" class="line"></span>        this._tilesLoading = 0;
<span id="line30010" class="line"></span>        this._wasBlending = this._isBlending;
<span id="line30011" class="line"></span>        this._isBlending = false;
<span id="line30012" class="line"></span>        this.loadingCoverage = {};
<span id="line30013" class="line"></span>        const lowestLevel = tiles.length ? tiles[0].level : 0;
<span id="line30014" class="line"></span>
<span id="line30015" class="line"></span>        const drawArea = this.getDrawArea();
<span id="line30016" class="line"></span>        if(!drawArea){
<span id="line30017" class="line"></span>            return;
<span id="line30018" class="line"></span>        }
<span id="line30019" class="line"></span>
<span id="line30020" class="line"></span>        // Update each tile in the list of tiles. As the tiles are updated,
<span id="line30021" class="line"></span>        // the coverage provided is also updated. If a level provides coverage
<span id="line30022" class="line"></span>        // as part of this process, discard tiles from lower levels
<span id="line30023" class="line"></span>        let level = 0;
<span id="line30024" class="line"></span>        for (const info of tiles) {
<span id="line30025" class="line"></span>            const tile = info.tile;
<span id="line30026" class="line"></span>            if (tile &amp;&amp; tile.loaded) {
<span id="line30027" class="line"></span>                const tileIsBlending = _this._blendTile(
<span id="line30028" class="line"></span>                    tile,
<span id="line30029" class="line"></span>                    tile.x,
<span id="line30030" class="line"></span>                    tile.y,
<span id="line30031" class="line"></span>                    info.level,
<span id="line30032" class="line"></span>                    info.levelOpacity,
<span id="line30033" class="line"></span>                    currentTime,
<span id="line30034" class="line"></span>                    lowestLevel
<span id="line30035" class="line"></span>                );
<span id="line30036" class="line"></span>                _this._isBlending = _this._isBlending || tileIsBlending;
<span id="line30037" class="line"></span>                _this._needsDraw = _this._needsDraw || tileIsBlending || _this._wasBlending;
<span id="line30038" class="line"></span>            }
<span id="line30039" class="line"></span>
<span id="line30040" class="line"></span>            if (this._providesCoverage(this.coverage, info.level)) {
<span id="line30041" class="line"></span>                level = Math.max(level, info.level);
<span id="line30042" class="line"></span>            }
<span id="line30043" class="line"></span>        }
<span id="line30044" class="line"></span>        if (level &gt; 0) {
<span id="line30045" class="line"></span>            for (const levelKey in this._tilesToDraw) {
<span id="line30046" class="line"></span>                if (levelKey &lt; level) {
<span id="line30047" class="line"></span>                    this._tilesToDraw[levelKey] = undefined;
<span id="line30048" class="line"></span>                }
<span id="line30049" class="line"></span>            }
<span id="line30050" class="line"></span>        }
<span id="line30051" class="line"></span>    },
<span id="line30052" class="line"></span>
<span id="line30053" class="line"></span>    /**
<span id="line30054" class="line"></span>     * Updates the opacity of a tile according to the time it has been on screen
<span id="line30055" class="line"></span>     * to perform a fade-in.
<span id="line30056" class="line"></span>     * Updates coverage once a tile is fully opaque.
<span id="line30057" class="line"></span>     * Returns whether the fade-in has completed.
<span id="line30058" class="line"></span>     * @private
<span id="line30059" class="line"></span>     *
<span id="line30060" class="line"></span>     * @param {OpenSeadragon.Tile} tile
<span id="line30061" class="line"></span>     * @param {Number} x
<span id="line30062" class="line"></span>     * @param {Number} y
<span id="line30063" class="line"></span>     * @param {Number} level
<span id="line30064" class="line"></span>     * @param {Number} levelOpacity
<span id="line30065" class="line"></span>     * @param {Number} currentTime
<span id="line30066" class="line"></span>     * @param {Boolean} lowestLevel
<span id="line30067" class="line"></span>     * @returns {Boolean} true if blending did not yet finish
<span id="line30068" class="line"></span>     */
<span id="line30069" class="line"></span>    _blendTile: function(tile, x, y, level, levelOpacity, currentTime, lowestLevel ){
<span id="line30070" class="line"></span>        let blendTimeMillis = 1000 * this.blendTime,
<span id="line30071" class="line"></span>            deltaTime,
<span id="line30072" class="line"></span>            opacity;
<span id="line30073" class="line"></span>
<span id="line30074" class="line"></span>        if ( !tile.blendStart ) {
<span id="line30075" class="line"></span>            tile.blendStart = currentTime;
<span id="line30076" class="line"></span>        }
<span id="line30077" class="line"></span>
<span id="line30078" class="line"></span>        deltaTime   = currentTime - tile.blendStart;
<span id="line30079" class="line"></span>        opacity     = blendTimeMillis ? Math.min( 1, deltaTime / ( blendTimeMillis ) ) : 1;
<span id="line30080" class="line"></span>
<span id="line30081" class="line"></span>        // if this tile is at the lowest level being drawn, render at opacity=1
<span id="line30082" class="line"></span>        if(level === lowestLevel){
<span id="line30083" class="line"></span>            opacity = 1;
<span id="line30084" class="line"></span>            deltaTime = blendTimeMillis;
<span id="line30085" class="line"></span>        }
<span id="line30086" class="line"></span>
<span id="line30087" class="line"></span>        if ( this.alwaysBlend ) {
<span id="line30088" class="line"></span>            opacity *= levelOpacity;
<span id="line30089" class="line"></span>        }
<span id="line30090" class="line"></span>        tile.opacity = opacity;
<span id="line30091" class="line"></span>
<span id="line30092" class="line"></span>        if ( opacity === 1 ) {
<span id="line30093" class="line"></span>            this._setCoverage( this.coverage, level, x, y, true );
<span id="line30094" class="line"></span>            this._hasOpaqueTile = true;
<span id="line30095" class="line"></span>        }
<span id="line30096" class="line"></span>        // return true if the tile is still blending
<span id="line30097" class="line"></span>        return deltaTime &lt; blendTimeMillis;
<span id="line30098" class="line"></span>    },
<span id="line30099" class="line"></span>
<span id="line30100" class="line"></span>    /**
<span id="line30101" class="line"></span>     * Updates all tiles at a given resolution level.
<span id="line30102" class="line"></span>     * @private
<span id="line30103" class="line"></span>     * @param {Number} level
<span id="line30104" class="line"></span>     * @param {Number} levelOpacity
<span id="line30105" class="line"></span>     * @param {Number} levelVisibility
<span id="line30106" class="line"></span>     * @param {OpenSeadragon.Rect} drawArea
<span id="line30107" class="line"></span>     * @param {OpenSeadragon.Rect} loadArea
<span id="line30108" class="line"></span>     * @param {Number} currentTime
<span id="line30109" class="line"></span>     * @param {OpenSeadragon.Tile[]} bestLoadTileCandidates Array of the current best tiles
<span id="line30110" class="line"></span>     * @returns {Object} Dictionary {
<span id="line30111" class="line"></span>     *    bestLoadTileCandidates: OpenSeadragon.Tile - the current "best" tiles to draw,
<span id="line30112" class="line"></span>     *    tilesToDraw: OpenSeadragon.Tile) - the updated tiles
<span id="line30113" class="line"></span>     * }
<span id="line30114" class="line"></span>     */
<span id="line30115" class="line"></span>    _updateLevel: function(level, levelOpacity,
<span id="line30116" class="line"></span>                            levelVisibility, drawArea, loadArea, currentTime, bestLoadTileCandidates) {
<span id="line30117" class="line"></span>
<span id="line30118" class="line"></span>        const drawTopLeftBound = drawArea.getBoundingBox().getTopLeft();
<span id="line30119" class="line"></span>        const drawBottomRightBound = drawArea.getBoundingBox().getBottomRight();
<span id="line30120" class="line"></span>        if (this.viewer) {
<span id="line30121" class="line"></span>            /**
<span id="line30122" class="line"></span>             * &lt;em&gt;- Needs documentation -&lt;/em&gt;
<span id="line30123" class="line"></span>             *
<span id="line30124" class="line"></span>             * @event update-level
<span id="line30125" class="line"></span>             * @memberof OpenSeadragon.Viewer
<span id="line30126" class="line"></span>             * @type {object}
<span id="line30127" class="line"></span>             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line30128" class="line"></span>             * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
<span id="line30129" class="line"></span>             * @property {Object} havedrawn - deprecated, always true (kept for backwards compatibility)
<span id="line30130" class="line"></span>             * @property {Object} level
<span id="line30131" class="line"></span>             * @property {Object} opacity
<span id="line30132" class="line"></span>             * @property {Object} visibility
<span id="line30133" class="line"></span>             * @property {OpenSeadragon.Rect} drawArea
<span id="line30134" class="line"></span>             * @property {Object} topleft deprecated, use drawArea instead
<span id="line30135" class="line"></span>             * @property {Object} bottomright deprecated, use drawArea instead
<span id="line30136" class="line"></span>             * @property {Object} currenttime
<span id="line30137" class="line"></span>             * @property {Object[]} best
<span id="line30138" class="line"></span>             * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line30139" class="line"></span>             */
<span id="line30140" class="line"></span>            this.viewer.raiseEvent('update-level', {
<span id="line30141" class="line"></span>                tiledImage: this,
<span id="line30142" class="line"></span>                havedrawn: true, // deprecated, kept for backwards compatibility
<span id="line30143" class="line"></span>                level: level,
<span id="line30144" class="line"></span>                opacity: levelOpacity,
<span id="line30145" class="line"></span>                visibility: levelVisibility,
<span id="line30146" class="line"></span>                drawArea: drawArea,
<span id="line30147" class="line"></span>                topleft: drawTopLeftBound,
<span id="line30148" class="line"></span>                bottomright: drawBottomRightBound,
<span id="line30149" class="line"></span>                currenttime: currentTime,
<span id="line30150" class="line"></span>                // todo misleading name, consider changing
<span id="line30151" class="line"></span>                best: bestLoadTileCandidates
<span id="line30152" class="line"></span>            });
<span id="line30153" class="line"></span>        }
<span id="line30154" class="line"></span>
<span id="line30155" class="line"></span>        const numberOfTiles = this.source.getNumTiles(level);
<span id="line30156" class="line"></span>        const viewportCenter = this.viewport.pixelFromPoint(this.viewport.getCenter());
<span id="line30157" class="line"></span>        this._resetCoverage(this.coverage, level);
<span id="line30158" class="line"></span>        if (loadArea) {
<span id="line30159" class="line"></span>            this._resetCoverage(this.loadingCoverage, level);
<span id="line30160" class="line"></span>        }
<span id="line30161" class="line"></span>
<span id="line30162" class="line"></span>        let tilesToDraw = null;
<span id="line30163" class="line"></span>        let tileIndex = 0;
<span id="line30164" class="line"></span>
<span id="line30165" class="line"></span>        // Iterate over tiles and decide, which will be loaded and drawn
<span id="line30166" class="line"></span>        this._visitTiles(level, drawArea, (x, y, total) =&gt; {
<span id="line30167" class="line"></span>            const tile = this._getTile(
<span id="line30168" class="line"></span>                x, y,
<span id="line30169" class="line"></span>                level,
<span id="line30170" class="line"></span>                currentTime,
<span id="line30171" class="line"></span>                numberOfTiles
<span id="line30172" class="line"></span>            );
<span id="line30173" class="line"></span>
<span id="line30174" class="line"></span>            if (!tilesToDraw) {
<span id="line30175" class="line"></span>                tilesToDraw = this._getCachedArray(level, total);
<span id="line30176" class="line"></span>            }
<span id="line30177" class="line"></span>
<span id="line30178" class="line"></span>            /////////////////////////////////////////////////////
<span id="line30179" class="line"></span>            // First Part: Decide if tile will be used to draw //
<span id="line30180" class="line"></span>            /////////////////////////////////////////////////////
<span id="line30181" class="line"></span>
<span id="line30182" class="line"></span>            if( this.viewer ){
<span id="line30183" class="line"></span>                /**
<span id="line30184" class="line"></span>                 * This event is called before tile is being updated: its position, coverage and other properties.
<span id="line30185" class="line"></span>                 * Note that this does not mean the tile will be loaded, it might be just updated greedily to avoid
<span id="line30186" class="line"></span>                 * visible load animation (happens if position is updated lazily when tile.loaded / loading is true).
<span id="line30187" class="line"></span>                 *
<span id="line30188" class="line"></span>                 * @event update-tile
<span id="line30189" class="line"></span>                 * @memberof OpenSeadragon.Viewer
<span id="line30190" class="line"></span>                 * @type {object}
<span id="line30191" class="line"></span>                 * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
<span id="line30192" class="line"></span>                 * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
<span id="line30193" class="line"></span>                 * @property {OpenSeadragon.Tile} tile
<span id="line30194" class="line"></span>                 * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line30195" class="line"></span>                 */
<span id="line30196" class="line"></span>                this.viewer.raiseEvent( 'update-tile', {
<span id="line30197" class="line"></span>                    tiledImage: this,
<span id="line30198" class="line"></span>                    tile: tile
<span id="line30199" class="line"></span>                });
<span id="line30200" class="line"></span>            }
<span id="line30201" class="line"></span>
<span id="line30202" class="line"></span>            this._setCoverage( this.coverage, level, x, y, false );
<span id="line30203" class="line"></span>
<span id="line30204" class="line"></span>            if (tile.exists) {
<span id="line30205" class="line"></span>                if (tile.loaded) {
<span id="line30206" class="line"></span>                    if (tile.opacity === 1) {
<span id="line30207" class="line"></span>                        this._setCoverage( this.coverage, level, x, y, true );
<span id="line30208" class="line"></span>                    }
<span id="line30209" class="line"></span>
<span id="line30210" class="line"></span>                    // Tiles are carried in info objects
<span id="line30211" class="line"></span>                    tilesToDraw[tileIndex++] = {
<span id="line30212" class="line"></span>                        tile: tile,
<span id="line30213" class="line"></span>                        level: level,
<span id="line30214" class="line"></span>                        levelOpacity: levelOpacity,
<span id="line30215" class="line"></span>                        currentTime: currentTime
<span id="line30216" class="line"></span>                    };
<span id="line30217" class="line"></span>                    this._setCoverage(this.loadingCoverage, level, x, y, true);
<span id="line30218" class="line"></span>                }
<span id="line30219" class="line"></span>
<span id="line30220" class="line"></span>                this._positionTile(
<span id="line30221" class="line"></span>                    tile,
<span id="line30222" class="line"></span>                    this.source.tileOverlap,
<span id="line30223" class="line"></span>                    this.viewport,
<span id="line30224" class="line"></span>                    viewportCenter,
<span id="line30225" class="line"></span>                    levelVisibility
<span id="line30226" class="line"></span>                );
<span id="line30227" class="line"></span>            }
<span id="line30228" class="line"></span>
<span id="line30229" class="line"></span>            /////////////////////////////////////////////////////
<span id="line30230" class="line"></span>            // Second Part: Decide if tile will be loaded      //
<span id="line30231" class="line"></span>            /////////////////////////////////////////////////////
<span id="line30232" class="line"></span>
<span id="line30233" class="line"></span>            if (loadArea &amp;&amp; !tile.loaded) {
<span id="line30234" class="line"></span>                let loadingCoverage = tile.loading || this._isCovered(this.loadingCoverage, level, x, y);
<span id="line30235" class="line"></span>                this._setCoverage(this.loadingCoverage, level, x, y, loadingCoverage);
<span id="line30236" class="line"></span>
<span id="line30237" class="line"></span>                if ( !tile.exists ) {
<span id="line30238" class="line"></span>                    return;
<span id="line30239" class="line"></span>                }
<span id="line30240" class="line"></span>
<span id="line30241" class="line"></span>                // Try-find will populate tile with data if equal tile exists in system
<span id="line30242" class="line"></span>                if (!tile.loading &amp;&amp; this._tryFindTileCacheRecord(tile)) {
<span id="line30243" class="line"></span>                    loadingCoverage = true;
<span id="line30244" class="line"></span>                }
<span id="line30245" class="line"></span>
<span id="line30246" class="line"></span>                if (tile.loading) {
<span id="line30247" class="line"></span>                    // the tile is already in the download queue or being processed
<span id="line30248" class="line"></span>                    this._tilesLoading++;
<span id="line30249" class="line"></span>                } else if (!loadingCoverage) {
<span id="line30250" class="line"></span>                    // add tile to best tiles to load only when not loaded already
<span id="line30251" class="line"></span>                    bestLoadTileCandidates = this._compareTiles( bestLoadTileCandidates, tile, this._currentMaxTilesPerFrame);
<span id="line30252" class="line"></span>                }
<span id="line30253" class="line"></span>            }
<span id="line30254" class="line"></span>        });
<span id="line30255" class="line"></span>
<span id="line30256" class="line"></span>        // _currentMaxTilesPerFrame can be temporarily boosted, bring it down after each usage if necessary
<span id="line30257" class="line"></span>        if (this._currentMaxTilesPerFrame &gt; this.maxTilesPerFrame) {
<span id="line30258" class="line"></span>            this._currentMaxTilesPerFrame = Math.max(Math.ceil(this._currentMaxTilesPerFrame / 2), this.maxTilesPerFrame);
<span id="line30259" class="line"></span>        }
<span id="line30260" class="line"></span>
<span id="line30261" class="line"></span>        if (tilesToDraw) {
<span id="line30262" class="line"></span>            tilesToDraw.length = tileIndex;
<span id="line30263" class="line"></span>        }
<span id="line30264" class="line"></span>
<span id="line30265" class="line"></span>        return {
<span id="line30266" class="line"></span>            bestLoadTileCandidates: bestLoadTileCandidates,
<span id="line30267" class="line"></span>            tilesToDraw: tilesToDraw || []
<span id="line30268" class="line"></span>        };
<span id="line30269" class="line"></span>    },
<span id="line30270" class="line"></span>
<span id="line30271" class="line"></span>    /**
<span id="line30272" class="line"></span>     * Visit all tiles in an a given area on a given level.
<span id="line30273" class="line"></span>     * @private
<span id="line30274" class="line"></span>     * @param {Number} level
<span id="line30275" class="line"></span>     * @param {OpenSeadragon.Rect} area
<span id="line30276" class="line"></span>     * @param {Function} callback - x, y, total - tile x, y position and total number of tiles
<span id="line30277" class="line"></span>     */
<span id="line30278" class="line"></span>    _visitTiles: function(level, area, callback) {
<span id="line30279" class="line"></span>        const bbox = area.getBoundingBox();
<span id="line30280" class="line"></span>        const drawCornerTiles = this._getCornerTiles(level, bbox.getTopLeft(), bbox.getBottomRight());
<span id="line30281" class="line"></span>        const drawTopLeftTile = drawCornerTiles.topLeft;
<span id="line30282" class="line"></span>        const drawBottomRightTile = drawCornerTiles.bottomRight;
<span id="line30283" class="line"></span>
<span id="line30284" class="line"></span>        const numberOfTiles  = this.source.getNumTiles(level);
<span id="line30285" class="line"></span>
<span id="line30286" class="line"></span>        if (this.getFlip()) {
<span id="line30287" class="line"></span>            // The right-most tile can be narrower than the others. When flipped,
<span id="line30288" class="line"></span>            // this tile is now on the left. Because it is narrower than the normal
<span id="line30289" class="line"></span>            // left-most tile, the subsequent tiles may not be wide enough to completely
<span id="line30290" class="line"></span>            // fill the viewport. Fix this by rendering an extra column of tiles. If we
<span id="line30291" class="line"></span>            // are not wrapping, make sure we never render more than the number of tiles
<span id="line30292" class="line"></span>            // in the image.
<span id="line30293" class="line"></span>            drawBottomRightTile.x += 1;
<span id="line30294" class="line"></span>            if (!this.wrapHorizontal) {
<span id="line30295" class="line"></span>                drawBottomRightTile.x  = Math.min(drawBottomRightTile.x, numberOfTiles.x - 1);
<span id="line30296" class="line"></span>            }
<span id="line30297" class="line"></span>        }
<span id="line30298" class="line"></span>        const numTiles = Math.max(0, (drawBottomRightTile.x - drawTopLeftTile.x) * (drawBottomRightTile.y - drawTopLeftTile.y));
<span id="line30299" class="line"></span>
<span id="line30300" class="line"></span>        for (let x = drawTopLeftTile.x; x &lt;= drawBottomRightTile.x; x++) {
<span id="line30301" class="line"></span>            for (let y = drawTopLeftTile.y; y &lt;= drawBottomRightTile.y; y++) {
<span id="line30302" class="line"></span>
<span id="line30303" class="line"></span>                let flippedX;
<span id="line30304" class="line"></span>                if (this.getFlip()) {
<span id="line30305" class="line"></span>                    const xMod = ( numberOfTiles.x + ( x % numberOfTiles.x ) ) % numberOfTiles.x;
<span id="line30306" class="line"></span>                    flippedX = x + numberOfTiles.x - xMod - xMod - 1;
<span id="line30307" class="line"></span>                } else {
<span id="line30308" class="line"></span>                    flippedX = x;
<span id="line30309" class="line"></span>                }
<span id="line30310" class="line"></span>
<span id="line30311" class="line"></span>                if (area.intersection(this.getTileBounds(level, flippedX, y)) === null) {
<span id="line30312" class="line"></span>                    // This tile is not in the draw area
<span id="line30313" class="line"></span>                    continue;
<span id="line30314" class="line"></span>                }
<span id="line30315" class="line"></span>
<span id="line30316" class="line"></span>                callback(flippedX, y, numTiles);
<span id="line30317" class="line"></span>            }
<span id="line30318" class="line"></span>        }
<span id="line30319" class="line"></span>    },
<span id="line30320" class="line"></span>
<span id="line30321" class="line"></span>    /**
<span id="line30322" class="line"></span>     * @private
<span id="line30323" class="line"></span>     * @param {OpenSeadragon.Tile} tile
<span id="line30324" class="line"></span>     * @param {Boolean} overlap
<span id="line30325" class="line"></span>     * @param {OpenSeadragon.Viewport} viewport
<span id="line30326" class="line"></span>     * @param {OpenSeadragon.Point} viewportCenter
<span id="line30327" class="line"></span>     * @param {Number} levelVisibility
<span id="line30328" class="line"></span>     */
<span id="line30329" class="line"></span>    _positionTile: function( tile, overlap, viewport, viewportCenter, levelVisibility ){
<span id="line30330" class="line"></span>        const boundsTL = tile.bounds.getTopLeft();
<span id="line30331" class="line"></span>
<span id="line30332" class="line"></span>        boundsTL.x *= this._scaleSpring.current.value;
<span id="line30333" class="line"></span>        boundsTL.y *= this._scaleSpring.current.value;
<span id="line30334" class="line"></span>        boundsTL.x += this._xSpring.current.value;
<span id="line30335" class="line"></span>        boundsTL.y += this._ySpring.current.value;
<span id="line30336" class="line"></span>
<span id="line30337" class="line"></span>        const boundsSize   = tile.bounds.getSize();
<span id="line30338" class="line"></span>
<span id="line30339" class="line"></span>        boundsSize.x *= this._scaleSpring.current.value;
<span id="line30340" class="line"></span>        boundsSize.y *= this._scaleSpring.current.value;
<span id="line30341" class="line"></span>
<span id="line30342" class="line"></span>        tile.positionedBounds.x = boundsTL.x;
<span id="line30343" class="line"></span>        tile.positionedBounds.y = boundsTL.y;
<span id="line30344" class="line"></span>        tile.positionedBounds.width = boundsSize.x;
<span id="line30345" class="line"></span>        tile.positionedBounds.height = boundsSize.y;
<span id="line30346" class="line"></span>
<span id="line30347" class="line"></span>        const positionC = viewport.pixelFromPointNoRotate(boundsTL, true);
<span id="line30348" class="line"></span>        const positionT = viewport.pixelFromPointNoRotate(boundsTL, false);
<span id="line30349" class="line"></span>        let sizeC = viewport.deltaPixelsFromPointsNoRotate(boundsSize, true);
<span id="line30350" class="line"></span>        const sizeT = viewport.deltaPixelsFromPointsNoRotate(boundsSize, false);
<span id="line30351" class="line"></span>        const tileCenter = positionT.plus( sizeT.divide( 2 ) );
<span id="line30352" class="line"></span>        const tileSquaredDistance = viewportCenter.squaredDistanceTo( tileCenter );
<span id="line30353" class="line"></span>
<span id="line30354" class="line"></span>        if(this.getDrawer().minimumOverlapRequired(this)){
<span id="line30355" class="line"></span>            if ( !overlap ) {
<span id="line30356" class="line"></span>                sizeC = sizeC.plus( new $.Point(1, 1));
<span id="line30357" class="line"></span>            }
<span id="line30358" class="line"></span>
<span id="line30359" class="line"></span>            if (tile.isRightMost &amp;&amp; this.wrapHorizontal) {
<span id="line30360" class="line"></span>                sizeC.x += 0.75; // Otherwise Firefox and Safari show seams
<span id="line30361" class="line"></span>            }
<span id="line30362" class="line"></span>
<span id="line30363" class="line"></span>            if (tile.isBottomMost &amp;&amp; this.wrapVertical) {
<span id="line30364" class="line"></span>                sizeC.y += 0.75; // Otherwise Firefox and Safari show seams
<span id="line30365" class="line"></span>            }
<span id="line30366" class="line"></span>        }
<span id="line30367" class="line"></span>
<span id="line30368" class="line"></span>        tile.position   = positionC;
<span id="line30369" class="line"></span>        tile.size       = sizeC;
<span id="line30370" class="line"></span>        tile.squaredDistance   = tileSquaredDistance;
<span id="line30371" class="line"></span>        tile.visibility = levelVisibility;
<span id="line30372" class="line"></span>    },
<span id="line30373" class="line"></span>
<span id="line30374" class="line"></span>    // private
<span id="line30375" class="line"></span>    _getCornerTiles: function(level, topLeftBound, bottomRightBound) {
<span id="line30376" class="line"></span>        let leftX;
<span id="line30377" class="line"></span>        let rightX;
<span id="line30378" class="line"></span>        if (this.wrapHorizontal) {
<span id="line30379" class="line"></span>            leftX = $.positiveModulo(topLeftBound.x, 1);
<span id="line30380" class="line"></span>            rightX = $.positiveModulo(bottomRightBound.x, 1);
<span id="line30381" class="line"></span>        } else {
<span id="line30382" class="line"></span>            leftX = Math.max(0, topLeftBound.x);
<span id="line30383" class="line"></span>            rightX = Math.min(1, bottomRightBound.x);
<span id="line30384" class="line"></span>        }
<span id="line30385" class="line"></span>        let topY;
<span id="line30386" class="line"></span>        let bottomY;
<span id="line30387" class="line"></span>        const aspectRatio = 1 / this.source.aspectRatio;
<span id="line30388" class="line"></span>        if (this.wrapVertical) {
<span id="line30389" class="line"></span>            topY = $.positiveModulo(topLeftBound.y, aspectRatio);
<span id="line30390" class="line"></span>            bottomY = $.positiveModulo(bottomRightBound.y, aspectRatio);
<span id="line30391" class="line"></span>        } else {
<span id="line30392" class="line"></span>            topY = Math.max(0, topLeftBound.y);
<span id="line30393" class="line"></span>            bottomY = Math.min(aspectRatio, bottomRightBound.y);
<span id="line30394" class="line"></span>        }
<span id="line30395" class="line"></span>
<span id="line30396" class="line"></span>        const topLeftTile = this.source.getTileAtPoint(level, new $.Point(leftX, topY));
<span id="line30397" class="line"></span>        const bottomRightTile = this.source.getTileAtPoint(level, new $.Point(rightX, bottomY));
<span id="line30398" class="line"></span>        const numTiles  = this.source.getNumTiles(level);
<span id="line30399" class="line"></span>
<span id="line30400" class="line"></span>        if (this.wrapHorizontal) {
<span id="line30401" class="line"></span>            topLeftTile.x += numTiles.x * Math.floor(topLeftBound.x);
<span id="line30402" class="line"></span>            bottomRightTile.x += numTiles.x * Math.floor(bottomRightBound.x);
<span id="line30403" class="line"></span>        }
<span id="line30404" class="line"></span>        if (this.wrapVertical) {
<span id="line30405" class="line"></span>            topLeftTile.y += numTiles.y * Math.floor(topLeftBound.y / aspectRatio);
<span id="line30406" class="line"></span>            bottomRightTile.y += numTiles.y * Math.floor(bottomRightBound.y / aspectRatio);
<span id="line30407" class="line"></span>        }
<span id="line30408" class="line"></span>
<span id="line30409" class="line"></span>        return {
<span id="line30410" class="line"></span>            topLeft: topLeftTile,
<span id="line30411" class="line"></span>            bottomRight: bottomRightTile,
<span id="line30412" class="line"></span>        };
<span id="line30413" class="line"></span>    },
<span id="line30414" class="line"></span>
<span id="line30415" class="line"></span>    /**
<span id="line30416" class="line"></span>     * @private
<span id="line30417" class="line"></span>     * @inner
<span id="line30418" class="line"></span>     * Try to find existing cache of the tile
<span id="line30419" class="line"></span>     * @param {OpenSeadragon.Tile} tile
<span id="line30420" class="line"></span>     */
<span id="line30421" class="line"></span>    _tryFindTileCacheRecord: function(tile) {
<span id="line30422" class="line"></span>        const record = this._tileCache.getCacheRecord(tile.originalCacheKey);
<span id="line30423" class="line"></span>
<span id="line30424" class="line"></span>        if (!record) {
<span id="line30425" class="line"></span>            return false;
<span id="line30426" class="line"></span>        }
<span id="line30427" class="line"></span>        tile.loading = true;
<span id="line30428" class="line"></span>        this._setTileLoaded(tile, record.data, null, null, record.type);
<span id="line30429" class="line"></span>        return true;
<span id="line30430" class="line"></span>    },
<span id="line30431" class="line"></span>
<span id="line30432" class="line"></span>    /**
<span id="line30433" class="line"></span>     * @private
<span id="line30434" class="line"></span>     * @inner
<span id="line30435" class="line"></span>     * Obtains a tile at the given location.
<span id="line30436" class="line"></span>     * @private
<span id="line30437" class="line"></span>     * @param {Number} x
<span id="line30438" class="line"></span>     * @param {Number} y
<span id="line30439" class="line"></span>     * @param {Number} level
<span id="line30440" class="line"></span>     * @param {Number} time
<span id="line30441" class="line"></span>     * @param {Number} numTiles
<span id="line30442" class="line"></span>     * @returns {OpenSeadragon.Tile}
<span id="line30443" class="line"></span>     */
<span id="line30444" class="line"></span>    _getTile: function(
<span id="line30445" class="line"></span>        x, y,
<span id="line30446" class="line"></span>        level,
<span id="line30447" class="line"></span>        time,
<span id="line30448" class="line"></span>        numTiles
<span id="line30449" class="line"></span>    ) {
<span id="line30450" class="line"></span>        let xMod,
<span id="line30451" class="line"></span>            yMod,
<span id="line30452" class="line"></span>            bounds,
<span id="line30453" class="line"></span>            sourceBounds,
<span id="line30454" class="line"></span>            exists,
<span id="line30455" class="line"></span>            urlOrGetter,
<span id="line30456" class="line"></span>            post,
<span id="line30457" class="line"></span>            ajaxHeaders,
<span id="line30458" class="line"></span>            tile,
<span id="line30459" class="line"></span>            tilesMatrix = this.tilesMatrix,
<span id="line30460" class="line"></span>            tileSource = this.source;
<span id="line30461" class="line"></span>
<span id="line30462" class="line"></span>        let matrixLevel = tilesMatrix[ level ];
<span id="line30463" class="line"></span>        if ( !matrixLevel ) {
<span id="line30464" class="line"></span>            tilesMatrix[ level ] = matrixLevel = {};
<span id="line30465" class="line"></span>        }
<span id="line30466" class="line"></span>        if ( !matrixLevel[ x ] ) {
<span id="line30467" class="line"></span>            matrixLevel[ x ] = {};
<span id="line30468" class="line"></span>        }
<span id="line30469" class="line"></span>
<span id="line30470" class="line"></span>        if ( !matrixLevel[ x ][ y ] || !matrixLevel[ x ][ y ].flipped !== !this.flipped ) {
<span id="line30471" class="line"></span>            xMod    = ( numTiles.x + ( x % numTiles.x ) ) % numTiles.x;
<span id="line30472" class="line"></span>            yMod    = ( numTiles.y + ( y % numTiles.y ) ) % numTiles.y;
<span id="line30473" class="line"></span>            bounds  = this.getTileBounds( level, x, y );
<span id="line30474" class="line"></span>            sourceBounds = tileSource.getTileBounds( level, xMod, yMod, true );
<span id="line30475" class="line"></span>            exists  = tileSource.tileExists( level, xMod, yMod );
<span id="line30476" class="line"></span>            urlOrGetter     = tileSource.getTileUrl( level, xMod, yMod );
<span id="line30477" class="line"></span>            post    = tileSource.getTilePostData( level, xMod, yMod );
<span id="line30478" class="line"></span>
<span id="line30479" class="line"></span>            // Headers are only applicable if loadTilesWithAjax is set
<span id="line30480" class="line"></span>            if (this.loadTilesWithAjax) {
<span id="line30481" class="line"></span>                ajaxHeaders = tileSource.getTileAjaxHeaders( level, xMod, yMod );
<span id="line30482" class="line"></span>                // Combine tile AJAX headers with tiled image AJAX headers (if applicable)
<span id="line30483" class="line"></span>                if ($.isPlainObject(this.ajaxHeaders)) {
<span id="line30484" class="line"></span>                    ajaxHeaders = $.extend({}, this.ajaxHeaders, ajaxHeaders);
<span id="line30485" class="line"></span>                }
<span id="line30486" class="line"></span>            } else {
<span id="line30487" class="line"></span>                ajaxHeaders = null;
<span id="line30488" class="line"></span>            }
<span id="line30489" class="line"></span>
<span id="line30490" class="line"></span>            tile = new $.Tile(
<span id="line30491" class="line"></span>                level,
<span id="line30492" class="line"></span>                x,
<span id="line30493" class="line"></span>                y,
<span id="line30494" class="line"></span>                bounds,
<span id="line30495" class="line"></span>                exists,
<span id="line30496" class="line"></span>                urlOrGetter,
<span id="line30497" class="line"></span>                undefined,
<span id="line30498" class="line"></span>                this.loadTilesWithAjax,
<span id="line30499" class="line"></span>                ajaxHeaders,
<span id="line30500" class="line"></span>                sourceBounds,
<span id="line30501" class="line"></span>                post,
<span id="line30502" class="line"></span>                tileSource.getTileHashKey(level, xMod, yMod, urlOrGetter, ajaxHeaders, post)
<span id="line30503" class="line"></span>            );
<span id="line30504" class="line"></span>
<span id="line30505" class="line"></span>            if (this.getFlip()) {
<span id="line30506" class="line"></span>                if (xMod === 0) {
<span id="line30507" class="line"></span>                    tile.isRightMost = true;
<span id="line30508" class="line"></span>                }
<span id="line30509" class="line"></span>            } else {
<span id="line30510" class="line"></span>                if (xMod === numTiles.x - 1) {
<span id="line30511" class="line"></span>                    tile.isRightMost = true;
<span id="line30512" class="line"></span>                }
<span id="line30513" class="line"></span>            }
<span id="line30514" class="line"></span>
<span id="line30515" class="line"></span>            if (yMod === numTiles.y - 1) {
<span id="line30516" class="line"></span>                tile.isBottomMost = true;
<span id="line30517" class="line"></span>            }
<span id="line30518" class="line"></span>
<span id="line30519" class="line"></span>            tile.flipped = this.flipped;
<span id="line30520" class="line"></span>
<span id="line30521" class="line"></span>            matrixLevel[ x ][ y ] = tile;
<span id="line30522" class="line"></span>        } else {
<span id="line30523" class="line"></span>            tile = matrixLevel[ x ][ y ];
<span id="line30524" class="line"></span>        }
<span id="line30525" class="line"></span>        tile.lastTouchTime = time;
<span id="line30526" class="line"></span>
<span id="line30527" class="line"></span>        return tile;
<span id="line30528" class="line"></span>    },
<span id="line30529" class="line"></span>
<span id="line30530" class="line"></span>    /**
<span id="line30531" class="line"></span>     * Dispatch a job to the ImageLoader to load the Image for a Tile.
<span id="line30532" class="line"></span>     * @private
<span id="line30533" class="line"></span>     * @param {OpenSeadragon.Tile} tile
<span id="line30534" class="line"></span>     * @param {Number} time
<span id="line30535" class="line"></span>     */
<span id="line30536" class="line"></span>    _loadTile: function(tile, time ) {
<span id="line30537" class="line"></span>        const _this = this;
<span id="line30538" class="line"></span>        tile.loading = true;
<span id="line30539" class="line"></span>        tile.tiledImage = this;
<span id="line30540" class="line"></span>        if (!this._imageLoader.addJob({
<span id="line30541" class="line"></span>            src: tile.getUrl(),
<span id="line30542" class="line"></span>            tile: tile,
<span id="line30543" class="line"></span>            source: this.source,
<span id="line30544" class="line"></span>            postData: tile.postData,
<span id="line30545" class="line"></span>            loadWithAjax: tile.loadWithAjax,
<span id="line30546" class="line"></span>            ajaxHeaders: tile.ajaxHeaders,
<span id="line30547" class="line"></span>            crossOriginPolicy: this.crossOriginPolicy,
<span id="line30548" class="line"></span>            ajaxWithCredentials: this.ajaxWithCredentials,
<span id="line30549" class="line"></span>            callback: function( data, errorMsg, tileRequest, dataType, tries ){
<span id="line30550" class="line"></span>                _this._onTileLoad( tile, time, data, errorMsg, tileRequest, dataType, tries );
<span id="line30551" class="line"></span>            },
<span id="line30552" class="line"></span>            abort: function() {
<span id="line30553" class="line"></span>                tile.loading = false;
<span id="line30554" class="line"></span>            }
<span id="line30555" class="line"></span>        })) {
<span id="line30556" class="line"></span>            /**
<span id="line30557" class="line"></span>             * Triggered if tile load job was added to a full queue.
<span id="line30558" class="line"></span>             * This allows to react upon e.g. network not being able to serve the tiles fast enough.
<span id="line30559" class="line"></span>             * @event job-queue-full
<span id="line30560" class="line"></span>             * @memberof OpenSeadragon.Viewer
<span id="line30561" class="line"></span>             * @type {object}
<span id="line30562" class="line"></span>             * @property {OpenSeadragon.Tile} tile - The tile that failed to load.
<span id="line30563" class="line"></span>             * @property {OpenSeadragon.TiledImage} tiledImage - The tiled image the tile belongs to.
<span id="line30564" class="line"></span>             * @property {number} time - The time in milliseconds when the tile load began.
<span id="line30565" class="line"></span>             */
<span id="line30566" class="line"></span>            this.viewer.raiseEvent("job-queue-full", {
<span id="line30567" class="line"></span>                tile: tile,
<span id="line30568" class="line"></span>                tiledImage: this,
<span id="line30569" class="line"></span>                time: time,
<span id="line30570" class="line"></span>            });
<span id="line30571" class="line"></span>        }
<span id="line30572" class="line"></span>    },
<span id="line30573" class="line"></span>
<span id="line30574" class="line"></span>    /**
<span id="line30575" class="line"></span>     * Callback fired when a Tile's Image finished downloading.
<span id="line30576" class="line"></span>     * @private
<span id="line30577" class="line"></span>     * @param {OpenSeadragon.Tile} tile
<span id="line30578" class="line"></span>     * @param {Number} time
<span id="line30579" class="line"></span>     * @param {*} data image data
<span id="line30580" class="line"></span>     * @param {String} errorMsg
<span id="line30581" class="line"></span>     * @param {XMLHttpRequest} tileRequest
<span id="line30582" class="line"></span>     * @param {String} [dataType=undefined] data type, derived automatically if not set
<span id="line30583" class="line"></span>     * @param {number} tries - The number of times the tile has been retried.
<span id="line30584" class="line"></span>     */
<span id="line30585" class="line"></span>    _onTileLoad: function( tile, time, data, errorMsg, tileRequest, dataType, tries ) {
<span id="line30586" class="line"></span>        //data is set to null on error by image loader, allow custom falsey values (e.g. 0)
<span id="line30587" class="line"></span>        if ( data === null || data === undefined ) {
<span id="line30588" class="line"></span>            $.console.error( "Tile %s failed to load: %s - error: %s", tile, tile.getUrl(), errorMsg );
<span id="line30589" class="line"></span>            /**
<span id="line30590" class="line"></span>             * Triggered when a tile fails to load.
<span id="line30591" class="line"></span>             *
<span id="line30592" class="line"></span>             * @event tile-load-failed
<span id="line30593" class="line"></span>             * @memberof OpenSeadragon.Viewer
<span id="line30594" class="line"></span>             * @type {object}
<span id="line30595" class="line"></span>             * @property {OpenSeadragon.Tile} tile - The tile that failed to load.
<span id="line30596" class="line"></span>             * @property {OpenSeadragon.TiledImage} tiledImage - The tiled image the tile belongs to.
<span id="line30597" class="line"></span>             * @property {number} time - The time in milliseconds when the tile load began.
<span id="line30598" class="line"></span>             * @property {string} message - The error message.
<span id="line30599" class="line"></span>             * @property {number} tries - The number of times the tile has been retried.
<span id="line30600" class="line"></span>             * @property {boolean} maxReached - Whether the maximum number of retries has been reached.
<span id="line30601" class="line"></span>             * @property {XMLHttpRequest} tileRequest - The XMLHttpRequest used to load the tile if available.
<span id="line30602" class="line"></span>             */
<span id="line30603" class="line"></span>            this.viewer.raiseEvent("tile-load-failed", {
<span id="line30604" class="line"></span>                tile: tile,
<span id="line30605" class="line"></span>                tiledImage: this,
<span id="line30606" class="line"></span>                time: time,
<span id="line30607" class="line"></span>                message: errorMsg,
<span id="line30608" class="line"></span>                tileRequest: tileRequest,
<span id="line30609" class="line"></span>                tries: tries,
<span id="line30610" class="line"></span>                maxReached: this.viewer.tileRetryMax === 0 ? true : tries &gt;= this.viewer.tileRetryMax
<span id="line30611" class="line"></span>            });
<span id="line30612" class="line"></span>            tile.loading = false;
<span id="line30613" class="line"></span>            tile.exists = false;
<span id="line30614" class="line"></span>            return;
<span id="line30615" class="line"></span>        } else {
<span id="line30616" class="line"></span>            tile.exists = true;
<span id="line30617" class="line"></span>        }
<span id="line30618" class="line"></span>
<span id="line30619" class="line"></span>        if ( time &lt; this.lastResetTime ) {
<span id="line30620" class="line"></span>            $.console.warn( "Ignoring tile %s loaded before reset: %s", tile, tile.getUrl() );
<span id="line30621" class="line"></span>            tile.loading = false;
<span id="line30622" class="line"></span>            return;
<span id="line30623" class="line"></span>        }
<span id="line30624" class="line"></span>
<span id="line30625" class="line"></span>        if (this.originalDataType) {
<span id="line30626" class="line"></span>            // First fetch conversion path to ensure safe conversion and to deduce target type it chooses as optimal one
<span id="line30627" class="line"></span>            const conversion = $.converter.getConversionPath(dataType, this.originalDataType);
<span id="line30628" class="line"></span>            if (conversion) {
<span id="line30629" class="line"></span>                const desiredType = $.converter.getConversionPathFinalType(conversion);
<span id="line30630" class="line"></span>                $.converter.convert(tile, data, dataType, desiredType).then(newData =&gt; {
<span id="line30631" class="line"></span>                    this._setTileLoaded(tile, newData, null, tileRequest, desiredType);
<span id="line30632" class="line"></span>                }).catch(e =&gt; {
<span id="line30633" class="line"></span>                    $.console.warn("Failed to satisfy original type [%s] %s from %s: %s", desiredType, tile, dataType, e);
<span id="line30634" class="line"></span>                    this._setTileLoaded(tile, data, null, tileRequest, dataType);
<span id="line30635" class="line"></span>                });
<span id="line30636" class="line"></span>            } else {
<span id="line30637" class="line"></span>                $.console.warn( "Ignoring default base tile data type %s: no conversion possible from %s", this.originalDataType, dataType);
<span id="line30638" class="line"></span>                this._setTileLoaded(tile, data, null, tileRequest, dataType);
<span id="line30639" class="line"></span>            }
<span id="line30640" class="line"></span>        } else {
<span id="line30641" class="line"></span>            this._setTileLoaded(tile, data, null, tileRequest, dataType);
<span id="line30642" class="line"></span>        }
<span id="line30643" class="line"></span>    },
<span id="line30644" class="line"></span>
<span id="line30645" class="line"></span>    /**
<span id="line30646" class="line"></span>     * @private
<span id="line30647" class="line"></span>     * @param {OpenSeadragon.Tile} tile
<span id="line30648" class="line"></span>     * @param {*} data image data, the data sent to ImageJob.prototype.finish(), by default an Image object,
<span id="line30649" class="line"></span>     *   can be null: in that case, cache is assigned to a tile without further processing
<span id="line30650" class="line"></span>     * @param {?Number} cutoff ignored, @deprecated
<span id="line30651" class="line"></span>     * @param {?XMLHttpRequest} tileRequest
<span id="line30652" class="line"></span>     * @param {?String} [dataType=undefined] data type, derived automatically if not set
<span id="line30653" class="line"></span>     */
<span id="line30654" class="line"></span>    _setTileLoaded: function(tile, data, cutoff, tileRequest, dataType) {
<span id="line30655" class="line"></span>        tile.tiledImage = this; //unloaded with tile.unload(), so we need to set it back
<span id="line30656" class="line"></span>        // does nothing if tile.cacheKey already present
<span id="line30657" class="line"></span>
<span id="line30658" class="line"></span>        $.console.assert(dataType !== undefined, "TileSource::downloadTileStart must return a dataType.");
<span id="line30659" class="line"></span>
<span id="line30660" class="line"></span>        let tileCacheCreated = false;
<span id="line30661" class="line"></span>        tile.addCache(tile.cacheKey, () =&gt; {
<span id="line30662" class="line"></span>            tileCacheCreated = true;
<span id="line30663" class="line"></span>            return data;
<span id="line30664" class="line"></span>        }, dataType, false, false);
<span id="line30665" class="line"></span>
<span id="line30666" class="line"></span>        let resolver = null,
<span id="line30667" class="line"></span>            increment = 0,
<span id="line30668" class="line"></span>            eventFinished = false;
<span id="line30669" class="line"></span>        const _this = this;
<span id="line30670" class="line"></span>
<span id="line30671" class="line"></span>        function completionCallback() {
<span id="line30672" class="line"></span>            increment--;
<span id="line30673" class="line"></span>            if (increment &gt; 0) {
<span id="line30674" class="line"></span>                return;
<span id="line30675" class="line"></span>            }
<span id="line30676" class="line"></span>            eventFinished = true;
<span id="line30677" class="line"></span>
<span id="line30678" class="line"></span>            //do not override true if set (false is default)
<span id="line30679" class="line"></span>            tile.hasTransparency = tile.hasTransparency || _this.source.hasTransparency(
<span id="line30680" class="line"></span>                undefined, tile.getUrl(), tile.ajaxHeaders, tile.postData
<span id="line30681" class="line"></span>            );
<span id="line30682" class="line"></span>            tile.loading = false;
<span id="line30683" class="line"></span>            tile.loaded = true;
<span id="line30684" class="line"></span>            _this.redraw();
<span id="line30685" class="line"></span>            resolver(tile);
<span id="line30686" class="line"></span>        }
<span id="line30687" class="line"></span>
<span id="line30688" class="line"></span>        function getCompletionCallback() {
<span id="line30689" class="line"></span>            if (eventFinished) {
<span id="line30690" class="line"></span>                $.console.error("Event 'tile-loaded' argument getCompletionCallback must be called synchronously. " +
<span id="line30691" class="line"></span>                    "Its return value should be called asynchronously.");
<span id="line30692" class="line"></span>            }
<span id="line30693" class="line"></span>            increment++;
<span id="line30694" class="line"></span>            return completionCallback;
<span id="line30695" class="line"></span>        }
<span id="line30696" class="line"></span>
<span id="line30697" class="line"></span>        function markTileAsReady() {
<span id="line30698" class="line"></span>            const fallbackCompletion = getCompletionCallback();
<span id="line30699" class="line"></span>
<span id="line30700" class="line"></span>            /**
<span id="line30701" class="line"></span>             * Triggered when a tile has just been loaded in memory. That means that the
<span id="line30702" class="line"></span>             * image has been downloaded and can be modified before being drawn to the canvas.
<span id="line30703" class="line"></span>             * This event is _awaiting_, it supports asynchronous functions or functions that return a promise.
<span id="line30704" class="line"></span>             *
<span id="line30705" class="line"></span>             * @event tile-loaded
<span id="line30706" class="line"></span>             * @memberof OpenSeadragon.Viewer
<span id="line30707" class="line"></span>             * @type {object}
<span id="line30708" class="line"></span>             * @property {Image|*} image - The image (data) of the tile. Deprecated.
<span id="line30709" class="line"></span>             * @property {*} data image data, the data sent to ImageJob.prototype.finish(),
<span id="line30710" class="line"></span>             *   by default an Image object. Deprecated
<span id="line30711" class="line"></span>             * @property {String} dataType type of the data
<span id="line30712" class="line"></span>             * @property {OpenSeadragon.TiledImage} tiledImage - The tiled image of the loaded tile.
<span id="line30713" class="line"></span>             * @property {OpenSeadragon.Tile} tile - The tile which has been loaded.
<span id="line30714" class="line"></span>             * @property {XMLHttpRequest} tileRequest - The AJAX request that loaded this tile (if applicable).
<span id="line30715" class="line"></span>             * @property {OpenSeadragon.Promise} - Promise resolved when the tile gets fully loaded.
<span id="line30716" class="line"></span>             *   NOTE: DO NOT await the promise in the handler: you will create a deadlock!
<span id="line30717" class="line"></span>             * @property {function} getCompletionCallback - deprecated
<span id="line30718" class="line"></span>             */
<span id="line30719" class="line"></span>            _this.viewer.raiseEventAwaiting("tile-loaded", {
<span id="line30720" class="line"></span>                tile: tile,
<span id="line30721" class="line"></span>                tiledImage: _this,
<span id="line30722" class="line"></span>                tileRequest: tileRequest,
<span id="line30723" class="line"></span>                promise: new $.Promise(resolve =&gt; {
<span id="line30724" class="line"></span>                    resolver = resolve;
<span id="line30725" class="line"></span>                }),
<span id="line30726" class="line"></span>                get image() {
<span id="line30727" class="line"></span>                    $.console.error("[tile-loaded] event 'image' has been deprecated. Use 'tile-invalidated' event to modify data instead.");
<span id="line30728" class="line"></span>                    return data;
<span id="line30729" class="line"></span>                },
<span id="line30730" class="line"></span>                get data() {
<span id="line30731" class="line"></span>                    $.console.error("[tile-loaded] event 'data' has been deprecated. Use 'tile-invalidated' event to modify data instead.");
<span id="line30732" class="line"></span>                    return data;
<span id="line30733" class="line"></span>                },
<span id="line30734" class="line"></span>                getCompletionCallback: function () {
<span id="line30735" class="line"></span>                    $.console.error("[tile-loaded] getCompletionCallback is deprecated: it introduces race conditions: " +
<span id="line30736" class="line"></span>                        "use async event handlers instead, execution order is deducted by addHandler(...) priority argument.");
<span id="line30737" class="line"></span>                    return getCompletionCallback();
<span id="line30738" class="line"></span>                },
<span id="line30739" class="line"></span>            }).catch(() =&gt; {
<span id="line30740" class="line"></span>                $.console.error("[tile-loaded] event finished with failure: there might be a problem with a plugin you are using.");
<span id="line30741" class="line"></span>            }).then(fallbackCompletion);
<span id="line30742" class="line"></span>        }
<span id="line30743" class="line"></span>
<span id="line30744" class="line"></span>
<span id="line30745" class="line"></span>        if (tileCacheCreated) {
<span id="line30746" class="line"></span>            // setting invalidation tstamp to 1 makes sure any update gets applied later on
<span id="line30747" class="line"></span>            this.viewer.world.requestTileInvalidateEvent([tile], undefined, false, true, true).then(markTileAsReady).catch(markTileAsReady);
<span id="line30748" class="line"></span>        } else {
<span id="line30749" class="line"></span>            const origCache = tile.getCache(tile.originalCacheKey);
<span id="line30750" class="line"></span>            // First, ensure we really are ready to draw the tile
<span id="line30751" class="line"></span>            const ensureValidDrawerType = (cache) =&gt; {
<span id="line30752" class="line"></span>                if (this.viewer.isDestroyed()) {
<span id="line30753" class="line"></span>                    return $.Promise.resolve();
<span id="line30754" class="line"></span>                }
<span id="line30755" class="line"></span>                const drawer = this.getDrawer();
<span id="line30756" class="line"></span>                if (!cache.isUsableForDrawer(drawer)) {
<span id="line30757" class="line"></span>                    return cache.prepareForRendering(drawer);
<span id="line30758" class="line"></span>                }
<span id="line30759" class="line"></span>                return $.Promise.resolve();
<span id="line30760" class="line"></span>            };
<span id="line30761" class="line"></span>
<span id="line30762" class="line"></span>            // Tile-invalidated not called on each tile, but only on tiles with new data! Verify we share the main cache
<span id="line30763" class="line"></span>            for (const t of origCache._tiles) {
<span id="line30764" class="line"></span>
<span id="line30765" class="line"></span>                // To keep consistent, if we find main cache tile that differs from original cache key, we inherit also main cache
<span id="line30766" class="line"></span>                if (t.cacheKey !== tile.cacheKey) {
<span id="line30767" class="line"></span>
<span id="line30768" class="line"></span>                    // add reference also to the main cache, no matter what the other tile state has
<span id="line30769" class="line"></span>                    // completion of the invaldate event should take care of all such tiles
<span id="line30770" class="line"></span>                    const targetMainCache = t.getCache();
<span id="line30771" class="line"></span>                    ensureValidDrawerType(targetMainCache).then(
<span id="line30772" class="line"></span>                        () =&gt; tile.setCache(t.cacheKey, targetMainCache, true, false)
<span id="line30773" class="line"></span>                    ).then(markTileAsReady);
<span id="line30774" class="line"></span>                    return;
<span id="line30775" class="line"></span>                }
<span id="line30776" class="line"></span>
<span id="line30777" class="line"></span>                if (t.processing) {
<span id="line30778" class="line"></span>                    // Or, if there is a processing promise, we wait for it to complete and then update the tile state.
<span id="line30779" class="line"></span>                    t.processingPromise.then(t =&gt; {
<span id="line30780" class="line"></span>                        const targetMainCache = t.getCache();
<span id="line30781" class="line"></span>                        ensureValidDrawerType(targetMainCache).then(() =&gt; {
<span id="line30782" class="line"></span>                            tile.setCache(t.cacheKey, targetMainCache, true, false);
<span id="line30783" class="line"></span>                            if (!targetMainCache.loaded) {
<span id="line30784" class="line"></span>                                return targetMainCache.await();
<span id="line30785" class="line"></span>                            }
<span id="line30786" class="line"></span>                            return null;
<span id="line30787" class="line"></span>                        }).then(markTileAsReady);
<span id="line30788" class="line"></span>                    });
<span id="line30789" class="line"></span>                    return;
<span id="line30790" class="line"></span>                }
<span id="line30791" class="line"></span>            }
<span id="line30792" class="line"></span>            ensureValidDrawerType(origCache).then(markTileAsReady);
<span id="line30793" class="line"></span>        }
<span id="line30794" class="line"></span>    },
<span id="line30795" class="line"></span>
<span id="line30796" class="line"></span>
<span id="line30797" class="line"></span>    /**
<span id="line30798" class="line"></span>     * Determines the 'best tiles' from the given 'last best' tiles and the
<span id="line30799" class="line"></span>     * tile in question. Keeps the best tiles sorted according to visibility and distance.
<span id="line30800" class="line"></span>     * @private
<span id="line30801" class="line"></span>     *
<span id="line30802" class="line"></span>     * @param {OpenSeadragon.Tile[]} previousBest The best tiles so far. Must be sorted. If not,
<span id="line30803" class="line"></span>     *    call previousBest.sort(this._sortTilesComparator) first.
<span id="line30804" class="line"></span>     * @param {OpenSeadragon.Tile} tile The new tile to consider.
<span id="line30805" class="line"></span>     * @param {Number} maxNTiles The max number of best tiles.
<span id="line30806" class="line"></span>     * @returns {OpenSeadragon.Tile[]} The new best tiles.
<span id="line30807" class="line"></span>     */
<span id="line30808" class="line"></span>    _compareTiles: function( previousBest, tile, maxNTiles ) {
<span id="line30809" class="line"></span>        if ( !previousBest ) {
<span id="line30810" class="line"></span>            return [tile];
<span id="line30811" class="line"></span>        }
<span id="line30812" class="line"></span>
<span id="line30813" class="line"></span>        let inserted = false;
<span id="line30814" class="line"></span>        for (let tileIndex = 0; tileIndex &lt; previousBest.length; tileIndex++) {
<span id="line30815" class="line"></span>            const nextTile = previousBest[tileIndex];
<span id="line30816" class="line"></span>            if (this._sortTilesComparator(nextTile, tile) &gt; 0) {
<span id="line30817" class="line"></span>                previousBest.splice(tileIndex, 0, tile);
<span id="line30818" class="line"></span>                inserted = true;
<span id="line30819" class="line"></span>                break;
<span id="line30820" class="line"></span>            }
<span id="line30821" class="line"></span>        }
<span id="line30822" class="line"></span>
<span id="line30823" class="line"></span>        if (!inserted) {
<span id="line30824" class="line"></span>            previousBest.push(tile);
<span id="line30825" class="line"></span>        }
<span id="line30826" class="line"></span>
<span id="line30827" class="line"></span>        if (previousBest.length &gt; maxNTiles) {
<span id="line30828" class="line"></span>            previousBest.pop();
<span id="line30829" class="line"></span>        }
<span id="line30830" class="line"></span>        return previousBest;
<span id="line30831" class="line"></span>    },
<span id="line30832" class="line"></span>
<span id="line30833" class="line"></span>    /**
<span id="line30834" class="line"></span>     * Comparator for tile sorting according to visibility and distance.
<span id="line30835" class="line"></span>     * @private
<span id="line30836" class="line"></span>     *
<span id="line30837" class="line"></span>     * @param {OpenSeadragon.Tile} a The tile a.
<span id="line30838" class="line"></span>     * @param {OpenSeadragon.Tile} b The tile b.
<span id="line30839" class="line"></span>     */
<span id="line30840" class="line"></span>    _sortTilesComparator: function(a, b) {
<span id="line30841" class="line"></span>        if (a === null) {
<span id="line30842" class="line"></span>            return 1;
<span id="line30843" class="line"></span>        }
<span id="line30844" class="line"></span>        if (b === null) {
<span id="line30845" class="line"></span>            return -1;
<span id="line30846" class="line"></span>        }
<span id="line30847" class="line"></span>        if (a.visibility === b.visibility) {
<span id="line30848" class="line"></span>            // sort by smallest squared distance
<span id="line30849" class="line"></span>            return a.squaredDistance - b.squaredDistance;
<span id="line30850" class="line"></span>        }
<span id="line30851" class="line"></span>        // sort by largest visibility value
<span id="line30852" class="line"></span>        return b.visibility - a.visibility;
<span id="line30853" class="line"></span>    },
<span id="line30854" class="line"></span>
<span id="line30855" class="line"></span>    /**
<span id="line30856" class="line"></span>     * To avoid repeatedly creating arrays for each frame, we cache them.
<span id="line30857" class="line"></span>     * @param {any} key
<span id="line30858" class="line"></span>     * @param {Number} [length=undefined]
<span id="line30859" class="line"></span>     * @private
<span id="line30860" class="line"></span>     */
<span id="line30861" class="line"></span>    _getCachedArray: function(key, length = undefined) {
<span id="line30862" class="line"></span>        let arr = this._arrayCacheMap[key];
<span id="line30863" class="line"></span>        if (!arr) {
<span id="line30864" class="line"></span>            if (length !== undefined) {
<span id="line30865" class="line"></span>                arr = this._arrayCacheMap[key] = new Array(length);
<span id="line30866" class="line"></span>            } else {
<span id="line30867" class="line"></span>                arr = this._arrayCacheMap[key] = [];
<span id="line30868" class="line"></span>            }
<span id="line30869" class="line"></span>        } else if (length !== undefined) {
<span id="line30870" class="line"></span>            arr.length = length;
<span id="line30871" class="line"></span>        }
<span id="line30872" class="line"></span>        return arr;
<span id="line30873" class="line"></span>    },
<span id="line30874" class="line"></span>
<span id="line30875" class="line"></span>    /**
<span id="line30876" class="line"></span>     * Returns true if the given tile provides coverage to lower-level tiles of
<span id="line30877" class="line"></span>     * lower resolution representing the same content. If neither x nor y is
<span id="line30878" class="line"></span>     * given, returns true if the entire visible level provides coverage.
<span id="line30879" class="line"></span>     *
<span id="line30880" class="line"></span>     * Note that out-of-bounds tiles provide coverage in this sense, since
<span id="line30881" class="line"></span>     * there's no content that they would need to cover. Tiles at non-existent
<span id="line30882" class="line"></span>     * levels that are within the image bounds, however, do not.
<span id="line30883" class="line"></span>     * @private
<span id="line30884" class="line"></span>     *
<span id="line30885" class="line"></span>     * @param {Object} coverage - A '3d' dictionary [level][x][y] --&gt; Boolean.
<span id="line30886" class="line"></span>     * @param {Number} level - The resolution level of the tile.
<span id="line30887" class="line"></span>     * @param {Number} x - The X position of the tile.
<span id="line30888" class="line"></span>     * @param {Number} y - The Y position of the tile.
<span id="line30889" class="line"></span>     * @returns {Boolean}
<span id="line30890" class="line"></span>     */
<span id="line30891" class="line"></span>    _providesCoverage: function( coverage, level, x, y ) {
<span id="line30892" class="line"></span>        let rows;
<span id="line30893" class="line"></span>        let cols;
<span id="line30894" class="line"></span>        let i, j;
<span id="line30895" class="line"></span>
<span id="line30896" class="line"></span>        if ( !coverage[ level ] ) {
<span id="line30897" class="line"></span>            return false;
<span id="line30898" class="line"></span>        }
<span id="line30899" class="line"></span>
<span id="line30900" class="line"></span>        if ( x === undefined || y === undefined ) {
<span id="line30901" class="line"></span>            rows = coverage[ level ];
<span id="line30902" class="line"></span>            for ( i in rows ) {
<span id="line30903" class="line"></span>                if ( Object.prototype.hasOwnProperty.call( rows, i ) ) {
<span id="line30904" class="line"></span>                    cols = rows[ i ];
<span id="line30905" class="line"></span>                    for ( j in cols ) {
<span id="line30906" class="line"></span>                        if ( Object.prototype.hasOwnProperty.call( cols, j ) &amp;&amp; !cols[ j ] ) {
<span id="line30907" class="line"></span>                            return false;
<span id="line30908" class="line"></span>                        }
<span id="line30909" class="line"></span>                    }
<span id="line30910" class="line"></span>                }
<span id="line30911" class="line"></span>            }
<span id="line30912" class="line"></span>
<span id="line30913" class="line"></span>            return true;
<span id="line30914" class="line"></span>        }
<span id="line30915" class="line"></span>
<span id="line30916" class="line"></span>        return (
<span id="line30917" class="line"></span>            coverage[ level ][ x] === undefined ||
<span id="line30918" class="line"></span>            coverage[ level ][ x ][ y ] === undefined ||
<span id="line30919" class="line"></span>            coverage[ level ][ x ][ y ] === true
<span id="line30920" class="line"></span>        );
<span id="line30921" class="line"></span>    },
<span id="line30922" class="line"></span>
<span id="line30923" class="line"></span>    /**
<span id="line30924" class="line"></span>     * Returns true if the given tile is completely covered by higher-level
<span id="line30925" class="line"></span>     * tiles of higher resolution representing the same content. If neither x
<span id="line30926" class="line"></span>     * nor y is given, returns true if the entire visible level is covered.
<span id="line30927" class="line"></span>     * @private
<span id="line30928" class="line"></span>     *
<span id="line30929" class="line"></span>     * @param {Object} coverage - A '3d' dictionary [level][x][y] --&gt; Boolean.
<span id="line30930" class="line"></span>     * @param {Number} level - The resolution level of the tile.
<span id="line30931" class="line"></span>     * @param {Number} x - The X position of the tile.
<span id="line30932" class="line"></span>     * @param {Number} y - The Y position of the tile.
<span id="line30933" class="line"></span>     * @returns {Boolean}
<span id="line30934" class="line"></span>     */
<span id="line30935" class="line"></span>    _isCovered: function( coverage, level, x, y ) {
<span id="line30936" class="line"></span>        if ( x === undefined || y === undefined ) {
<span id="line30937" class="line"></span>            return this._providesCoverage( coverage, level + 1 );
<span id="line30938" class="line"></span>        } else {
<span id="line30939" class="line"></span>            return (
<span id="line30940" class="line"></span>                this._providesCoverage( coverage, level + 1, 2 * x, 2 * y ) &amp;&amp;
<span id="line30941" class="line"></span>                this._providesCoverage( coverage, level + 1, 2 * x, 2 * y + 1 ) &amp;&amp;
<span id="line30942" class="line"></span>                this._providesCoverage( coverage, level + 1, 2 * x + 1, 2 * y ) &amp;&amp;
<span id="line30943" class="line"></span>                this._providesCoverage( coverage, level + 1, 2 * x + 1, 2 * y + 1 )
<span id="line30944" class="line"></span>            );
<span id="line30945" class="line"></span>        }
<span id="line30946" class="line"></span>    },
<span id="line30947" class="line"></span>
<span id="line30948" class="line"></span>    /**
<span id="line30949" class="line"></span>     * Sets whether the given tile provides coverage or not.
<span id="line30950" class="line"></span>     * @private
<span id="line30951" class="line"></span>     *
<span id="line30952" class="line"></span>     * @param {Object} coverage - A '3d' dictionary [level][x][y] --&gt; Boolean.
<span id="line30953" class="line"></span>     * @param {Number} level - The resolution level of the tile.
<span id="line30954" class="line"></span>     * @param {Number} x - The X position of the tile.
<span id="line30955" class="line"></span>     * @param {Number} y - The Y position of the tile.
<span id="line30956" class="line"></span>     * @param {Boolean} covers - Whether the tile provides coverage.
<span id="line30957" class="line"></span>     */
<span id="line30958" class="line"></span>    _setCoverage: function( coverage, level, x, y, covers ) {
<span id="line30959" class="line"></span>        if ( !coverage[ level ] ) {
<span id="line30960" class="line"></span>            $.console.warn(
<span id="line30961" class="line"></span>                "Setting coverage for a tile before its level's coverage has been reset: %s",
<span id="line30962" class="line"></span>                level
<span id="line30963" class="line"></span>            );
<span id="line30964" class="line"></span>            return;
<span id="line30965" class="line"></span>        }
<span id="line30966" class="line"></span>
<span id="line30967" class="line"></span>        if ( !coverage[ level ][ x ] ) {
<span id="line30968" class="line"></span>            coverage[ level ][ x ] = {};
<span id="line30969" class="line"></span>        }
<span id="line30970" class="line"></span>
<span id="line30971" class="line"></span>        coverage[ level ][ x ][ y ] = covers;
<span id="line30972" class="line"></span>    },
<span id="line30973" class="line"></span>
<span id="line30974" class="line"></span>    /**
<span id="line30975" class="line"></span>     * Resets coverage information for the given level. This should be called
<span id="line30976" class="line"></span>     * after every draw routine. Note that at the beginning of the next draw
<span id="line30977" class="line"></span>     * routine, coverage for every visible tile should be explicitly set.
<span id="line30978" class="line"></span>     * @private
<span id="line30979" class="line"></span>     *
<span id="line30980" class="line"></span>     * @param {Object} coverage - A '3d' dictionary [level][x][y] --&gt; Boolean.
<span id="line30981" class="line"></span>     * @param {Number} level - The resolution level of tiles to completely reset.
<span id="line30982" class="line"></span>     */
<span id="line30983" class="line"></span>    _resetCoverage: function( coverage, level ) {
<span id="line30984" class="line"></span>        coverage[ level ] = {};
<span id="line30985" class="line"></span>    }
<span id="line30986" class="line"></span>});
<span id="line30987" class="line"></span>
<span id="line30988" class="line"></span>
<span id="line30989" class="line"></span>
<span id="line30990" class="line"></span>}( OpenSeadragon ));
<span id="line30991" class="line"></span>
<span id="line30992" class="line"></span>/*
<span id="line30993" class="line"></span> * OpenSeadragon - TileCache
<span id="line30994" class="line"></span> *
<span id="line30995" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line30996" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line30997" class="line"></span> *
<span id="line30998" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line30999" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line31000" class="line"></span> * met:
<span id="line31001" class="line"></span> *
<span id="line31002" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line31003" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line31004" class="line"></span> *
<span id="line31005" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line31006" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line31007" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line31008" class="line"></span> *
<span id="line31009" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line31010" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line31011" class="line"></span> *   this software without specific prior written permission.
<span id="line31012" class="line"></span> *
<span id="line31013" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line31014" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line31015" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line31016" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line31017" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line31018" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line31019" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line31020" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line31021" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line31022" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line31023" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line31024" class="line"></span> */
<span id="line31025" class="line"></span>
<span id="line31026" class="line"></span>(function( $ ){
<span id="line31027" class="line"></span>
<span id="line31028" class="line"></span>    const OpenSeadragon = $; // alias for JSDoc
<span id="line31029" class="line"></span>
<span id="line31030" class="line"></span>    const DRAWER_INTERNAL_CACHE = Symbol("DRAWER_INTERNAL_CACHE");
<span id="line31031" class="line"></span>
<span id="line31032" class="line"></span>    /**
<span id="line31033" class="line"></span>     * @class OpenSeadragon.CacheRecord
<span id="line31034" class="line"></span>     * @memberof OpenSeadragon
<span id="line31035" class="line"></span>     * @classdesc Cached Data Record, the cache object. Keeps only latest object type required.
<span id="line31036" class="line"></span>     *
<span id="line31037" class="line"></span>     * This class acts like the Maybe type:
<span id="line31038" class="line"></span>     *  - it has 'loaded' flag indicating whether the tile data is ready
<span id="line31039" class="line"></span>     *  - it has 'data' property that has value if loaded=true
<span id="line31040" class="line"></span>     *
<span id="line31041" class="line"></span>     * Furthermore, it has a 'getData' function that returns a promise resolving
<span id="line31042" class="line"></span>     * with the value on the desired type passed to the function.
<span id="line31043" class="line"></span>     */
<span id="line31044" class="line"></span>    OpenSeadragon.CacheRecord = class CacheRecord {
<span id="line31045" class="line"></span>        constructor() {
<span id="line31046" class="line"></span>            this.revive();
<span id="line31047" class="line"></span>        }
<span id="line31048" class="line"></span>
<span id="line31049" class="line"></span>        /**
<span id="line31050" class="line"></span>         * Access the cache record data directly. Preferred way of data access.
<span id="line31051" class="line"></span>         * Might be undefined if this.loaded = false.
<span id="line31052" class="line"></span>         * You can access the data in synchronous way, but the data might not be available.
<span id="line31053" class="line"></span>         * If you want to access the data indirectly (await), use this.transformTo or this.getDataAs
<span id="line31054" class="line"></span>         * @returns {any}
<span id="line31055" class="line"></span>         */
<span id="line31056" class="line"></span>        get data() {
<span id="line31057" class="line"></span>            return this._data;
<span id="line31058" class="line"></span>        }
<span id="line31059" class="line"></span>
<span id="line31060" class="line"></span>        /**
<span id="line31061" class="line"></span>         * Read the cache type. The type can dynamically change, but should be consistent at
<span id="line31062" class="line"></span>         * one point in the time. For available types see the OpenSeadragon.Converter, or the tutorials.
<span id="line31063" class="line"></span>         * @returns {string}
<span id="line31064" class="line"></span>         */
<span id="line31065" class="line"></span>        get type() {
<span id="line31066" class="line"></span>            return this._type;
<span id="line31067" class="line"></span>        }
<span id="line31068" class="line"></span>
<span id="line31069" class="line"></span>        /**
<span id="line31070" class="line"></span>         * Await ongoing process so that we get cache ready on callback.
<span id="line31071" class="line"></span>         * @returns {OpenSeadragon.Promise&lt;?&gt;}
<span id="line31072" class="line"></span>         */
<span id="line31073" class="line"></span>        await() {
<span id="line31074" class="line"></span>            if (!this._promise) { //if not cache loaded, do not fail
<span id="line31075" class="line"></span>                return $.Promise.resolve(this._data);
<span id="line31076" class="line"></span>            }
<span id="line31077" class="line"></span>            return this._promise;
<span id="line31078" class="line"></span>        }
<span id="line31079" class="line"></span>
<span id="line31080" class="line"></span>        getImage() {
<span id="line31081" class="line"></span>            $.console.error("[CacheRecord.getImage] options.image is deprecated. Moreover, it might not work" +
<span id="line31082" class="line"></span>                " correctly as the cache system performs conversion asynchronously in case the type needs to be converted.");
<span id="line31083" class="line"></span>            this.transformTo("image");
<span id="line31084" class="line"></span>            return this.data;
<span id="line31085" class="line"></span>        }
<span id="line31086" class="line"></span>
<span id="line31087" class="line"></span>        getRenderedContext() {
<span id="line31088" class="line"></span>            $.console.error("[CacheRecord.getRenderedContext] options.getRenderedContext  is deprecated. Moreover, it might not work" +
<span id="line31089" class="line"></span>                " correctly as the cache system performs conversion asynchronously in case the type needs to be converted.");
<span id="line31090" class="line"></span>            this.transformTo("context2d");
<span id="line31091" class="line"></span>            return this.data;
<span id="line31092" class="line"></span>        }
<span id="line31093" class="line"></span>
<span id="line31094" class="line"></span>        /**
<span id="line31095" class="line"></span>         * Set the cache data. Asynchronous.
<span id="line31096" class="line"></span>         * @param {any} data
<span id="line31097" class="line"></span>         * @param {string} type
<span id="line31098" class="line"></span>         * @returns {OpenSeadragon.Promise&lt;?&gt;} the old cache data that has been overwritten
<span id="line31099" class="line"></span>         */
<span id="line31100" class="line"></span>        setDataAs(data, type) {
<span id="line31101" class="line"></span>            //allow set data with destroyed state, destroys the data if necessary
<span id="line31102" class="line"></span>            $.console.assert(data !== undefined &amp;&amp; data !== null, "[CacheRecord.setDataAs] needs valid data to set!");
<span id="line31103" class="line"></span>            if (this._conversionJobQueue) {
<span id="line31104" class="line"></span>                //delay saving if ongiong conversion, these were registered first
<span id="line31105" class="line"></span>                let resolver = null;
<span id="line31106" class="line"></span>                const promise = new $.Promise((resolve, reject) =&gt; {
<span id="line31107" class="line"></span>                    resolver = resolve;
<span id="line31108" class="line"></span>                });
<span id="line31109" class="line"></span>                this._conversionJobQueue.push(() =&gt; resolver(this._overwriteData(data, type)));
<span id="line31110" class="line"></span>                return promise;
<span id="line31111" class="line"></span>            }
<span id="line31112" class="line"></span>            return this._overwriteData(data, type);
<span id="line31113" class="line"></span>        }
<span id="line31114" class="line"></span>
<span id="line31115" class="line"></span>        /**
<span id="line31116" class="line"></span>         * Access the cache record data indirectly. Preferred way of data access. Asynchronous.
<span id="line31117" class="line"></span>         * @param {string} [type=undefined]
<span id="line31118" class="line"></span>         * @param {boolean} [copy=true] if false and same type is retrieved as the cache type,
<span id="line31119" class="line"></span>         *  copy is not performed: note that this is potentially dangerous as it might
<span id="line31120" class="line"></span>         *  introduce race conditions (you get a cache data direct reference you modify).
<span id="line31121" class="line"></span>         * @returns {OpenSeadragon.Promise&lt;?&gt;} desired data type in promise, undefined if the cache was destroyed
<span id="line31122" class="line"></span>         */
<span id="line31123" class="line"></span>        getDataAs(type = undefined, copy = true) {
<span id="line31124" class="line"></span>            if (this.loaded) {
<span id="line31125" class="line"></span>                if (type === this._type) {
<span id="line31126" class="line"></span>                    return copy ? $.converter.copy(this._tRef, this._data, type || this._type) : this._promise;
<span id="line31127" class="line"></span>                }
<span id="line31128" class="line"></span>                return this._transformDataIfNeeded(this._tRef, this._data, type || this._type, copy) || this._promise;
<span id="line31129" class="line"></span>            }
<span id="line31130" class="line"></span>            return this._promise.then(data =&gt; this._transformDataIfNeeded(this._tRef, data, type || this._type, copy) || data);
<span id="line31131" class="line"></span>        }
<span id="line31132" class="line"></span>
<span id="line31133" class="line"></span>        _transformDataIfNeeded(referenceTile, data, type, copy) {
<span id="line31134" class="line"></span>            //might get destroyed in meanwhile
<span id="line31135" class="line"></span>            if (this._destroyed) {
<span id="line31136" class="line"></span>                return $.Promise.resolve();
<span id="line31137" class="line"></span>            }
<span id="line31138" class="line"></span>
<span id="line31139" class="line"></span>            let result;
<span id="line31140" class="line"></span>            if (type !== this._type) {
<span id="line31141" class="line"></span>                result = $.converter.convert(referenceTile, data, this._type, type);
<span id="line31142" class="line"></span>            } else if (copy) { //convert does not copy data if same type, do explicitly
<span id="line31143" class="line"></span>                result = $.converter.copy(referenceTile, data, type);
<span id="line31144" class="line"></span>            }
<span id="line31145" class="line"></span>            if (result) {
<span id="line31146" class="line"></span>                return result.then(finalData =&gt; {
<span id="line31147" class="line"></span>                    if (this._destroyed) {
<span id="line31148" class="line"></span>                        $.converter.destroy(finalData, type);
<span id="line31149" class="line"></span>                        return undefined;
<span id="line31150" class="line"></span>                    }
<span id="line31151" class="line"></span>                    return finalData;
<span id="line31152" class="line"></span>                }).catch(e =&gt; {
<span id="line31153" class="line"></span>                    this._handleConversionError(e);
<span id="line31154" class="line"></span>                    return undefined;
<span id="line31155" class="line"></span>                });
<span id="line31156" class="line"></span>            }
<span id="line31157" class="line"></span>            return false; // no conversion needed, parent function returns item as-is
<span id="line31158" class="line"></span>        }
<span id="line31159" class="line"></span>
<span id="line31160" class="line"></span>        /**
<span id="line31161" class="line"></span>         * Access of the data by drawers, synchronous function. Should always access a valid main cache.
<span id="line31162" class="line"></span>         * This is ensured by invalidation routine that executes data modification on a copy record, and
<span id="line31163" class="line"></span>         * then synchronously swaps records (main caches) to the new data between render calls.
<span id="line31164" class="line"></span>         *
<span id="line31165" class="line"></span>         * If a drawer decides to have internal cache with synchronous behavior, it is (if necessary)
<span id="line31166" class="line"></span>         * performed during this phase.
<span id="line31167" class="line"></span>         *
<span id="line31168" class="line"></span>         * @param {OpenSeadragon.DrawerBase} drawer drawer reference which requests the data: the drawer
<span id="line31169" class="line"></span>         *   defines the supported formats this cache should return **synchronously**
<span id="line31170" class="line"></span>         * @param {OpenSeadragon.Tile} tileToDraw reference to the tile that is in the process of drawing and
<span id="line31171" class="line"></span>         *   for which we request the data; if we attempt to draw such tile while main cache target is destroyed,
<span id="line31172" class="line"></span>         *   attempt to reset the tile state to force system to re-download it again
<span id="line31173" class="line"></span>         * @returns {OpenSeadragon.CacheRecord|OpenSeadragon.InternalCacheRecord|undefined} desired data if available,
<span id="line31174" class="line"></span>         *   wrapped in the cache container. This data is guaranteed to be loaded &amp; in the type supported by the drawer.
<span id="line31175" class="line"></span>         *   Returns undefined if the data is not ready for rendering.
<span id="line31176" class="line"></span>         * @private
<span id="line31177" class="line"></span>         */
<span id="line31178" class="line"></span>        getDataForRendering(drawer, tileToDraw) {
<span id="line31179" class="line"></span>            // Test cache state
<span id="line31180" class="line"></span>            if (this._destroyed) {
<span id="line31181" class="line"></span>                $.console.error(`Attempt to draw tile with destroyed main cache ${this}!`);
<span id="line31182" class="line"></span>                tileToDraw._unload();
<span id="line31183" class="line"></span>                return undefined;
<span id="line31184" class="line"></span>            }
<span id="line31185" class="line"></span>            if (!this.loaded) {
<span id="line31186" class="line"></span>                // If a conversion/load is in progress, it is normal that the cache is temporarily not loaded.
<span id="line31187" class="line"></span>                // Avoid spamming errors; just skip drawing this tile this frame.
<span id="line31188" class="line"></span>                if (this._promise) {
<span id="line31189" class="line"></span>                    return undefined;
<span id="line31190" class="line"></span>                }
<span id="line31191" class="line"></span>                $.console.error(`Attempt to draw cache ${this} when not loaded!`);
<span id="line31192" class="line"></span>                return undefined;
<span id="line31193" class="line"></span>            }
<span id="line31194" class="line"></span>            if (this._destroyed) {
<span id="line31195" class="line"></span>                $.console.error(`Attempt to draw tile with destroyed main cache ${this}!`);
<span id="line31196" class="line"></span>                tileToDraw._unload();  // try to restore the state so that the tile is later on fetched again
<span id="line31197" class="line"></span>                return undefined;
<span id="line31198" class="line"></span>            }
<span id="line31199" class="line"></span>
<span id="line31200" class="line"></span>            // Ensure cache in a format suitable for the current drawer. If not it is an error, prepareForRendering
<span id="line31201" class="line"></span>            // should be called at the end of invalidation routine instead. Since the processing is async, we are
<span id="line31202" class="line"></span>            // unable to provide the rendering data immediatelly - return.
<span id="line31203" class="line"></span>            const supportedTypes = drawer.getSupportedDataFormats();
<span id="line31204" class="line"></span>            if (!supportedTypes.includes(this.type)) {
<span id="line31205" class="line"></span>                $.console.error(`Attempt to draw tile cache ${this} with unsupported type '${this.type}' for the target drawer!`);
<span id="line31206" class="line"></span>                this.prepareForRendering(drawer);
<span id="line31207" class="line"></span>                return undefined;
<span id="line31208" class="line"></span>            }
<span id="line31209" class="line"></span>
<span id="line31210" class="line"></span>            // If we support internal cache
<span id="line31211" class="line"></span>            if (drawer.options.usePrivateCache) {
<span id="line31212" class="line"></span>                // let sync preparation handle data if no preloading desired
<span id="line31213" class="line"></span>                if (!drawer.options.preloadCache) {
<span id="line31214" class="line"></span>                    return this.prepareInternalCacheSync(drawer);
<span id="line31215" class="line"></span>                }
<span id="line31216" class="line"></span>                // or check internal cache state before returning
<span id="line31217" class="line"></span>                const internalCache = this._getInternalCacheRef(drawer);
<span id="line31218" class="line"></span>                if (!internalCache || !internalCache.loaded) {
<span id="line31219" class="line"></span>                    $.console.error(`Attempt to draw tile cache ${this} with internal cache non-ready state!`);
<span id="line31220" class="line"></span>                    return undefined;
<span id="line31221" class="line"></span>                }
<span id="line31222" class="line"></span>                return internalCache;
<span id="line31223" class="line"></span>            }
<span id="line31224" class="line"></span>
<span id="line31225" class="line"></span>            // else just return self reference
<span id="line31226" class="line"></span>            return this;
<span id="line31227" class="line"></span>        }
<span id="line31228" class="line"></span>
<span id="line31229" class="line"></span>        /**
<span id="line31230" class="line"></span>         * Check whether the cache is usable for the given drawer. The cache is considered
<span id="line31231" class="line"></span>         * usable if it is in a format supported by the drawer and, if the drawer uses internal cache,
<span id="line31232" class="line"></span>         * the internal cache was created (it might not be loaded yet though).
<span id="line31233" class="line"></span>         * @param {OpenSeadragon.DrawerBase} drawer
<span id="line31234" class="line"></span>         * @return {boolean}
<span id="line31235" class="line"></span>         */
<span id="line31236" class="line"></span>        isUsableForDrawer(drawer) {
<span id="line31237" class="line"></span>            const supportedTypes = drawer.getSupportedDataFormats();
<span id="line31238" class="line"></span>            if (!supportedTypes.includes(this.type)) {
<span id="line31239" class="line"></span>                return false;
<span id="line31240" class="line"></span>            }
<span id="line31241" class="line"></span>            if (drawer.options.usePrivateCache) {
<span id="line31242" class="line"></span>                const internalCache = this._getInternalCacheRef(drawer);
<span id="line31243" class="line"></span>                if (!internalCache) {
<span id="line31244" class="line"></span>                    return false;
<span id="line31245" class="line"></span>                }
<span id="line31246" class="line"></span>            }
<span id="line31247" class="line"></span>            return true;
<span id="line31248" class="line"></span>        }
<span id="line31249" class="line"></span>
<span id="line31250" class="line"></span>        /**
<span id="line31251" class="line"></span>         * Preparation for rendering ensures the CacheRecord is in a format supported by the current
<span id="line31252" class="line"></span>         * drawer. Furthermore, if internal cache is to be used by a drawer with preloading enabled,
<span id="line31253" class="line"></span>         * it happens in this step.
<span id="line31254" class="line"></span>         *
<span id="line31255" class="line"></span>         * Note: Should not be called if cache type is already among supported types.
<span id="line31256" class="line"></span>         * @private
<span id="line31257" class="line"></span>         * @param {OpenSeadragon.DrawerBase} drawer
<span id="line31258" class="line"></span>         * @return {OpenSeadragon.Promise&lt;*&gt;} reference to the data,
<span id="line31259" class="line"></span>         *  or null if not data yet loaded/ready (usually due to error)
<span id="line31260" class="line"></span>         */
<span id="line31261" class="line"></span>        prepareForRendering(drawer) {
<span id="line31262" class="line"></span>            const supportedTypes = drawer.getRequiredDataFormats();
<span id="line31263" class="line"></span>
<span id="line31264" class="line"></span>            // If not loaded, await until ready and try again
<span id="line31265" class="line"></span>            if (!this.loaded) {
<span id="line31266" class="line"></span>                return this.await().then(_ =&gt; this.prepareForRendering(drawer));
<span id="line31267" class="line"></span>            }
<span id="line31268" class="line"></span>
<span id="line31269" class="line"></span>            let selfPromise;
<span id="line31270" class="line"></span>            // If not in one of required types, transform
<span id="line31271" class="line"></span>            if (!supportedTypes.includes(this.type)) {
<span id="line31272" class="line"></span>                selfPromise = this.transformTo(supportedTypes);
<span id="line31273" class="line"></span>            } else {
<span id="line31274" class="line"></span>                selfPromise = this.await();
<span id="line31275" class="line"></span>            }
<span id="line31276" class="line"></span>
<span id="line31277" class="line"></span>            const swallow = (p) =&gt; p.catch(e =&gt; {
<span id="line31278" class="line"></span>                this._handleConversionError(e);
<span id="line31279" class="line"></span>                return null;
<span id="line31280" class="line"></span>            });
<span id="line31281" class="line"></span>
<span id="line31282" class="line"></span>            // If internal cache wanted and preloading enabled, convert now
<span id="line31283" class="line"></span>            if (drawer.options.usePrivateCache &amp;&amp; drawer.options.preloadCache) {
<span id="line31284" class="line"></span>                return swallow(selfPromise.then(_ =&gt; this.prepareInternalCacheAsync(drawer)));
<span id="line31285" class="line"></span>            }
<span id="line31286" class="line"></span>            return swallow(selfPromise);
<span id="line31287" class="line"></span>        }
<span id="line31288" class="line"></span>
<span id="line31289" class="line"></span>        /**
<span id="line31290" class="line"></span>         * Internal cache is defined by a Drawer. Async preparation happens as the last step in the
<span id="line31291" class="line"></span>         * invalidation routine.
<span id="line31292" class="line"></span>         * Must not be called if drawer.options.usePrivateCache == false. Called inside prepareForRenderine
<span id="line31293" class="line"></span>         * by cache itself if preloadCache == true (supports async behavior).
<span id="line31294" class="line"></span>         *
<span id="line31295" class="line"></span>         * @private
<span id="line31296" class="line"></span>         * @param {OpenSeadragon.DrawerBase} drawer
<span id="line31297" class="line"></span>         * @return {OpenSeadragon.Promise&lt;*&gt;} reference to the data wrapped in a promise,
<span id="line31298" class="line"></span>         *  or null if not data yet loaded/ready (usually due to error)
<span id="line31299" class="line"></span>         */
<span id="line31300" class="line"></span>        prepareInternalCacheAsync(drawer) {
<span id="line31301" class="line"></span>            let internalCache = this._getInternalCacheRef(drawer);
<span id="line31302" class="line"></span>            if (this._checkInternalCacheUpToDate(internalCache, drawer)) {
<span id="line31303" class="line"></span>                return internalCache.await();
<span id="line31304" class="line"></span>            }
<span id="line31305" class="line"></span>
<span id="line31306" class="line"></span>            // Force reset
<span id="line31307" class="line"></span>            if (internalCache &amp;&amp; !internalCache.loaded) {
<span id="line31308" class="line"></span>                internalCache.await().then(() =&gt; internalCache.destroy());
<span id="line31309" class="line"></span>            }
<span id="line31310" class="line"></span>
<span id="line31311" class="line"></span>            $.console.assert(this._tRef, "Data Create called from invalidation routine needs tile reference!");
<span id="line31312" class="line"></span>            const transformedData = drawer.internalCacheCreate(this, this._tRef);
<span id="line31313" class="line"></span>            $.console.assert(transformedData !== undefined, "[DrawerBase.internalCacheCreate] must return a value if usePrivateCache is enabled!");
<span id="line31314" class="line"></span>            const drawerID = drawer.getId();
<span id="line31315" class="line"></span>            internalCache = this[DRAWER_INTERNAL_CACHE][drawerID] = new $.InternalCacheRecord(transformedData,
<span id="line31316" class="line"></span>                drawerID, (data) =&gt; drawer.internalCacheFree(data));
<span id="line31317" class="line"></span>            return internalCache.await();
<span id="line31318" class="line"></span>        }
<span id="line31319" class="line"></span>
<span id="line31320" class="line"></span>        /**
<span id="line31321" class="line"></span>         * Internal cache is defined by a Drawer. Sync preparation happens directly before rendering.
<span id="line31322" class="line"></span>         * Must not be called if drawer.options.usePrivateCache == false. Called inside getDataForRendering
<span id="line31323" class="line"></span>         * by cache itself if preloadCache == false (without support for async behavior).
<span id="line31324" class="line"></span>         * @private
<span id="line31325" class="line"></span>         * @param {OpenSeadragon.DrawerBase} drawer
<span id="line31326" class="line"></span>         * @return {OpenSeadragon.InternalCacheRecord} reference to the cache
<span id="line31327" class="line"></span>         */
<span id="line31328" class="line"></span>        prepareInternalCacheSync(drawer) {
<span id="line31329" class="line"></span>            let internalCache = this._getInternalCacheRef(drawer);
<span id="line31330" class="line"></span>            if (this._checkInternalCacheUpToDate(internalCache, drawer)) {
<span id="line31331" class="line"></span>                return internalCache;
<span id="line31332" class="line"></span>            }
<span id="line31333" class="line"></span>
<span id="line31334" class="line"></span>            // Force reset
<span id="line31335" class="line"></span>            if (internalCache) {
<span id="line31336" class="line"></span>                internalCache.destroy();
<span id="line31337" class="line"></span>            }
<span id="line31338" class="line"></span>
<span id="line31339" class="line"></span>            $.console.assert(this._tRef, "Data Create called from drawing loop needs tile reference!");
<span id="line31340" class="line"></span>            const transformedData = drawer.internalCacheCreate(this, this._tRef);
<span id="line31341" class="line"></span>            $.console.assert(transformedData !== undefined, "[DrawerBase.internalCacheCreate] must return a value if usePrivateCache is enabled!");
<span id="line31342" class="line"></span>
<span id="line31343" class="line"></span>            const drawerID = drawer.getId();
<span id="line31344" class="line"></span>            internalCache = this[DRAWER_INTERNAL_CACHE][drawerID] = new $.InternalCacheRecord(transformedData,
<span id="line31345" class="line"></span>                drawerID, (data) =&gt; drawer.internalCacheFree(data));
<span id="line31346" class="line"></span>            return internalCache;
<span id="line31347" class="line"></span>        }
<span id="line31348" class="line"></span>
<span id="line31349" class="line"></span>        /**
<span id="line31350" class="line"></span>         * Get an internal cache reference for given drawer
<span id="line31351" class="line"></span>         * @param {OpenSeadragon.DrawerBase} drawer
<span id="line31352" class="line"></span>         * @return {OpenSeadragon.InternalCacheRecord|undefined}
<span id="line31353" class="line"></span>         * @private
<span id="line31354" class="line"></span>         */
<span id="line31355" class="line"></span>        _getInternalCacheRef(drawer) {
<span id="line31356" class="line"></span>            const options = drawer.options;
<span id="line31357" class="line"></span>            if (!options.usePrivateCache) {
<span id="line31358" class="line"></span>                $.console.error("[CacheRecord.prepareInternalCacheSync] must not be called when usePrivateCache is false.");
<span id="line31359" class="line"></span>                return undefined;
<span id="line31360" class="line"></span>            }
<span id="line31361" class="line"></span>
<span id="line31362" class="line"></span>            // we can get here only if we want to render incompatible type
<span id="line31363" class="line"></span>            let internalCache = this[DRAWER_INTERNAL_CACHE];
<span id="line31364" class="line"></span>            if (!internalCache) {
<span id="line31365" class="line"></span>                internalCache = this[DRAWER_INTERNAL_CACHE] = {};
<span id="line31366" class="line"></span>            }
<span id="line31367" class="line"></span>            return internalCache[drawer.getId()];
<span id="line31368" class="line"></span>        }
<span id="line31369" class="line"></span>
<span id="line31370" class="line"></span>        /**
<span id="line31371" class="line"></span>         * Check if internal cache is up to date. Might be in loading state.
<span id="line31372" class="line"></span>         * @param {OpenSeadragon.InternalCacheRecord} internalCache
<span id="line31373" class="line"></span>         * @param {OpenSeadragon.DrawerBase} drawer
<span id="line31374" class="line"></span>         * @return {boolean} false if the internal cache is outdated
<span id="line31375" class="line"></span>         * @private
<span id="line31376" class="line"></span>         */
<span id="line31377" class="line"></span>        _checkInternalCacheUpToDate(internalCache, drawer) {
<span id="line31378" class="line"></span>            // We respect existing records, unless they are outdated. Invalidation routine by its nature
<span id="line31379" class="line"></span>            // destroys internal cache, therefore we do not need to check if internal cache is consistent with its parent.
<span id="line31380" class="line"></span>            return internalCache &amp;&amp; internalCache.tstamp &gt;= drawer._dataNeedsRefresh;
<span id="line31381" class="line"></span>        }
<span id="line31382" class="line"></span>
<span id="line31383" class="line"></span>        /**
<span id="line31384" class="line"></span>         * Transform cache to desired type and get the data after conversion.
<span id="line31385" class="line"></span>         * Does nothing if the type equals to the current type. Asynchronous.
<span id="line31386" class="line"></span>         * Transformation is LAZY, meaning conversions are performed only to
<span id="line31387" class="line"></span>         * match the last conversion request target type.
<span id="line31388" class="line"></span>         * @param {string|string[]} type if array provided, the system will
<span id="line31389" class="line"></span>         *   try to optimize for the best type to convert to.
<span id="line31390" class="line"></span>         * @return {OpenSeadragon.Promise&lt;?&gt;}
<span id="line31391" class="line"></span>         */
<span id="line31392" class="line"></span>        transformTo(type = this._type) {
<span id="line31393" class="line"></span>            if (!this.loaded) {
<span id="line31394" class="line"></span>                this._conversionJobQueue = this._conversionJobQueue || [];
<span id="line31395" class="line"></span>                let resolver = null;
<span id="line31396" class="line"></span>                const promise = new $.Promise((resolve, reject) =&gt; {
<span id="line31397" class="line"></span>                    resolver = resolve;
<span id="line31398" class="line"></span>                });
<span id="line31399" class="line"></span>
<span id="line31400" class="line"></span>                // Todo consider submitting only single tranform job to queue: any other transform calls will have
<span id="line31401" class="line"></span>                //  no effect, the last one decides the target format
<span id="line31402" class="line"></span>                this._conversionJobQueue.push(() =&gt; {
<span id="line31403" class="line"></span>                    if (this._destroyed) {
<span id="line31404" class="line"></span>                        return;
<span id="line31405" class="line"></span>                    }
<span id="line31406" class="line"></span>                    //must re-check types since we perform in a queue of conversion requests
<span id="line31407" class="line"></span>                    if ((typeof type === "string" &amp;&amp; type !== this._type) || (Array.isArray(type) &amp;&amp; !type.includes(this._type))) {
<span id="line31408" class="line"></span>                        //ensures queue gets executed after finish
<span id="line31409" class="line"></span>                        this._convert(this._type, type);
<span id="line31410" class="line"></span>                        this._promise.then(data =&gt; resolver(data));
<span id="line31411" class="line"></span>                    } else {
<span id="line31412" class="line"></span>                        //must ensure manually, but after current promise finished, we won't wait for the following job
<span id="line31413" class="line"></span>                        this._promise.then(data =&gt; {
<span id="line31414" class="line"></span>                            this._checkAwaitsConvert();
<span id="line31415" class="line"></span>                            return resolver(data);
<span id="line31416" class="line"></span>                        });
<span id="line31417" class="line"></span>                    }
<span id="line31418" class="line"></span>                });
<span id="line31419" class="line"></span>                return promise;
<span id="line31420" class="line"></span>            }
<span id="line31421" class="line"></span>
<span id="line31422" class="line"></span>            if ((typeof type === "string" &amp;&amp; type !== this._type) || (Array.isArray(type) &amp;&amp; !type.includes(this._type))) {
<span id="line31423" class="line"></span>                this._convert(this._type, type);
<span id="line31424" class="line"></span>            }
<span id="line31425" class="line"></span>            return this._promise;
<span id="line31426" class="line"></span>        }
<span id="line31427" class="line"></span>
<span id="line31428" class="line"></span>        /**
<span id="line31429" class="line"></span>         * If cache ceases to be the primary one, free data
<span id="line31430" class="line"></span>         * @param {string} drawerId if undefined, all caches are freed, else only target one
<span id="line31431" class="line"></span>         * @private
<span id="line31432" class="line"></span>         */
<span id="line31433" class="line"></span>        destroyInternalCache(drawerId = undefined) {
<span id="line31434" class="line"></span>            const internal = this[DRAWER_INTERNAL_CACHE];
<span id="line31435" class="line"></span>            if (internal) {
<span id="line31436" class="line"></span>                if (drawerId) {
<span id="line31437" class="line"></span>                    const cache = internal[drawerId];
<span id="line31438" class="line"></span>                    if (cache) {
<span id="line31439" class="line"></span>                        cache.destroy();
<span id="line31440" class="line"></span>                        delete internal[drawerId];
<span id="line31441" class="line"></span>                    }
<span id="line31442" class="line"></span>                } else {
<span id="line31443" class="line"></span>                    for (const iCache in internal) {
<span id="line31444" class="line"></span>                        internal[iCache].destroy();
<span id="line31445" class="line"></span>                    }
<span id="line31446" class="line"></span>                    delete this[DRAWER_INTERNAL_CACHE];
<span id="line31447" class="line"></span>                }
<span id="line31448" class="line"></span>            }
<span id="line31449" class="line"></span>        }
<span id="line31450" class="line"></span>
<span id="line31451" class="line"></span>        /**
<span id="line31452" class="line"></span>         * Conversion requires tile references:
<span id="line31453" class="line"></span>         * keep the most 'up to date' ref here. It is called and managed automatically.
<span id="line31454" class="line"></span>         * @param {OpenSeadragon.Tile} ref
<span id="line31455" class="line"></span>         * @return {OpenSeadragon.CacheRecord} self reference for builder pattern
<span id="line31456" class="line"></span>         * @private
<span id="line31457" class="line"></span>         */
<span id="line31458" class="line"></span>        withTileReference(ref) {
<span id="line31459" class="line"></span>            this._tRef = ref;
<span id="line31460" class="line"></span>            return this;
<span id="line31461" class="line"></span>        }
<span id="line31462" class="line"></span>
<span id="line31463" class="line"></span>        /**
<span id="line31464" class="line"></span>         * Get cache description. Used for system messages and errors.
<span id="line31465" class="line"></span>         * @return {string}
<span id="line31466" class="line"></span>         */
<span id="line31467" class="line"></span>        toString() {
<span id="line31468" class="line"></span>            const tile = this._tRef || (this._tiles.length &amp;&amp; this._tiles[0]);
<span id="line31469" class="line"></span>            return tile ? `Cache ${this.type} [used e.g. by ${tile.toString()}]` : `Orphan cache!`;
<span id="line31470" class="line"></span>        }
<span id="line31471" class="line"></span>
<span id="line31472" class="line"></span>        /**
<span id="line31473" class="line"></span>         * Set initial state, prepare for usage.
<span id="line31474" class="line"></span>         * Must not be called on active cache, e.g. first call destroy().
<span id="line31475" class="line"></span>         */
<span id="line31476" class="line"></span>        revive() {
<span id="line31477" class="line"></span>            $.console.assert(!this.loaded &amp;&amp; !this._type, "[CacheRecord::revive] must not be called when loaded!");
<span id="line31478" class="line"></span>            this._tiles = [];
<span id="line31479" class="line"></span>            this._data = null;
<span id="line31480" class="line"></span>            this._type = null;
<span id="line31481" class="line"></span>            this.loaded = false;
<span id="line31482" class="line"></span>            this._promise = null;
<span id="line31483" class="line"></span>            this._destroyed = false;
<span id="line31484" class="line"></span>
<span id="line31485" class="line"></span>            // Optional ownership metadata (set by TileCache for managed records).
<span id="line31486" class="line"></span>            // Working caches created during invalidation are intentionally left without an owner.
<span id="line31487" class="line"></span>            this._ownerTileCache = null;
<span id="line31488" class="line"></span>            this.cacheKey = null;
<span id="line31489" class="line"></span>        }
<span id="line31490" class="line"></span>
<span id="line31491" class="line"></span>        /**
<span id="line31492" class="line"></span>         * Free all the data and call data destructors if defined.
<span id="line31493" class="line"></span>         */
<span id="line31494" class="line"></span>        destroy() {
<span id="line31495" class="line"></span>            if (!this._destroyed) {
<span id="line31496" class="line"></span>                delete this._conversionJobQueue;
<span id="line31497" class="line"></span>                this._destroyed = true;
<span id="line31498" class="line"></span>
<span id="line31499" class="line"></span>                // make sure this gets destroyed even if loaded=false
<span id="line31500" class="line"></span>                if (this.loaded) {
<span id="line31501" class="line"></span>                    this._destroySelfUnsafe(this._data, this._type);
<span id="line31502" class="line"></span>                } else if (this._promise) {
<span id="line31503" class="line"></span>                    const oldType = this._type;
<span id="line31504" class="line"></span>                    this._promise.then(x =&gt; this._destroySelfUnsafe(x, oldType)).catch($.console.error);
<span id="line31505" class="line"></span>                }
<span id="line31506" class="line"></span>            }
<span id="line31507" class="line"></span>
<span id="line31508" class="line"></span>        }
<span id="line31509" class="line"></span>
<span id="line31510" class="line"></span>        _destroySelfUnsafe(data, type) {
<span id="line31511" class="line"></span>            // ensure old data destroyed
<span id="line31512" class="line"></span>            $.converter.destroy(data, type);
<span id="line31513" class="line"></span>            this.destroyInternalCache();
<span id="line31514" class="line"></span>            // might've got revived in meanwhile if async ...
<span id="line31515" class="line"></span>            if (!this._destroyed) {
<span id="line31516" class="line"></span>                return;
<span id="line31517" class="line"></span>            }
<span id="line31518" class="line"></span>            this.loaded = false;
<span id="line31519" class="line"></span>            this._tiles = null;
<span id="line31520" class="line"></span>            this._data = null;
<span id="line31521" class="line"></span>            this._type = null;
<span id="line31522" class="line"></span>            this._tRef = null;
<span id="line31523" class="line"></span>            this._promise = null;
<span id="line31524" class="line"></span>        }
<span id="line31525" class="line"></span>
<span id="line31526" class="line"></span>        /**
<span id="line31527" class="line"></span>         * Add tile dependency on this record
<span id="line31528" class="line"></span>         * @param tile
<span id="line31529" class="line"></span>         * @param data can be null|undefined =&gt; optimization, will skip data initialization and just adds tile reference
<span id="line31530" class="line"></span>         * @param type
<span id="line31531" class="line"></span>         */
<span id="line31532" class="line"></span>        addTile(tile, data, type) {
<span id="line31533" class="line"></span>            if (this._destroyed) {
<span id="line31534" class="line"></span>                return;
<span id="line31535" class="line"></span>            }
<span id="line31536" class="line"></span>            $.console.assert(tile, '[CacheRecord.addTile] tile is required');
<span id="line31537" class="line"></span>
<span id="line31538" class="line"></span>            // first come first served, data for existing tiles is NOT overridden
<span id="line31539" class="line"></span>            if (data !== undefined &amp;&amp; data !== null &amp;&amp; this._tiles.length &lt; 1) {
<span id="line31540" class="line"></span>                // Since we IGNORE new data if already initialized, we support 'data getter'
<span id="line31541" class="line"></span>                if (typeof data === 'function') {
<span id="line31542" class="line"></span>                    data = data();
<span id="line31543" class="line"></span>                }
<span id="line31544" class="line"></span>
<span id="line31545" class="line"></span>                // in case we attempt to write to existing data object
<span id="line31546" class="line"></span>                if (this.type &amp;&amp; this._promise) {
<span id="line31547" class="line"></span>                    if (data instanceof $.Promise) {
<span id="line31548" class="line"></span>                        this._promise = data.then(d =&gt; {
<span id="line31549" class="line"></span>                            this._overwriteData(d, type);
<span id="line31550" class="line"></span>                        });
<span id="line31551" class="line"></span>                    } else {
<span id="line31552" class="line"></span>                        this._overwriteData(data, type);
<span id="line31553" class="line"></span>                    }
<span id="line31554" class="line"></span>                } else {
<span id="line31555" class="line"></span>                    // If we receive async callback, we consume the async state
<span id="line31556" class="line"></span>                    if (data instanceof $.Promise) {
<span id="line31557" class="line"></span>                        this._promise = data.then(data =&gt; {
<span id="line31558" class="line"></span>                            if (this._destroyed) {
<span id="line31559" class="line"></span>                                try {
<span id="line31560" class="line"></span>                                    $.converter.destroy(data, this._type);
<span id="line31561" class="line"></span>                                } catch (e) {
<span id="line31562" class="line"></span>                                    // no-op
<span id="line31563" class="line"></span>                                }
<span id="line31564" class="line"></span>                                return undefined;
<span id="line31565" class="line"></span>                            }
<span id="line31566" class="line"></span>                            this.loaded = true;
<span id="line31567" class="line"></span>                            this._data = data;
<span id="line31568" class="line"></span>                            return data;
<span id="line31569" class="line"></span>                        }).catch(e =&gt; {
<span id="line31570" class="line"></span>                            this._handleConversionError(e);
<span id="line31571" class="line"></span>                            return undefined;
<span id="line31572" class="line"></span>                        });
<span id="line31573" class="line"></span>                        this._data = null;
<span id="line31574" class="line"></span>                    } else {
<span id="line31575" class="line"></span>                        this._promise = $.Promise.resolve(data);
<span id="line31576" class="line"></span>                        this._data = data;
<span id="line31577" class="line"></span>                        this.loaded = true;
<span id="line31578" class="line"></span>                    }
<span id="line31579" class="line"></span>
<span id="line31580" class="line"></span>                    this._type = type;
<span id="line31581" class="line"></span>                }
<span id="line31582" class="line"></span>                this._tiles.push(tile);
<span id="line31583" class="line"></span>            } else {
<span id="line31584" class="line"></span>                const tileExists = this._tiles.includes(tile);
<span id="line31585" class="line"></span>                if (!tileExists &amp;&amp; this.type &amp;&amp; this._promise) {
<span id="line31586" class="line"></span>                    // here really check we are loaded, since if optimization allows sending no data and we add tile without
<span id="line31587" class="line"></span>                    // proper initialization it is a bug
<span id="line31588" class="line"></span>                    this._tiles.push(tile);
<span id="line31589" class="line"></span>                } else if (!tileExists) {
<span id="line31590" class="line"></span>                    $.console.warn("Tile %s caching attempt without data argument on uninitialized cache entry!", tile);
<span id="line31591" class="line"></span>                }
<span id="line31592" class="line"></span>            }
<span id="line31593" class="line"></span>        }
<span id="line31594" class="line"></span>
<span id="line31595" class="line"></span>        /**
<span id="line31596" class="line"></span>         * Remove tile dependency on this record.
<span id="line31597" class="line"></span>         * @param tile
<span id="line31598" class="line"></span>         * @returns {Boolean} true if record removed
<span id="line31599" class="line"></span>         */
<span id="line31600" class="line"></span>        removeTile(tile) {
<span id="line31601" class="line"></span>            if (this._destroyed) {
<span id="line31602" class="line"></span>                return false;
<span id="line31603" class="line"></span>            }
<span id="line31604" class="line"></span>            for (let i = 0; i &lt; this._tiles.length; i++) {
<span id="line31605" class="line"></span>                if (this._tiles[i] === tile) {
<span id="line31606" class="line"></span>                    this._tiles.splice(i, 1);
<span id="line31607" class="line"></span>                    if (this._tRef === tile) {
<span id="line31608" class="line"></span>                        // keep fresh ref
<span id="line31609" class="line"></span>                        this._tRef = this._tiles[i - 1];
<span id="line31610" class="line"></span>                    }
<span id="line31611" class="line"></span>                    return true;
<span id="line31612" class="line"></span>                }
<span id="line31613" class="line"></span>            }
<span id="line31614" class="line"></span>            $.console.warn('[CacheRecord.removeTile] trying to remove unknown tile', tile);
<span id="line31615" class="line"></span>            return false;
<span id="line31616" class="line"></span>        }
<span id="line31617" class="line"></span>
<span id="line31618" class="line"></span>        /**
<span id="line31619" class="line"></span>         * Get the amount of tiles sharing this record.
<span id="line31620" class="line"></span>         * @return {number}
<span id="line31621" class="line"></span>         */
<span id="line31622" class="line"></span>        getTileCount() {
<span id="line31623" class="line"></span>            return this._tiles ? this._tiles.length : 0;
<span id="line31624" class="line"></span>        }
<span id="line31625" class="line"></span>
<span id="line31626" class="line"></span>        /**
<span id="line31627" class="line"></span>         * Private conversion that makes sure collided requests are
<span id="line31628" class="line"></span>         * processed eventually
<span id="line31629" class="line"></span>         * @private
<span id="line31630" class="line"></span>         */
<span id="line31631" class="line"></span>        _checkAwaitsConvert() {
<span id="line31632" class="line"></span>            if (!this._conversionJobQueue || this._destroyed) {
<span id="line31633" class="line"></span>                return;
<span id="line31634" class="line"></span>            }
<span id="line31635" class="line"></span>            //let other code finish first
<span id="line31636" class="line"></span>            setTimeout(() =&gt; {
<span id="line31637" class="line"></span>                //check again, meanwhile things might've changed
<span id="line31638" class="line"></span>                if (!this._conversionJobQueue || this._destroyed) {
<span id="line31639" class="line"></span>                    return;
<span id="line31640" class="line"></span>                }
<span id="line31641" class="line"></span>                const job = this._conversionJobQueue[0];
<span id="line31642" class="line"></span>                this._conversionJobQueue.splice(0, 1);
<span id="line31643" class="line"></span>                if (this._conversionJobQueue.length === 0) {
<span id="line31644" class="line"></span>                    delete this._conversionJobQueue;
<span id="line31645" class="line"></span>                }
<span id="line31646" class="line"></span>                job();
<span id="line31647" class="line"></span>            });
<span id="line31648" class="line"></span>        }
<span id="line31649" class="line"></span>
<span id="line31650" class="line"></span>        _triggerNeedsDraw() {
<span id="line31651" class="line"></span>            if (this._tiles.length &gt; 0) {
<span id="line31652" class="line"></span>                this._tiles[0].tiledImage.viewer.forceRedraw();
<span id="line31653" class="line"></span>            }
<span id="line31654" class="line"></span>        }
<span id="line31655" class="line"></span>
<span id="line31656" class="line"></span>        /**
<span id="line31657" class="line"></span>         * Safely overwrite the cache data and return the old data
<span id="line31658" class="line"></span>         * @private
<span id="line31659" class="line"></span>         */
<span id="line31660" class="line"></span>        _overwriteData(data, type) {
<span id="line31661" class="line"></span>            if (this._destroyed) {
<span id="line31662" class="line"></span>                //we have received the ownership of the data, destroy it too since we are destroyed
<span id="line31663" class="line"></span>                $.converter.destroy(data, type);
<span id="line31664" class="line"></span>                return $.Promise.resolve();
<span id="line31665" class="line"></span>            }
<span id="line31666" class="line"></span>            if (this.loaded) {
<span id="line31667" class="line"></span>                // No-op if attempt to replace with the same object
<span id="line31668" class="line"></span>                if (this._data === data &amp;&amp; this._type === type) {
<span id="line31669" class="line"></span>                    return this._promise;
<span id="line31670" class="line"></span>                }
<span id="line31671" class="line"></span>                $.converter.destroy(this._data, this._type);
<span id="line31672" class="line"></span>                this._type = type;
<span id="line31673" class="line"></span>                this._data = data;
<span id="line31674" class="line"></span>                this._promise = $.Promise.resolve(data);
<span id="line31675" class="line"></span>                const internal = this[DRAWER_INTERNAL_CACHE];
<span id="line31676" class="line"></span>                if (internal) {
<span id="line31677" class="line"></span>                    for (const iCache in internal) {
<span id="line31678" class="line"></span>                        internal[iCache].setDataAs(data, type);
<span id="line31679" class="line"></span>                    }
<span id="line31680" class="line"></span>                }
<span id="line31681" class="line"></span>                this._triggerNeedsDraw();
<span id="line31682" class="line"></span>                return this._promise;
<span id="line31683" class="line"></span>            }
<span id="line31684" class="line"></span>            return this._promise.then(() =&gt; {
<span id="line31685" class="line"></span>                // No-op if attempt to replace with the same object
<span id="line31686" class="line"></span>                if (this._data === data &amp;&amp; this._type === type) {
<span id="line31687" class="line"></span>                    return this._data;
<span id="line31688" class="line"></span>                }
<span id="line31689" class="line"></span>                $.converter.destroy(this._data, this._type);
<span id="line31690" class="line"></span>                this._type = type;
<span id="line31691" class="line"></span>                this._data = data;
<span id="line31692" class="line"></span>                this._promise = $.Promise.resolve(data);
<span id="line31693" class="line"></span>                const internal = this[DRAWER_INTERNAL_CACHE];
<span id="line31694" class="line"></span>                if (internal) {
<span id="line31695" class="line"></span>                    for (const iCache in internal) {
<span id="line31696" class="line"></span>                        internal[iCache].setDataAs(data, type);
<span id="line31697" class="line"></span>                    }
<span id="line31698" class="line"></span>                }
<span id="line31699" class="line"></span>                this._triggerNeedsDraw();
<span id="line31700" class="line"></span>                return this._data;
<span id="line31701" class="line"></span>            });
<span id="line31702" class="line"></span>        }
<span id="line31703" class="line"></span>
<span id="line31704" class="line"></span>        /**
<span id="line31705" class="line"></span>         * Private conversion that makes sure the cache knows its data is ready
<span id="line31706" class="line"></span>         * @param to array or a string - allowed types
<span id="line31707" class="line"></span>         * @param from string - type origin
<span id="line31708" class="line"></span>         * @private
<span id="line31709" class="line"></span>         */
<span id="line31710" class="line"></span>        _convert(from, to) {
<span id="line31711" class="line"></span>            const converter = $.converter,
<span id="line31712" class="line"></span>                conversionPath = converter.getConversionPath(from, to);
<span id="line31713" class="line"></span>            if (!conversionPath) {
<span id="line31714" class="line"></span>                $.console.error(`[CacheRecord._convert] Conversion ${from} ---&gt; ${to} cannot be done!`);
<span id="line31715" class="line"></span>                return; //no-op
<span id="line31716" class="line"></span>            }
<span id="line31717" class="line"></span>
<span id="line31718" class="line"></span>            const originalData = this._data;
<span id="line31719" class="line"></span>            const stepCount = conversionPath.length;
<span id="line31720" class="line"></span>            const _this = this;
<span id="line31721" class="line"></span>            const convert = (x, i) =&gt; {
<span id="line31722" class="line"></span>                if (i &gt;= stepCount) {
<span id="line31723" class="line"></span>                    _this._data = x;
<span id="line31724" class="line"></span>                    _this.loaded = true;
<span id="line31725" class="line"></span>                    _this._checkAwaitsConvert();
<span id="line31726" class="line"></span>                    return $.Promise.resolve(x);
<span id="line31727" class="line"></span>                }
<span id="line31728" class="line"></span>                const edge = conversionPath[i];
<span id="line31729" class="line"></span>                let y;
<span id="line31730" class="line"></span>                try {
<span id="line31731" class="line"></span>                    y = edge.transform(_this._tRef, x);
<span id="line31732" class="line"></span>                } catch (err) {
<span id="line31733" class="line"></span>                    converter.destroy(x, edge.origin.value); // prevent leak
<span id="line31734" class="line"></span>                    return $.Promise.reject(`[CacheRecord._convert] sync failure (while converting using ${edge.target.value}, ${edge.origin.value})`);
<span id="line31735" class="line"></span>                }
<span id="line31736" class="line"></span>                if (y === undefined) {
<span id="line31737" class="line"></span>                    _this.loaded = false;
<span id="line31738" class="line"></span>                    converter.destroy(x, edge.origin.value); // prevent leak
<span id="line31739" class="line"></span>                    return $.Promise.reject(`[CacheRecord._convert] data mid result undefined value (while converting using ${edge.target.value}, ${edge.origin.value})`);
<span id="line31740" class="line"></span>                }
<span id="line31741" class="line"></span>                converter.destroy(x, edge.origin.value);
<span id="line31742" class="line"></span>                const result = $.type(y) === "promise" ? y : $.Promise.resolve(y);
<span id="line31743" class="line"></span>                return result.then(res =&gt; convert(res, i + 1));
<span id="line31744" class="line"></span>            };
<span id="line31745" class="line"></span>
<span id="line31746" class="line"></span>            this.loaded = false;
<span id="line31747" class="line"></span>            this._data = undefined;
<span id="line31748" class="line"></span>            // Read target type from the conversion path: [edge.target] = Vertex, its value=type
<span id="line31749" class="line"></span>            this._type = conversionPath[stepCount - 1].target.value;
<span id="line31750" class="line"></span>
<span id="line31751" class="line"></span>            // IMPORTANT: conversion failures must not poison the cache record with a permanently
<span id="line31752" class="line"></span>            // rejected promise (methods rely on being able to await() without throwing).
<span id="line31753" class="line"></span>            this._promise = convert(originalData, 0).catch(e =&gt; {
<span id="line31754" class="line"></span>                this._handleConversionError(e);
<span id="line31755" class="line"></span>                return undefined;
<span id="line31756" class="line"></span>            });
<span id="line31757" class="line"></span>        }
<span id="line31758" class="line"></span>
<span id="line31759" class="line"></span>        /**
<span id="line31760" class="line"></span>         * Handle conversion error by cleaning up and unloading affected tiles
<span id="line31761" class="line"></span>         * @param {Error} e
<span id="line31762" class="line"></span>         * @private
<span id="line31763" class="line"></span>         */
<span id="line31764" class="line"></span>        _handleConversionError(e) {
<span id="line31765" class="line"></span>            $.console.error("[CacheRecord] Conversion/preparation error:", e);
<span id="line31766" class="line"></span>
<span id="line31767" class="line"></span>            this._destroyed = true;
<span id="line31768" class="line"></span>            this.loaded = false;
<span id="line31769" class="line"></span>            this._data = null;
<span id="line31770" class="line"></span>
<span id="line31771" class="line"></span>            // WORKING CACHE: do not escalate to TileCache, do not unload tiles.
<span id="line31772" class="line"></span>            // A working cache is not registered (no cacheKey and/or no owner).
<span id="line31773" class="line"></span>            if (!this.cacheKey || !this._ownerTileCache) {
<span id="line31774" class="line"></span>                this._promise = $.Promise.resolve(undefined);
<span id="line31775" class="line"></span>                this._tiles = [];
<span id="line31776" class="line"></span>                this._tRef = null;
<span id="line31777" class="line"></span>                return;
<span id="line31778" class="line"></span>            }
<span id="line31779" class="line"></span>
<span id="line31780" class="line"></span>            // MANAGED CACHE: notify TileCache to remove record and possibly mark tile missing.
<span id="line31781" class="line"></span>            this._ownerTileCache._handleBrokenCacheRecord(this);
<span id="line31782" class="line"></span>        }
<span id="line31783" class="line"></span>    };
<span id="line31784" class="line"></span>
<span id="line31785" class="line"></span>    /**
<span id="line31786" class="line"></span>     * @class OpenSeadragon.InternalCacheRecord
<span id="line31787" class="line"></span>     * @memberof OpenSeadragon
<span id="line31788" class="line"></span>     * @classdesc Simple cache record without robust support for async access. Meant for internal use only.
<span id="line31789" class="line"></span>     *
<span id="line31790" class="line"></span>     * This class acts like the Maybe type:
<span id="line31791" class="line"></span>     *  - it has 'loaded' flag indicating whether the tile data is ready
<span id="line31792" class="line"></span>     *  - it has 'data' property that has value if loaded=true
<span id="line31793" class="line"></span>     *
<span id="line31794" class="line"></span>     * This class supposes synchronous access, no collision of transform calls.
<span id="line31795" class="line"></span>     * It also does not record tiles nor allows cache/tile sharing.
<span id="line31796" class="line"></span>     * @private
<span id="line31797" class="line"></span>     */
<span id="line31798" class="line"></span>    OpenSeadragon.InternalCacheRecord = class InternalCacheRecord {
<span id="line31799" class="line"></span>        constructor(data, type, onDestroy) {
<span id="line31800" class="line"></span>            this.tstamp = $.now();
<span id="line31801" class="line"></span>            this._ondestroy = onDestroy;
<span id="line31802" class="line"></span>            this._type = type;
<span id="line31803" class="line"></span>
<span id="line31804" class="line"></span>            if (data instanceof $.Promise) {
<span id="line31805" class="line"></span>                this._promise = data;
<span id="line31806" class="line"></span>                data.then(data =&gt; {
<span id="line31807" class="line"></span>                    this.loaded = true;
<span id="line31808" class="line"></span>                    this._data = data;
<span id="line31809" class="line"></span>                });
<span id="line31810" class="line"></span>            } else {
<span id="line31811" class="line"></span>                this._promise = null;
<span id="line31812" class="line"></span>                this.loaded = true;
<span id="line31813" class="line"></span>                this._data = data;
<span id="line31814" class="line"></span>            }
<span id="line31815" class="line"></span>        }
<span id="line31816" class="line"></span>
<span id="line31817" class="line"></span>        /**
<span id="line31818" class="line"></span>         * Sync access to the data
<span id="line31819" class="line"></span>         * @returns {any}
<span id="line31820" class="line"></span>         */
<span id="line31821" class="line"></span>        get data() {
<span id="line31822" class="line"></span>            return this._data;
<span id="line31823" class="line"></span>        }
<span id="line31824" class="line"></span>
<span id="line31825" class="line"></span>        /**
<span id="line31826" class="line"></span>         * Sync access to the current type
<span id="line31827" class="line"></span>         * @returns {string}
<span id="line31828" class="line"></span>         */
<span id="line31829" class="line"></span>        get type() {
<span id="line31830" class="line"></span>            return this._type;
<span id="line31831" class="line"></span>        }
<span id="line31832" class="line"></span>
<span id="line31833" class="line"></span>        /**
<span id="line31834" class="line"></span>         * Await ongoing process so that we get cache ready on callback.
<span id="line31835" class="line"></span>         * @returns {OpenSeadragon.Promise&lt;?&gt;}
<span id="line31836" class="line"></span>         */
<span id="line31837" class="line"></span>        await() {
<span id="line31838" class="line"></span>            if (!this._promise) { //if not cache loaded, do not fail
<span id="line31839" class="line"></span>                return $.Promise.resolve(this._data);
<span id="line31840" class="line"></span>            }
<span id="line31841" class="line"></span>            return this._promise;
<span id="line31842" class="line"></span>        }
<span id="line31843" class="line"></span>
<span id="line31844" class="line"></span>        /**
<span id="line31845" class="line"></span>         * Must be called before transformTo or setDataAs. To keep
<span id="line31846" class="line"></span>         * compatible api with CacheRecord where tile refs are known.
<span id="line31847" class="line"></span>         * @param {OpenSeadragon.Tile} referenceTile reference tile for conversion
<span id="line31848" class="line"></span>         * @return {OpenSeadragon.InternalCacheRecord} self reference for builder pattern
<span id="line31849" class="line"></span>         */
<span id="line31850" class="line"></span>        withTileReference(referenceTile) {
<span id="line31851" class="line"></span>            this._temporaryTileRef = referenceTile;
<span id="line31852" class="line"></span>            return this;
<span id="line31853" class="line"></span>        }
<span id="line31854" class="line"></span>
<span id="line31855" class="line"></span>        /**
<span id="line31856" class="line"></span>         * Free all the data and call data destructors if defined.
<span id="line31857" class="line"></span>         */
<span id="line31858" class="line"></span>        destroy() {
<span id="line31859" class="line"></span>            if (this.loaded) {
<span id="line31860" class="line"></span>                if (this._ondestroy) {
<span id="line31861" class="line"></span>                    this._ondestroy(this._data);
<span id="line31862" class="line"></span>                }
<span id="line31863" class="line"></span>                this._data = null;
<span id="line31864" class="line"></span>                this.loaded = false;
<span id="line31865" class="line"></span>            }
<span id="line31866" class="line"></span>        }
<span id="line31867" class="line"></span>    };
<span id="line31868" class="line"></span>
<span id="line31869" class="line"></span>
<span id="line31870" class="line"></span>    /**
<span id="line31871" class="line"></span>     * @class OpenSeadragon.TileCache
<span id="line31872" class="line"></span>     * @memberof OpenSeadragon
<span id="line31873" class="line"></span>     * @classdesc Stores all the tiles displayed in a {@link OpenSeadragon.Viewer}.
<span id="line31874" class="line"></span>     * You generally won't have to interact with the TileCache directly.
<span id="line31875" class="line"></span>     * @param {Object} options - Configuration for this TileCache.
<span id="line31876" class="line"></span>     * @param {Number} [options.maxImageCacheCount] - See maxImageCacheCount in
<span id="line31877" class="line"></span>     * {@link OpenSeadragon.Options} for details.
<span id="line31878" class="line"></span>     */
<span id="line31879" class="line"></span>    OpenSeadragon.TileCache = class TileCache {
<span id="line31880" class="line"></span>        constructor( options ) {
<span id="line31881" class="line"></span>
<span id="line31882" class="line"></span>            options = options || {};
<span id="line31883" class="line"></span>
<span id="line31884" class="line"></span>            this._maxCacheItemCount = options.maxImageCacheCount || $.DEFAULT_SETTINGS.maxImageCacheCount;
<span id="line31885" class="line"></span>            // requestInvalidate() touches this private property due to performance reasons
<span id="line31886" class="line"></span>            this._tilesLoaded = [];
<span id="line31887" class="line"></span>            this._zombiesLoaded = [];
<span id="line31888" class="line"></span>            this._zombiesLoadedCount = 0;
<span id="line31889" class="line"></span>            this._cachesLoaded = [];
<span id="line31890" class="line"></span>            this._cachesLoadedCount = 0;
<span id="line31891" class="line"></span>        }
<span id="line31892" class="line"></span>
<span id="line31893" class="line"></span>        /**
<span id="line31894" class="line"></span>         * @returns {Number} The total number of tiles that have been loaded by
<span id="line31895" class="line"></span>         * this TileCache. Note that the tile might be recorded here mutliple times,
<span id="line31896" class="line"></span>         * once for each cache it uses.
<span id="line31897" class="line"></span>         */
<span id="line31898" class="line"></span>        numTilesLoaded() {
<span id="line31899" class="line"></span>            return this._tilesLoaded.length;
<span id="line31900" class="line"></span>        }
<span id="line31901" class="line"></span>
<span id="line31902" class="line"></span>        /**
<span id="line31903" class="line"></span>         * @returns {Number} The total number of cached objects (+ zombies)
<span id="line31904" class="line"></span>         */
<span id="line31905" class="line"></span>        numCachesLoaded() {
<span id="line31906" class="line"></span>            return this._zombiesLoadedCount + this._cachesLoadedCount;
<span id="line31907" class="line"></span>        }
<span id="line31908" class="line"></span>
<span id="line31909" class="line"></span>        /**
<span id="line31910" class="line"></span>         * Caches the specified tile, removing an old tile if necessary to stay under the
<span id="line31911" class="line"></span>         * maxImageCacheCount specified on construction. Note that if multiple tiles reference
<span id="line31912" class="line"></span>         * the same image, there may be more tiles than maxImageCacheCount; the goal is to keep
<span id="line31913" class="line"></span>         * the number of images below that number. Note, as well, that even the number of images
<span id="line31914" class="line"></span>         * may temporarily surpass that number, but should eventually come back down to the max specified.
<span id="line31915" class="line"></span>         * @private
<span id="line31916" class="line"></span>         * @param {Object} options - Cache creation parameters.
<span id="line31917" class="line"></span>         * @param {OpenSeadragon.Tile} options.tile - The tile to cache.
<span id="line31918" class="line"></span>         * @param {?String} [options.cacheKey=undefined] - Cache Key to use. Defaults to options.tile.cacheKey
<span id="line31919" class="line"></span>         * @param {String} options.tile.cacheKey - The unique key used to identify this tile in the cache.
<span id="line31920" class="line"></span>         *   Used if options.cacheKey not set.
<span id="line31921" class="line"></span>         * @param {Image} options.image - The image of the tile to cache. Deprecated.
<span id="line31922" class="line"></span>         * @param {*} options.data - The data of the tile to cache. If `typeof data === 'function'` holds,
<span id="line31923" class="line"></span>         *   the data is called to obtain the data item: this is an optimization to load data only when necessary.
<span id="line31924" class="line"></span>         * @param {string} [options.dataType] - The data type of the tile to cache. Required.
<span id="line31925" class="line"></span>         * @param {Number} [options.cutoff=0] - If adding this tile goes over the cache max count, this
<span id="line31926" class="line"></span>         *   function will release an old tile. The cutoff option specifies a tile level at or below which
<span id="line31927" class="line"></span>         *   tiles will not be released.
<span id="line31928" class="line"></span>         * @returns {OpenSeadragon.CacheRecord} - The cache record the tile was attached to.
<span id="line31929" class="line"></span>         */
<span id="line31930" class="line"></span>        cacheTile(options) {
<span id="line31931" class="line"></span>            $.console.assert(options, "[TileCache.cacheTile] options is required");
<span id="line31932" class="line"></span>            const theTile = options.tile;
<span id="line31933" class="line"></span>            $.console.assert(theTile, "[TileCache.cacheTile] options.tile is required");
<span id="line31934" class="line"></span>            $.console.assert(theTile.cacheKey, "[TileCache.cacheTile] options.tile.cacheKey is required");
<span id="line31935" class="line"></span>
<span id="line31936" class="line"></span>            if (options.image instanceof Image) {
<span id="line31937" class="line"></span>                $.console.warn("[TileCache.cacheTile] options.image is deprecated!");
<span id="line31938" class="line"></span>                options.data = options.image;
<span id="line31939" class="line"></span>                options.dataType = "image";
<span id="line31940" class="line"></span>            }
<span id="line31941" class="line"></span>
<span id="line31942" class="line"></span>            const cacheKey = options.cacheKey || theTile.cacheKey;
<span id="line31943" class="line"></span>
<span id="line31944" class="line"></span>            let cacheRecord = this._cachesLoaded[cacheKey];
<span id="line31945" class="line"></span>            if (!cacheRecord) {
<span id="line31946" class="line"></span>                if (options.data === undefined) {
<span id="line31947" class="line"></span>                    $.console.error("[TileCache.cacheTile] options.image was renamed to options.data. '.image' attribute " +
<span id="line31948" class="line"></span>                        "has been deprecated and will be removed in the future.");
<span id="line31949" class="line"></span>                    options.data = options.image;
<span id="line31950" class="line"></span>                }
<span id="line31951" class="line"></span>
<span id="line31952" class="line"></span>                cacheRecord = this._zombiesLoaded[cacheKey];
<span id="line31953" class="line"></span>                if (cacheRecord) {
<span id="line31954" class="line"></span>                    // zombies should not be (yet) destroyed, but if we encounter one...
<span id="line31955" class="line"></span>                    if (cacheRecord._destroyed) {
<span id="line31956" class="line"></span>                        // if destroyed, invalidation routine will get triggered for us automatically
<span id="line31957" class="line"></span>                        cacheRecord.revive();
<span id="line31958" class="line"></span>                    } else {
<span id="line31959" class="line"></span>                        // if zombie ready, do not overwrite its data, in that case try to call
<span id="line31960" class="line"></span>                        // we need to trigger invalidation routine, data was not part of the system!
<span id="line31961" class="line"></span>                        if (typeof options.data === 'function') {
<span id="line31962" class="line"></span>                            options.data();
<span id="line31963" class="line"></span>                        }
<span id="line31964" class="line"></span>                        delete options.data;
<span id="line31965" class="line"></span>                    }
<span id="line31966" class="line"></span>                    delete this._zombiesLoaded[cacheKey];
<span id="line31967" class="line"></span>                    this._zombiesLoadedCount--;
<span id="line31968" class="line"></span>                    this._cachesLoaded[cacheKey] = cacheRecord;
<span id="line31969" class="line"></span>                    this._cachesLoadedCount++;
<span id="line31970" class="line"></span>                } else {
<span id="line31971" class="line"></span>                    //allow anything but undefined, null, false (other values mean the data was set, for example '0')
<span id="line31972" class="line"></span>                    const validData = options.data !== undefined &amp;&amp; options.data !== null &amp;&amp; options.data !== false;
<span id="line31973" class="line"></span>                    $.console.assert(validData, "[TileCache.cacheTile] options.data is required to create an CacheRecord");
<span id="line31974" class="line"></span>                    cacheRecord = this._cachesLoaded[cacheKey] = new $.CacheRecord();
<span id="line31975" class="line"></span>                    this._cachesLoadedCount++;
<span id="line31976" class="line"></span>                }
<span id="line31977" class="line"></span>            }
<span id="line31978" class="line"></span>
<span id="line31979" class="line"></span>            if (!options.dataType) {
<span id="line31980" class="line"></span>                $.console.error("[TileCache.cacheTile] options.dataType is newly required. " +
<span id="line31981" class="line"></span>                    "For easier use of the cache system, use the tile instance API.");
<span id="line31982" class="line"></span>
<span id="line31983" class="line"></span>                // We need to force data acquisition now to guess the type
<span id="line31984" class="line"></span>                if (typeof options.data === 'function') {
<span id="line31985" class="line"></span>                    $.console.error("[TileCache.cacheTile] options.dataType is mandatory " +
<span id="line31986" class="line"></span>                        " when data item is a callback!");
<span id="line31987" class="line"></span>                }
<span id="line31988" class="line"></span>                options.dataType = $.converter.guessType(options.data);
<span id="line31989" class="line"></span>            }
<span id="line31990" class="line"></span>
<span id="line31991" class="line"></span>            cacheRecord._ownerTileCache = this;
<span id="line31992" class="line"></span>            cacheRecord.cacheKey = cacheKey;
<span id="line31993" class="line"></span>            cacheRecord.addTile(theTile, options.data, options.dataType);
<span id="line31994" class="line"></span>            this._freeOldRecordRoutine(theTile, options.cutoff || 0);
<span id="line31995" class="line"></span>            return cacheRecord;
<span id="line31996" class="line"></span>        }
<span id="line31997" class="line"></span>
<span id="line31998" class="line"></span>        /**
<span id="line31999" class="line"></span>         * Changes cache key
<span id="line32000" class="line"></span>         * @private
<span id="line32001" class="line"></span>         * @param {Object} options - Cache creation parameters.
<span id="line32002" class="line"></span>         * @param {String} options.oldCacheKey - Current key
<span id="line32003" class="line"></span>         * @param {String} options.newCacheKey - New key to set
<span id="line32004" class="line"></span>         * @return {OpenSeadragon.CacheRecord | null}
<span id="line32005" class="line"></span>         */
<span id="line32006" class="line"></span>        renameCache(options) {
<span id="line32007" class="line"></span>            const newKey = options.newCacheKey,
<span id="line32008" class="line"></span>                oldKey = options.oldCacheKey;
<span id="line32009" class="line"></span>            let originalCache = this._cachesLoaded[oldKey];
<span id="line32010" class="line"></span>
<span id="line32011" class="line"></span>            if (!originalCache) {
<span id="line32012" class="line"></span>                originalCache = this._zombiesLoaded[oldKey];
<span id="line32013" class="line"></span>                $.console.assert(originalCache, "[TileCache.renameCache] oldCacheKey must reference existing cache!");
<span id="line32014" class="line"></span>                if (this._zombiesLoaded[newKey]) {
<span id="line32015" class="line"></span>                    $.console.error("Cannot rename zombie cache %s to %s: the target cache is occupied!",
<span id="line32016" class="line"></span>                        oldKey, newKey);
<span id="line32017" class="line"></span>                    return null;
<span id="line32018" class="line"></span>                }
<span id="line32019" class="line"></span>                this._zombiesLoaded[newKey] = originalCache;
<span id="line32020" class="line"></span>                delete this._zombiesLoaded[oldKey];
<span id="line32021" class="line"></span>            } else if (this._cachesLoaded[newKey]) {
<span id="line32022" class="line"></span>                $.console.error("Cannot rename cache %s to %s: the target cache is occupied!",
<span id="line32023" class="line"></span>                    oldKey, newKey);
<span id="line32024" class="line"></span>                return null; // do not remove, we perform additional fixes on caches later on when swap occurred
<span id="line32025" class="line"></span>            } else {
<span id="line32026" class="line"></span>                this._cachesLoaded[newKey] = originalCache;
<span id="line32027" class="line"></span>                delete this._cachesLoaded[oldKey];
<span id="line32028" class="line"></span>            }
<span id="line32029" class="line"></span>
<span id="line32030" class="line"></span>            originalCache._ownerTileCache = this;
<span id="line32031" class="line"></span>            originalCache.cacheKey = newKey;
<span id="line32032" class="line"></span>            for (const tile of originalCache._tiles) {
<span id="line32033" class="line"></span>                tile.reflectCacheRenamed(oldKey, newKey);
<span id="line32034" class="line"></span>            }
<span id="line32035" class="line"></span>
<span id="line32036" class="line"></span>            // do not call free old record routine, we did not increase cache size
<span id="line32037" class="line"></span>            return originalCache;
<span id="line32038" class="line"></span>        }
<span id="line32039" class="line"></span>
<span id="line32040" class="line"></span>        /**
<span id="line32041" class="line"></span>         * Reads a cache if it exists and creates a new copy of a target, different cache if it does not
<span id="line32042" class="line"></span>         * @param {Object} options
<span id="line32043" class="line"></span>         * @param {OpenSeadragon.Tile} options.tile - The tile to own ot add record for the cache.
<span id="line32044" class="line"></span>         * @param {String} options.copyTargetKey - The unique key used to identify this tile in the cache.
<span id="line32045" class="line"></span>         * @param {String} options.newCacheKey - The unique key the copy will be created for.
<span id="line32046" class="line"></span>         * @param {String} [options.desiredType=undefined] - For optimization purposes, the desired type. Can
<span id="line32047" class="line"></span>         *   be ignored.
<span id="line32048" class="line"></span>         * @param {Number} [options.cutoff=0] - If adding this tile goes over the cache max count, this
<span id="line32049" class="line"></span>         *   function will release an old tile. The cutoff option specifies a tile level at or below which
<span id="line32050" class="line"></span>         *   tiles will not be released.
<span id="line32051" class="line"></span>         * @returns {OpenSeadragon.Promise&lt;OpenSeadragon.CacheRecord&gt;} - New record.
<span id="line32052" class="line"></span>         * @private
<span id="line32053" class="line"></span>         */
<span id="line32054" class="line"></span>        cloneCache(options) {
<span id="line32055" class="line"></span>            const theTile = options.tile;
<span id="line32056" class="line"></span>            const cacheKey = options.copyTargetKey;
<span id="line32057" class="line"></span>            const cacheRecord = this._cachesLoaded[cacheKey] || this._zombiesLoaded[cacheKey];
<span id="line32058" class="line"></span>            $.console.assert(cacheRecord, "[TileCache.cloneCache] attempt to clone non-existent cache %s!", cacheKey);
<span id="line32059" class="line"></span>            $.console.assert(!this._cachesLoaded[options.newCacheKey],
<span id="line32060" class="line"></span>                "[TileCache.cloneCache] attempt to copy clone to existing cache %s!", options.newCacheKey);
<span id="line32061" class="line"></span>
<span id="line32062" class="line"></span>            const desiredType = options.desiredType || undefined;
<span id="line32063" class="line"></span>            return cacheRecord.getDataAs(desiredType, true).then(data =&gt; {
<span id="line32064" class="line"></span>                const newRecord = this._cachesLoaded[options.newCacheKey] = new $.CacheRecord();
<span id="line32065" class="line"></span>                newRecord.addTile(theTile, data, cacheRecord.type);
<span id="line32066" class="line"></span>                this._cachesLoadedCount++;
<span id="line32067" class="line"></span>                this._freeOldRecordRoutine(theTile, options.cutoff || 0);
<span id="line32068" class="line"></span>                return newRecord;
<span id="line32069" class="line"></span>            });
<span id="line32070" class="line"></span>        }
<span id="line32071" class="line"></span>
<span id="line32072" class="line"></span>        /**
<span id="line32073" class="line"></span>         * Inject new cache to the system
<span id="line32074" class="line"></span>         * @param {Object} options
<span id="line32075" class="line"></span>         * @param {OpenSeadragon.Tile} options.tile - Reference tile. All tiles sharing original data will be affected.
<span id="line32076" class="line"></span>         * @param {OpenSeadragon.CacheRecord} options.cache - Cache that will be injected.
<span id="line32077" class="line"></span>         * @param {String} options.targetKey - The target cache key to inhabit. Can replace existing cache.
<span id="line32078" class="line"></span>         * @param {Boolean} options.setAsMainCache - If true, tiles main cache gets updated to consumerKey.
<span id="line32079" class="line"></span>         *   Otherwise, if consumerKey==tile.cacheKey the cache is set as main too.
<span id="line32080" class="line"></span>         * @param {Boolean} options.tileAllowNotLoaded - if true, tile that is not loaded is also processed,
<span id="line32081" class="line"></span>         *   this is internal parameter used in tile-loaded completion routine, as we need to prepare tile but
<span id="line32082" class="line"></span>         *   it is not yet loaded and cannot be marked as so (otherwise the system would think it is ready)
<span id="line32083" class="line"></span>         * @private
<span id="line32084" class="line"></span>         */
<span id="line32085" class="line"></span>        injectCache(options) {
<span id="line32086" class="line"></span>            const targetKey = options.targetKey,
<span id="line32087" class="line"></span>                tile = options.tile;
<span id="line32088" class="line"></span>            if (!options.tileAllowNotLoaded &amp;&amp; !tile.loaded &amp;&amp; !tile.loading) {
<span id="line32089" class="line"></span>                $.console.warn("Attempt to inject cache on tile in invalid state: this is probably a bug!");
<span id="line32090" class="line"></span>                return;
<span id="line32091" class="line"></span>            }
<span id="line32092" class="line"></span>            const consumer = this._cachesLoaded[targetKey];
<span id="line32093" class="line"></span>            if (consumer) {
<span id="line32094" class="line"></span>                // We need to avoid async execution here: replace consumer instead of overwriting the data.
<span id="line32095" class="line"></span>                const iterateTiles = [...consumer._tiles];  // unloadCacheForTile() will modify the array, use a copy
<span id="line32096" class="line"></span>                for (const tile of iterateTiles) {
<span id="line32097" class="line"></span>                    this.unloadCacheForTile(tile, targetKey, true, false);
<span id="line32098" class="line"></span>                }
<span id="line32099" class="line"></span>            }
<span id="line32100" class="line"></span>            if (this._cachesLoaded[targetKey]) {
<span id="line32101" class="line"></span>                $.console.error("The inject routine should've freed cache!");
<span id="line32102" class="line"></span>            }
<span id="line32103" class="line"></span>
<span id="line32104" class="line"></span>            const cache = options.cache;
<span id="line32105" class="line"></span>            this._cachesLoaded[targetKey] = cache;
<span id="line32106" class="line"></span>            cache._ownerTileCache = this;
<span id="line32107" class="line"></span>            cache.cacheKey = targetKey;
<span id="line32108" class="line"></span>
<span id="line32109" class="line"></span>            // Update cache: add the new cache, we must add since we removed above with unloadCacheForTile()
<span id="line32110" class="line"></span>            for (const t of tile.getCache(tile.originalCacheKey)._tiles) {  // grab all cache-equal tiles
<span id="line32111" class="line"></span>                t.setCache(targetKey, cache, options.setAsMainCache, false);
<span id="line32112" class="line"></span>            }
<span id="line32113" class="line"></span>        }
<span id="line32114" class="line"></span>
<span id="line32115" class="line"></span>        /**
<span id="line32116" class="line"></span>         * Replace cache (and update tile references) by another cache
<span id="line32117" class="line"></span>         * @param {Object} options
<span id="line32118" class="line"></span>         * @param {OpenSeadragon.Tile} options.tile - The tile to own ot add record for the cache.
<span id="line32119" class="line"></span>         * @param {String} options.victimKey - Cache that will be erased. In fact, the victim _replaces_ consumer,
<span id="line32120" class="line"></span>         *   inheriting its tiles and key.
<span id="line32121" class="line"></span>         * @param {String} options.consumerKey - The cache that consumes the victim. In fact, it gets destroyed and
<span id="line32122" class="line"></span>         *   replaced by victim, which inherits all its metadata.
<span id="line32123" class="line"></span>         * @param {Boolean} options.setAsMainCache - If true, tiles main cache gets updated to consumerKey.
<span id="line32124" class="line"></span>         *   Otherwise, if consumerKey==tile.cacheKey the cache is set as main too.
<span id="line32125" class="line"></span>         * @param {Boolean} options.tileAllowNotLoaded - if true, tile that is not loaded is also processed,
<span id="line32126" class="line"></span>         *   this is internal parameter used in tile-loaded completion routine, as we need to prepare tile but
<span id="line32127" class="line"></span>         *   it is not yet loaded and cannot be marked as so (otherwise the system would think it is ready)
<span id="line32128" class="line"></span>         * @private
<span id="line32129" class="line"></span>         */
<span id="line32130" class="line"></span>        replaceCache(options) {
<span id="line32131" class="line"></span>            const victimKey = options.victimKey,
<span id="line32132" class="line"></span>                consumerKey = options.consumerKey,
<span id="line32133" class="line"></span>                victim = this._cachesLoaded[victimKey],
<span id="line32134" class="line"></span>                tile = options.tile;
<span id="line32135" class="line"></span>            if (!victim || (!options.tileAllowNotLoaded &amp;&amp; !tile.loaded &amp;&amp; !tile.loading)) {
<span id="line32136" class="line"></span>                $.console.warn("Attempt to consume cache on tile in invalid state: this is probably a bug!");
<span id="line32137" class="line"></span>                return;
<span id="line32138" class="line"></span>            }
<span id="line32139" class="line"></span>            const consumer = this._cachesLoaded[consumerKey];
<span id="line32140" class="line"></span>            if (consumer) {
<span id="line32141" class="line"></span>                // We need to avoid async execution here: replace consumer instead of overwriting the data.
<span id="line32142" class="line"></span>                const iterateTiles = [...consumer._tiles];  // unloadCacheForTile() will modify the array, use a copy
<span id="line32143" class="line"></span>                for (const tile of iterateTiles) {
<span id="line32144" class="line"></span>                    this.unloadCacheForTile(tile, consumerKey, true, false);
<span id="line32145" class="line"></span>                }
<span id="line32146" class="line"></span>            }
<span id="line32147" class="line"></span>            if (this._cachesLoaded[consumerKey]) {
<span id="line32148" class="line"></span>                $.console.error("The consume routine should've freed cache!");
<span id="line32149" class="line"></span>            }
<span id="line32150" class="line"></span>            // Just swap victim to become new consumer
<span id="line32151" class="line"></span>            const resultCache = this.renameCache({
<span id="line32152" class="line"></span>                oldCacheKey: victimKey,
<span id="line32153" class="line"></span>                newCacheKey: consumerKey
<span id="line32154" class="line"></span>            });
<span id="line32155" class="line"></span>
<span id="line32156" class="line"></span>            if (resultCache) {
<span id="line32157" class="line"></span>                // Only one cache got working item, other caches were idle: update cache: add the new cache
<span id="line32158" class="line"></span>                // we must add since we removed above with unloadCacheForTile()
<span id="line32159" class="line"></span>                for (const t of tile.getCache(tile.originalCacheKey)._tiles) {  // grab all cache-equal tiles
<span id="line32160" class="line"></span>                    t.setCache(consumerKey, resultCache, options.setAsMainCache, false);
<span id="line32161" class="line"></span>                }
<span id="line32162" class="line"></span>            }
<span id="line32163" class="line"></span>        }
<span id="line32164" class="line"></span>
<span id="line32165" class="line"></span>        /**
<span id="line32166" class="line"></span>         * This method ensures other tiles are restored if one of the tiles
<span id="line32167" class="line"></span>         * was requested restore().
<span id="line32168" class="line"></span>         * @param tile
<span id="line32169" class="line"></span>         * @param originalCache
<span id="line32170" class="line"></span>         * @param freeIfUnused if true, zombie is not created
<span id="line32171" class="line"></span>         * @private
<span id="line32172" class="line"></span>         */
<span id="line32173" class="line"></span>        restoreTilesThatShareOriginalCache(tile, originalCache, freeIfUnused) {
<span id="line32174" class="line"></span>            for (const t of originalCache._tiles) {
<span id="line32175" class="line"></span>                if (t.cacheKey !== t.originalCacheKey) {
<span id="line32176" class="line"></span>                    this.unloadCacheForTile(t, t.cacheKey, freeIfUnused, true);
<span id="line32177" class="line"></span>                    delete t._caches[t.cacheKey];
<span id="line32178" class="line"></span>                    t.cacheKey = t.originalCacheKey;
<span id="line32179" class="line"></span>                }
<span id="line32180" class="line"></span>            }
<span id="line32181" class="line"></span>        }
<span id="line32182" class="line"></span>
<span id="line32183" class="line"></span>        _freeOldRecordRoutine(theTile, cutoff) {
<span id="line32184" class="line"></span>            let insertionIndex = this._tilesLoaded.length,
<span id="line32185" class="line"></span>                worstTileIndex = -1;
<span id="line32186" class="line"></span>
<span id="line32187" class="line"></span>            // Note that just because we're unloading a tile doesn't necessarily mean
<span id="line32188" class="line"></span>            // we're unloading its cache records. With repeated calls it should sort itself out, though.
<span id="line32189" class="line"></span>            if (this._cachesLoadedCount + this._zombiesLoadedCount &gt; this._maxCacheItemCount) {
<span id="line32190" class="line"></span>                //prefer zombie deletion, faster, better
<span id="line32191" class="line"></span>                if (this._zombiesLoadedCount &gt; 0) {
<span id="line32192" class="line"></span>                    for (const zombie in this._zombiesLoaded) {
<span id="line32193" class="line"></span>                        this._zombiesLoaded[zombie].destroy();
<span id="line32194" class="line"></span>                        delete this._zombiesLoaded[zombie];
<span id="line32195" class="line"></span>                        this._zombiesLoadedCount--;
<span id="line32196" class="line"></span>                        break;
<span id="line32197" class="line"></span>                    }
<span id="line32198" class="line"></span>                } else {
<span id="line32199" class="line"></span>                    let worstTile = null;
<span id="line32200" class="line"></span>                    let prevTile, worstTime, worstLevel, prevTime, prevLevel;
<span id="line32201" class="line"></span>
<span id="line32202" class="line"></span>                    for (let i = this._tilesLoaded.length - 1; i &gt;= 0; i--) {
<span id="line32203" class="line"></span>                        prevTile = this._tilesLoaded[i];
<span id="line32204" class="line"></span>
<span id="line32205" class="line"></span>                        if (prevTile.level &lt;= cutoff ||
<span id="line32206" class="line"></span>                            prevTile.beingDrawn ||
<span id="line32207" class="line"></span>                            prevTile.loading ||
<span id="line32208" class="line"></span>                            prevTile.processing) {
<span id="line32209" class="line"></span>                            continue;
<span id="line32210" class="line"></span>                        }
<span id="line32211" class="line"></span>                        if (!worstTile) {
<span id="line32212" class="line"></span>                            worstTile = prevTile;
<span id="line32213" class="line"></span>                            worstTileIndex = i;
<span id="line32214" class="line"></span>                            continue;
<span id="line32215" class="line"></span>                        }
<span id="line32216" class="line"></span>
<span id="line32217" class="line"></span>                        prevTime = prevTile.lastTouchTime;
<span id="line32218" class="line"></span>                        worstTime = worstTile.lastTouchTime;
<span id="line32219" class="line"></span>                        prevLevel = prevTile.level;
<span id="line32220" class="line"></span>                        worstLevel = worstTile.level;
<span id="line32221" class="line"></span>
<span id="line32222" class="line"></span>                        if (prevTime &lt; worstTime ||
<span id="line32223" class="line"></span>                            (prevTime === worstTime &amp;&amp; prevLevel &gt; worstLevel)) {
<span id="line32224" class="line"></span>                            worstTile = prevTile;
<span id="line32225" class="line"></span>                            worstTileIndex = i;
<span id="line32226" class="line"></span>                        }
<span id="line32227" class="line"></span>                    }
<span id="line32228" class="line"></span>
<span id="line32229" class="line"></span>                    if (worstTile &amp;&amp; worstTileIndex &gt;= 0) {
<span id="line32230" class="line"></span>                        this._unloadTile(worstTile, true);
<span id="line32231" class="line"></span>                        insertionIndex = worstTileIndex;
<span id="line32232" class="line"></span>                    }
<span id="line32233" class="line"></span>                }
<span id="line32234" class="line"></span>            }
<span id="line32235" class="line"></span>
<span id="line32236" class="line"></span>            if (theTile.getCacheSize() === 0) {
<span id="line32237" class="line"></span>                this._tilesLoaded[insertionIndex] = theTile;
<span id="line32238" class="line"></span>            } else if (worstTileIndex &gt;= 0) {
<span id="line32239" class="line"></span>                //tile is already recorded, do not add tile, but remove the tile at insertion index
<span id="line32240" class="line"></span>                this._tilesLoaded.splice(insertionIndex, 1);
<span id="line32241" class="line"></span>            }
<span id="line32242" class="line"></span>        }
<span id="line32243" class="line"></span>
<span id="line32244" class="line"></span>        _handleBrokenCacheRecord(cache) {
<span id="line32245" class="line"></span>            if (!cache) {
<span id="line32246" class="line"></span>                return;
<span id="line32247" class="line"></span>            }
<span id="line32248" class="line"></span>
<span id="line32249" class="line"></span>            const key = cache.cacheKey;
<span id="line32250" class="line"></span>
<span id="line32251" class="line"></span>            if (key &amp;&amp; this._cachesLoaded[key] === cache) {
<span id="line32252" class="line"></span>                delete this._cachesLoaded[key];
<span id="line32253" class="line"></span>                this._cachesLoadedCount--;
<span id="line32254" class="line"></span>            }
<span id="line32255" class="line"></span>            if (key &amp;&amp; this._zombiesLoaded[key] === cache) {
<span id="line32256" class="line"></span>                delete this._zombiesLoaded[key];
<span id="line32257" class="line"></span>                this._zombiesLoadedCount--;
<span id="line32258" class="line"></span>            }
<span id="line32259" class="line"></span>
<span id="line32260" class="line"></span>            const tiles = cache._tiles ? [...cache._tiles] : [];
<span id="line32261" class="line"></span>            for (const tile of tiles) {
<span id="line32262" class="line"></span>                const isMainCache = tile.getCache &amp;&amp; tile.getCache() === cache;
<span id="line32263" class="line"></span>                const isOriginalCache = key &amp;&amp; tile.originalCacheKey === key;
<span id="line32264" class="line"></span>
<span id="line32265" class="line"></span>                if (isMainCache || isOriginalCache) {
<span id="line32266" class="line"></span>                    tile.exists = false; // prevents the tile from loading (TODO: consider ability to revive!)
<span id="line32267" class="line"></span>                    tile.unload(true);
<span id="line32268" class="line"></span>                } else {
<span id="line32269" class="line"></span>                    if (tile.removeCache &amp;&amp; key) {
<span id="line32270" class="line"></span>                        tile.removeCache(key);
<span id="line32271" class="line"></span>                    }
<span id="line32272" class="line"></span>                    cache.removeTile(tile);
<span id="line32273" class="line"></span>                }
<span id="line32274" class="line"></span>            }
<span id="line32275" class="line"></span>
<span id="line32276" class="line"></span>            cache._promise = $.Promise.resolve(undefined);
<span id="line32277" class="line"></span>            cache._tiles = [];
<span id="line32278" class="line"></span>            cache._tRef = null;
<span id="line32279" class="line"></span>            cache._ownerTileCache = null;
<span id="line32280" class="line"></span>        }
<span id="line32281" class="line"></span>
<span id="line32282" class="line"></span>        /**
<span id="line32283" class="line"></span>         * Clears all tiles associated with the specified tiledImage.
<span id="line32284" class="line"></span>         * @param {OpenSeadragon.TiledImage} tiledImage
<span id="line32285" class="line"></span>         */
<span id="line32286" class="line"></span>        clearTilesFor(tiledImage) {
<span id="line32287" class="line"></span>            $.console.assert(tiledImage, '[TileCache.clearTilesFor] tiledImage is required');
<span id="line32288" class="line"></span>            let tile;
<span id="line32289" class="line"></span>
<span id="line32290" class="line"></span>            let cacheOverflows = this._cachesLoadedCount + this._zombiesLoadedCount &gt; this._maxCacheItemCount;
<span id="line32291" class="line"></span>            if (tiledImage._zombieCache &amp;&amp; cacheOverflows &amp;&amp; this._zombiesLoadedCount &gt; 0) {
<span id="line32292" class="line"></span>                //prefer newer (fresh ;) zombies
<span id="line32293" class="line"></span>                for (const zombie in this._zombiesLoaded) {
<span id="line32294" class="line"></span>                    this._zombiesLoaded[zombie].destroy();
<span id="line32295" class="line"></span>                    delete this._zombiesLoaded[zombie];
<span id="line32296" class="line"></span>                }
<span id="line32297" class="line"></span>                this._zombiesLoadedCount = 0;
<span id="line32298" class="line"></span>                cacheOverflows = this._cachesLoadedCount &gt; this._maxCacheItemCount;
<span id="line32299" class="line"></span>            }
<span id="line32300" class="line"></span>            for (let i = this._tilesLoaded.length - 1; i &gt;= 0; i--) {
<span id="line32301" class="line"></span>                tile = this._tilesLoaded[i];
<span id="line32302" class="line"></span>
<span id="line32303" class="line"></span>                if (tile.tiledImage === tiledImage) {
<span id="line32304" class="line"></span>                    if (!tile.loaded) {
<span id="line32305" class="line"></span>                        //iterates from the array end, safe to remove
<span id="line32306" class="line"></span>                        this._tilesLoaded.splice(i, 1);
<span id="line32307" class="line"></span>                    } else if (tile.tiledImage === tiledImage) {
<span id="line32308" class="line"></span>                        this._unloadTile(tile, !tiledImage._zombieCache || cacheOverflows, i);
<span id="line32309" class="line"></span>                    }
<span id="line32310" class="line"></span>                }
<span id="line32311" class="line"></span>            }
<span id="line32312" class="line"></span>        }
<span id="line32313" class="line"></span>
<span id="line32314" class="line"></span>        /**
<span id="line32315" class="line"></span>         * Delete all data in the cache
<span id="line32316" class="line"></span>         * @param {boolean} withZombies
<span id="line32317" class="line"></span>         */
<span id="line32318" class="line"></span>        clear(withZombies = true) {
<span id="line32319" class="line"></span>            for (const zombie in this._zombiesLoaded) {
<span id="line32320" class="line"></span>                this._zombiesLoaded[zombie].destroy();
<span id="line32321" class="line"></span>            }
<span id="line32322" class="line"></span>            for (const tile in this._tilesLoaded) {
<span id="line32323" class="line"></span>                this._unloadTile(tile, true);
<span id="line32324" class="line"></span>            }
<span id="line32325" class="line"></span>            this._tilesLoaded = [];
<span id="line32326" class="line"></span>            this._zombiesLoaded = [];
<span id="line32327" class="line"></span>            this._zombiesLoadedCount = 0;
<span id="line32328" class="line"></span>            this._cachesLoaded = [];
<span id="line32329" class="line"></span>            this._cachesLoadedCount = 0;
<span id="line32330" class="line"></span>        }
<span id="line32331" class="line"></span>
<span id="line32332" class="line"></span>        /**
<span id="line32333" class="line"></span>         * Clean up internal drawer data for a given drawer
<span id="line32334" class="line"></span>         * @param {OpenSeadragon.DrawerBase} drawer
<span id="line32335" class="line"></span>         */
<span id="line32336" class="line"></span>        clearDrawerInternalCache(drawer) {
<span id="line32337" class="line"></span>            const drawerId = drawer.getId();
<span id="line32338" class="line"></span>            for (const zombie of this._zombiesLoaded) {
<span id="line32339" class="line"></span>                if (zombie) {
<span id="line32340" class="line"></span>                    zombie.destroyInternalCache(drawerId);
<span id="line32341" class="line"></span>                }
<span id="line32342" class="line"></span>            }
<span id="line32343" class="line"></span>            for (const cache of this._cachesLoaded) {
<span id="line32344" class="line"></span>                if (cache) {
<span id="line32345" class="line"></span>                    cache.destroyInternalCache(drawerId);
<span id="line32346" class="line"></span>                }
<span id="line32347" class="line"></span>            }
<span id="line32348" class="line"></span>        }
<span id="line32349" class="line"></span>
<span id="line32350" class="line"></span>        /**
<span id="line32351" class="line"></span>         * Returns reference to all tiles loaded by a particular
<span id="line32352" class="line"></span>         * tiled image item
<span id="line32353" class="line"></span>         * @param {OpenSeadragon.TiledImage|null} tiledImage if null, gets all tiles, else filters out tiles
<span id="line32354" class="line"></span>         *   that belong to a specific image
<span id="line32355" class="line"></span>         */
<span id="line32356" class="line"></span>        getLoadedTilesFor(tiledImage) {
<span id="line32357" class="line"></span>            if (!tiledImage) {
<span id="line32358" class="line"></span>                return [...this._tilesLoaded];
<span id="line32359" class="line"></span>            }
<span id="line32360" class="line"></span>            return this._tilesLoaded.filter(tile =&gt; tile.tiledImage === tiledImage);
<span id="line32361" class="line"></span>        }
<span id="line32362" class="line"></span>
<span id="line32363" class="line"></span>        /**
<span id="line32364" class="line"></span>         * Get cache record (might be a unattached record, i.e. a zombie)
<span id="line32365" class="line"></span>         * @param cacheKey
<span id="line32366" class="line"></span>         * @returns {OpenSeadragon.CacheRecord|undefined}
<span id="line32367" class="line"></span>         */
<span id="line32368" class="line"></span>        getCacheRecord(cacheKey) {
<span id="line32369" class="line"></span>            $.console.assert(cacheKey, '[TileCache.getCacheRecord] cacheKey is required');
<span id="line32370" class="line"></span>            return this._cachesLoaded[cacheKey] || this._zombiesLoaded[cacheKey];
<span id="line32371" class="line"></span>        }
<span id="line32372" class="line"></span>
<span id="line32373" class="line"></span>        /**
<span id="line32374" class="line"></span>         * Delete cache safely from the system if it is not needed
<span id="line32375" class="line"></span>         * @param {OpenSeadragon.CacheRecord} cache
<span id="line32376" class="line"></span>         */
<span id="line32377" class="line"></span>        safeUnloadCache(cache) {
<span id="line32378" class="line"></span>            if (cache &amp;&amp; !cache._destroyed &amp;&amp; cache.getTileCount() &lt; 1) {
<span id="line32379" class="line"></span>                for (const i in this._zombiesLoaded) {
<span id="line32380" class="line"></span>                    const c = this._zombiesLoaded[i];
<span id="line32381" class="line"></span>                    if (c === cache) {
<span id="line32382" class="line"></span>                        delete this._zombiesLoaded[i];
<span id="line32383" class="line"></span>                        c.destroy();
<span id="line32384" class="line"></span>                        return;
<span id="line32385" class="line"></span>                    }
<span id="line32386" class="line"></span>                }
<span id="line32387" class="line"></span>                $.console.error("Attempt to delete an orphan cache that is not in zombie list: this could be a bug!", cache);
<span id="line32388" class="line"></span>                cache.destroy();
<span id="line32389" class="line"></span>            }
<span id="line32390" class="line"></span>        }
<span id="line32391" class="line"></span>
<span id="line32392" class="line"></span>        /**
<span id="line32393" class="line"></span>         * Delete cache record for a given til
<span id="line32394" class="line"></span>         * @param {OpenSeadragon.Tile} tile
<span id="line32395" class="line"></span>         * @param {string} key cache key
<span id="line32396" class="line"></span>         * @param {boolean} destroy if true, empty cache is destroyed, else left as a zombie
<span id="line32397" class="line"></span>         * @param {boolean} okIfNotExists sometimes we call destruction just to make sure, if true do not report as error
<span id="line32398" class="line"></span>         * @private
<span id="line32399" class="line"></span>         */
<span id="line32400" class="line"></span>        unloadCacheForTile(tile, key, destroy, okIfNotExists) {
<span id="line32401" class="line"></span>            const cacheRecord = this._cachesLoaded[key];
<span id="line32402" class="line"></span>            //unload record only if relevant - the tile exists in the record
<span id="line32403" class="line"></span>            if (cacheRecord) {
<span id="line32404" class="line"></span>                if (cacheRecord.removeTile(tile)) {
<span id="line32405" class="line"></span>                    if (!cacheRecord.getTileCount()) {
<span id="line32406" class="line"></span>                        if (destroy) {
<span id="line32407" class="line"></span>                            // #1 tile marked as destroyed (e.g. too much cached tiles or not a zombie)
<span id="line32408" class="line"></span>                            cacheRecord.destroy();
<span id="line32409" class="line"></span>                        } else {
<span id="line32410" class="line"></span>                            // #2 Tile is a zombie. Do not delete record, reuse.
<span id="line32411" class="line"></span>                            this._zombiesLoaded[key] = cacheRecord;
<span id="line32412" class="line"></span>                            this._zombiesLoadedCount++;
<span id="line32413" class="line"></span>                        }
<span id="line32414" class="line"></span>                        // Either way clear cache
<span id="line32415" class="line"></span>                        delete this._cachesLoaded[key];
<span id="line32416" class="line"></span>                        this._cachesLoadedCount--;
<span id="line32417" class="line"></span>                    }
<span id="line32418" class="line"></span>                    return true;
<span id="line32419" class="line"></span>                }
<span id="line32420" class="line"></span>                $.console.error("[TileCache.unloadCacheForTile] System tried to delete tile from cache it " +
<span id="line32421" class="line"></span>                    "does not belong to! This could mean a bug in the cache system.");
<span id="line32422" class="line"></span>                return false;
<span id="line32423" class="line"></span>            }
<span id="line32424" class="line"></span>            if (!okIfNotExists) {
<span id="line32425" class="line"></span>                $.console.warn("[TileCache.unloadCacheForTile] Attempting to delete missing cache!");
<span id="line32426" class="line"></span>            }
<span id="line32427" class="line"></span>            return false;
<span id="line32428" class="line"></span>        }
<span id="line32429" class="line"></span>
<span id="line32430" class="line"></span>        /**
<span id="line32431" class="line"></span>         * Unload tile: this will free the tile data and mark the tile as unloaded.
<span id="line32432" class="line"></span>         * @param {OpenSeadragon.Tile} tile
<span id="line32433" class="line"></span>         * @param {boolean} destroy if set to true, tile data is not preserved as zombies but deleted immediatelly
<span id="line32434" class="line"></span>         */
<span id="line32435" class="line"></span>        unloadTile(tile, destroy = false) {
<span id="line32436" class="line"></span>            if (!tile.loaded) {
<span id="line32437" class="line"></span>                $.console.warn("Attempt to unload already unloaded tile.");
<span id="line32438" class="line"></span>                return;
<span id="line32439" class="line"></span>            }
<span id="line32440" class="line"></span>            const index = this._tilesLoaded.findIndex(x =&gt; x === tile);
<span id="line32441" class="line"></span>            this._unloadTile(tile, destroy, index);
<span id="line32442" class="line"></span>        }
<span id="line32443" class="line"></span>
<span id="line32444" class="line"></span>        /**
<span id="line32445" class="line"></span>         * @param {OpenSeadragon.Tile} tile tile to unload
<span id="line32446" class="line"></span>         * @param {boolean} destroy destroy tile cache if the cache tile counts falls to zero
<span id="line32447" class="line"></span>         * @param {Number} [deleteAtIndex=undefined] index to remove the tile record at, will not remove from _tilesLoaded if not set
<span id="line32448" class="line"></span>         * @private
<span id="line32449" class="line"></span>         */
<span id="line32450" class="line"></span>        _unloadTile(tile, destroy, deleteAtIndex = undefined) {
<span id="line32451" class="line"></span>            $.console.assert(tile, '[TileCache._unloadTile] tile is required');
<span id="line32452" class="line"></span>
<span id="line32453" class="line"></span>            for (const key in tile._caches) {
<span id="line32454" class="line"></span>                //we are 'ok' to remove tile caches here since we later call destroy on tile, otherwise
<span id="line32455" class="line"></span>                //tile has count of its cache size --&gt; would be inconsistent
<span id="line32456" class="line"></span>                this.unloadCacheForTile(tile, key, destroy, false);
<span id="line32457" class="line"></span>            }
<span id="line32458" class="line"></span>            //delete also the tile record
<span id="line32459" class="line"></span>            if (deleteAtIndex !== undefined) {
<span id="line32460" class="line"></span>                this._tilesLoaded.splice(deleteAtIndex, 1);
<span id="line32461" class="line"></span>            }
<span id="line32462" class="line"></span>
<span id="line32463" class="line"></span>            // Possible error: it can happen that unloaded tile gets to this stage. Should it even be allowed to happen?
<span id="line32464" class="line"></span>            if (!tile.loaded) {
<span id="line32465" class="line"></span>                return;
<span id="line32466" class="line"></span>            }
<span id="line32467" class="line"></span>
<span id="line32468" class="line"></span>            const tiledImage = tile.tiledImage;
<span id="line32469" class="line"></span>            tile._unload();
<span id="line32470" class="line"></span>
<span id="line32471" class="line"></span>            /**
<span id="line32472" class="line"></span>             * Triggered when a tile has just been unloaded from memory.
<span id="line32473" class="line"></span>             @@ -255,12 +668,15 @@ $.TileCache.prototype = {
<span id="line32474" class="line"></span>             * @type {object}
<span id="line32475" class="line"></span>             * @property {OpenSeadragon.TiledImage} tiledImage - The tiled image of the unloaded tile.
<span id="line32476" class="line"></span>             * @property {OpenSeadragon.Tile} tile - The tile which has been unloaded.
<span id="line32477" class="line"></span>             * @property {boolean} destroyed - False if the tile data was kept in the system.
<span id="line32478" class="line"></span>             */
<span id="line32479" class="line"></span>            tiledImage.viewer.raiseEvent("tile-unloaded", {
<span id="line32480" class="line"></span>                tile: tile,
<span id="line32481" class="line"></span>                tiledImage: tiledImage,
<span id="line32482" class="line"></span>                destroyed: destroy
<span id="line32483" class="line"></span>            });
<span id="line32484" class="line"></span>        }
<span id="line32485" class="line"></span>    };
<span id="line32486" class="line"></span>
<span id="line32487" class="line"></span>}(OpenSeadragon));
<span id="line32488" class="line"></span>
<span id="line32489" class="line"></span>/*
<span id="line32490" class="line"></span> * OpenSeadragon - World
<span id="line32491" class="line"></span> *
<span id="line32492" class="line"></span> * Copyright (C) 2009 CodePlex Foundation
<span id="line32493" class="line"></span> * Copyright (C) 2010-2025 OpenSeadragon contributors
<span id="line32494" class="line"></span> *
<span id="line32495" class="line"></span> * Redistribution and use in source and binary forms, with or without
<span id="line32496" class="line"></span> * modification, are permitted provided that the following conditions are
<span id="line32497" class="line"></span> * met:
<span id="line32498" class="line"></span> *
<span id="line32499" class="line"></span> * - Redistributions of source code must retain the above copyright notice,
<span id="line32500" class="line"></span> *   this list of conditions and the following disclaimer.
<span id="line32501" class="line"></span> *
<span id="line32502" class="line"></span> * - Redistributions in binary form must reproduce the above copyright
<span id="line32503" class="line"></span> *   notice, this list of conditions and the following disclaimer in the
<span id="line32504" class="line"></span> *   documentation and/or other materials provided with the distribution.
<span id="line32505" class="line"></span> *
<span id="line32506" class="line"></span> * - Neither the name of CodePlex Foundation nor the names of its
<span id="line32507" class="line"></span> *   contributors may be used to endorse or promote products derived from
<span id="line32508" class="line"></span> *   this software without specific prior written permission.
<span id="line32509" class="line"></span> *
<span id="line32510" class="line"></span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span id="line32511" class="line"></span> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span id="line32512" class="line"></span> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span id="line32513" class="line"></span> * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
<span id="line32514" class="line"></span> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span id="line32515" class="line"></span> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
<span id="line32516" class="line"></span> * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span id="line32517" class="line"></span> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span id="line32518" class="line"></span> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span id="line32519" class="line"></span> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span id="line32520" class="line"></span> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span id="line32521" class="line"></span> */
<span id="line32522" class="line"></span>
<span id="line32523" class="line"></span>(function( $ ){
<span id="line32524" class="line"></span>
<span id="line32525" class="line"></span>/**
<span id="line32526" class="line"></span> * @class World
<span id="line32527" class="line"></span> * @memberof OpenSeadragon
<span id="line32528" class="line"></span> * @extends OpenSeadragon.EventSource
<span id="line32529" class="line"></span> * @classdesc Keeps track of all of the tiled images in the scene.
<span id="line32530" class="line"></span> * @param {Object} options - World options.
<span id="line32531" class="line"></span> * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this World.
<span id="line32532" class="line"></span> **/
<span id="line32533" class="line"></span>$.World = function( options ) {
<span id="line32534" class="line"></span>    const _this = this;
<span id="line32535" class="line"></span>
<span id="line32536" class="line"></span>    $.console.assert( options.viewer, "[World] options.viewer is required" );
<span id="line32537" class="line"></span>
<span id="line32538" class="line"></span>    $.EventSource.call( this );
<span id="line32539" class="line"></span>
<span id="line32540" class="line"></span>    this.viewer = options.viewer;
<span id="line32541" class="line"></span>    this._items = [];
<span id="line32542" class="line"></span>    this._needsDraw = false;
<span id="line32543" class="line"></span>    this.__invalidatedAt = 1;
<span id="line32544" class="line"></span>    this._autoRefigureSizes = true;
<span id="line32545" class="line"></span>    this._needsSizesFigured = false;
<span id="line32546" class="line"></span>    this._delegatedFigureSizes = function(event) {
<span id="line32547" class="line"></span>        if (_this._autoRefigureSizes) {
<span id="line32548" class="line"></span>            _this._figureSizes();
<span id="line32549" class="line"></span>        } else {
<span id="line32550" class="line"></span>            _this._needsSizesFigured = true;
<span id="line32551" class="line"></span>        }
<span id="line32552" class="line"></span>    };
<span id="line32553" class="line"></span>
<span id="line32554" class="line"></span>    this._figureSizes();
<span id="line32555" class="line"></span>};
<span id="line32556" class="line"></span>
<span id="line32557" class="line"></span>$.extend( $.World.prototype, $.EventSource.prototype, /** @lends OpenSeadragon.World.prototype */{
<span id="line32558" class="line"></span>    /**
<span id="line32559" class="line"></span>     * Add the specified item.
<span id="line32560" class="line"></span>     * @param {OpenSeadragon.TiledImage} item - The item to add.
<span id="line32561" class="line"></span>     * @param {Object} options - Options affecting insertion.
<span id="line32562" class="line"></span>     * @param {Number} [options.index] - Index for the item. If not specified, goes at the top.
<span id="line32563" class="line"></span>     * @fires OpenSeadragon.World.event:add-item
<span id="line32564" class="line"></span>     * @fires OpenSeadragon.World.event:metrics-change
<span id="line32565" class="line"></span>     */
<span id="line32566" class="line"></span>    addItem: function( item, options ) {
<span id="line32567" class="line"></span>        $.console.assert(item, "[World.addItem] item is required");
<span id="line32568" class="line"></span>        $.console.assert(item instanceof $.TiledImage, "[World.addItem] only TiledImages supported at this time");
<span id="line32569" class="line"></span>
<span id="line32570" class="line"></span>        options = options || {};
<span id="line32571" class="line"></span>        if (options.index !== undefined) {
<span id="line32572" class="line"></span>            const index = Math.max(0, Math.min(this._items.length, options.index));
<span id="line32573" class="line"></span>            this._items.splice(index, 0, item);
<span id="line32574" class="line"></span>        } else {
<span id="line32575" class="line"></span>            this._items.push( item );
<span id="line32576" class="line"></span>        }
<span id="line32577" class="line"></span>
<span id="line32578" class="line"></span>        if (this._autoRefigureSizes) {
<span id="line32579" class="line"></span>            this._figureSizes();
<span id="line32580" class="line"></span>        } else {
<span id="line32581" class="line"></span>            this._needsSizesFigured = true;
<span id="line32582" class="line"></span>        }
<span id="line32583" class="line"></span>
<span id="line32584" class="line"></span>        this._needsDraw = true;
<span id="line32585" class="line"></span>
<span id="line32586" class="line"></span>        item.addHandler('bounds-change', this._delegatedFigureSizes);
<span id="line32587" class="line"></span>        item.addHandler('clip-change', this._delegatedFigureSizes);
<span id="line32588" class="line"></span>
<span id="line32589" class="line"></span>        /**
<span id="line32590" class="line"></span>         * Raised when an item is added to the World.
<span id="line32591" class="line"></span>         * @event add-item
<span id="line32592" class="line"></span>         * @memberOf OpenSeadragon.World
<span id="line32593" class="line"></span>         * @type {object}
<span id="line32594" class="line"></span>         * @property {OpenSeadragon.Viewer} eventSource - A reference to the World which raised the event.
<span id="line32595" class="line"></span>         * @property {OpenSeadragon.TiledImage} item - The item that has been added.
<span id="line32596" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line32597" class="line"></span>         */
<span id="line32598" class="line"></span>        this.raiseEvent( 'add-item', {
<span id="line32599" class="line"></span>            item: item
<span id="line32600" class="line"></span>        } );
<span id="line32601" class="line"></span>    },
<span id="line32602" class="line"></span>
<span id="line32603" class="line"></span>    /**
<span id="line32604" class="line"></span>     * Get the item at the specified index.
<span id="line32605" class="line"></span>     * @param {Number} index - The item's index.
<span id="line32606" class="line"></span>     * @returns {OpenSeadragon.TiledImage} The item at the specified index.
<span id="line32607" class="line"></span>     */
<span id="line32608" class="line"></span>    getItemAt: function( index ) {
<span id="line32609" class="line"></span>        $.console.assert(index !== undefined, "[World.getItemAt] index is required");
<span id="line32610" class="line"></span>        return this._items[ index ];
<span id="line32611" class="line"></span>    },
<span id="line32612" class="line"></span>
<span id="line32613" class="line"></span>    /**
<span id="line32614" class="line"></span>     * Get the index of the given item or -1 if not present.
<span id="line32615" class="line"></span>     * @param {OpenSeadragon.TiledImage} item - The item.
<span id="line32616" class="line"></span>     * @returns {Number} The index of the item or -1 if not present.
<span id="line32617" class="line"></span>     */
<span id="line32618" class="line"></span>    getIndexOfItem: function( item ) {
<span id="line32619" class="line"></span>        $.console.assert(item, "[World.getIndexOfItem] item is required");
<span id="line32620" class="line"></span>        return $.indexOf( this._items, item );
<span id="line32621" class="line"></span>    },
<span id="line32622" class="line"></span>
<span id="line32623" class="line"></span>    /**
<span id="line32624" class="line"></span>     * @returns {Number} The number of items used.
<span id="line32625" class="line"></span>     */
<span id="line32626" class="line"></span>    getItemCount: function() {
<span id="line32627" class="line"></span>        return this._items.length;
<span id="line32628" class="line"></span>    },
<span id="line32629" class="line"></span>
<span id="line32630" class="line"></span>    /**
<span id="line32631" class="line"></span>     * Change the index of a item so that it appears over or under others.
<span id="line32632" class="line"></span>     * @param {OpenSeadragon.TiledImage} item - The item to move.
<span id="line32633" class="line"></span>     * @param {Number} index - The new index.
<span id="line32634" class="line"></span>     * @fires OpenSeadragon.World.event:item-index-change
<span id="line32635" class="line"></span>     */
<span id="line32636" class="line"></span>    setItemIndex: function( item, index ) {
<span id="line32637" class="line"></span>        $.console.assert(item, "[World.setItemIndex] item is required");
<span id="line32638" class="line"></span>        $.console.assert(index !== undefined, "[World.setItemIndex] index is required");
<span id="line32639" class="line"></span>
<span id="line32640" class="line"></span>        const oldIndex = this.getIndexOfItem( item );
<span id="line32641" class="line"></span>
<span id="line32642" class="line"></span>        if ( index &gt;= this._items.length ) {
<span id="line32643" class="line"></span>            throw new Error( "Index bigger than number of layers." );
<span id="line32644" class="line"></span>        }
<span id="line32645" class="line"></span>
<span id="line32646" class="line"></span>        this._items.splice( oldIndex, 1 );
<span id="line32647" class="line"></span>        this._items.splice( index, 0, item );
<span id="line32648" class="line"></span>        this._needsDraw = true;
<span id="line32649" class="line"></span>
<span id="line32650" class="line"></span>        /**
<span id="line32651" class="line"></span>         * Raised when the order of the indexes has been changed.
<span id="line32652" class="line"></span>         * @event item-index-change
<span id="line32653" class="line"></span>         * @memberOf OpenSeadragon.World
<span id="line32654" class="line"></span>         * @type {object}
<span id="line32655" class="line"></span>         * @property {OpenSeadragon.World} eventSource - A reference to the World which raised the event.
<span id="line32656" class="line"></span>         * @property {OpenSeadragon.TiledImage} item - The item whose index has
<span id="line32657" class="line"></span>         * been changed
<span id="line32658" class="line"></span>         * @property {Number} previousIndex - The previous index of the item
<span id="line32659" class="line"></span>         * @property {Number} newIndex - The new index of the item
<span id="line32660" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line32661" class="line"></span>         */
<span id="line32662" class="line"></span>        this.raiseEvent( 'item-index-change', {
<span id="line32663" class="line"></span>            item: item,
<span id="line32664" class="line"></span>            previousIndex: oldIndex,
<span id="line32665" class="line"></span>            newIndex: index
<span id="line32666" class="line"></span>        } );
<span id="line32667" class="line"></span>    },
<span id="line32668" class="line"></span>
<span id="line32669" class="line"></span>    /**
<span id="line32670" class="line"></span>     * Remove an item.
<span id="line32671" class="line"></span>     * @param {OpenSeadragon.TiledImage} item - The item to remove.
<span id="line32672" class="line"></span>     * @fires OpenSeadragon.World.event:remove-item
<span id="line32673" class="line"></span>     * @fires OpenSeadragon.World.event:metrics-change
<span id="line32674" class="line"></span>     */
<span id="line32675" class="line"></span>    removeItem: function( item ) {
<span id="line32676" class="line"></span>        $.console.assert(item, "[World.removeItem] item is required");
<span id="line32677" class="line"></span>
<span id="line32678" class="line"></span>        const index = $.indexOf(this._items, item );
<span id="line32679" class="line"></span>        if ( index === -1 ) {
<span id="line32680" class="line"></span>            return;
<span id="line32681" class="line"></span>        }
<span id="line32682" class="line"></span>
<span id="line32683" class="line"></span>        item.removeHandler('bounds-change', this._delegatedFigureSizes);
<span id="line32684" class="line"></span>        item.removeHandler('clip-change', this._delegatedFigureSizes);
<span id="line32685" class="line"></span>        item.destroy();
<span id="line32686" class="line"></span>        this._items.splice( index, 1 );
<span id="line32687" class="line"></span>        this._figureSizes();
<span id="line32688" class="line"></span>        this._needsDraw = true;
<span id="line32689" class="line"></span>        this._raiseRemoveItem(item);
<span id="line32690" class="line"></span>    },
<span id="line32691" class="line"></span>
<span id="line32692" class="line"></span>    /**
<span id="line32693" class="line"></span>     * Remove all items.
<span id="line32694" class="line"></span>     * @fires OpenSeadragon.World.event:remove-item
<span id="line32695" class="line"></span>     * @fires OpenSeadragon.World.event:metrics-change
<span id="line32696" class="line"></span>     */
<span id="line32697" class="line"></span>    removeAll: function() {
<span id="line32698" class="line"></span>        // We need to make sure any pending images are canceled so the world items don't get messed up
<span id="line32699" class="line"></span>        this.viewer._cancelPendingImages();
<span id="line32700" class="line"></span>        let item;
<span id="line32701" class="line"></span>        for (let i = 0; i &lt; this._items.length; i++) {
<span id="line32702" class="line"></span>            item = this._items[i];
<span id="line32703" class="line"></span>            item.removeHandler('bounds-change', this._delegatedFigureSizes);
<span id="line32704" class="line"></span>            item.removeHandler('clip-change', this._delegatedFigureSizes);
<span id="line32705" class="line"></span>            item.destroy();
<span id="line32706" class="line"></span>        }
<span id="line32707" class="line"></span>
<span id="line32708" class="line"></span>        const removedItems = this._items;
<span id="line32709" class="line"></span>        this._items = [];
<span id="line32710" class="line"></span>        this._figureSizes();
<span id="line32711" class="line"></span>        this._needsDraw = true;
<span id="line32712" class="line"></span>
<span id="line32713" class="line"></span>        for (let i = 0; i &lt; removedItems.length; i++) {
<span id="line32714" class="line"></span>            item = removedItems[i];
<span id="line32715" class="line"></span>            this._raiseRemoveItem(item);
<span id="line32716" class="line"></span>        }
<span id="line32717" class="line"></span>    },
<span id="line32718" class="line"></span>
<span id="line32719" class="line"></span>    /**
<span id="line32720" class="line"></span>     * Forces the system consider all tiles across all tiled images
<span id="line32721" class="line"></span>     * as outdated, and fire tile update event on relevant tiles
<span id="line32722" class="line"></span>     * Detailed description is available within the 'tile-invalidated'
<span id="line32723" class="line"></span>     * event.
<span id="line32724" class="line"></span>     * @param {Boolean} [restoreTiles=true] if true, tile processing starts from the tile original data
<span id="line32725" class="line"></span>     * @param {number} [tStamp=OpenSeadragon.now()] optionally provide tStamp of the update event
<span id="line32726" class="line"></span>     * @function
<span id="line32727" class="line"></span>     * @fires OpenSeadragon.Viewer.event:tile-invalidated
<span id="line32728" class="line"></span>     * @return {OpenSeadragon.Promise&lt;?&gt;}
<span id="line32729" class="line"></span>     */
<span id="line32730" class="line"></span>    requestInvalidate: function (restoreTiles = true, tStamp = $.now()) {
<span id="line32731" class="line"></span>
<span id="line32732" class="line"></span>        // Note: Getting the async cache + invalidation flow right is VERY tricky.
<span id="line32733" class="line"></span>        //
<span id="line32734" class="line"></span>        // When debugging invalidation flow, instead of this optimized version,
<span id="line32735" class="line"></span>        // uncomment the following snipplet and test in easier setting:
<span id="line32736" class="line"></span>        //
<span id="line32737" class="line"></span>        // this.__invalidatedAt = tStamp;
<span id="line32738" class="line"></span>        // const batch = this.viewer.tileCache.getLoadedTilesFor(null);
<span id="line32739" class="line"></span>        // OpenSeadragon.trace(`Invalidate request ${tStamp} - ${batch.length} tiles`);
<span id="line32740" class="line"></span>        // return this.requestTileInvalidateEvent(batch, tStamp, restoreTiles);
<span id="line32741" class="line"></span>        //
<span id="line32742" class="line"></span>        // This makes the code easier to reason about. Also, recommended is to put logging
<span id="line32743" class="line"></span>        // messages into a buffered logger using OpenSeadragon.trace(..)
<span id="line32744" class="line"></span>        // to avoid change of flow in the async execution with detailed logs.
<span id="line32745" class="line"></span>
<span id="line32746" class="line"></span>
<span id="line32747" class="line"></span>        this.__invalidatedAt = tStamp;
<span id="line32748" class="line"></span>        let drawnTstamp = Infinity;
<span id="line32749" class="line"></span>        for (const item of this._items) {
<span id="line32750" class="line"></span>            if (item._lastDrawn.length) {
<span id="line32751" class="line"></span>                drawnTstamp = Math.min(drawnTstamp, item._lastDrawn[0].tile.lastTouchTime);
<span id="line32752" class="line"></span>            }
<span id="line32753" class="line"></span>            // Might be nested
<span id="line32754" class="line"></span>            for (const tileSet of item._tilesToDraw) {
<span id="line32755" class="line"></span>                if (Array.isArray(tileSet)) {
<span id="line32756" class="line"></span>                    if (tileSet.length) {
<span id="line32757" class="line"></span>                        drawnTstamp = Math.min(drawnTstamp, tileSet[0].tile.lastTouchTime);
<span id="line32758" class="line"></span>                    }
<span id="line32759" class="line"></span>                } else if (tileSet) {
<span id="line32760" class="line"></span>                    drawnTstamp = Math.min(drawnTstamp, tileSet.tile.lastTouchTime);
<span id="line32761" class="line"></span>                }
<span id="line32762" class="line"></span>            }
<span id="line32763" class="line"></span>        }
<span id="line32764" class="line"></span>
<span id="line32765" class="line"></span>        const allTiles = this.viewer.tileCache.getLoadedTilesFor(null);
<span id="line32766" class="line"></span>        const tilesToRestore = new Array(allTiles.length);
<span id="line32767" class="line"></span>
<span id="line32768" class="line"></span>        let restoreIndex = 0;
<span id="line32769" class="line"></span>        let deletedTiles = 0;
<span id="line32770" class="line"></span>
<span id="line32771" class="line"></span>        const cache = this.viewer.tileCache;
<span id="line32772" class="line"></span>        for (let i = 0; i &lt; allTiles.length; i++) {
<span id="line32773" class="line"></span>            const tile = allTiles[i];
<span id="line32774" class="line"></span>            const isRecentlyTouched = tile.lastTouchTime &gt;= drawnTstamp;
<span id="line32775" class="line"></span>            const isAboveCutoff = tile.level &lt;= (tile.tiledImage.source.getClosestLevel() || 0);
<span id="line32776" class="line"></span>
<span id="line32777" class="line"></span>            if (isRecentlyTouched || isAboveCutoff) {
<span id="line32778" class="line"></span>                tilesToRestore[restoreIndex++] = tile;
<span id="line32779" class="line"></span>            } else {
<span id="line32780" class="line"></span>                cache._unloadTile(tile, false, i - deletedTiles);
<span id="line32781" class="line"></span>                deletedTiles++;
<span id="line32782" class="line"></span>            }
<span id="line32783" class="line"></span>        }
<span id="line32784" class="line"></span>        tilesToRestore.length = restoreIndex;
<span id="line32785" class="line"></span>        return this.requestTileInvalidateEvent(tilesToRestore, tStamp, restoreTiles);
<span id="line32786" class="line"></span>    },
<span id="line32787" class="line"></span>
<span id="line32788" class="line"></span>    /**
<span id="line32789" class="line"></span>     * Requests tile data update.
<span id="line32790" class="line"></span>     * @function OpenSeadragon.Viewer.prototype._updateSequenceButtons
<span id="line32791" class="line"></span>     * @private
<span id="line32792" class="line"></span>     * @param {OpenSeadragon.Tile[]} tilesToProcess tiles to update
<span id="line32793" class="line"></span>     * @param {Number} tStamp timestamp in milliseconds, if active timestamp of the same value is executing,
<span id="line32794" class="line"></span>     *   changes are added to the cycle, else they await next iteration
<span id="line32795" class="line"></span>     * @param {Boolean} [restoreTiles=true] if true, tile processing starts from the tile original data
<span id="line32796" class="line"></span>     * @param {Boolean} [_allowTileUnloaded=false] internal flag for calling on tiles that come new to the system
<span id="line32797" class="line"></span>     * @param {Boolean} [_isFromTileLoad=false] internal flag that must not be used manually
<span id="line32798" class="line"></span>     * @fires OpenSeadragon.Viewer.event:tile-invalidated
<span id="line32799" class="line"></span>     * @return {OpenSeadragon.Promise&lt;?&gt;}
<span id="line32800" class="line"></span>     */
<span id="line32801" class="line"></span>    requestTileInvalidateEvent: function(tilesToProcess, tStamp, restoreTiles = true,
<span id="line32802" class="line"></span>                                         _allowTileUnloaded = false, _isFromTileLoad = false) {
<span id="line32803" class="line"></span>        // Calling the event is not considered invalidation, as tile load events finishes with this too.
<span id="line32804" class="line"></span>        if (!this.viewer.isOpen()) {
<span id="line32805" class="line"></span>            return $.Promise.resolve();
<span id="line32806" class="line"></span>        }
<span id="line32807" class="line"></span>
<span id="line32808" class="line"></span>        if (tStamp === undefined) {
<span id="line32809" class="line"></span>            tStamp = this.__invalidatedAt;
<span id="line32810" class="line"></span>        }
<span id="line32811" class="line"></span>
<span id="line32812" class="line"></span>        const tilesThatNeedReprocessing = [];
<span id="line32813" class="line"></span>
<span id="line32814" class="line"></span>        const jobList = tilesToProcess.map(tile =&gt; {
<span id="line32815" class="line"></span>            // We allow re-execution on tiles that are in process but have too low processing timestamp,
<span id="line32816" class="line"></span>            // which must be solved by ensuring subsequent data calls in the suddenly outdated processing
<span id="line32817" class="line"></span>            // pipeline take no effect.
<span id="line32818" class="line"></span>            // Note that in the same list we can have tiles that have shared cache and such
<span id="line32819" class="line"></span>            // cache needs to be processed just once.
<span id="line32820" class="line"></span>            if (!tile || (!_allowTileUnloaded &amp;&amp; !tile.loaded &amp;&amp; !tile.processing)) {
<span id="line32821" class="line"></span>                // OpenSeadragon.trace(`Ignoring tile ${tile ? tile.toString() : 'null'} tstamp ${tStamp}`);
<span id="line32822" class="line"></span>                return Promise.resolve();
<span id="line32823" class="line"></span>            }
<span id="line32824" class="line"></span>
<span id="line32825" class="line"></span>            const tiledImage = tile.tiledImage;
<span id="line32826" class="line"></span>            const drawer = tiledImage.getDrawer();
<span id="line32827" class="line"></span>            // We call the event on the parent viewer window no matter what, nested viewers have parent viewer ref.
<span id="line32828" class="line"></span>            //  we use the knowledge that drawerBase keeps track of parent viewer to register into, we use this ref.
<span id="line32829" class="line"></span>            //  We could turn this into API...
<span id="line32830" class="line"></span>            const eventTarget = drawer._parentViewer || this.viewer;
<span id="line32831" class="line"></span>            const originalCache = tile.getCache(tile.originalCacheKey);
<span id="line32832" class="line"></span>            const tileCache = tile.getCache(tile.originalCacheKey);
<span id="line32833" class="line"></span>            if (tileCache.__invStamp &amp;&amp; tileCache.__invStamp &gt;= tStamp) {
<span id="line32834" class="line"></span>                // OpenSeadragon.trace(`Ignoring tile - old,  ${tile ? tile.toString() : 'null'} tstamp ${tStamp}`);
<span id="line32835" class="line"></span>                return Promise.resolve();
<span id="line32836" class="line"></span>            }
<span id="line32837" class="line"></span>
<span id="line32838" class="line"></span>
<span id="line32839" class="line"></span>            let wasOutdatedRun = false;
<span id="line32840" class="line"></span>            if (originalCache.__finishProcessing) {
<span id="line32841" class="line"></span>                // OpenSeadragon.trace(`                 Tile Pre-Finisher,  ${tile ? tile.toString() : 'null'} as Invalid from future ${tStamp}`);
<span id="line32842" class="line"></span>                originalCache.__finishProcessing(true);
<span id="line32843" class="line"></span>            }
<span id="line32844" class="line"></span>
<span id="line32845" class="line"></span>            // Keep the original promise alive until the processing finished normally. If the
<span id="line32846" class="line"></span>            // processing was interrupted, the old promise gets reused in the new run - awaited logics
<span id="line32847" class="line"></span>            // will wait for proper invalidation finish.
<span id="line32848" class="line"></span>            let promise;
<span id="line32849" class="line"></span>            if (!originalCache.__resolve) {
<span id="line32850" class="line"></span>                promise = new $.Promise((resolve) =&gt; {
<span id="line32851" class="line"></span>                    originalCache.__resolve = resolve;
<span id="line32852" class="line"></span>                });
<span id="line32853" class="line"></span>            }
<span id="line32854" class="line"></span>
<span id="line32855" class="line"></span>            originalCache.__finishProcessing = (asInvalidRun) =&gt; {
<span id="line32856" class="line"></span>                wasOutdatedRun = wasOutdatedRun || asInvalidRun;
<span id="line32857" class="line"></span>                // OpenSeadragon.trace(`                  Tile Finisher, ${tile ? tile.toString() : 'null'} as Invalid run ${asInvalidRun} with ${tStamp}`);
<span id="line32858" class="line"></span>                tile.processing = false;
<span id="line32859" class="line"></span>                originalCache.__finishProcessing = null;
<span id="line32860" class="line"></span>                // resolve only when finished without interruption
<span id="line32861" class="line"></span>                if (!asInvalidRun) {
<span id="line32862" class="line"></span>                    originalCache.__resolve(tile);
<span id="line32863" class="line"></span>                    originalCache.__resolve = null;
<span id="line32864" class="line"></span>                }
<span id="line32865" class="line"></span>            };
<span id="line32866" class="line"></span>
<span id="line32867" class="line"></span>            for (const t of originalCache._tiles) {
<span id="line32868" class="line"></span>                // Mark all related tiles as processing and register callback to unmark later on
<span id="line32869" class="line"></span>                t.processing = tStamp;
<span id="line32870" class="line"></span>                if (promise) {
<span id="line32871" class="line"></span>                    t.processingPromise = promise;
<span id="line32872" class="line"></span>                }
<span id="line32873" class="line"></span>            }
<span id="line32874" class="line"></span>            originalCache.__invStamp = tStamp;
<span id="line32875" class="line"></span>            originalCache.__wasRestored = restoreTiles;
<span id="line32876" class="line"></span>
<span id="line32877" class="line"></span>
<span id="line32878" class="line"></span>            let workingCache = null;
<span id="line32879" class="line"></span>            const getWorkingCacheData = (type) =&gt; {
<span id="line32880" class="line"></span>                if (workingCache) {
<span id="line32881" class="line"></span>                    return workingCache.getDataAs(type, false);
<span id="line32882" class="line"></span>                }
<span id="line32883" class="line"></span>
<span id="line32884" class="line"></span>                const targetCopyKey = restoreTiles ? tile.originalCacheKey : tile.cacheKey;
<span id="line32885" class="line"></span>                const origCache = tile.getCache(targetCopyKey);
<span id="line32886" class="line"></span>                if (!origCache) {
<span id="line32887" class="line"></span>                    $.console.error("[Tile::getData] There is no cache available for tile with key %s", targetCopyKey);
<span id="line32888" class="line"></span>                    return $.Promise.reject();
<span id="line32889" class="line"></span>                }
<span id="line32890" class="line"></span>                // Here ensure type is defined, rquired by data callbacks
<span id="line32891" class="line"></span>                type = type || origCache.type;
<span id="line32892" class="line"></span>                workingCache = new $.CacheRecord().withTileReference(tile);
<span id="line32893" class="line"></span>                return origCache.getDataAs(type, true).then(data =&gt; {
<span id="line32894" class="line"></span>                    if (data === undefined || data === null) {
<span id="line32895" class="line"></span>                        // Conversion/loading failed upstream; abort invalidation for this tile.
<span id="line32896" class="line"></span>                        return $.Promise.reject(new Error('[World.getData] Working cache source data unavailable'));
<span id="line32897" class="line"></span>                    }
<span id="line32898" class="line"></span>                    workingCache.addTile(tile, data, type);
<span id="line32899" class="line"></span>                    return workingCache.data;
<span id="line32900" class="line"></span>                });
<span id="line32901" class="line"></span>            };
<span id="line32902" class="line"></span>            const setWorkingCacheData = (value, type) =&gt; {
<span id="line32903" class="line"></span>                // // OpenSeadragon.trace(`        WORKER tile,  ${tile ? tile.toString() : 'null'} tstamp ${tStamp}`);
<span id="line32904" class="line"></span>                if (!workingCache) {
<span id="line32905" class="line"></span>                    workingCache = new $.CacheRecord().withTileReference(tile);
<span id="line32906" class="line"></span>                    workingCache.addTile(tile, value, type);
<span id="line32907" class="line"></span>                    return $.Promise.resolve();
<span id="line32908" class="line"></span>                }
<span id="line32909" class="line"></span>                return workingCache.setDataAs(value, type);
<span id="line32910" class="line"></span>            };
<span id="line32911" class="line"></span>            const atomicCacheSwap = () =&gt; {
<span id="line32912" class="line"></span>                if (workingCache) {
<span id="line32913" class="line"></span>                    const newCacheKey = tile.buildDistinctMainCacheKey();
<span id="line32914" class="line"></span>                    tiledImage._tileCache.injectCache({
<span id="line32915" class="line"></span>                        tile: tile,
<span id="line32916" class="line"></span>                        cache: workingCache,
<span id="line32917" class="line"></span>                        targetKey: newCacheKey,
<span id="line32918" class="line"></span>                        setAsMainCache: true,
<span id="line32919" class="line"></span>                        tileAllowNotLoaded: tile.loading
<span id="line32920" class="line"></span>                    });
<span id="line32921" class="line"></span>                } else if (restoreTiles) {
<span id="line32922" class="line"></span>                    // If we requested restore, perform now
<span id="line32923" class="line"></span>                    tiledImage._tileCache.restoreTilesThatShareOriginalCache(tile, tile.getCache(tile.originalCacheKey), true);
<span id="line32924" class="line"></span>                }
<span id="line32925" class="line"></span>            };
<span id="line32926" class="line"></span>
<span id="line32927" class="line"></span>            const outdatedTest = () =&gt; wasOutdatedRun ||
<span id="line32928" class="line"></span>                (typeof originalCache.__invStamp === "number" &amp;&amp; originalCache.__invStamp &lt; this.__invalidatedAt) ||
<span id="line32929" class="line"></span>                (!tile.loaded &amp;&amp; !tile.loading);
<span id="line32930" class="line"></span>
<span id="line32931" class="line"></span>            // OpenSeadragon.trace(`   Procesing tile, ${tile ? tile.toString() : 'null'} tstamp ${tStamp}`);
<span id="line32932" class="line"></span>            /**
<span id="line32933" class="line"></span>             * @event tile-invalidated
<span id="line32934" class="line"></span>             * @memberof OpenSeadragon.Viewer
<span id="line32935" class="line"></span>             * @type {object}
<span id="line32936" class="line"></span>             * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
<span id="line32937" class="line"></span>             * @property {OpenSeadragon.Tile} tile
<span id="line32938" class="line"></span>             * @property {AsyncNullaryFunction&lt;boolean&gt;} outdated - predicate that evaluates to true if the event
<span id="line32939" class="line"></span>             *   is outdated and should not be longer processed (has no effect)
<span id="line32940" class="line"></span>             * @property {AsyncUnaryFunction&lt;any, string&gt;} getData - get data of desired type (string argument)
<span id="line32941" class="line"></span>             * @property {AsyncBinaryFunction&lt;undefined, any, string&gt;} setData - set data (any)
<span id="line32942" class="line"></span>             *   and the type of the data (string)
<span id="line32943" class="line"></span>             * @property {function} resetData - function that deletes any previous data modification in the current
<span id="line32944" class="line"></span>             *   execution pipeline
<span id="line32945" class="line"></span>             * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line32946" class="line"></span>             */
<span id="line32947" class="line"></span>            return eventTarget.raiseEventAwaiting('tile-invalidated', {
<span id="line32948" class="line"></span>                tile: tile,
<span id="line32949" class="line"></span>                tiledImage: tiledImage,
<span id="line32950" class="line"></span>                outdated: outdatedTest,
<span id="line32951" class="line"></span>                getData: getWorkingCacheData,
<span id="line32952" class="line"></span>                setData: setWorkingCacheData,
<span id="line32953" class="line"></span>                resetData: () =&gt; {
<span id="line32954" class="line"></span>                    if (workingCache) {
<span id="line32955" class="line"></span>                        workingCache.destroy();
<span id="line32956" class="line"></span>                        workingCache = null;
<span id="line32957" class="line"></span>                    }
<span id="line32958" class="line"></span>                },
<span id="line32959" class="line"></span>                stopPropagation: () =&gt; {
<span id="line32960" class="line"></span>                    const result = outdatedTest();
<span id="line32961" class="line"></span>                    // if (result) {
<span id="line32962" class="line"></span>                    //     OpenSeadragon.trace( `              Stop propagation ${tile.toString()}: out: ${wasOutdatedRun} | ${originalCache.__invStamp} ${tile.loaded} ${tile.loading}`);
<span id="line32963" class="line"></span>                    // }
<span id="line32964" class="line"></span>                    return result;
<span id="line32965" class="line"></span>                },
<span id="line32966" class="line"></span>            }).catch(err =&gt; {
<span id="line32967" class="line"></span>                // Plugin/invalidation error: keep existing main cache, discard working cache, and finish processing as invalid.
<span id="line32968" class="line"></span>                $.console.error('Update routine error:', err);
<span id="line32969" class="line"></span>                if (workingCache) {
<span id="line32970" class="line"></span>                    try {
<span id="line32971" class="line"></span>                        workingCache.destroy();
<span id="line32972" class="line"></span>                    } catch (e) {
<span id="line32973" class="line"></span>                        //no-op
<span id="line32974" class="line"></span>                    }
<span id="line32975" class="line"></span>                    workingCache = null;
<span id="line32976" class="line"></span>                }
<span id="line32977" class="line"></span>                wasOutdatedRun = true;
<span id="line32978" class="line"></span>                if (originalCache.__finishProcessing) {
<span id="line32979" class="line"></span>                    originalCache.__finishProcessing(true);
<span id="line32980" class="line"></span>                }
<span id="line32981" class="line"></span>                return null;
<span id="line32982" class="line"></span>            }).then(_ =&gt; {
<span id="line32983" class="line"></span>                if (this.viewer.isDestroyed()) {
<span id="line32984" class="line"></span>                    if (originalCache.__finishProcessing) {
<span id="line32985" class="line"></span>                        originalCache.__finishProcessing(true);
<span id="line32986" class="line"></span>                    }
<span id="line32987" class="line"></span>                    return null;
<span id="line32988" class="line"></span>                }
<span id="line32989" class="line"></span>
<span id="line32990" class="line"></span>                if (wasOutdatedRun) {
<span id="line32991" class="line"></span>                    return null;
<span id="line32992" class="line"></span>                }
<span id="line32993" class="line"></span>
<span id="line32994" class="line"></span>                // OpenSeadragon.trace(`           FF Tile, ${tile ? tile.toString() : 'null'}    FINISH   ${tStamp}`);
<span id="line32995" class="line"></span>
<span id="line32996" class="line"></span>                // If we do not have the handler, we were already discarded
<span id="line32997" class="line"></span>                if (originalCache.__finishProcessing) {
<span id="line32998" class="line"></span>                    // If we are not in outdated run, we can finish the data processing if the state is valid
<span id="line32999" class="line"></span>                    if (!wasOutdatedRun &amp;&amp; (tile.loaded || tile.loading)) {
<span id="line33000" class="line"></span>                        // If we find out that processing was outdated but the system did not find about this yet, request re-processing
<span id="line33001" class="line"></span>                        if (originalCache.__invStamp &lt; this.__invalidatedAt) {
<span id="line33002" class="line"></span>                            // OpenSeadragon.trace(`         Tile,  ${tile ? tile.toString() : 'null'} tstamp ${tStamp} needs reprocessing`);
<span id="line33003" class="line"></span>                            // todo consider some recursion loop prevention
<span id="line33004" class="line"></span>                            tilesThatNeedReprocessing.push(tile);
<span id="line33005" class="line"></span>                            // we will let it fall through to handle later
<span id="line33006" class="line"></span>                        } else if (originalCache.__invStamp === tStamp) {
<span id="line33007" class="line"></span>                            // If we matched the invalidation state, ensure the new working cache (if created) is used
<span id="line33008" class="line"></span>                            if (workingCache) {
<span id="line33009" class="line"></span>                                // OpenSeadragon.trace(`         Tile,  ${tile ? tile.toString() : 'null'} tstamp ${tStamp} finishing normally, working cache exists.`);
<span id="line33010" class="line"></span>                                return workingCache.prepareForRendering(drawer).then(c =&gt; {
<span id="line33011" class="line"></span>                                    // OpenSeadragon.trace(`            Tile,  ${tile ? tile.toString() : 'null'} swapping working cache ${tStamp}`);
<span id="line33012" class="line"></span>
<span id="line33013" class="line"></span>                                    // Inside async then, we need to again check validity of the state
<span id="line33014" class="line"></span>                                    if (!wasOutdatedRun) {
<span id="line33015" class="line"></span>                                        if (!outdatedTest() &amp;&amp; c) {
<span id="line33016" class="line"></span>                                            atomicCacheSwap();
<span id="line33017" class="line"></span>                                        } else {
<span id="line33018" class="line"></span>                                            workingCache.destroy();
<span id="line33019" class="line"></span>                                            workingCache = null;
<span id="line33020" class="line"></span>                                        }
<span id="line33021" class="line"></span>                                        originalCache.__finishProcessing();
<span id="line33022" class="line"></span>                                    } else {
<span id="line33023" class="line"></span>                                        workingCache.destroy();
<span id="line33024" class="line"></span>                                        workingCache = null;
<span id="line33025" class="line"></span>                                    }
<span id="line33026" class="line"></span>                                });
<span id="line33027" class="line"></span>                            }
<span id="line33028" class="line"></span>
<span id="line33029" class="line"></span>                            // If we requested restore, restore to originalCacheKey
<span id="line33030" class="line"></span>                            if (restoreTiles) {
<span id="line33031" class="line"></span>                                // OpenSeadragon.trace(`         Tile, ${tile ? tile.toString() : 'null'} tstamp ${tStamp} finishing normally, original data restored.`);
<span id="line33032" class="line"></span>
<span id="line33033" class="line"></span>                                const mainCacheRef = tile.getCache();
<span id="line33034" class="line"></span>                                const freshOriginalCacheRef = tile.getCache(tile.originalCacheKey);
<span id="line33035" class="line"></span>                                if (mainCacheRef !== freshOriginalCacheRef) {
<span id="line33036" class="line"></span>                                    return freshOriginalCacheRef.prepareForRendering(drawer).then((c) =&gt; {
<span id="line33037" class="line"></span>                                        // OpenSeadragon.trace(`            Tile, ${tile ? tile.toString() : 'null'}  SWAP2 ${tStamp}`);
<span id="line33038" class="line"></span>                                        // Inside async then, we need to again check validity of the state
<span id="line33039" class="line"></span>                                        if (!wasOutdatedRun) {
<span id="line33040" class="line"></span>                                            if (!outdatedTest() &amp;&amp; c) {
<span id="line33041" class="line"></span>                                                atomicCacheSwap();
<span id="line33042" class="line"></span>                                            }
<span id="line33043" class="line"></span>                                            originalCache.__finishProcessing();
<span id="line33044" class="line"></span>                                        }
<span id="line33045" class="line"></span>                                    });
<span id="line33046" class="line"></span>                                } else {
<span id="line33047" class="line"></span>                                    // OpenSeadragon.trace(`         Tile, ${tile ? tile.toString() : 'null'} tstamp ${tStamp} finished - no need to swap cache.`);
<span id="line33048" class="line"></span>                                    return null;
<span id="line33049" class="line"></span>                                }
<span id="line33050" class="line"></span>                            }
<span id="line33051" class="line"></span>                            // else we will let it fall through to handle later
<span id="line33052" class="line"></span>                        } else {
<span id="line33053" class="line"></span>                            $.console.error(
<span id="line33054" class="line"></span>                                `Invalidation flow error: tile processing state is invalid. ` +
<span id="line33055" class="line"></span>                                `Tile: ${tile ? tile.toString() : 'null'}, ` +
<span id="line33056" class="line"></span>                                `loaded: ${tile ? tile.loaded : 'n/a'}, loading: ${tile ? tile.loading : 'n/a'}, ` +
<span id="line33057" class="line"></span>                                `originalCache.__invStamp: ${originalCache.__invStamp}, ` +
<span id="line33058" class="line"></span>                                `this.__invalidatedAt: ${this.__invalidatedAt}, ` +
<span id="line33059" class="line"></span>                                `tStamp: ${tStamp}, wasOutdatedRun: ${wasOutdatedRun}`
<span id="line33060" class="line"></span>                            );
<span id="line33061" class="line"></span>                        }
<span id="line33062" class="line"></span>
<span id="line33063" class="line"></span>                        // If we did not handle the data, finish here - still a valid run.
<span id="line33064" class="line"></span>
<span id="line33065" class="line"></span>                        // If this is also the first run on the tile, ensure the main cache, whatever it is, is ready for render
<span id="line33066" class="line"></span>                        if (_isFromTileLoad) {
<span id="line33067" class="line"></span>                            // OpenSeadragon.trace(`                             Tile, ${tile ? tile.toString() : 'null'} needs render prep as a first run ${tStamp}`);
<span id="line33068" class="line"></span>                            const freshMainCacheRef = tile.getCache();
<span id="line33069" class="line"></span>                            return freshMainCacheRef.prepareForRendering(drawer).then(() =&gt; {
<span id="line33070" class="line"></span>                                // Inside async then, we need to again check validity of the state
<span id="line33071" class="line"></span>                                if (!wasOutdatedRun &amp;&amp; originalCache.__finishProcessing) {
<span id="line33072" class="line"></span>                                    originalCache.__finishProcessing();
<span id="line33073" class="line"></span>                                }
<span id="line33074" class="line"></span>                                // else: do not destroy, we are the initial base cache, the system will remove
<span id="line33075" class="line"></span>                                // any rendering internal cache on events such as atomic cache swap
<span id="line33076" class="line"></span>                                // OpenSeadragon.trace(`            Tile, ${tile ? tile.toString() : 'null'}  SWAP FIRST LOAD FINISH ${tStamp}`);
<span id="line33077" class="line"></span>                            });
<span id="line33078" class="line"></span>                        }
<span id="line33079" class="line"></span>                        originalCache.__finishProcessing();
<span id="line33080" class="line"></span>                        return null;
<span id="line33081" class="line"></span>                    }
<span id="line33082" class="line"></span>                    // else invalid state, let this fall through
<span id="line33083" class="line"></span>                    // OpenSeadragon.trace(`Tile, ${tile ? tile.toString() : 'null'} tstamp ${tStamp} discarded.`);
<span id="line33084" class="line"></span>                    if (!wasOutdatedRun) {
<span id="line33085" class="line"></span>                        originalCache.__finishProcessing(true);
<span id="line33086" class="line"></span>                    }
<span id="line33087" class="line"></span>                }
<span id="line33088" class="line"></span>
<span id="line33089" class="line"></span>                // If this is also the first run on the tile, ensure the main cache, whatever it is, is ready for render
<span id="line33090" class="line"></span>                if (_isFromTileLoad) {
<span id="line33091" class="line"></span>                    // OpenSeadragon.trace(`                             Tile, ${tile ? tile.toString() : 'null'} needs render prep as a first run ${tStamp} - from invalid event!`);
<span id="line33092" class="line"></span>                    const freshMainCacheRef = tile.getCache();
<span id="line33093" class="line"></span>                    return freshMainCacheRef.prepareForRendering(drawer).then(() =&gt; {
<span id="line33094" class="line"></span>                        // OpenSeadragon.trace(`            Tile,  ${tile ? tile.toString() : 'null'}  SWAP FIRST LOAD FINISH ${tStamp}`);
<span id="line33095" class="line"></span>                        if (!wasOutdatedRun &amp;&amp; originalCache.__finishProcessing) {
<span id="line33096" class="line"></span>                            originalCache.__finishProcessing();
<span id="line33097" class="line"></span>                        }
<span id="line33098" class="line"></span>                        // else: do not destroy, we are the initial base cache, the system will remove
<span id="line33099" class="line"></span>                        // any rendering internal cache on events such as atomic cache swap
<span id="line33100" class="line"></span>                    });
<span id="line33101" class="line"></span>                }
<span id="line33102" class="line"></span>
<span id="line33103" class="line"></span>                if (workingCache) {
<span id="line33104" class="line"></span>                    workingCache.destroy();
<span id="line33105" class="line"></span>                    workingCache = null;
<span id="line33106" class="line"></span>                }
<span id="line33107" class="line"></span>                return null;
<span id="line33108" class="line"></span>            }).catch(e =&gt; {
<span id="line33109" class="line"></span>                $.console.error("Update routine error:", e);
<span id="line33110" class="line"></span>                if (workingCache) {
<span id="line33111" class="line"></span>                    workingCache.destroy();
<span id="line33112" class="line"></span>                    workingCache = null;
<span id="line33113" class="line"></span>                }
<span id="line33114" class="line"></span>                originalCache.__finishProcessing();
<span id="line33115" class="line"></span>            });
<span id="line33116" class="line"></span>        });
<span id="line33117" class="line"></span>
<span id="line33118" class="line"></span>        return $.Promise.all(jobList).then(() =&gt; {
<span id="line33119" class="line"></span>            if (tilesThatNeedReprocessing.length) {
<span id="line33120" class="line"></span>                this.requestTileInvalidateEvent(tilesThatNeedReprocessing, undefined, restoreTiles, true);
<span id="line33121" class="line"></span>            }
<span id="line33122" class="line"></span>            if (!_allowTileUnloaded &amp;&amp; !this.viewer.isDestroyed()) {
<span id="line33123" class="line"></span>                this.draw();
<span id="line33124" class="line"></span>            }
<span id="line33125" class="line"></span>        });
<span id="line33126" class="line"></span>    },
<span id="line33127" class="line"></span>
<span id="line33128" class="line"></span>    /**
<span id="line33129" class="line"></span>     * Check if a tile needs update, update such tiles in the given list
<span id="line33130" class="line"></span>     * @param {OpenSeadragon.Tile[]} tileList
<span id="line33131" class="line"></span>     */
<span id="line33132" class="line"></span>    ensureTilesUpToDate: function(tileList) {
<span id="line33133" class="line"></span>        let updateList;
<span id="line33134" class="line"></span>        // we cannot track this on per-tile level, but at least we try to find last used value
<span id="line33135" class="line"></span>        let wasRestored;
<span id="line33136" class="line"></span>        for (let tile of tileList) {
<span id="line33137" class="line"></span>            tile = tile.tile || tile;  // osd uses objects of draw-spec with nested tile ref
<span id="line33138" class="line"></span>            if (!tile.loaded || tile.processing) {
<span id="line33139" class="line"></span>                continue;
<span id="line33140" class="line"></span>            }
<span id="line33141" class="line"></span>
<span id="line33142" class="line"></span>            const originalCache = tile.getCache(tile.originalCacheKey);
<span id="line33143" class="line"></span>            wasRestored = originalCache.__wasRestored;
<span id="line33144" class="line"></span>            if (originalCache.__invStamp &lt; this.__invalidatedAt) {
<span id="line33145" class="line"></span>                if (!updateList) {
<span id="line33146" class="line"></span>                    updateList = [tile];
<span id="line33147" class="line"></span>                } else {
<span id="line33148" class="line"></span>                    updateList.push(tile);
<span id="line33149" class="line"></span>                }
<span id="line33150" class="line"></span>            }
<span id="line33151" class="line"></span>        }
<span id="line33152" class="line"></span>        if (updateList &amp;&amp; updateList.length) {
<span id="line33153" class="line"></span>            // OpenSeadragon.trace(`Ensure tiles up to date ${this.__invalidatedAt} - ${updateList.length} tiles`);
<span id="line33154" class="line"></span>            this.requestTileInvalidateEvent(updateList, $.now(), wasRestored, false);
<span id="line33155" class="line"></span>        }
<span id="line33156" class="line"></span>    },
<span id="line33157" class="line"></span>
<span id="line33158" class="line"></span>    /**
<span id="line33159" class="line"></span>     * Clears all tiles and triggers updates for all items.
<span id="line33160" class="line"></span>     */
<span id="line33161" class="line"></span>    resetItems: function() {
<span id="line33162" class="line"></span>        for ( let i = 0; i &lt; this._items.length; i++ ) {
<span id="line33163" class="line"></span>            this._items[i].reset();
<span id="line33164" class="line"></span>        }
<span id="line33165" class="line"></span>    },
<span id="line33166" class="line"></span>
<span id="line33167" class="line"></span>    /**
<span id="line33168" class="line"></span>     * Updates (i.e. animates bounds of) all items.
<span id="line33169" class="line"></span>     * @function
<span id="line33170" class="line"></span>     * @param viewportChanged Whether the viewport changed, which indicates that
<span id="line33171" class="line"></span>     * all TiledImages need to be updated.
<span id="line33172" class="line"></span>     */
<span id="line33173" class="line"></span>    update: function(viewportChanged) {
<span id="line33174" class="line"></span>        let animated = false;
<span id="line33175" class="line"></span>        for ( let i = 0; i &lt; this._items.length; i++ ) {
<span id="line33176" class="line"></span>            animated = this._items[i].update(viewportChanged) || animated;
<span id="line33177" class="line"></span>        }
<span id="line33178" class="line"></span>
<span id="line33179" class="line"></span>        return animated;
<span id="line33180" class="line"></span>    },
<span id="line33181" class="line"></span>
<span id="line33182" class="line"></span>    /**
<span id="line33183" class="line"></span>     * Draws all items.
<span id="line33184" class="line"></span>     */
<span id="line33185" class="line"></span>    draw: function() {
<span id="line33186" class="line"></span>        this.viewer.drawer.draw(this._items);
<span id="line33187" class="line"></span>        this._needsDraw = false;
<span id="line33188" class="line"></span>        for (const item of this._items) {
<span id="line33189" class="line"></span>            this._needsDraw = item.setDrawn() || this._needsDraw;
<span id="line33190" class="line"></span>        }
<span id="line33191" class="line"></span>    },
<span id="line33192" class="line"></span>
<span id="line33193" class="line"></span>    /**
<span id="line33194" class="line"></span>     * @returns {Boolean} true if any items need updating.
<span id="line33195" class="line"></span>     */
<span id="line33196" class="line"></span>    needsDraw: function() {
<span id="line33197" class="line"></span>        for ( let i = 0; i &lt; this._items.length; i++ ) {
<span id="line33198" class="line"></span>            if ( this._items[i].needsDraw() ) {
<span id="line33199" class="line"></span>                return true;
<span id="line33200" class="line"></span>            }
<span id="line33201" class="line"></span>        }
<span id="line33202" class="line"></span>        return this._needsDraw;
<span id="line33203" class="line"></span>    },
<span id="line33204" class="line"></span>
<span id="line33205" class="line"></span>    /**
<span id="line33206" class="line"></span>     * @returns {OpenSeadragon.Rect} The smallest rectangle that encloses all items, in viewport coordinates.
<span id="line33207" class="line"></span>     */
<span id="line33208" class="line"></span>    getHomeBounds: function() {
<span id="line33209" class="line"></span>        return this._homeBounds.clone();
<span id="line33210" class="line"></span>    },
<span id="line33211" class="line"></span>
<span id="line33212" class="line"></span>    /**
<span id="line33213" class="line"></span>     * To facilitate zoom constraints, we keep track of the pixel density of the
<span id="line33214" class="line"></span>     * densest item in the World (i.e. the item whose content size to viewport size
<span id="line33215" class="line"></span>     * ratio is the highest) and save it as this "content factor".
<span id="line33216" class="line"></span>     * @returns {Number} the number of content units per viewport unit.
<span id="line33217" class="line"></span>     */
<span id="line33218" class="line"></span>    getContentFactor: function() {
<span id="line33219" class="line"></span>        return this._contentFactor;
<span id="line33220" class="line"></span>    },
<span id="line33221" class="line"></span>
<span id="line33222" class="line"></span>    /**
<span id="line33223" class="line"></span>     * As a performance optimization, setting this flag to false allows the bounds-change event handler
<span id="line33224" class="line"></span>     * on tiledImages to skip calculations on the world bounds. If a lot of images are going to be positioned in
<span id="line33225" class="line"></span>     * rapid succession, this is a good idea. When finished, setAutoRefigureSizes should be called with true
<span id="line33226" class="line"></span>     * or the system may behave oddly.
<span id="line33227" class="line"></span>     * @param {Boolean} [value] The value to which to set the flag.
<span id="line33228" class="line"></span>     */
<span id="line33229" class="line"></span>    setAutoRefigureSizes: function(value) {
<span id="line33230" class="line"></span>        this._autoRefigureSizes = value;
<span id="line33231" class="line"></span>        if (value &amp; this._needsSizesFigured) {
<span id="line33232" class="line"></span>            this._figureSizes();
<span id="line33233" class="line"></span>            this._needsSizesFigured = false;
<span id="line33234" class="line"></span>        }
<span id="line33235" class="line"></span>    },
<span id="line33236" class="line"></span>
<span id="line33237" class="line"></span>    /**
<span id="line33238" class="line"></span>     * Arranges all of the TiledImages with the specified settings.
<span id="line33239" class="line"></span>     * @param {Object} options - Specifies how to arrange.
<span id="line33240" class="line"></span>     * @param {Boolean} [options.immediately=false] - Whether to animate to the new arrangement.
<span id="line33241" class="line"></span>     * @param {String} [options.layout] - See collectionLayout in {@link OpenSeadragon.Options}.
<span id="line33242" class="line"></span>     * @param {Number} [options.rows] - See collectionRows in {@link OpenSeadragon.Options}.
<span id="line33243" class="line"></span>     * @param {Number} [options.columns] - See collectionColumns in {@link OpenSeadragon.Options}.
<span id="line33244" class="line"></span>     * @param {Number} [options.tileSize] - See collectionTileSize in {@link OpenSeadragon.Options}.
<span id="line33245" class="line"></span>     * @param {Number} [options.tileMargin] - See collectionTileMargin in {@link OpenSeadragon.Options}.
<span id="line33246" class="line"></span>     * @fires OpenSeadragon.World.event:metrics-change
<span id="line33247" class="line"></span>     */
<span id="line33248" class="line"></span>    arrange: function(options) {
<span id="line33249" class="line"></span>        options = options || {};
<span id="line33250" class="line"></span>        const immediately = options.immediately || false;
<span id="line33251" class="line"></span>        const layout = options.layout || $.DEFAULT_SETTINGS.collectionLayout;
<span id="line33252" class="line"></span>        const rows = options.rows || $.DEFAULT_SETTINGS.collectionRows;
<span id="line33253" class="line"></span>        const columns = options.columns || $.DEFAULT_SETTINGS.collectionColumns;
<span id="line33254" class="line"></span>        const tileSize = options.tileSize || $.DEFAULT_SETTINGS.collectionTileSize;
<span id="line33255" class="line"></span>        const tileMargin = options.tileMargin || $.DEFAULT_SETTINGS.collectionTileMargin;
<span id="line33256" class="line"></span>        const increment = tileSize + tileMargin;
<span id="line33257" class="line"></span>        let wrap;
<span id="line33258" class="line"></span>        if (!options.rows &amp;&amp; columns) {
<span id="line33259" class="line"></span>            wrap = columns;
<span id="line33260" class="line"></span>        } else {
<span id="line33261" class="line"></span>            wrap = Math.ceil(this._items.length / rows);
<span id="line33262" class="line"></span>        }
<span id="line33263" class="line"></span>        let x = 0;
<span id="line33264" class="line"></span>        let y = 0;
<span id="line33265" class="line"></span>        let item, box, width, height, position;
<span id="line33266" class="line"></span>
<span id="line33267" class="line"></span>        this.setAutoRefigureSizes(false);
<span id="line33268" class="line"></span>        for (let i = 0; i &lt; this._items.length; i++) {
<span id="line33269" class="line"></span>            if (i &amp;&amp; (i % wrap) === 0) {
<span id="line33270" class="line"></span>                if (layout === 'horizontal') {
<span id="line33271" class="line"></span>                    y += increment;
<span id="line33272" class="line"></span>                    x = 0;
<span id="line33273" class="line"></span>                } else {
<span id="line33274" class="line"></span>                    x += increment;
<span id="line33275" class="line"></span>                    y = 0;
<span id="line33276" class="line"></span>                }
<span id="line33277" class="line"></span>            }
<span id="line33278" class="line"></span>
<span id="line33279" class="line"></span>            item = this._items[i];
<span id="line33280" class="line"></span>            box = item.getBoundsNoRotate();
<span id="line33281" class="line"></span>            if (box.width &gt; box.height) {
<span id="line33282" class="line"></span>                width = tileSize;
<span id="line33283" class="line"></span>            } else {
<span id="line33284" class="line"></span>                width = tileSize * (box.width / box.height);
<span id="line33285" class="line"></span>            }
<span id="line33286" class="line"></span>
<span id="line33287" class="line"></span>            height = width * (box.height / box.width);
<span id="line33288" class="line"></span>            position = new $.Point(x + ((tileSize - width) / 2),
<span id="line33289" class="line"></span>                y + ((tileSize - height) / 2));
<span id="line33290" class="line"></span>
<span id="line33291" class="line"></span>            item.setPosition(position, immediately);
<span id="line33292" class="line"></span>            item.setWidth(width, immediately);
<span id="line33293" class="line"></span>
<span id="line33294" class="line"></span>            if (layout === 'horizontal') {
<span id="line33295" class="line"></span>                x += increment;
<span id="line33296" class="line"></span>            } else {
<span id="line33297" class="line"></span>                y += increment;
<span id="line33298" class="line"></span>            }
<span id="line33299" class="line"></span>        }
<span id="line33300" class="line"></span>        this.setAutoRefigureSizes(true);
<span id="line33301" class="line"></span>    },
<span id="line33302" class="line"></span>
<span id="line33303" class="line"></span>    // private
<span id="line33304" class="line"></span>    _figureSizes: function() {
<span id="line33305" class="line"></span>        const oldHomeBounds = this._homeBounds ? this._homeBounds.clone() : null;
<span id="line33306" class="line"></span>        const oldContentSize = this._contentSize ? this._contentSize.clone() : null;
<span id="line33307" class="line"></span>        const oldContentFactor = this._contentFactor || 0;
<span id="line33308" class="line"></span>
<span id="line33309" class="line"></span>        if (!this._items.length) {
<span id="line33310" class="line"></span>            this._homeBounds = new $.Rect(0, 0, 1, 1);
<span id="line33311" class="line"></span>            this._contentSize = new $.Point(1, 1);
<span id="line33312" class="line"></span>            this._contentFactor = 1;
<span id="line33313" class="line"></span>        } else {
<span id="line33314" class="line"></span>            let item = this._items[0];
<span id="line33315" class="line"></span>            let bounds = item.getBounds();
<span id="line33316" class="line"></span>            this._contentFactor = item.getContentSize().x / bounds.width;
<span id="line33317" class="line"></span>            let clippedBounds = item.getClippedBounds().getBoundingBox();
<span id="line33318" class="line"></span>            let left = clippedBounds.x;
<span id="line33319" class="line"></span>            let top = clippedBounds.y;
<span id="line33320" class="line"></span>            let right = clippedBounds.x + clippedBounds.width;
<span id="line33321" class="line"></span>            let bottom = clippedBounds.y + clippedBounds.height;
<span id="line33322" class="line"></span>            for (let i = 1; i &lt; this._items.length; i++) {
<span id="line33323" class="line"></span>                item = this._items[i];
<span id="line33324" class="line"></span>                bounds = item.getBounds();
<span id="line33325" class="line"></span>                this._contentFactor = Math.max(this._contentFactor,
<span id="line33326" class="line"></span>                    item.getContentSize().x / bounds.width);
<span id="line33327" class="line"></span>                clippedBounds = item.getClippedBounds().getBoundingBox();
<span id="line33328" class="line"></span>                left = Math.min(left, clippedBounds.x);
<span id="line33329" class="line"></span>                top = Math.min(top, clippedBounds.y);
<span id="line33330" class="line"></span>                right = Math.max(right, clippedBounds.x + clippedBounds.width);
<span id="line33331" class="line"></span>                bottom = Math.max(bottom, clippedBounds.y + clippedBounds.height);
<span id="line33332" class="line"></span>            }
<span id="line33333" class="line"></span>
<span id="line33334" class="line"></span>            this._homeBounds = new $.Rect(left, top, right - left, bottom - top);
<span id="line33335" class="line"></span>            this._contentSize = new $.Point(
<span id="line33336" class="line"></span>                this._homeBounds.width * this._contentFactor,
<span id="line33337" class="line"></span>                this._homeBounds.height * this._contentFactor);
<span id="line33338" class="line"></span>        }
<span id="line33339" class="line"></span>
<span id="line33340" class="line"></span>        if (this._contentFactor !== oldContentFactor ||
<span id="line33341" class="line"></span>            !this._homeBounds.equals(oldHomeBounds) ||
<span id="line33342" class="line"></span>            !this._contentSize.equals(oldContentSize)) {
<span id="line33343" class="line"></span>            /**
<span id="line33344" class="line"></span>             * Raised when the home bounds or content factor change.
<span id="line33345" class="line"></span>             * @event metrics-change
<span id="line33346" class="line"></span>             * @memberOf OpenSeadragon.World
<span id="line33347" class="line"></span>             * @type {object}
<span id="line33348" class="line"></span>             * @property {OpenSeadragon.World} eventSource - A reference to the World which raised the event.
<span id="line33349" class="line"></span>             * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line33350" class="line"></span>             */
<span id="line33351" class="line"></span>            this.raiseEvent('metrics-change', {});
<span id="line33352" class="line"></span>        }
<span id="line33353" class="line"></span>    },
<span id="line33354" class="line"></span>
<span id="line33355" class="line"></span>    // private
<span id="line33356" class="line"></span>    _raiseRemoveItem: function(item) {
<span id="line33357" class="line"></span>        /**
<span id="line33358" class="line"></span>         * Raised when an item is removed.
<span id="line33359" class="line"></span>         * @event remove-item
<span id="line33360" class="line"></span>         * @memberOf OpenSeadragon.World
<span id="line33361" class="line"></span>         * @type {object}
<span id="line33362" class="line"></span>         * @property {OpenSeadragon.World} eventSource - A reference to the World which raised the event.
<span id="line33363" class="line"></span>         * @property {OpenSeadragon.TiledImage} item - The item's underlying item.
<span id="line33364" class="line"></span>         * @property {?Object} userData - Arbitrary subscriber-defined object.
<span id="line33365" class="line"></span>         */
<span id="line33366" class="line"></span>        this.raiseEvent( 'remove-item', { item: item } );
<span id="line33367" class="line"></span>    }
<span id="line33368" class="line"></span>});
<span id="line33369" class="line"></span>
<span id="line33370" class="line"></span>}( OpenSeadragon ));
<span id="line33371" class="line"></span>
<span id="line33372" class="line"></span>//# sourceMappingURL=openseadragon.js.map</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#configure">configure</a></li><li><a href="global.html#getImageInfo">getImageInfo</a></li><li><a href="global.html#getLevelScale">getLevelScale</a></li><li><a href="global.html#getMetadataUrl">getMetadataUrl</a></li><li><a href="global.html#getNumTiles">getNumTiles</a></li><li><a href="global.html#getTileUrl">getTileUrl</a></li><li><a href="global.html#guessType">guessType</a></li><li><a href="global.html#parseMetadata">parseMetadata</a></li><li><a href="global.html#supports">supports</a></li></ul><h3>Namespaces</h3><ul><li><a href="OpenSeadragon.html">OpenSeadragon</a></li></ul><h3>Classes</h3><ul><li><a href="-_anonymous_-OpenSeadragon-OpenSeadragon.PriorityQueue.html">PriorityQueue</a></li><li><a href="OpenSeadragon.BatchImageJob.html">BatchImageJob</a></li><li><a href="OpenSeadragon.Button.html">Button</a></li><li><a href="OpenSeadragon.ButtonGroup.html">ButtonGroup</a></li><li><a href="OpenSeadragon.CacheRecord.html">CacheRecord</a></li><li><a href="OpenSeadragon.CanvasDrawer.html">CanvasDrawer</a></li><li><a href="OpenSeadragon.Control.html">Control</a></li><li><a href="OpenSeadragon.ControlDock.html">ControlDock</a></li><li><a href="OpenSeadragon.DataTypeConverter.html">DataTypeConverter</a></li><li><a href="OpenSeadragon.DisplayRect.html">DisplayRect</a></li><li><a href="OpenSeadragon.DrawerBase.html">DrawerBase</a></li><li><a href="OpenSeadragon.DziTileSource.html">DziTileSource</a></li><li><a href="OpenSeadragon.EventSource.html">EventSource</a></li><li><a href="OpenSeadragon.HTMLDrawer.html">HTMLDrawer</a></li><li><a href="OpenSeadragon.IIIFTileSource.html">IIIFTileSource</a></li><li><a href="OpenSeadragon.IIPTileSource.html">IIPTileSource</a></li><li><a href="OpenSeadragon.ImageJob.html">ImageJob</a></li><li><a href="OpenSeadragon.ImageLoader.html">ImageLoader</a></li><li><a href="OpenSeadragon.ImageTileSource.html">ImageTileSource</a></li><li><a href="OpenSeadragon.IrisTileSource.html">IrisTileSource</a></li><li><a href="OpenSeadragon.LegacyTileSource.html">LegacyTileSource</a></li><li><a href="OpenSeadragon.Mat3.html">Mat3</a></li><li><a href="OpenSeadragon.MouseTracker.html">MouseTracker</a></li><li><a href="OpenSeadragon.MouseTracker.GesturePointList.html">GesturePointList</a></li><li><a href="OpenSeadragon.Navigator.html">Navigator</a></li><li><a href="OpenSeadragon.OsmTileSource.html">OsmTileSource</a></li><li><a href="OpenSeadragon.Overlay.html">Overlay</a></li><li><a href="OpenSeadragon.Point.html">Point</a></li><li><a href="OpenSeadragon.PriorityQueue.html">PriorityQueue</a></li><li><a href="OpenSeadragon.Rect.html">Rect</a></li><li><a href="OpenSeadragon.ReferenceStrip.html">ReferenceStrip</a></li><li><a href="OpenSeadragon.Spring.html">Spring</a></li><li><a href="OpenSeadragon.Tile.html">Tile</a></li><li><a href="OpenSeadragon.TileCache.html">TileCache</a></li><li><a href="OpenSeadragon.TiledImage.html">TiledImage</a></li><li><a href="OpenSeadragon.TileSource.html">TileSource</a></li><li><a href="OpenSeadragon.TmsTileSource.html">TmsTileSource</a></li><li><a href="OpenSeadragon.Viewer.html">Viewer</a></li><li><a href="OpenSeadragon.Viewport.html">Viewport</a></li><li><a href="OpenSeadragon.WebGLDrawer.html">WebGLDrawer</a></li><li><a href="OpenSeadragon.World.html">World</a></li><li><a href="OpenSeadragon.ZoomifyTileSource.html">ZoomifyTileSource</a></li><li><a href="WebglContextManager.html">WebglContextManager</a></li></ul><h3>Events</h3><h4>OpenSeadragon.Button</h4><ul><li><a href="OpenSeadragon.Button.html#.event:blur">blur</a></li><li><a href="OpenSeadragon.Button.html#.event:click">click</a></li><li><a href="OpenSeadragon.Button.html#.event:enter">enter</a></li><li><a href="OpenSeadragon.Button.html#.event:exit">exit</a></li><li><a href="OpenSeadragon.Button.html#.event:focus">focus</a></li><li><a href="OpenSeadragon.Button.html#.event:press">press</a></li><li><a href="OpenSeadragon.Button.html#.event:release">release</a></li></ul><h4>OpenSeadragon.TiledImage</h4><ul><li><a href="OpenSeadragon.TiledImage.html#.event:bounds-change">bounds-change</a></li><li><a href="OpenSeadragon.TiledImage.html#.event:clip-change">clip-change</a></li><li><a href="OpenSeadragon.TiledImage.html#.event:composite-operation-change">composite-operation-change</a></li><li><a href="OpenSeadragon.TiledImage.html#.event:fully-loaded-change">fully-loaded-change</a></li><li><a href="OpenSeadragon.TiledImage.html#.event:opacity-change">opacity-change</a></li></ul><h4>OpenSeadragon.TileSource</h4><ul><li><a href="OpenSeadragon.TileSource.html#.event:open-failed">open-failed</a></li><li><a href="OpenSeadragon.TileSource.html#.event:ready">ready</a></li></ul><h4>OpenSeadragon.Viewer</h4><ul><li><a href="OpenSeadragon.Viewer.html#.event:add-item-failed">add-item-failed</a></li><li><a href="OpenSeadragon.Viewer.html#.event:add-overlay">add-overlay</a></li><li><a href="OpenSeadragon.Viewer.html#.event:after-resize">after-resize</a></li><li><a href="OpenSeadragon.Viewer.html#.event:animation">animation</a></li><li><a href="OpenSeadragon.Viewer.html#.event:animation-finish">animation-finish</a></li><li><a href="OpenSeadragon.Viewer.html#.event:animation-start">animation-start</a></li><li><a href="OpenSeadragon.Viewer.html#.event:before-destroy">before-destroy</a></li><li><a href="OpenSeadragon.Viewer.html#.event:canvas-blur">canvas-blur</a></li><li><a href="OpenSeadragon.Viewer.html#.event:canvas-click">canvas-click</a></li><li><a href="OpenSeadragon.Viewer.html#.event:canvas-contextmenu">canvas-contextmenu</a></li><li><a href="OpenSeadragon.Viewer.html#.event:canvas-double-click">canvas-double-click</a></li><li><a href="OpenSeadragon.Viewer.html#.event:canvas-drag">canvas-drag</a></li><li><a href="OpenSeadragon.Viewer.html#.event:canvas-drag-end">canvas-drag-end</a></li><li><a href="OpenSeadragon.Viewer.html#.event:canvas-enter">canvas-enter</a></li><li><a href="OpenSeadragon.Viewer.html#.event:canvas-exit">canvas-exit</a></li><li><a href="OpenSeadragon.Viewer.html#.event:canvas-focus">canvas-focus</a></li><li><a href="OpenSeadragon.Viewer.html#.event:canvas-key">canvas-key</a></li><li><a href="OpenSeadragon.Viewer.html#.event:canvas-key-press">canvas-key-press</a></li><li><a href="OpenSeadragon.Viewer.html#.event:canvas-nonprimary-press">canvas-nonprimary-press</a></li><li><a href="OpenSeadragon.Viewer.html#.event:canvas-nonprimary-release">canvas-nonprimary-release</a></li><li><a href="OpenSeadragon.Viewer.html#.event:canvas-pinch">canvas-pinch</a></li><li><a href="OpenSeadragon.Viewer.html#.event:canvas-press">canvas-press</a></li><li><a href="OpenSeadragon.Viewer.html#.event:canvas-release">canvas-release</a></li><li><a href="OpenSeadragon.Viewer.html#.event:canvas-scroll">canvas-scroll</a></li><li><a href="OpenSeadragon.Viewer.html#.event:clear-overlay">clear-overlay</a></li><li><a href="OpenSeadragon.Viewer.html#.event:close">close</a></li><li><a href="OpenSeadragon.Viewer.html#.event:constrain">constrain</a></li><li><a href="OpenSeadragon.Viewer.html#.event:container-enter">container-enter</a></li><li><a href="OpenSeadragon.Viewer.html#.event:container-exit">container-exit</a></li><li><a href="OpenSeadragon.Viewer.html#.event:controls-enabled">controls-enabled</a></li><li><a href="OpenSeadragon.Viewer.html#.event:destroy">destroy</a></li><li><a href="OpenSeadragon.Viewer.html#.event:drawer-error">drawer-error</a></li><li><a href="OpenSeadragon.Viewer.html#.event:flip">flip</a></li><li><a href="OpenSeadragon.Viewer.html#.event:full-page">full-page</a></li><li><a href="OpenSeadragon.Viewer.html#.event:full-screen">full-screen</a></li><li><a href="OpenSeadragon.Viewer.html#.event:fully-loaded-change">fully-loaded-change</a></li><li><a href="OpenSeadragon.Viewer.html#.event:home">home</a></li><li><a href="OpenSeadragon.Viewer.html#.event:job-queue-full">job-queue-full</a></li><li><a href="OpenSeadragon.Viewer.html#.event:keyboard-enabled">keyboard-enabled</a></li><li><a href="OpenSeadragon.Viewer.html#.event:mouse-enabled">mouse-enabled</a></li><li><a href="OpenSeadragon.Viewer.html#.event:navigator-click">navigator-click</a></li><li><a href="OpenSeadragon.Viewer.html#.event:navigator-drag">navigator-drag</a></li><li><a href="OpenSeadragon.Viewer.html#.event:navigator-scroll">navigator-scroll</a></li><li><a href="OpenSeadragon.Viewer.html#.event:open">open</a></li><li><a href="OpenSeadragon.Viewer.html#.event:open-failed">open-failed</a></li><li><a href="OpenSeadragon.Viewer.html#.event:page">page</a></li><li><a href="OpenSeadragon.Viewer.html#.event:pan">pan</a></li><li><a href="OpenSeadragon.Viewer.html#.event:pre-full-page">pre-full-page</a></li><li><a href="OpenSeadragon.Viewer.html#.event:pre-full-screen">pre-full-screen</a></li><li><a href="OpenSeadragon.Viewer.html#.event:remove-overlay">remove-overlay</a></li><li><a href="OpenSeadragon.Viewer.html#.event:reset-size">reset-size</a></li><li><a href="OpenSeadragon.Viewer.html#.event:resize">resize</a></li><li><a href="OpenSeadragon.Viewer.html#.event:rotate">rotate</a></li><li><a href="OpenSeadragon.Viewer.html#.event:tile-drawing">tile-drawing</a></li><li><a href="OpenSeadragon.Viewer.html#.event:tile-drawn">tile-drawn</a></li><li><a href="OpenSeadragon.Viewer.html#.event:tile-invalidated">tile-invalidated</a></li><li><a href="OpenSeadragon.Viewer.html#.event:tile-load-failed">tile-load-failed</a></li><li><a href="OpenSeadragon.Viewer.html#.event:tile-loaded">tile-loaded</a></li><li><a href="OpenSeadragon.Viewer.html#.event:update-level">update-level</a></li><li><a href="OpenSeadragon.Viewer.html#.event:update-overlay">update-overlay</a></li><li><a href="OpenSeadragon.Viewer.html#.event:update-tile">update-tile</a></li><li><a href="OpenSeadragon.Viewer.html#.event:update-viewport">update-viewport</a></li><li><a href="OpenSeadragon.Viewer.html#.event:viewport-change">viewport-change</a></li><li><a href="OpenSeadragon.Viewer.html#.event:visible">visible</a></li><li><a href="OpenSeadragon.Viewer.html#.event:webgl-context-recovered">webgl-context-recovered</a></li><li><a href="OpenSeadragon.Viewer.html#.event:webgl-context-recovery-failed">webgl-context-recovery-failed</a></li><li><a href="OpenSeadragon.Viewer.html#.event:zoom">zoom</a></li></ul><h4>OpenSeadragon.World</h4><ul><li><a href="OpenSeadragon.World.html#.event:add-item">add-item</a></li><li><a href="OpenSeadragon.World.html#.event:item-index-change">item-index-change</a></li><li><a href="OpenSeadragon.World.html#.event:metrics-change">metrics-change</a></li><li><a href="OpenSeadragon.World.html#.event:remove-item">remove-item</a></li></ul>
</nav>

<br clear="both">

<footer>
    OpenSeadragon documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> on Wed Feb 18 2026 10:52:01 GMT-0800 (Pacific Standard Time)
</footer>
</div>

</body>
</html>
